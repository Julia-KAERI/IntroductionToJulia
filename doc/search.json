[
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "Summary",
    "section": "",
    "text": "Summary\nIn summary, this book has no content whatsoever."
  },
  {
    "objectID": "src/introduction_to_julia/11_polynomial.html",
    "href": "src/introduction_to_julia/11_polynomial.html",
    "title": "Introduction To Julia",
    "section": "",
    "text": "이제 일변수 다항식 (\\(x\\) 에 대한 다항식)을 특별한 자료형으로 Julia 언어에서 구현해보자. 다항식은 기본적인 함수일 뿐만 아니라 수치해석에도 널리 사용된다. 여기서는 다항식에 대한 객체를 만들어 앞으로도 사용하고자 한다. Julia 자체는 다항식에 대한 자료구조나 객체를 포함하지 않지만 2022 년 현재 Polynomials.jl 이라는 라이브러리가 널리 사용된다. 그러나 여기서는 이 책에서 계속 사용할 다항식 객체를 만들고자 한다.\n\n\n\nJulia 에서 함수는 1급 객체로, 변수에 할당 될 수 있으며, 타입을 가질 수 있고, 함수의 리턴값으로 사용 될 수 있다. 이를 이용하면 계수를 1차원 배열인 벡터로 전달하여 익명 함수를 리턴하는 함수를 작성 할 수 있다. 다음 poly1 함수는 다항식의 전체 계수 벡터 coeff 를 인자로 받아 coeff[i] 가 다항식의 \\(i-1\\) 차 계수가 되는 함수를 리턴한다.\nfunction poly1(coeff::Vector{T}) where T&lt;:Number\n    return x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1))))\nend\n우리는 이 함수가 잘 작동함을 확인 할 수 있다.\nIn [2]: ff = poly1([1.0, -2.0, 1.0])\nOut[2]: #3 (generic function with 1 method)\n\nIn [3]: ff(1.0)\nOut[3]: 0.0\n함수 시그니쳐의 poly1(coeff::Vector{T}) where T&lt;:Number 에서 poly1(coeff::Vector{T}) 는 poly1 함수가 T 타입의 벡터를 인자로 받는다는 뜻이며 뒤의 where T&lt;:Number 는 T 가 Number 의 서브타입만을 허락한다는 의미이다. Number 는 추상 타입(abstract type) 이므로 변수에 할당 될 수 없다. 따라서 coeff 가 벡터가 아니거나, 수 타입에 대한 벡터가 아니면 에러가 발생한다.\nIn [4]: poly1(3)\nERROR: MethodError: no method matching poly1(::Int64)\n\nIn [5]: poly1([sin, 1])\nERROR: MethodError: no method matching poly1(::Vector{Any})\nreturn 뒤의 x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1)))) 구문은 익명함수를 만드는 구문이다. 수를 받아 다항식을 계산하는 익명 함수를 반환한다. 이렇게 하면 ff = poly1([1.0, -2.0, 1.0]) 라 하면 ff(x) 는 \\(1-2x+x^2\\) 를 나타내는 다항식이다. 이 다항식의 함수에서 리턴 타입은 coeff 와 x 의 타입의 연산 규칙에 다라 결정된다.\n때에 따라서는 이것도 충분하며, 타입을 고려하지 않는다면 심지어 이것보다 간단한 버젼도 가능하다. 그러나 보통 다항식을 나타내는 자료구조를 생각하면, 최소한 다항식간의 덧셈, 뺄셈, 곱셈이 가능하면 좋을 것이다. 그리고 행렬의 다항식도 가능하다면 구현하면 좋을 것이다.\n익명 함수로는 이것이 힘들다. structure 를 이용하여 다항식 객체를 만들어 보자. 이미 널리 사용되는 Polynomials.jl 패키지가 있으므로 SimplePolynomial 이라는 객체를 만들도록 하자.\n\n\n\n\nstruct SimplePolynomial{T} \n    coeffs :: Vector{T}\n    \n    function SimplePolynomial(a::AbstractVector{P}) where P &lt;: Number\n        if length(a) == 0 \n            return new{P}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{P}(a[1:a_last])\n        end\n    end\n\n    function SimplePolynomial{T}(a::AbstractVector{P}) where {T &lt;: Number, P&lt;:Number}\n        if length(a) == 0 \n            return new{T}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{T}(convert.(T, a[1:a_last]))\n        end\n    end\n\nend\nSimplePolynomial 은 immutable 한 객체로 구현되었다. 즉 coeffs 속성은 변경 될 수 없다.\nIn [1]: a = SimplePolynomial([1, 3])\nOut[1]: SimplePolynomial{Int64}([1, 3])\n\nIn [2]: a.coeffs = [3.0, 4.0]\nERROR: setfield!: immutable struct of type SimplePolynomial cannot be changed\nstruct 구문 내부의 function SimplePolynomial 로 시작하는 구문은 내부생성자 (inner constructor) 구문이다. SimplePolynomial 자체가 타입매개변수 T 를 정할수 있는 타입이기 때문에 하나는 타입매개변수가 지정되지 않았을 때 타입을 계수로 주어진 인자 a 의 성분의 타입으로 정하고, 남은 하나는 a 를 타입 인자 T 로 주어지는 타입으로 변환시켜 다항식을 만들어 내게 된다.\n이제 SimplePolynomial 객체를 이용하여 수 형식, 혹은 정사각 행렬에 대한 다항식을 계산하는 함수를 만들자.\nusing LinearAlgebra\n\nfunction (p::SimplePolynomial)(x::Number)\n    return evalpoly(x, p.coeffs)\nend\n\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Matrix{N} where N&lt;:Number\n    r = UniformScaling(p.coeffs[1])\n\n    @assert size(x)[1] == size(x)[2] # 정사각 행렬에 대해서만 가능하다.\n    for i in 2:length(p.coeffs)\n        @inbounds r +=  p.coeffs[i]*x^(i-1)\n    end\n    return r\nend\n단위행렬의 상수배를 나타내는 연산자 UniformScaling을 위해 LinearAlgebra 모듈을 임포트 했다. 정사각 행렬임을 확인하기 위해 @assert size(x)[1] == size(x)[2] 를 삽입하였다. REPL 에서의 아래의 결과를 보면 정확히 구현되었음을 알 수 있다.\nIn [1]: a1 = SimplePolynomial([1.0, 2.0, 3.0])\nOut[1]: SimplePolynomial{Float64}([1.0, 2.0, 3.0])\n\nIn [2]: a1(1.0)\nOut[2]: 6.0\n\nIn [3]: a1([4 3; 2 4])\nOut[3]: 2×2 Matrix{Float64}:\n 75.0  78.0\n 52.0  75.0\n\nIn [4]: a1([4 3 3; 2 4 3])\nERROR: AssertionError: (size(x))[1] == (size(x))[2]\n다항식의 덧셈, 뺄셈, 곱셈을 정의하기 전에 다항식의 차수에 관련된 값을 리턴하는 함수를 만들자. 일반적으로 배열은 length 함수로 원소의 갯수를 알 수 있는데, 다항식에서는 계수의 갯수-1 이 차수가 된다. Base.length 함수에 대한 디스패치를 작성하여 이 함수를 이용하자.\nfunction Base.:length(b::P) where {P&lt;: SimplePolynomial}\n    return length(b.coeffs)\nend\n이제 SimpllePolynomial 객체 사이에 혹은 SimplePolynomial 객체와 상수간의 +, -, *, / 연산을 정의 할 수 있다. / 의 경우 일단은 다항식/상수 만을 정의한다. 이것에 대한 구현은 polynomial.jl 파일에 존재한다. Julia REPL 이나 Jupyter notebook 등에서 include 명령을 통해 사용 할 수 있다.\ninclude(\"path_to_polynomial.jl\")\n다항식 \\(p(x) = a_0 + a_1 x + \\cdots + a_n x^n\\) 일 때,\n\\[\n\\begin{aligned}\n\\dfrac{d}{dx}p(x) &= a_1 + 2a_2 x + \\cdots + na_n x^{n-1},\\\\\n\\int_x p(t)\\, dt &=a_0 x + \\dfrac{a_1}{2}x^2 + \\cdots + \\dfrac{a_n}{n+1}x^{n+1} + \\text{const.}\n\\end{aligned}\n\\]\n임을 안다. 이것을 이용하여 다항식을 미분하는 함수 differentiate(p::Polynomial{T}) 와 정적분 함수 integrate(p::Polynomial{T}, c) 함수를 구현하였다. 여기서 c 는 정적분의 상수항이다.\n\n\n\n\n다항식 \\(p(x)\\) 의 전체 근이 \\(x_1,\\,x_2,\\ldots,\\,x_n\\) 라고 하면 이 다항식은 상수 \\(c\\) 에 대해\n\\[\np(x) = c \\prod_{i=1}^n (x-x_i)\n\\]\n의 꼴을 갖는다. 우리는 이미 다항식의 곱셈을 구현했으므로 이를 쉽게 구현 할 수 있다. 여기서는 \\(c=1\\) 로 정해진 다항식을 리턴한다.\nfunction polynomial_from_roots(xp::Vector{T}) where T&lt;:Number\n    r = one(T)\n    for i in 1:length(xp) \n        @inbounds r = r* SimplePolynomial([-xp[i],  1])\n    end\n    return r\nend\n그렇다면,\njulia&gt; pp3 = polynomial_from_roots([1.0, 1.0, 2.0])\nSimplePolynomial :  + 1.0 x^3 - 4.0 x^2 + 5.0 x^1 - 2.0 \n의 결과가 나온다. \\((x-1)^2(x-2)= x^3-4x^2+5x-2\\) 이므로 정확한 결과가 나왔다."
  },
  {
    "objectID": "src/introduction_to_julia/11_polynomial.html#일변수-다항식의-julia-구현",
    "href": "src/introduction_to_julia/11_polynomial.html#일변수-다항식의-julia-구현",
    "title": "Introduction To Julia",
    "section": "",
    "text": "이제 일변수 다항식 (\\(x\\) 에 대한 다항식)을 특별한 자료형으로 Julia 언어에서 구현해보자. 다항식은 기본적인 함수일 뿐만 아니라 수치해석에도 널리 사용된다. 여기서는 다항식에 대한 객체를 만들어 앞으로도 사용하고자 한다. Julia 자체는 다항식에 대한 자료구조나 객체를 포함하지 않지만 2022 년 현재 Polynomials.jl 이라는 라이브러리가 널리 사용된다. 그러나 여기서는 이 책에서 계속 사용할 다항식 객체를 만들고자 한다.\n\n\n\nJulia 에서 함수는 1급 객체로, 변수에 할당 될 수 있으며, 타입을 가질 수 있고, 함수의 리턴값으로 사용 될 수 있다. 이를 이용하면 계수를 1차원 배열인 벡터로 전달하여 익명 함수를 리턴하는 함수를 작성 할 수 있다. 다음 poly1 함수는 다항식의 전체 계수 벡터 coeff 를 인자로 받아 coeff[i] 가 다항식의 \\(i-1\\) 차 계수가 되는 함수를 리턴한다.\nfunction poly1(coeff::Vector{T}) where T&lt;:Number\n    return x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1))))\nend\n우리는 이 함수가 잘 작동함을 확인 할 수 있다.\nIn [2]: ff = poly1([1.0, -2.0, 1.0])\nOut[2]: #3 (generic function with 1 method)\n\nIn [3]: ff(1.0)\nOut[3]: 0.0\n함수 시그니쳐의 poly1(coeff::Vector{T}) where T&lt;:Number 에서 poly1(coeff::Vector{T}) 는 poly1 함수가 T 타입의 벡터를 인자로 받는다는 뜻이며 뒤의 where T&lt;:Number 는 T 가 Number 의 서브타입만을 허락한다는 의미이다. Number 는 추상 타입(abstract type) 이므로 변수에 할당 될 수 없다. 따라서 coeff 가 벡터가 아니거나, 수 타입에 대한 벡터가 아니면 에러가 발생한다.\nIn [4]: poly1(3)\nERROR: MethodError: no method matching poly1(::Int64)\n\nIn [5]: poly1([sin, 1])\nERROR: MethodError: no method matching poly1(::Vector{Any})\nreturn 뒤의 x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1)))) 구문은 익명함수를 만드는 구문이다. 수를 받아 다항식을 계산하는 익명 함수를 반환한다. 이렇게 하면 ff = poly1([1.0, -2.0, 1.0]) 라 하면 ff(x) 는 \\(1-2x+x^2\\) 를 나타내는 다항식이다. 이 다항식의 함수에서 리턴 타입은 coeff 와 x 의 타입의 연산 규칙에 다라 결정된다.\n때에 따라서는 이것도 충분하며, 타입을 고려하지 않는다면 심지어 이것보다 간단한 버젼도 가능하다. 그러나 보통 다항식을 나타내는 자료구조를 생각하면, 최소한 다항식간의 덧셈, 뺄셈, 곱셈이 가능하면 좋을 것이다. 그리고 행렬의 다항식도 가능하다면 구현하면 좋을 것이다.\n익명 함수로는 이것이 힘들다. structure 를 이용하여 다항식 객체를 만들어 보자. 이미 널리 사용되는 Polynomials.jl 패키지가 있으므로 SimplePolynomial 이라는 객체를 만들도록 하자.\n\n\n\n\nstruct SimplePolynomial{T} \n    coeffs :: Vector{T}\n    \n    function SimplePolynomial(a::AbstractVector{P}) where P &lt;: Number\n        if length(a) == 0 \n            return new{P}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{P}(a[1:a_last])\n        end\n    end\n\n    function SimplePolynomial{T}(a::AbstractVector{P}) where {T &lt;: Number, P&lt;:Number}\n        if length(a) == 0 \n            return new{T}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{T}(convert.(T, a[1:a_last]))\n        end\n    end\n\nend\nSimplePolynomial 은 immutable 한 객체로 구현되었다. 즉 coeffs 속성은 변경 될 수 없다.\nIn [1]: a = SimplePolynomial([1, 3])\nOut[1]: SimplePolynomial{Int64}([1, 3])\n\nIn [2]: a.coeffs = [3.0, 4.0]\nERROR: setfield!: immutable struct of type SimplePolynomial cannot be changed\nstruct 구문 내부의 function SimplePolynomial 로 시작하는 구문은 내부생성자 (inner constructor) 구문이다. SimplePolynomial 자체가 타입매개변수 T 를 정할수 있는 타입이기 때문에 하나는 타입매개변수가 지정되지 않았을 때 타입을 계수로 주어진 인자 a 의 성분의 타입으로 정하고, 남은 하나는 a 를 타입 인자 T 로 주어지는 타입으로 변환시켜 다항식을 만들어 내게 된다.\n이제 SimplePolynomial 객체를 이용하여 수 형식, 혹은 정사각 행렬에 대한 다항식을 계산하는 함수를 만들자.\nusing LinearAlgebra\n\nfunction (p::SimplePolynomial)(x::Number)\n    return evalpoly(x, p.coeffs)\nend\n\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Matrix{N} where N&lt;:Number\n    r = UniformScaling(p.coeffs[1])\n\n    @assert size(x)[1] == size(x)[2] # 정사각 행렬에 대해서만 가능하다.\n    for i in 2:length(p.coeffs)\n        @inbounds r +=  p.coeffs[i]*x^(i-1)\n    end\n    return r\nend\n단위행렬의 상수배를 나타내는 연산자 UniformScaling을 위해 LinearAlgebra 모듈을 임포트 했다. 정사각 행렬임을 확인하기 위해 @assert size(x)[1] == size(x)[2] 를 삽입하였다. REPL 에서의 아래의 결과를 보면 정확히 구현되었음을 알 수 있다.\nIn [1]: a1 = SimplePolynomial([1.0, 2.0, 3.0])\nOut[1]: SimplePolynomial{Float64}([1.0, 2.0, 3.0])\n\nIn [2]: a1(1.0)\nOut[2]: 6.0\n\nIn [3]: a1([4 3; 2 4])\nOut[3]: 2×2 Matrix{Float64}:\n 75.0  78.0\n 52.0  75.0\n\nIn [4]: a1([4 3 3; 2 4 3])\nERROR: AssertionError: (size(x))[1] == (size(x))[2]\n다항식의 덧셈, 뺄셈, 곱셈을 정의하기 전에 다항식의 차수에 관련된 값을 리턴하는 함수를 만들자. 일반적으로 배열은 length 함수로 원소의 갯수를 알 수 있는데, 다항식에서는 계수의 갯수-1 이 차수가 된다. Base.length 함수에 대한 디스패치를 작성하여 이 함수를 이용하자.\nfunction Base.:length(b::P) where {P&lt;: SimplePolynomial}\n    return length(b.coeffs)\nend\n이제 SimpllePolynomial 객체 사이에 혹은 SimplePolynomial 객체와 상수간의 +, -, *, / 연산을 정의 할 수 있다. / 의 경우 일단은 다항식/상수 만을 정의한다. 이것에 대한 구현은 polynomial.jl 파일에 존재한다. Julia REPL 이나 Jupyter notebook 등에서 include 명령을 통해 사용 할 수 있다.\ninclude(\"path_to_polynomial.jl\")\n다항식 \\(p(x) = a_0 + a_1 x + \\cdots + a_n x^n\\) 일 때,\n\\[\n\\begin{aligned}\n\\dfrac{d}{dx}p(x) &= a_1 + 2a_2 x + \\cdots + na_n x^{n-1},\\\\\n\\int_x p(t)\\, dt &=a_0 x + \\dfrac{a_1}{2}x^2 + \\cdots + \\dfrac{a_n}{n+1}x^{n+1} + \\text{const.}\n\\end{aligned}\n\\]\n임을 안다. 이것을 이용하여 다항식을 미분하는 함수 differentiate(p::Polynomial{T}) 와 정적분 함수 integrate(p::Polynomial{T}, c) 함수를 구현하였다. 여기서 c 는 정적분의 상수항이다.\n\n\n\n\n다항식 \\(p(x)\\) 의 전체 근이 \\(x_1,\\,x_2,\\ldots,\\,x_n\\) 라고 하면 이 다항식은 상수 \\(c\\) 에 대해\n\\[\np(x) = c \\prod_{i=1}^n (x-x_i)\n\\]\n의 꼴을 갖는다. 우리는 이미 다항식의 곱셈을 구현했으므로 이를 쉽게 구현 할 수 있다. 여기서는 \\(c=1\\) 로 정해진 다항식을 리턴한다.\nfunction polynomial_from_roots(xp::Vector{T}) where T&lt;:Number\n    r = one(T)\n    for i in 1:length(xp) \n        @inbounds r = r* SimplePolynomial([-xp[i],  1])\n    end\n    return r\nend\n그렇다면,\njulia&gt; pp3 = polynomial_from_roots([1.0, 1.0, 2.0])\nSimplePolynomial :  + 1.0 x^3 - 4.0 x^2 + 5.0 x^1 - 2.0 \n의 결과가 나온다. \\((x-1)^2(x-2)= x^3-4x^2+5x-2\\) 이므로 정확한 결과가 나왔다."
  },
  {
    "objectID": "src/introduction_to_julia/10_metaprogramming_and_macro.html",
    "href": "src/introduction_to_julia/10_metaprogramming_and_macro.html",
    "title": "메타프로그래밍과 매크로",
    "section": "",
    "text": "메타프로그래밍은 프로그램 실행중에 자기 자신 혹은 다른 프로그램을 읽고 수정하고 실행할 수 있는 기술을 말합니다. Julia 처럼 어떤 언어가 자기 자신을 메타프로그래밍 하는것을 reflection 이라고 합니다. Julia 에서는 메타프로그래밍이 macro 를 통해 구현됩니다. Julia 에서의 메타프로그래밍과 매크로를 이해하기 위해서는 소스코드가 어떻게 실행되는지 그 과정을 이해해야 합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "메타프로그래밍과 매크로"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10_metaprogramming_and_macro.html#표현식",
    "href": "src/introduction_to_julia/10_metaprogramming_and_macro.html#표현식",
    "title": "메타프로그래밍과 매크로",
    "section": "1 표현식",
    "text": "1 표현식\n\n표현식의 생성\n\nMeta.parse\nJulia 에서 소스코드의 실행은 소스코드의 문자열을 파싱(parsing) 하여 Expr 객체인 표현식(expression) 을 만드는데서 시작합니다. 문자열을 표현식으로 바꾸는 함수는 Meta.parse 입니다. `\nIn [1]: ex1 = Meta.parse(\"1+2\")\nOut[1]: :(1 + 2)\n\nIn [2]: typeof(ex1)\nOut[2]: Expr\n\nIn [3]: ex1.head\nOut[3]: :call\n\nIn [4]: ex1.args\nOut[4]: 3-element Vector{Any}:\n  :+\n 1\n 2\nExpr 객체는 head 와 args 라는 두 부분으로 나뉩니다. head 는 Symbol 타입으로 표현식의 종류를, args 는 표현식에 사용되는 Symbol, 값, 구문 등을 의미합니다. 앞서 ex1.head 가 :call 인데 이것은 함수, 혹은 연산자 호출이라는 것을 의미합니다. 아래의 코드에서 보듯이 함수 호출이 아닌 할당에서는 head 가 :(=) 로 바뀝니다.\nIn [5]: ex2=Meta.parse(\"a=2\")\nOut[5]: :(a = 2)\n\nIn [6]: ex2.head, ex2.args\nOut[6]: (:(=), Any[:a, 2])\n\n표현식은 eval 함수를 통해 실행 할 수 있습니다.\nIn [8]: eval(ex1)\nOut[8]: 3\n\n\n\nQuoting\n우리는 앞서 심볼 타입 에서 a=:b 와 같이 : 를 사용하여 심볼 타입을 정의하는 것을 보았습니다. : 로 시작하는 구문은 심볼 타입 뿐만 아니라 표현식도 생성합니다. Out[1] 에서 보듯이 : 로 시작하여 ( ) 안에 표현된 구문은 표현식을 정의합니다. 이렇게 :( ) 를 이용하여 표현식을 정의하는 것을 quoting 이라고 합니다.\nIn [1]: ex1 = :(a=1+2)\nOut[1]: :(a = 1 + 2)\n\nIn [2]: ex2 = Meta.parse(\"a=1+2\")\nOut[2]: :(a = 1 + 2)\n\nIn [3]: ex1==ex2\nOut[3]: true\n\nIn [4]: eval(ex1)\nOut[4]: 3\n\nIn [5]: a\nOut[5]: 3\n\n\n표현식의 내부\n이제 표현식이 내부적으로 어떻게 구성되는지를 봅시다. 보통 두가지 방법이 있습니다. 하나는 dump 함수를 통해 들여쓰기와 참조 표시를 포함하여 출력하는 것입니다.\nIn [7]: dump(ex1)\nExpr\n  head: Symbol =\n  args: Array{Any}((2,))\n    1: Symbol a\n    2: Expr\n      head: Symbol call\n      args: Array{Any}((3,))\n        1: Symbol +\n        2: Int64 1\n        3: Int64 2\n다른 하나는 S-표현식 의 형태로 보는 것으로 Meta.show_sexp 함수를 이용합니다.\nIn [8]: Meta.show_sexpr(ex1)\n(:(=), :a, (:call, :+, 1, 2))\n\n\n\n:( ) 안에 값이 있는 경우\n한가지 유의해야 할 것은 표현식에 :(3) 처럼 :( ) 안에 값을 넣는다면 표현식이 아닌 값이 됩니다.\nIn [12]: :(3)\nOut[12]: 3\n\nIn [13]: :(3.34)\nOut[13]: 3.34\n\nIn [14]: :(\"aBγΔ\")\nOut[14]: \"aBγΔ\"\n\n\n\n\n\nquote ... end\n앞서 알아본 것처럼 :( ) 를 이용한 quting 을 통해 표현식을 정의 할 수 있으며 단순한 표현식에 적합합니다. 좀 더 복잡한 표현식을 위해서는 quote ... end 블럭을 다음과 같이 사용 할 수 있습니다.\nex = quote\n    x = 1\n    y = 2\n    x + y\nend\nex 는 :(x=1;y=2;x+y) 와 같습니다.\n\n\n\n표현식의 보간법\n\n$ 를 이용한 보간\n$ 를 이용한 문자열 보간처럼 $ 를 이용하여 표현식을 보간 할 수 있습니다.\nIn [1]: a=1;\n\nIn [2]: ex1 = :(b=$a+3)\nOut[2]: :(b = 1 + 3)\nex1 표현식 내의 $a 는 즉시 a 라는 변수가 가진 값 1 로 치환됩니다. $ 로 보간하지 않았을 경우에는 a 변수의 값이 바뀔 경우 그 결과가 달라집니다.\nIn [3]: ex2 = :(b=a+3)\nOut[3]: :(b = a + 3)\n\nIn [4]: eval(ex1), eval(ex2)\nOut[4]: (4, 4)\n\nIn [5]: a=4; eval(ex1), eval(ex2)\nOut[5]: (4, 7)\n앞서 말했듯이 $ 로 보간했을 때는 즉시 변수가 현재의 값으로 치환됩니다. 따라서 ex1 에는 변수 a 의 흔적이 남아 있지 않습니다. 그러나 $ 로 보간되지 않은 ex2 는 eval 함수가 실행 될 때의 a 값이 입력되므로 그 값이 바뀌게 됩니다.\nIn [6]: Meta.show_sexpr(ex1)\n(:(=), :b, (:call, :+, 1, 3))\n\nIn [7]: Meta.show_sexpr(ex2)\n(:(=), :b, (:call, :+, :a, 3))\n\n\n\n스플래팅 보간\n$ 를 이용한 보간은 한번에 하나의 표현식만 보간합니다. 앞서 알아본 … 연산자 처럼 표현식의 배열을 이용하여 한꺼번에 보간 할 수 있습니다.\nIn [1]: exprs = [:a, :b, :c]\nOut[1]: 3-element Vector{Symbol}:\n :a\n :b\n :c\n\nIn [2]: :(f(1, $(exprs...)))\nOut[2]: :(f(1, a, b, c))\n\n\n\n중첩된 quote\n앞서 우리는 표현식의 보간을 알아보았습니다. 표현식 또한 표현식에 보간 될 수 있습니다. 다음을 봅시다.\nIn [1]: ex = :(1+2);\n\nIn [2]: ex1 = quote $ex end\nOut[2]: quote\n    #= REPL[2]:1 =#\n    1 + 2\nend\n\nIn [3]: eval(ex1)\nOut[3]: 3\n\nIn [4]: ex2 = quote ex end\nOut[4]: quote\n    #= REPL[4]:1 =#\n    ex\nend\n\nIn [5]: eval(ex2)\nOut[5]: :(1 + 2)\n\nIn [6]: eval(eval(ex2))\nOut[6]: 3\nex 는 표현식이며 ex1 은 quoto ... end 안에 $ex 즉 1+2 라는 식을 삽입합니다. 따라서 ex1 은 quote 1+2 end 와 같습니다. ex2 는 quote ... end 안에 :(1+2) 를 삽입합니다. 따라서 ex2 는 quote :(1+2) end 와 같으며, eval(ex2) 는 (1 + 2) 를 반환합니다. 아래의 ex3 는 당연히 quote ex end 와 같습니다.\nIn [8]: ex3 = quote quote $ex end end\nOut[8]: quote\n    #= REPL[8]:1 =#\n    $(Expr(:quote, quote\n    #= REPL[8]:1 =#\n    $(Expr(:$, :ex))\nend))\nend\n\n\n\n\nQuoteNode\n\n\n\n함수를 호출하는 표현식\n두 수의 최대공약수를 구하는 함수는 gcd 입니다. 즉 gcd(4, 6) 은 2 입니다. 이 표현식에 대한 S-표현식은 다음과 같습니다.\nIn [1]: ex1 = :(gcd(4, 6))\nOut[1]: :(gcd(4, 6))\n\nIn [2]: Meta.show_sexpr(ex1)\n(:call, :gcd, 4, 6)\nS- 표현식을 이용하여 ex1 과 같은 표현식을 Expr(:call, :gcd, 4, 6) 을 통해 만들 수 있습니다.\nIn [3]: ex3 = Expr(:call, :gcd, 4, 6)\nOut[3]: :(gcd(4, 6))\n\nIn [4]: eval(ex3)\nOut[4]: 2\n즉 인자 op1, op1 를 받는 함수 func1 을 호출하는 표현식은 Expr(:call, :func1, op1, op2) 입니다. 만약 인자가 많아지면 계속 , 로 이어 쓰면 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "메타프로그래밍과 매크로"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10_metaprogramming_and_macro.html#매크로",
    "href": "src/introduction_to_julia/10_metaprogramming_and_macro.html#매크로",
    "title": "메타프로그래밍과 매크로",
    "section": "2 매크로",
    "text": "2 매크로\n매크로는 인자를 받아 표현식을 반환하는 특별한 타입의 함수라고 볼 수 있습니다. mymacro 라는 함수에 인자로 ag1, ag2 를 입력 할 때 @mymacro(ag1, ag2) 혹은 @mymacro ag1 ag2 와 같이 실핼 시킬 수 있습니다. 좀 더 자세히 알아봅시다.\n\n매크로와 함수의 차이\n매크로에 인자를 입력 할 수 있으며, 역시 함수와 유사합니다. 그러나 매크로는 함수와 다른 몇가지 차이점이 존재합니다.\n\n매크로는 전역 범위 내에서만 정의 될 수 있습니다.\n매크로의 인자는 매크로 내부에서 인자에 대한 표현식으로 바뀝니다.\n매크로의 반환값은 표현식이며 반환값을 값으로 반환하지 않고 실행합니다.\n매크로는 함수처럼 괄호 안에 인자를 나열할 수도 있으며, 괄호 없이 공백으로 구분하여 나열할 수도 있습니다.\n\n\n1은 매크로가 함수 정의 안이나 for ... end 같은 블럭 내부에서 정의될 수 없다는 것을 말합니다. 함수는 이와 반대로 함수 내부나 블럭 내부에서 정의 될 수 있습니다.\n\n\n매크로의 정의와 반환값\n매크로는 인자들을 받아 표현식을 반환하는 함수를 의미합니다. 매크로는 함수와 비슷하게 macro ... end 구문으로 정의하며, 매크로 이름 앞에 @ 를 붙여 실행 할 수 있습니다.\nIn [1]: macro hello_world()\n            return :(println(\"Hello, world!\"))\n        end\nOut[1]: @hello_world (macro with 1 method)\n\nIn [2]: @hello_world()\nHello, world!\n\n\n\n매크로의 인자\n우선 매크로에 전달되는 인자가 매크로 내부에서 어떻게 되는지 알아봅시다.\nIn [1]: macro hello_world(your_name)\n            println(\"In macro, arg is = \", your_name, \", and the type is \", typeof(your_name))\n            return :(println(:\"Hello, world! I'm \", $your_name))\n        end\nOut[1]: @hello_world (macro with 1 method)\n\nIn [2]: @hello_world(\"Julia\")\nIn macro, arg is = Julia, and the type is String\nHello, world! I'm Julia\n\nIn [3]: @hello_world(1+1)\nIn macro, arg is = 1 + 1, and the type is Expr\nHello, world! I'm 2\nIn [3] 를 봅시다. 인자로 1+1 을 넣었을 때 macro 내부에서는 Expr 객체인 :(1+1) 로 인식이 된다는 것을 알 수 있습니다. In [2] 의 경우처럼 식이 아닌 값을 넣는 경우는 앞에서 언급했듯이 표현식이 값으로 바뀝니다.\n\n\n\n매크로의 반환값과 macroexpand 매크로\n매크로는 정의상 표현식을 반환하지만 실제로는 반환되는 표현식을 실행합니다. 표현식을 반환받기 위해서는 macroexpand 라는 매크로를 사용합니다.\nIn [10]: @macroexpand(hello_world(\"Julia\"))\nOut[10]: :(hello_world(\"Julia\"))\n@macroexpand 는 매크로 분석에 아주 유용한 메크로입니다. 앞으로 @macroexpand 와 같이 @ 로 시작하는 이름은 별다른 설명이 없다면 매크로를 의미합니다.\n\n\n\n매크로 실행시 인자의 입력\n매크로는 인자를 함수처럼 ( ) 안에 넣어서 전달 할 수도 있지만 매크로 이름 뒤와 인자들 사이에 공백을 두고 나열 할 수 있습니다.\nIn [1]: macro club_members(mem1, mem2, mem3)\n            return :(println(\"Members are : \", $mem1, \", \", $mem2, \", \", $mem3))\n            end\nOut[1]: @club_members (macro with 1 method)\n\nIn [2]: @club_members(\"John\", \"Jenny\", \"Jucy\")\nMembers are : John, Jenny, Jucy\n\nIn [3]: @club_members \"Henny\" \"Mark\" \"Tony\"\nMembers are : Henny, Mark, Tony\n\n\n\n\n@assert 매크로\n개인적으로 많이 사용하는 매크로입니다. @assert 매크로는 인자로 true 나 false 를 판별하는 표현식과 문자열을 받으며 표현식이 true 일 경우는 아무것도 하지 않고 false 일 경우는 에러를 내며 프로그램을 정지합니다. @assert 매크로는 built-in 이므로 julia 에서 추가 패키지 설치 없이 실행 할 수 있습니다.\nIn [1]: @assert 2==3 \"에러 메시지\"\nERROR: AssertionError: 에러 메시지\n...\n2==3 은 거짓이므로 에러를 발생시킵니다. 에러에는 여러 종류가 있으며 여기서는 AssertionError 를 발생시켰습니다. 에러를 발생시킬 때는 추가 메시지를 출력 할 수 있는데 @assert 의 두번째 인자가 바로 추가메시지 입니다. @macroexpand 를 통해 @assert 가 반환하는 표현식을 봅시다.\nIn [22]: @macroexpand @assert a==b\nOut[22]: :(if a == b\n      nothing\n  else\n      Base.throw(Base.AssertionError(\"a == b\"))\n  end)\n자 이제 이것과 같은 일을 하는 매크로를 작성 해 봅시다. 실제 @assert 매크로와는 다를 수 있지만 거의 똑같이 작동합니다.\nIn [1]: macro myassert(ex, msgs...)\n            msg = ((isempty(msgs) ? ex : msgs[1]) |&gt; string)\n            return :($ex ? nothing : AssertionError($msg))\n        end\nOut[1]: @myassert (macro with 1 method)\n\nIn [2]: @myassert 3&gt;4 \"맞을 경우는 메시지가 출력되지 않음\"\nOut[2]: AssertionError(\"맞을 경우는 메시지가 출력되지 않음\")\n\nIn [3]: @myassert 3&lt;4 \"맞을 경우는 메시지가 출력되지 않음\"\n\n\n\n청결한 매크로\n매크로에 전달되는 표현식이 매크로를 오염시킬 수 있습니다. 다음의 코드를 봅시다.\nmacro mm(ex)\n    return quote\n        t = 1\n        println(\"표현식 평가 이전 t = \", t)\n        val = $ex\n        println(\"표현식 평가 이후 t = \", t, \", val = \", val)\n        return val\n    end\nend\n@mm t=100 으로 실행시키면 다음과 같은 출력을 얻습니다.\n표현식 평가 이전 t = 1\n표현식 평가 이후 t = 100, val = 100\n100\n코드의 5 번째 줄 val = $ex 에서 실제로 수행하는 것은 val = t = 100 이며, t 와 val 모두 100 이 됩니다. 이 때 사용될 수 있는 것이 esc 함수입니다. esc 함수는 매크로 내에서만 사용 할 수 있는 함수로, 표현식을 평가할 때 내부 변수의 오염을 막아줍니다. 이제 다음 코드를 봅시다.\nmacro nn(ex)\n    return quote\n        t = 1\n        println(\"표현식 평가 이전 t = \", t)\n        val = $(esc(ex))\n        println(\"표현식 평가 이후 t = \", t, \", val = \", val)\n        val\n    end\nend\n@mm 과 @nn 의 차이는 5번째 줄에 esc 함수를 사용했다는 것 뿐입니다. @nn t=100 을 실행하면 우리가 원했던 오염되지 않은 결과를 얻습니다.\n표현식 평가 이전 t = 1\n표현식 평가 이후 t = 1, val = 100\n100\n\n\n\n코드 생성\n예를 들어 당신이 Float64 형태의 값에 대한 특별한 타입을 필요로 한다고 하자. 이 값은 일반적인 실수에 대해 sin 과 cos 값이 바뀌고, 따라서 tan 와 cot 함수값이 바뀌어야 한다고 하자. 실제로 이런 타입이 필요한지는 모르겠지만 일단은 연습이다. 새로운 타입을 XNum 이라고 하자. 물론 sin(v::XNum) = cos(v.val) 과 같이 네 함수에 대해 정의 할 수 있지만 표현식을 이용하여 다음과 같이 일괄적으로 바꿔 줄 수 있다.\nstruct XNum\n    val::Real\n\n    function XNum(v::Real)\n        return new(Float64(v))\n    end\nend\n\nfor (op1, op2) ∈ zip((:sin, :cos, :tan, :cot), (:cos, :sin, :cot, :tan))\n    eval(quote\n        Base.$op1(a::XNum) = XNum($op2(a.val))\n    end)\nend\nfor ... 문 안의 eval(ex::Expr) 함수는 표현식 ex 를 실행시키며 이것은 @eval 매크로를 사용하여 다음과 같이 쓸 수 있다.\nfor (op1, op2) ∈ zip((:sin, :cos, :tan, :cot), (:cos, :sin, :cot, :tan))\n    @eval Base.$op1(a::XNum) = XNum($op2(a.val))\nend",
    "crumbs": [
      "Julia 언어의 기초",
      "메타프로그래밍과 매크로"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html",
    "href": "src/introduction_to_julia/09_composite_types.html",
    "title": "복합 타입",
    "section": "",
    "text": "복합 타입(composite type) 은 필드(field)라고 불리는 하위 변수를 갖는 타입이며, 필드는 정수나 실수 타입 뿐만 아니라 함수 타입이나 다른 복합 타입이 될 수 있습니다. 아주 간단한 복합 타입으로 2차원 평면 상의 점에 대한 복합타입을 다음과 같이 정의 할 수 있습니다.\nstruct Point\n    x\n    y\nend\n복합타입의 정의는 struct 로부터 시작하여 end 로 끝납니다. 위에서 Point 는 구체적 타입의 이름이 되며, x, y 라는 두개의 필드를 가질 수 있습니다.\nIn [2]: isconcretetype(Point)\nOut[2]: true\nPoint 타입의 변수는 p1 = Point(1, 2) 와 같이 생성할 수 있으며 각 필드는 p1.x, p1.y 와 같이 접근합니다.\nIn [3]: p1 = Point(1, 2)\nOut[3]: Point(1, 2)\n\nIn [4]: println(\"Point p1.x=$(p1.x), p1.y=$(p1.y)\")\nPoint p1.x=1, p1.y=2\n\nIn [5]: typeof(p1) # `Point` is a name of type\nOut[5]: Point\n복합 타입 인스턴스는 특별히 따로 정하지 않았다면 타입이름을 함수처럼 사용하여 생성합니다. 인자는 타입 정의에서 나열된 필드순으로 입력하면 됩니다. 즉 p1=Point(1, 2) 는 x 필드는 1, y 필드는 2 의 값을 갖는 Point 객체 인스턴스를 생성하라는 뜻입니다. 이렇게 타입 인스턴스를 만드는 함수를 생성자(constructor) 라고 합니다. 생성자는 별도로 정의할수도 있지만 위에서처럼 타입 이름을 함수로 사용하여 인자로 필드 값을 나열하는 생성자를 기본 생성자(default constructor) 라고 합니다.\n\n\n\n\n복합타입을 정의 할 때 아래와 같이 타입 매개 변수를 사용하여 정의 할 수 있습니다.\nstruct OneValue{T}\n    val::T\nend\nIn [8]: x=OneValue(3)\nOut[8]: OneValue{Int64}(3)\n\nIn [9]: y=OneValue{Float64}(4)\nOut[9]: OneValue{Float64}(4.0)\n\nIn [10]: typeof(x) == typeof(y)\nOut[10]: false\n\nIn [11]: typeof(x) == typeof(OneValue{Int64}(5))\nOut[11]: true\nstruct OneValue{T} 에서 OneValue 는 타입 이름이며 {T} 에서 {T} 가 타입에 대한 매개변수입니다. 타입에 대한 매개변수는 타입 이름일 수도 있으며 정수, 실수, Symbol 이나 Bool 과 같은 bit 타입의 값이 올 수 있습니다. 일단 매개변수로 받으면 필드의 정의나 생성자의 정의에서 사용 할 수 있습니다. 이 때 x 와 y 의 타입 즉 OneValue{Int64} 와 OneValue{Float64} 는 다른 타입입니다.\nIn [8] 을 봅시다. 매개변수 T 는 필드 val 의 타입으로 정의되었습니다. x=OneValue(3) 처럼 매개변수를 사용하지 않고 인스턴스를 만들면 val 의 타입이 자연스럽게 T 가 됩니다. In [9] 의 경우처럼 y=OneValue{Float64}(4) 와 같이 매개변수를 명시적으로 지정했을 경우에는 필드 val 의 타입이 T==Float64 로 강제로 변환됩니다.\n이렇게 타입 매개변수로 타입을 만들면 그 매개변수를 이후에도 사용 할 수 있습니다. 아래의 isIntType(o::OneValue{T}) 함수는 OneValue{T} 의 T 가 Integer 의 하위타입인지를 확인하는 함수입니다. 물론 o.val 의 타입을 확인할 수도 있지만 아래의 것이 훨씬 깔끔합니다.\nfunction isIntType(o::OneValue{T}) where T\n    if T&lt;:Integer\n        return true\n    else\n        return false\n    end\nend\nOut[13]: isIntType (generic function with 1 method)\n\nIn [14]: isIntType(x)\nOut[14]: true\n\nIn [15]: isIntType(y)\nOut[15]: false\n\n\n\n\n이제 우선 우리에게 아마도 익숙할 복소수 타입을 봅시다. Julia 는 복소수를 다루기 위한 Complex{T} 타입을 내장하고 있습니다. Complex{T} 는 필드로 실수부와 허수부를 가지며 다음과 같이 정의됩니다.\nstruct Complex{T&lt;:Real} &lt;: Number\n    re::T\n    im::T\nend\n\nComplex(x::Real, y::Real) = Complex(promote(x,y)...)\nComplex(x::Real) = Complex(x, zero(x))\n\n&lt;:Number 를 통해 Complex 객체는 Number 의 하위타입으로 정의됩니다.\nComplex{T&lt;:Real} 은 매개변수 T 를 통해 re 와 im 필드의 타입을 제한합니다. T&lt;:Real 이며 re::T, im::T 이므로 두 필드 는 Real 의 동일한 하위타입이어야 합니다. 두 개 이상의 타입이 필요할 경우는 {T1&lt;:Real, T2&lt;:Integer} 와 같이 { } 안에 , 로 분리하여 나열하면 됩니다.\n생성자가 타입 정의 외부에 존재합니다. 이를 외부생성자라고 합니다.\n첫번째 생성자는 x 와 y 가 Real 타입의 하위 타입일 때 타입을 일치시키기 위한 생성자입니다. promote(x, y) 는 x 와 y 변수의 타입을 두 변수를 공통적으로 표현할 수 있는 타입으로 변환시켜 튜플로 반환합니다. 이렇게 다른 타입의 둘 이상의 값을 같은 타입이 되도록 변환하는 것을 julia 에서는 promotion 이라고 합니다. promote(2, 3.0) == (2.0, 3.0) 입니다. 그런데 Complex(promote(2, 3.0)) 은 Complex(2.0, 3.0) 이 아니라 Complex((2.0, 3.0)) 으로 튜플 인자 하나만 주어지며, 따라서 에러가 발생합니다. Complex(promote(2, 3.0)...) 는 promote(2, 3.0) 의 결과로 주어지는 튜플을 풀어서 함수의 인자로 넣도록 합니다. 즉, Complex(promote(2, 3.0)...) 은 결과적으로 Complex(2.0, 3.0) 입니다. 함수를 실행시킬때 인자에서의 사용법 을 참고하시기 바랍니다.\n두번째 생성자는 인자가 하나만 주어졌을 때 im 필드를 인자 re 필드와 같은 타입의 0 으로 간주하여 생성하도록 하는 생성자입니다.\n\nComplex{T&lt;:Real} 은 다음과 같이 사용 할 수 있습니다.\nIn [1]: com1 = Complex{Float32}(3.3, 2.3) #Float32 타입의 필드를 갖는 복소수\nOut[1]: 3.3f0 + 2.3f0im\n\nIn [2]: com2 = Complex(3.3, 2.3) # 3.3, 2.3 이 Float64 이므로 타입의 필드를 갖는 복소수\nOut[2]: 3.3 + 2.3im\n\nIn [3]: com3 = 3.3 + 2.3im # 복소수를 선언하는 두번째 방법\nOut[3]: 3.3 + 2.3im\n\nIn [4]: com2 == com3 # 둘은 같다\nOut[4]: true\ntrue\n\n복합타입 변수의 필드에 접근하기 위해서는 . 를 사용합니다.\nIn [6]: c1 = Complex{Float64}(2.0, 3.0)\nOut[6]: 2.0 + 3.0im\n\nIn [7]: c1.re\nOut[7]: 2.0\n\nIn [8]: c1.im\nOut[8]: 3.0\n\nIn [9]: c1.im = 4.0\nERROR: setfield!: immutable struct of type Complex cannot be changed\n\n복합타입의 경우는 기본적으로 immutable 입니다. 즉 필드의 값을 직접적으로 바꿀 수 없으며 In [9] 에서와 같이 직접적으로 변경하고자 하면 에러가 발생합니다. 복합타입의 필드의 값을 바꿀 수 있는 복합타입은 mutable 이라고 하며 뒤에 변경할 수 있는 복합 타입 에서 다루겠습니다.\n\n\n\n\n복합 타입 선언 내부에서 정의된 생성자를 내부생성자 (inner constructor) 라고 하며 반대로 앞서의 Complex{T&lt;:Real} 처럼 생성자가 복합 타입 선언 밖에서 정의된 생성자를 외부 생성자 (outer constructor) 라고 합니다. 내부생성자에는 new 함수를 사용 할 수 있는데 new 함수는 생성자를 찾지 않고 즉각적으로 멤버에 접근하여 복합 타입을 만들게 해 줍니다. new 함수는 외부생성자에서는 사용 할 수 없습니다.\n코드 유지보수의 관점에서는 아무래도 외부생성자가 편리합니다. 그러나 내부생성자만이 할 수 있는 일은 기본생성자를 변경하는 것입니다. 다음의 예를 봅시다.\nstruct A\n    m::Int64\n    function A(x, y)\n        return new(Int64(x+y))\n    end\nend\n\nstruct B\n    m::Int64\nend\n\nfunction B(x, y)\n    return B(Int64(x+y))\nend\nA 와 B 는 모두 m 이라는 필드 하나만 가지고 있습니다. 이 때 B(3) 은 기본생성자가 호출되어 B.m==3 인 객체가 만들어지지만 A(3) 은 기본생성자가 교체되었으므로 에러가 발생합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "복합 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html#복합-타입",
    "href": "src/introduction_to_julia/09_composite_types.html#복합-타입",
    "title": "복합 타입",
    "section": "",
    "text": "복합 타입(composite type) 은 필드(field)라고 불리는 하위 변수를 갖는 타입이며, 필드는 정수나 실수 타입 뿐만 아니라 함수 타입이나 다른 복합 타입이 될 수 있습니다. 아주 간단한 복합 타입으로 2차원 평면 상의 점에 대한 복합타입을 다음과 같이 정의 할 수 있습니다.\nstruct Point\n    x\n    y\nend\n복합타입의 정의는 struct 로부터 시작하여 end 로 끝납니다. 위에서 Point 는 구체적 타입의 이름이 되며, x, y 라는 두개의 필드를 가질 수 있습니다.\nIn [2]: isconcretetype(Point)\nOut[2]: true\nPoint 타입의 변수는 p1 = Point(1, 2) 와 같이 생성할 수 있으며 각 필드는 p1.x, p1.y 와 같이 접근합니다.\nIn [3]: p1 = Point(1, 2)\nOut[3]: Point(1, 2)\n\nIn [4]: println(\"Point p1.x=$(p1.x), p1.y=$(p1.y)\")\nPoint p1.x=1, p1.y=2\n\nIn [5]: typeof(p1) # `Point` is a name of type\nOut[5]: Point\n복합 타입 인스턴스는 특별히 따로 정하지 않았다면 타입이름을 함수처럼 사용하여 생성합니다. 인자는 타입 정의에서 나열된 필드순으로 입력하면 됩니다. 즉 p1=Point(1, 2) 는 x 필드는 1, y 필드는 2 의 값을 갖는 Point 객체 인스턴스를 생성하라는 뜻입니다. 이렇게 타입 인스턴스를 만드는 함수를 생성자(constructor) 라고 합니다. 생성자는 별도로 정의할수도 있지만 위에서처럼 타입 이름을 함수로 사용하여 인자로 필드 값을 나열하는 생성자를 기본 생성자(default constructor) 라고 합니다.\n\n\n\n\n복합타입을 정의 할 때 아래와 같이 타입 매개 변수를 사용하여 정의 할 수 있습니다.\nstruct OneValue{T}\n    val::T\nend\nIn [8]: x=OneValue(3)\nOut[8]: OneValue{Int64}(3)\n\nIn [9]: y=OneValue{Float64}(4)\nOut[9]: OneValue{Float64}(4.0)\n\nIn [10]: typeof(x) == typeof(y)\nOut[10]: false\n\nIn [11]: typeof(x) == typeof(OneValue{Int64}(5))\nOut[11]: true\nstruct OneValue{T} 에서 OneValue 는 타입 이름이며 {T} 에서 {T} 가 타입에 대한 매개변수입니다. 타입에 대한 매개변수는 타입 이름일 수도 있으며 정수, 실수, Symbol 이나 Bool 과 같은 bit 타입의 값이 올 수 있습니다. 일단 매개변수로 받으면 필드의 정의나 생성자의 정의에서 사용 할 수 있습니다. 이 때 x 와 y 의 타입 즉 OneValue{Int64} 와 OneValue{Float64} 는 다른 타입입니다.\nIn [8] 을 봅시다. 매개변수 T 는 필드 val 의 타입으로 정의되었습니다. x=OneValue(3) 처럼 매개변수를 사용하지 않고 인스턴스를 만들면 val 의 타입이 자연스럽게 T 가 됩니다. In [9] 의 경우처럼 y=OneValue{Float64}(4) 와 같이 매개변수를 명시적으로 지정했을 경우에는 필드 val 의 타입이 T==Float64 로 강제로 변환됩니다.\n이렇게 타입 매개변수로 타입을 만들면 그 매개변수를 이후에도 사용 할 수 있습니다. 아래의 isIntType(o::OneValue{T}) 함수는 OneValue{T} 의 T 가 Integer 의 하위타입인지를 확인하는 함수입니다. 물론 o.val 의 타입을 확인할 수도 있지만 아래의 것이 훨씬 깔끔합니다.\nfunction isIntType(o::OneValue{T}) where T\n    if T&lt;:Integer\n        return true\n    else\n        return false\n    end\nend\nOut[13]: isIntType (generic function with 1 method)\n\nIn [14]: isIntType(x)\nOut[14]: true\n\nIn [15]: isIntType(y)\nOut[15]: false\n\n\n\n\n이제 우선 우리에게 아마도 익숙할 복소수 타입을 봅시다. Julia 는 복소수를 다루기 위한 Complex{T} 타입을 내장하고 있습니다. Complex{T} 는 필드로 실수부와 허수부를 가지며 다음과 같이 정의됩니다.\nstruct Complex{T&lt;:Real} &lt;: Number\n    re::T\n    im::T\nend\n\nComplex(x::Real, y::Real) = Complex(promote(x,y)...)\nComplex(x::Real) = Complex(x, zero(x))\n\n&lt;:Number 를 통해 Complex 객체는 Number 의 하위타입으로 정의됩니다.\nComplex{T&lt;:Real} 은 매개변수 T 를 통해 re 와 im 필드의 타입을 제한합니다. T&lt;:Real 이며 re::T, im::T 이므로 두 필드 는 Real 의 동일한 하위타입이어야 합니다. 두 개 이상의 타입이 필요할 경우는 {T1&lt;:Real, T2&lt;:Integer} 와 같이 { } 안에 , 로 분리하여 나열하면 됩니다.\n생성자가 타입 정의 외부에 존재합니다. 이를 외부생성자라고 합니다.\n첫번째 생성자는 x 와 y 가 Real 타입의 하위 타입일 때 타입을 일치시키기 위한 생성자입니다. promote(x, y) 는 x 와 y 변수의 타입을 두 변수를 공통적으로 표현할 수 있는 타입으로 변환시켜 튜플로 반환합니다. 이렇게 다른 타입의 둘 이상의 값을 같은 타입이 되도록 변환하는 것을 julia 에서는 promotion 이라고 합니다. promote(2, 3.0) == (2.0, 3.0) 입니다. 그런데 Complex(promote(2, 3.0)) 은 Complex(2.0, 3.0) 이 아니라 Complex((2.0, 3.0)) 으로 튜플 인자 하나만 주어지며, 따라서 에러가 발생합니다. Complex(promote(2, 3.0)...) 는 promote(2, 3.0) 의 결과로 주어지는 튜플을 풀어서 함수의 인자로 넣도록 합니다. 즉, Complex(promote(2, 3.0)...) 은 결과적으로 Complex(2.0, 3.0) 입니다. 함수를 실행시킬때 인자에서의 사용법 을 참고하시기 바랍니다.\n두번째 생성자는 인자가 하나만 주어졌을 때 im 필드를 인자 re 필드와 같은 타입의 0 으로 간주하여 생성하도록 하는 생성자입니다.\n\nComplex{T&lt;:Real} 은 다음과 같이 사용 할 수 있습니다.\nIn [1]: com1 = Complex{Float32}(3.3, 2.3) #Float32 타입의 필드를 갖는 복소수\nOut[1]: 3.3f0 + 2.3f0im\n\nIn [2]: com2 = Complex(3.3, 2.3) # 3.3, 2.3 이 Float64 이므로 타입의 필드를 갖는 복소수\nOut[2]: 3.3 + 2.3im\n\nIn [3]: com3 = 3.3 + 2.3im # 복소수를 선언하는 두번째 방법\nOut[3]: 3.3 + 2.3im\n\nIn [4]: com2 == com3 # 둘은 같다\nOut[4]: true\ntrue\n\n복합타입 변수의 필드에 접근하기 위해서는 . 를 사용합니다.\nIn [6]: c1 = Complex{Float64}(2.0, 3.0)\nOut[6]: 2.0 + 3.0im\n\nIn [7]: c1.re\nOut[7]: 2.0\n\nIn [8]: c1.im\nOut[8]: 3.0\n\nIn [9]: c1.im = 4.0\nERROR: setfield!: immutable struct of type Complex cannot be changed\n\n복합타입의 경우는 기본적으로 immutable 입니다. 즉 필드의 값을 직접적으로 바꿀 수 없으며 In [9] 에서와 같이 직접적으로 변경하고자 하면 에러가 발생합니다. 복합타입의 필드의 값을 바꿀 수 있는 복합타입은 mutable 이라고 하며 뒤에 변경할 수 있는 복합 타입 에서 다루겠습니다.\n\n\n\n\n복합 타입 선언 내부에서 정의된 생성자를 내부생성자 (inner constructor) 라고 하며 반대로 앞서의 Complex{T&lt;:Real} 처럼 생성자가 복합 타입 선언 밖에서 정의된 생성자를 외부 생성자 (outer constructor) 라고 합니다. 내부생성자에는 new 함수를 사용 할 수 있는데 new 함수는 생성자를 찾지 않고 즉각적으로 멤버에 접근하여 복합 타입을 만들게 해 줍니다. new 함수는 외부생성자에서는 사용 할 수 없습니다.\n코드 유지보수의 관점에서는 아무래도 외부생성자가 편리합니다. 그러나 내부생성자만이 할 수 있는 일은 기본생성자를 변경하는 것입니다. 다음의 예를 봅시다.\nstruct A\n    m::Int64\n    function A(x, y)\n        return new(Int64(x+y))\n    end\nend\n\nstruct B\n    m::Int64\nend\n\nfunction B(x, y)\n    return B(Int64(x+y))\nend\nA 와 B 는 모두 m 이라는 필드 하나만 가지고 있습니다. 이 때 B(3) 은 기본생성자가 호출되어 B.m==3 인 객체가 만들어지지만 A(3) 은 기본생성자가 교체되었으므로 에러가 발생합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "복합 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html#다양한-복합-타입",
    "href": "src/introduction_to_julia/09_composite_types.html#다양한-복합-타입",
    "title": "복합 타입",
    "section": "2 다양한 복합 타입",
    "text": "2 다양한 복합 타입\n\n변경할 수 있는 복합 타입 (mutable struct)\n앞서 언급했듯이 복합타입은 기본적으로 immutable 입니다. 이 말은 한 번 생성된 복합타입의 필드의 값을 바꿀 수 없다는 뜻입니다. 필드의 값을 바꿀 수 있는 복합타입은 struct 앞에 mutable 키워드를 넣습니다.\nmutable struct mycomplex2{T&lt;:Real} &lt;: Number\n    re::T\n    im::T\nend\n\nmycomplex2(x::Real, y::Real) = mycomplex2(promote(x, y)...)\nmycomplex2(x::Real) = mycomplex2(x, zero(x))\n위의 mycomplext2 타입을 생성하고 필드의 값을 바꿀 수 있습니다.\nIn [4]: c2 = mycomplex2(2.0, 3.0)\nOut[4]: mycomplex2{Float64}(2.0, 3.0)\n\nIn [5]: c2.im\nOut[5]: 3.0\n\nIn [6]: c2.im = -3\nOut[6]: -3\n\nIn [7]: c2\nOut[7]: mycomplex2{Float64}(2.0, -3.0)\n\n\n\n싱글톤 타입\n어떤 타입의 인스턴스가 단 하나만 존재할 수 있을 때 이를 싱글톤(singleton) 객체라고 합니다. 예를 들어 Complex(3.0, 4.0) 과 Complex(1.0, 2.0) 은 모두 Complex{Float64} 타입의 서로 다른 인스턴스입니다. 그러나 싱글톤 타입이라면 모든 타입 인스턴스가 같아야 합니다. Julia 에서 싱글톤 타입은 필드가 없는 복합타입입니다.\nstruct mysingleton end\n와 같이 정의합니다. 이 때 모든 mysingleton 타입의 인스턴스는 동일합니다.\nIn [1]: struct mysingleton end;\n\nIn [2]: a, b = mysingleton(), mysingleton();\n\nIn [3]: a===b\nOut[3]: true\n타입 매개변수를 가지는 싱글턴 타입도 존재합니다.\nstruct mysingleton1{T} end\n와 같이 정의합니다. 이 때 T 가 다르면 다른 인스턴스이며, T 가 같으면 같은 인스턴스입니다.\nIn [5]: struct mysingleton1{T} end\n\nIn [6]: c, d = mysingleton1{Int64}, mysingleton1{Int64}\nOut[6]: (mysingleton1{Int64}, mysingleton1{Int64})\n\nIn [7]: c === d\nOut[7]: true\n\nIn [8]: c, d = mysingleton1{Int64}, mysingleton1{Float64}\nOut[8]: (mysingleton1{Int64}, mysingleton1{Float64})\n\nIn [9]: c === d\nOut[9]: false\n\nIn [10]: c == d\nOut[10]: false\n\n당연히 어떤 추상 타입의 하위 타입으로서의 싱글턴 타입도 정할 수 있습니다.\nabstract type AbsSingletonType end\n\nstruct abstype1 &lt;: AbsSingletonType end\n\nJulia 에서 싱글턴 타입은 아주 많이 사용됩니다. 우선 아주 많이 사용하는 nothing 은 Nothing 타입의 싱글턴 객체입니다. 또한 julia 에서의 함수는 추상타입 Function 의 하위타입인 싱글턴 객체입니다.\nIn [15]: typeof(sin)\nOut[15]: typeof(sin) (singleton type of function sin, subtype of Function)\n당신이 당신의 코드 내에서 어떤 유일한 것을 원한다면 그것을 싱글턴 객체로 만들 수 있습니다. 또 하나 중요한것은 싱글턴 객체는 저장공간을 차지하지 않습니다.\n\n\n\n매개변수를 갖는 추상 타입\n우리는 추상적 타입 에 대해 이미 알아보았습니다. 매개변수를 갖는 추상적 타입도 존재합니다. 다음과 같이 선언합니다.\nabstract type PAType{T} end     # parametric abstract type\n\nstruct PCType{T} &lt;: PAType{T}   # parametric concrete type\n    field::T\nend\n이렇게 되면 PCT{T} 는 같은 T 에 대해서만 PAType{T} 의 하위 타입 이 됩니다.\nIn [3]: PCType{Float32} &lt;: PAType{Float32}\nOut[3]: true\n\nIn [4]: PCType{Float32} &lt;: PAType{Int64}\nOut[4]: false\n\n이제 다음과 같은 타입 구조를 봅시다.\nabstract type AA end\n\nabstract type AB{T&lt;:Real} &lt;: AA end\n\nstruct AC{T} &lt;: AB{T}\n    f::T\nend\nAC{T} 의 상위 타입이 AB{T&lt;:Real} 이므로 T 는 Real 의 하위 타입이어야만 합니다. 따라서 AC{String} 로 타입을 정할 수 없습니다. 또한 메서드를 정의할 때 AA 타입으로 인자를 정하면 모든 AC{T} 타입에 대해 사용 할 수 있습니다.\nIn [5]: qad(x::AA) = x.f+3\nOut[5]: qad (generic function with 1 method)\n\nIn [6]: qad(AC{Float32}(4))\nOut[6]: 7.0f0",
    "crumbs": [
      "Julia 언어의 기초",
      "복합 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html#연습-모듈러-산술",
    "href": "src/introduction_to_julia/09_composite_types.html#연습-모듈러-산술",
    "title": "복합 타입",
    "section": "3 연습 : 모듈러 산술",
    "text": "3 연습 : 모듈러 산술\n이제 지금까지 했던 것을 가지고 뭔가 좀 고차원적인 일을 해 봅시다. 정수를 다루는 수학의 분야를 정수론이라고 하며 여기서 모듈러 산술이라는 것을 다룹니다. 8 을 5로 나누면 나머지가 3이며 33 도 5로 나누면 나머지가 3입니다. 이것을 다음과 같이 표현합니다.\n\\[\n8 \\equiv 33 \\, (\\textrm{mod}\\, 5)\n\\]\n이것은 8 과 33 은 5로 나눈 나머지가 같다는 뜻입니다.두 정수 \\(a,\\,b\\) 와 자연수 \\(n\\) 에 대해\n\\[\na \\equiv b \\, (\\textrm{mod}\\, n)\n\\]\n은 \\(a\\) 와 \\(b\\) 는 \\(n\\) 으로 나누었을 때의 나머지와 같다는 입니다. 재미있는 것은 이 관계를 이용하여 사칙연산을 할 수 있다는 것입니다. \\(a \\equiv b \\, (\\textrm{mod}\\, n)\\), \\(c \\equiv d\\, (\\textrm{mod}\\, n)\\) 일 때 다음이 성립합니다.\n  (\\(1\\)) \\((a+c) \\equiv (b+d)\\, (\\textrm{mod}\\, n)\\).\n  (\\(2\\)) \\((a-c) \\equiv (b-d)\\, (\\textrm{mod}\\, n)\\).\n  (\\(3\\)) \\(ac \\equiv bd\\, (\\textrm{mod}\\, n)\\).\n  (\\(4\\)) \\(n\\) 이 소수이면 \\(ax \\equiv 1\\, (\\textrm{mod}\\, n)\\) 인 자연수 \\(x\\) 가 존재한다.\n\\(n\\) 이 소수가 아니더라라도 \\(a\\) 와 \\(n\\) 의 최대공약수가 \\(1\\) 이라면, 즉 \\(\\gcd(a,\\, n)=1\\) 이면 \\(ax\\equiv 1\\, (\\textrm{mod}\\, n)\\) 인 \\(x\\) 가 존재하지만 모든 수에 대해 존재하는 것은 아닙니다. \\(n\\) 이 소수일 경우에는 \\(n\\) 보다 작은 모든 자연수 \\(a\\) 에 대해 \\(\\gcd (a,n)=1\\) 이므로 (\\(4\\)) 가 성립합니다. 이 때 \\(x = a^{-1}\\) 이라고 하고 나누기를 \\(b/a := ba^{-1}\\) 로 정의 할 수 있습니다. 그렇다면 소수인 \\(n\\) 에 대해 \\(a^{-1}\\) 값은 어떻게 계산할까요? 그리고 주어진 \\(a\\) 에 대해 \\(ax \\equiv 1 \\, (\\text{mod}\\, n)\\) 인 \\(x\\) 는 오직 하나일까요? 일단 뒤의 문제부터 답하자면 소수 \\(n\\) 에 대해 \\(a^{n-1} \\equiv 1\\, (\\text{mod}\\, n)\\) 이라는 것이 알려져 있습니다\\(^1\\). 따라서 \\(a^{-1} \\equiv a^{n-2}\\, (\\textrm{mod}\\, n)\\) 이다. 또한 \\(ax\\equiv 1\\, (\\textrm{mod}\\, n),\\, ay\\equiv 1\\, (\\textrm{mod}\\, n)\\) 이면 \\(n\\) 이 소수일 때 \\(x \\equiv y\\, (\\textrm{mod}\\, n)\\) 입니다.\\(^1\\) 이를 페르마의 소정리(Fermat’s little theorem) 이라고 합니다.\n이렇게 어떤 자연수(\\(n\\)) 에 대한 나머지로 사칙연산을 수행하는 것을 모듈러 산술(modular arithematic) 이라고 합니다. \\(n\\) 이 소수가 아니라면 덧셈 뺄셈, 곱셈만 정의되며 나눗셈은 정의 할 수 없지만 \\(n\\) 이 소수라면 모두 정의 할 수 있습니다.\n이제 이 모듈러 산술에 대한 자료형과 함수를 만들어 봅시다. \\(n\\) 이 소수인 경우와 소수가 아닌 경우를 구분해야 하기 때문에 소수를 판별하는 함수를 작성해야 합니다. \\(n\\) 이 매우 큰 수가 아니라면 가장 간단하게 사용할 수 있는 알고리즘은 \\(2\\) 부터 \\(\\sqrt{n}\\) 보다 크지 않은 모든 정수에 대해 \\(n\\) 과의 최대공약수가 1 인지를 확인하는 것입니다.\nconst max_modular = 1_000_000_000\n\nfunction isprime(v::Integer)\n    @assert 1&lt;v&lt;max_modular \n    result = true\n    for x in 2:floor(Int64, √v)\n        if v % x == 0\n            result = false\n            break\n        end\n    end\n    return result\nend\nmax_modular 는 \\(n\\) 값이 될 수 있는 최대값으로 정합니다. 너무 큰 수에 대해 계산하는 것을 방지하기 위한 것 말고는 큰 의미가 없습니다.\n우선 최상위의 추상 타입 (코드에서는 AbstractMod{T, N}) 과 \\(n\\) 이 소수일 때, 그리고 소수가 아닐 때를 구별하여 타입을 만듭니다. 각각 PrimeMod 와 Mod 입니다. 값은 여러 정수의 타입을 가질수 있어야 하기 때문에 타입 매개변수 T 를 사용합니다. 더불어 \\(n\\) 값도 복합타입의 매개변수 N 으로 넣습니다.\nabstract type AbstractMod{T, N} end \n\nconst max_modular = 1_000_000_000\n\nfunction isprime(v::Integer)\n    @assert 1&lt;v&lt;max_modular \n    result = true\n    for x in 2:floor(Int64, √v)\n        if v % x == 0\n            result = false\n            break\n        end\n    end\n    return result\nend\n\nstruct PrimeMod{T, N} &lt;: AbstractMod{T, N}\n    value::T\n    \n    function PrimeMod{T, N}(x::Integer) where {T&lt;:Integer, N}\n        @assert N &gt; 1 \"Modulos must be larger than 1\"\n        @assert isprime(N) \"Must be a prime number\"\n        r = (x ≥ 0) ? x%N : (x%N)+N \n        return new{T, N}(r)\n    end\nend\n\nstruct Mod{T, N} &lt;: AbstractMod{T, N}\n    value::T\n\n    function Mod{T, N}(x::Integer) where {T&lt;:Integer, N}\n        @assert N &gt; 1 \"Modulos must be larger than 1\"\n        x = T(x)\n        r = (x ≥ 0) ? x%N : (x%N)+N \n        if isprime(N)\n            return PrimeMod{T, N}(r)\n        else \n            return new{T, N}(r)\n        end\n    end\nend\n\nMod{N}(x::Integer) where {N} = Mod{Int64, N}(x)\nPrimeMod{N}(x::Integer) where {N} = PrimeMod{Int64, N}(x)\n\n\nfunction Base.show(io::IO, x::AbstractMod{T, N}) where {T, N} \n    println(io, \"$(x.value)_$N\")\nend\n\nBase.zero(a::AbstractMod{T, N}) where {T, N}  = Mod{T, N}(0)\nBase.one(a::AbstractMod{T, N}) where {T, N}  = Mod{T, N}(1)\nBase.:-(a::AbstractMod{T, N}) where {T, N}  = Mod{T, N}(-a.value)\nBase.:isequal(a::AbstractMod{T, N}, b::AbstractMod{T, N}) where {T, N} = (a.value == b.value)\n\nfunction Base.:+(a::AbstractMod{T, N}, b::AbstractMod{T, N}) where {T, N} \n    return Mod{T, N}(a.value+b.value)\nend\n\nfunction Base.:-(a::AbstractMod{T, N}, b::AbstractMod{T, N}) where {T, N}  \n    return Mod{T, N}(a.value-b.value)\nend\n\nfunction Base.:*(a::AbstractMod{T, N}, b::AbstractMod{T, N}) where {T, N}  \n    return Mod{T, N}(a.value*b.value)\nend\n\nfunction Base.:inv(a::PrimeMod{T, N}) where {T, N} \n    return Mod{T, N}(a.value^(N-2))\nend\n\nfunction Base.:^(a::AbstractMod{T, N}, n::Integer) where {T, N} \n     return Mod{T, N}(a.value^n)\nend\n\nfunction Base.:/(a::PrimeMod{T, N}, b::PrimeMod{T, N}) where {T, N} \n    if b == zero(b)\n        throw(DivideError)\n    end\n    return a*inv(b)\nend\nMod 와 PrimeMod 둘 다 에게 적용되는 메서드는 AbstractMod 타입을 인자로 받으며 PrimeMod 에만 적용되는 나머지나 곱셈의 역원(Base.:inv) 함수의 경우 인자를 PrimeMod 타입을 받도록 합니다.\n이것은 NAJ.jl 에 포함되어 있으며 다음과 같이 사용합니다.\nIn [2]: using NAJ\n\nIn [3]: a=Mod{13}(5)\nOut[3]: 5_13\n\n\nIn [4]: b=-a\nOut[4]: 8_13\n\nIn [5]: a+b\nOut[5]: 0_13\n\nIn [6]: a*b\nOut[6]: 1_13\n\n\nIn [7]: a^5\nOut[7]: 5_13\n\nIn [8]: a^-2\nOut[8]: 12_13",
    "crumbs": [
      "Julia 언어의 기초",
      "복합 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/08_type_hierarchy.html",
    "href": "src/introduction_to_julia/08_type_hierarchy.html",
    "title": "타입의 계층구조와 메서드 디스패치",
    "section": "",
    "text": "Julia 에서 다루는 모든 값은 특정 타입(Type) 의 값입니다. 타입은 julia 언어에서 제공하는 Int64 나 Complex{Float64} 일 수도 있고 필요에 의해 만든 것일 수도 있습니다. Julia 에서 변수에 값을 할당할 때 타입을 명시적으로 지정할 수 있으며, 명시적으로 지정되어 있지 않을 경우 julia 에 의해 지정되기도 합니다. 다음의 코드와 설명을 보고 이해하시기 바랍니다.\nIn [1]: a=3;typeof(a)\nOut[1]: Int64\n\nIn [2]: b=3.42;typeof(b)\nOut[2]: Float64\n\nIn [3]: c=Float32(6.44);typeof(c)\nOut[3]: Float32\n\nIn [4]: d::Float32=3.3;typeof(d)\nOut[4]: Float32\n\nIn [5]: e::UInt8=3;typeof(e)\nOut[5]: UInt8\n특별히 형을 지정하지 않았을 경우 정수는 Int64, 실수는 Float64 타입으로 암시적으로 지정됩니다. c 의 경우는 6.44 라는 Float64 의 값을 Float32 로 변환시켜 할당하였으며, d 의 경우는 변수를 Float32 타입으로 지정한 후 대입하여 자동적으로 변환되었습니다. e 의 경우도 UInt8 타입으로 지정한 후 3 을 할당하여 지정된 타입으로 자동적으로 변환되었습니다.\n\n\n\nJulia 의 타입은 추상적 타입(abstract type) 과 구체적 타입(concrete type) 으로 분류 할 수 있습니다. 구체적 타입은 변수가 지정되어 값을 할당 할 수 있지만 추상적 타입에는 변수를 지정 할 수 없으며, 값도 할당 할 수 없습니다. 억지로 할당할 경우 적당한 구체적 타입으로 변환됩니다. 우리가 지금까지 사용한 UInt8, Int64, Float64 등은 구체적 타입이며 아래의 예에서 AbstractFloat 는 부동소수에 대한 추상적인 타입입니다.\nIn [6]: aa=AbstractFloat(0.0);typeof(aa)\nOut[6]: Float64\n어떤 타입이 구체적인 타입인지 추상적인 타입인지는 isabstracttype() 함수나 isconcretetype() 함수로 확인 할 수 있습니다. Julia 에서 모든 타입은 Any 타입에서 뻗어나온 가지와 같은 계층구조를 가지고 있습니다. 예를 들어 julia 에서 제공하는 수 타입은 그림 1 와 같은 계층구조를 가집니다.\nJulia 에서 추상적 타입은 abstract 키워드를 사용하여 다음과 같이 정의합니다.\nabstract type Number end\nabstract type Real     &lt;: Number end\nabstract type AbstractFloat &lt;: Real end\nabstract type Integer  &lt;: Real end\nabstract type Signed   &lt;: Integer end\nabstract type Unsigned &lt;: Integer end\n위의 코드는 저자가 임의로 작성한 코드가 아니라 julia 에서 실제 추상 타입을 구현한 코드를 복사한 것입니다. abstract type Real &lt;: Number end 에서 Real &lt;: Number 는 Real 타입이 미리 정의된 Number 타입의 하위 타입 이란 의미입니다. Any 타입의 직접적인 하위타입은 &lt;: Any 없이 추상 타입을 정의 할 수 있습니다. 이렇게 정의된 것이 Number 타입입니다. Number 라는 수 전체를 아우르는 상위 타입이 있으며, 실수를 나타내는 Real 타입, 부동소수를 나타내는 AbstractFloat 타입, 정수를 나타내는 Integer 타입, 부호 있는 정수를 나타내는 Signed 타입, 부호 없는 정수, 즉 0 을 포함한 자연수를 나타내는 Unsigned 타입과 같은 추상 타입이 있습니다.\nJulia 의 모든 타입은 어떤 타입의 하위 타입(subtype) 이며 단 하나의 상위 타입(supertype) 을 계승합니다. 타입의 하위타입에는 갯수 제한이 없습니다. 타입 계층의 최상단에는 Any 타입이 있으며, 모든 타입은 Any 의 하위타입 이던가 Any 의 하위타입의 하위타입 이던가…. Any 의 몇대 자손중의 하나입니다. 심지어 Any 의 상위타입은 Any 입니다. 어떤 타입의 상위 타입을 알기 위해서는 supertype() 함수를 사용 하며 하위 타입들을 알기 위해서는 subtypes() 함수를 사용합니다.\nIn [7]: supertype(UInt8)\nOut[7]: Unsigned\n\nIn [8]: subtypes(Integer)\nOut[8]: 3-element Vector{Any}:\n Bool\n Signed\n Unsigned\n어떤 타입의 상위 타입은 추상적 타입만이 가능하며, 구체적 타입은 어떤 타입의 상위 타입이 될 수 없습니다. 당연히 Any 는 추상적 타입입니다. 그림 그림 1 은 Julia 에서 자체적으로 제공하는 수(number) 에 대한 타입의 계층 구조입니다. 추상적 타입은 좌우 변이 두겹인 사각형, 구체적 타입은 좌우가 둥근 도형으로 표현하였습니다. Irrational 은 \\(\\pi\\) 나 \\(e\\) 같은 특별한 무리수를 위한 타입으로 계산 될 때 적당한 타입의 값으로 변환됩니다.\n\n\n\n\n\n\nflowchart TB\n    Any[[Any]] --- Number[[Number]]\n    Number ---- Real[[Real]]\n    Number --- Complex[[Complex]]\n    Real ------- Integer[[Integer]] \n    Real --- Rational([Rational])\n    Real --- AbstractIrrational[[AbstractIrrational]]\n    Real ----- AbstractFloat[[AbstractFloat]]\n    Integer --- Unsigned[[Unsigned]] & Bool([Bool])\n    Integer ----- Signed[[Signed]]\n    AbstractIrrational --- Irrational[Irrational]\n    AbstractFloat --- Float16([Float16]) & Float32([Float32]) & Float64([Float64])  &  BigFloat([BigFloat])\n    Unsigned --- UInt8([UInt8]) & UInt16([UInt16]) & UInt32([UInt32]) & UInt64([UInt64]) & UInt128([UInt128])\n    Signed --- Int8([Int8]) & Int16([Int16]) & Int32([Int32]) & Int64([Int64])  & Int128([Int128]) & BigInt([BigInt])\n\n\n\n\n그림 1: Type hierarchy of number\n\n\n\n\n\n\n이것을 정리하면 다음과 같습니다.\n\n\n\n\n추상적 타입\n구체적 타입\n\n\n\n\n하위타입 지정\no\nx\n\n\n변수 할당\nx\no\n\n\n\n여기서 Complex 만 추상적 타입으로 구체적인 하위타입이 존재하지 않습니다. 실제로 Julia 에서 복소수는 복합 타입(composite type) 으로 정의됩니다. 여기에 대해서는 복합 타입에서 다루겠습니다.\n\n\n\n\nInt64 나 Float32 와 같이 값이 저장되는데 사용되는 바이트 수가 결정된 구체적 타입을 원시 타입(Primitive type) 이라고 합니다. isprimitivetype() 함수를 통해 특정 타입이 원시 타입인지를 확인할 수 있습니다. Julia 의 모든 기본 타입은 julia 자체 내에서 다음과 같이 정의되었습니다. 저의 경우는 Julia 설치 디렉토리의 /share/julia/base/boot.jl 파일에 정의되었습니다.\nprimitive type Float16 &lt;: AbstractFloat 16 end\nprimitive type Float32 &lt;: AbstractFloat 32 end\nprimitive type Float64 &lt;: AbstractFloat 64 end\n\nprimitive type Bool &lt;: Integer 8 end\nprimitive type Char &lt;: AbstractChar 32 end\n\nprimitive type Int8    &lt;: Signed   8 end\nprimitive type UInt8   &lt;: Unsigned 8 end\nprimitive type Int16   &lt;: Signed   16 end\nprimitive type UInt16  &lt;: Unsigned 16 end\nprimitive type Int32   &lt;: Signed   32 end\nprimitive type UInt32  &lt;: Unsigned 32 end\nprimitive type Int64   &lt;: Signed   64 end\nprimitive type UInt64  &lt;: Unsigned 64 end\nprimitive type Int128  &lt;: Signed   128 end\nprimitive type UInt128 &lt;: Unsigned 128 end\n첫번째 primitive type Float16 &lt;: AbstractFloat 16 end 는 Float16 타입은 AbstractFloat 타입의 하위타입으로 16비트, 즉 2바이트를 차지하는 타입이라는 의미입니다. 앞서 말했듯이 구체적 타입은 상위 타입이 될 수 없으므로 원시 타입은 어떤 추상 타입의 하위타입이 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "타입의 계층구조와 메서드 디스패치"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/08_type_hierarchy.html#sec-type_hierarchy",
    "href": "src/introduction_to_julia/08_type_hierarchy.html#sec-type_hierarchy",
    "title": "타입의 계층구조와 메서드 디스패치",
    "section": "",
    "text": "Julia 에서 다루는 모든 값은 특정 타입(Type) 의 값입니다. 타입은 julia 언어에서 제공하는 Int64 나 Complex{Float64} 일 수도 있고 필요에 의해 만든 것일 수도 있습니다. Julia 에서 변수에 값을 할당할 때 타입을 명시적으로 지정할 수 있으며, 명시적으로 지정되어 있지 않을 경우 julia 에 의해 지정되기도 합니다. 다음의 코드와 설명을 보고 이해하시기 바랍니다.\nIn [1]: a=3;typeof(a)\nOut[1]: Int64\n\nIn [2]: b=3.42;typeof(b)\nOut[2]: Float64\n\nIn [3]: c=Float32(6.44);typeof(c)\nOut[3]: Float32\n\nIn [4]: d::Float32=3.3;typeof(d)\nOut[4]: Float32\n\nIn [5]: e::UInt8=3;typeof(e)\nOut[5]: UInt8\n특별히 형을 지정하지 않았을 경우 정수는 Int64, 실수는 Float64 타입으로 암시적으로 지정됩니다. c 의 경우는 6.44 라는 Float64 의 값을 Float32 로 변환시켜 할당하였으며, d 의 경우는 변수를 Float32 타입으로 지정한 후 대입하여 자동적으로 변환되었습니다. e 의 경우도 UInt8 타입으로 지정한 후 3 을 할당하여 지정된 타입으로 자동적으로 변환되었습니다.\n\n\n\nJulia 의 타입은 추상적 타입(abstract type) 과 구체적 타입(concrete type) 으로 분류 할 수 있습니다. 구체적 타입은 변수가 지정되어 값을 할당 할 수 있지만 추상적 타입에는 변수를 지정 할 수 없으며, 값도 할당 할 수 없습니다. 억지로 할당할 경우 적당한 구체적 타입으로 변환됩니다. 우리가 지금까지 사용한 UInt8, Int64, Float64 등은 구체적 타입이며 아래의 예에서 AbstractFloat 는 부동소수에 대한 추상적인 타입입니다.\nIn [6]: aa=AbstractFloat(0.0);typeof(aa)\nOut[6]: Float64\n어떤 타입이 구체적인 타입인지 추상적인 타입인지는 isabstracttype() 함수나 isconcretetype() 함수로 확인 할 수 있습니다. Julia 에서 모든 타입은 Any 타입에서 뻗어나온 가지와 같은 계층구조를 가지고 있습니다. 예를 들어 julia 에서 제공하는 수 타입은 그림 1 와 같은 계층구조를 가집니다.\nJulia 에서 추상적 타입은 abstract 키워드를 사용하여 다음과 같이 정의합니다.\nabstract type Number end\nabstract type Real     &lt;: Number end\nabstract type AbstractFloat &lt;: Real end\nabstract type Integer  &lt;: Real end\nabstract type Signed   &lt;: Integer end\nabstract type Unsigned &lt;: Integer end\n위의 코드는 저자가 임의로 작성한 코드가 아니라 julia 에서 실제 추상 타입을 구현한 코드를 복사한 것입니다. abstract type Real &lt;: Number end 에서 Real &lt;: Number 는 Real 타입이 미리 정의된 Number 타입의 하위 타입 이란 의미입니다. Any 타입의 직접적인 하위타입은 &lt;: Any 없이 추상 타입을 정의 할 수 있습니다. 이렇게 정의된 것이 Number 타입입니다. Number 라는 수 전체를 아우르는 상위 타입이 있으며, 실수를 나타내는 Real 타입, 부동소수를 나타내는 AbstractFloat 타입, 정수를 나타내는 Integer 타입, 부호 있는 정수를 나타내는 Signed 타입, 부호 없는 정수, 즉 0 을 포함한 자연수를 나타내는 Unsigned 타입과 같은 추상 타입이 있습니다.\nJulia 의 모든 타입은 어떤 타입의 하위 타입(subtype) 이며 단 하나의 상위 타입(supertype) 을 계승합니다. 타입의 하위타입에는 갯수 제한이 없습니다. 타입 계층의 최상단에는 Any 타입이 있으며, 모든 타입은 Any 의 하위타입 이던가 Any 의 하위타입의 하위타입 이던가…. Any 의 몇대 자손중의 하나입니다. 심지어 Any 의 상위타입은 Any 입니다. 어떤 타입의 상위 타입을 알기 위해서는 supertype() 함수를 사용 하며 하위 타입들을 알기 위해서는 subtypes() 함수를 사용합니다.\nIn [7]: supertype(UInt8)\nOut[7]: Unsigned\n\nIn [8]: subtypes(Integer)\nOut[8]: 3-element Vector{Any}:\n Bool\n Signed\n Unsigned\n어떤 타입의 상위 타입은 추상적 타입만이 가능하며, 구체적 타입은 어떤 타입의 상위 타입이 될 수 없습니다. 당연히 Any 는 추상적 타입입니다. 그림 그림 1 은 Julia 에서 자체적으로 제공하는 수(number) 에 대한 타입의 계층 구조입니다. 추상적 타입은 좌우 변이 두겹인 사각형, 구체적 타입은 좌우가 둥근 도형으로 표현하였습니다. Irrational 은 \\(\\pi\\) 나 \\(e\\) 같은 특별한 무리수를 위한 타입으로 계산 될 때 적당한 타입의 값으로 변환됩니다.\n\n\n\n\n\n\nflowchart TB\n    Any[[Any]] --- Number[[Number]]\n    Number ---- Real[[Real]]\n    Number --- Complex[[Complex]]\n    Real ------- Integer[[Integer]] \n    Real --- Rational([Rational])\n    Real --- AbstractIrrational[[AbstractIrrational]]\n    Real ----- AbstractFloat[[AbstractFloat]]\n    Integer --- Unsigned[[Unsigned]] & Bool([Bool])\n    Integer ----- Signed[[Signed]]\n    AbstractIrrational --- Irrational[Irrational]\n    AbstractFloat --- Float16([Float16]) & Float32([Float32]) & Float64([Float64])  &  BigFloat([BigFloat])\n    Unsigned --- UInt8([UInt8]) & UInt16([UInt16]) & UInt32([UInt32]) & UInt64([UInt64]) & UInt128([UInt128])\n    Signed --- Int8([Int8]) & Int16([Int16]) & Int32([Int32]) & Int64([Int64])  & Int128([Int128]) & BigInt([BigInt])\n\n\n\n\n그림 1: Type hierarchy of number\n\n\n\n\n\n\n이것을 정리하면 다음과 같습니다.\n\n\n\n\n추상적 타입\n구체적 타입\n\n\n\n\n하위타입 지정\no\nx\n\n\n변수 할당\nx\no\n\n\n\n여기서 Complex 만 추상적 타입으로 구체적인 하위타입이 존재하지 않습니다. 실제로 Julia 에서 복소수는 복합 타입(composite type) 으로 정의됩니다. 여기에 대해서는 복합 타입에서 다루겠습니다.\n\n\n\n\nInt64 나 Float32 와 같이 값이 저장되는데 사용되는 바이트 수가 결정된 구체적 타입을 원시 타입(Primitive type) 이라고 합니다. isprimitivetype() 함수를 통해 특정 타입이 원시 타입인지를 확인할 수 있습니다. Julia 의 모든 기본 타입은 julia 자체 내에서 다음과 같이 정의되었습니다. 저의 경우는 Julia 설치 디렉토리의 /share/julia/base/boot.jl 파일에 정의되었습니다.\nprimitive type Float16 &lt;: AbstractFloat 16 end\nprimitive type Float32 &lt;: AbstractFloat 32 end\nprimitive type Float64 &lt;: AbstractFloat 64 end\n\nprimitive type Bool &lt;: Integer 8 end\nprimitive type Char &lt;: AbstractChar 32 end\n\nprimitive type Int8    &lt;: Signed   8 end\nprimitive type UInt8   &lt;: Unsigned 8 end\nprimitive type Int16   &lt;: Signed   16 end\nprimitive type UInt16  &lt;: Unsigned 16 end\nprimitive type Int32   &lt;: Signed   32 end\nprimitive type UInt32  &lt;: Unsigned 32 end\nprimitive type Int64   &lt;: Signed   64 end\nprimitive type UInt64  &lt;: Unsigned 64 end\nprimitive type Int128  &lt;: Signed   128 end\nprimitive type UInt128 &lt;: Unsigned 128 end\n첫번째 primitive type Float16 &lt;: AbstractFloat 16 end 는 Float16 타입은 AbstractFloat 타입의 하위타입으로 16비트, 즉 2바이트를 차지하는 타입이라는 의미입니다. 앞서 말했듯이 구체적 타입은 상위 타입이 될 수 없으므로 원시 타입은 어떤 추상 타입의 하위타입이 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "타입의 계층구조와 메서드 디스패치"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/08_type_hierarchy.html#sec-method_multiple_dispatch",
    "href": "src/introduction_to_julia/08_type_hierarchy.html#sec-method_multiple_dispatch",
    "title": "타입의 계층구조와 메서드 디스패치",
    "section": "2 메서드 다중 디스패치(Multiple dispatch)",
    "text": "2 메서드 다중 디스패치(Multiple dispatch)\n\n함수와 메서드\n각각의 컴퓨터 프로그래밍 언어나 프로그래밍 패러다임마다 함수와 메서드의 의미와 관계가 조금씩 다릅니다. 보통 프로그래밍에서 함수란 어떤 일련의 동작들을 모아 하나의 기능으로 만든 것을 말합니다. Julia 기본 문서의 Methods 를 보면 Julia 에서 보는 함수와 메서드는 이와는 약간 다릅니다. Julia 에서의 함수는 일종의 기능의 추상화입니다. 예를 들어 두 수를 더하는 함수를 생각해 봅시다. 먼저 원시 타입에 대한 더하기를 생각해보면, 원시 타입이란 특정한 비트의 배열이기 때문에 각 원시 타입마다 내부적으로 더하기를 다르게 구현해야 합니다. 하지만 모두 + 라는 연산자에 대해 정의됩니다. 이렇게 추상적으로 정의된 함수에 대해 각 타입마다 구체적으로 구현된 코드를 julia 에서는 메서드라고 부릅니다. 함수와 메서드의 의미와 관계는 언어마다 다르기 때문에 julia 에서 사용되는 용어가 다른 용어에서는 다른 의미 일 수 있습니다.\n다음의 함수 정의를 봅시다.\nIn [1]: function myfunc1(a, b)\n            return a*b\n        end\nOut[1]: myfunc1 (generic function with 1 method)\n함수를 정의할 때 특별히 인자에 제한조건을 두지 않았습니다. 이제 인자의 타입을 바꿔 가며 함수를 실행시켜봅시다.\nIn [2]: myfunc1(1, 3)\nOut[2]: 3\n\nIn [3]: myfunc1(2.2, 3.3)\nOut[3]: 7.26\n\nIn [4]: myfunc1(\"a\", \"bc\")\nOut[4]: \"abc\"\nJulia 는 함수의 정의를 기억했다가 처음 실행할 때 주어진 인자의 타입에 맞추어 컴파일하며 한 번 컴파일된 함수는 그 인자 타입으로 다음번 실행 할 때는 컴파일 없이 빠르게 실행 할 수 있습니다다. 이렇게 어떤 소스코드를 실행 전에 컴파일 하는 것이 아니라 실행하는 가운데 컴파일 하는것을 JIT(just-in-time) 컴파일 이라고 합니다\nmyfunc1 함수를 선언 할 때 인자의 타입에 대해 제한을 가하지 않았다는 것은 a, b 모두 Any 타입으로 지정되었다는 것입니다. 만약 a, b 모두 정수일 때, 즉 Integer 의 하위타입일 때는 곱하기가 아니라 더하기를 수행하기를 원한다고 해 봅시다.\nIn [5]: function myfunc1(a::Integer, b::Integer)\n        return a+b\n        end\nOut[5]: myfunc1 (generic function with 2 methods)\n\nIn [6]: myfunc1(1, 2)\nOut[6]: 3\n\nIn [7]: myfunc1(1.0, 2.0)\nOut[7]: 2.0\n\nIn [8]: myfunc1(1.0, 2)\nOut[8]: 2.0\n인자가 둘 다 정수일 때는 더하기가, 둘 중 하나라도 정수가 아니라면 곱하기가 수행됩니다. 만약 a 가 문자열이고 b 가 정수라면 a 를 b 의 절대값만큼 반복하도록 합시다.\nIn [9]: function myfunc1(a::String, b::Integer) \n        return a^abs(b)\n        end\nOut[9]: myfunc1 (generic function with 3 methods)\n\nIn [10]: myfunc1(\"aa\", -3)\nOut[10]: \"aaaaaa\"\n이렇게 우리는 인자 타입에 대해 myfunc1 이라는 함수 이름으로 3개의 메서드를 생성하였습니다.\n\n\n시그너쳐와 methods 함수\n메서드의 시그너쳐(signature) 는 함수이름과 인자, 그리고 인자의 타입을 포함합니다. 하나의 함수의 다양한 메서드는 시그너쳐로 구분되며, 한 함수의 시그너쳐는 method 함수로 확인 할 수 있습니다. methods(myfunc1) 는 함수 myfunc1 에 대한 모든 메서드의 시그너쳐를 반환합니다.\nIn [12]: methods(myfunc1)\nOut[12]: # 3 methods for generic function \"myfunc1\" from Main:\n [1] myfunc1(a::Integer, b::Integer)\n     @ REPL[5]:1\n [2] myfunc1(a::String, b::Integer)\n     @ REPL[9]:1\n [3] myfunc1(a, b)\n     @ REPL[1]:1\n여기서 볼 수 있듯이 myfunc1 함수에는 세가지의 메서드가 구현되었으며, 특정 타입에 대해 어떤 메서드가 실행될 지 파악 할 수 있습니다.\n\n함수 뿐만 아니라 연산자도 여러개의 메서드를 가질 수 있습니다. methods(+) 를 통해 + 연산자가 아주 많이 정의되었다는 것을 확인해 보시기 바랍니다. 이렇게 같은 함수나 연산자의 이름으로 인자의 타입에 따라 기능을 정하는 것을 메서드 디스패치, 혹은 다중 디스패치라고 합니다. 여러분은 앞으로 새로운 타입을 만드는 방법을 알게 될텐데 이미 존재하는 +, - 등의 연산자나 println, length 등의 함수를 다중 디스패치를 통해 타입에 맞게 사용 할 수 있습니다.\n\n\n\n\n모호한 메써드\n\\(a^b\\) 를 리턴하는 mypow 함수를 다음과 같이 구현했다고 해 봅시다.\nIn [1]: function mypow(a, b)\n        return a^b\n        end\nOut[1]: mypow (generic function with 1 method)\n\nIn [2]: function mypow(a::Number, b)\n        return a^b\n        end\nOut[2]: mypow (generic function with 2 methods)\n\nIn [3]: function mypow(a, b::Number)\n        return a^b\n        end\nOut[3]: mypow (generic function with 3 methods)\n\nIn [4]: methods(mypow)\nOut[4]: # 3 methods for generic function \"mypow\" from Main:\n [1] mypow(a::Number, b)\n     @ REPL[2]:1\n [2] mypow(a, b::Number)\n     @ REPL[3]:1\n [3] mypow(a, b)\n     @ REPL[1]:1\n3가지의 메서드가 구현되었습니다. 여기에 mypow(2, 3) 는 어떤 값을 리턴할까요? 컴파일러 입장에서는 두번째와 세번째 메써드가 동등한 권리를 갖고 있기 때문에 불확실 성이 존재하며 컴파일러는 에러를 발생시킵니다.\nIn [5]: mypow(2, 3)\nERROR: MethodError: mypow(::Int64, ::Int64) is ambiguous.\n\n\n\n타입 매개변수를 갖는 메서드\n메서드를 정의할 때 구체적, 추상적인 타입을 직접 표현하는 것이 아니라 타입 매개변수를 이용하여 정의 할 수도 있습니다. Julia 공식 문서의 예를 가져와 보겠습니다. 함수 인자 두개에 대해 그 타입이 같으면 true, 다르면 false 를 반환하는 함수를 작성해 봅시다. typeof 함수를 이용 할 수도 있겠지만 메서드를 이용하여 깔끔하게 정의 할 수도 있습니다. 일단 두개의 타입이 같으면 true 를 반환하는 함수를 작성합니다.\nIn [1]: same_type(x::T, y::T) where {T} = true\nOut[1]: same_type (generic function with 1 method)\n여기서 T 는 타입 매개변수 입니다. 함수의 인자 표현에서 x::T, y::T 는 x 와 y 가 그것이 무엇이든 같은 타입이어야 한다는 의미입니다. 타입이 다르면 적용할 메서드가 없다는 에러가 발생합니다.\nIn [2]: same_type(1, 2.0)\nERROR: MethodError: no method matching same_type(::Int64, ::Float64)\n타입이 다를 때는 false 를 반환하게 하려면\nIn [3]: same_type(x,y) = false\nOut[3]: same_type (generic function with 2 methods)\n와 같이만 하면 됩니다.\nIn [4]: same_type(1, 2.0)\nOut[4]: false\n이것이 작동하는 원리는 쉽습니다. 함수를 호출하면 메서드의 시그너쳐를 확인하여 실제 실행될 메서드를 찾는데 두 인자가 같은 타입일 경우 same_type(x::T, y::T) where {T} = true 메서드가 호출되며, 다른 타입일 경우 same_type(x,y) = false 메서드가 호출됩니다.\n\n타입 매개변수에 재한을 걸 수 있습니다. 예를 들어 다음을 봅시다.\nIn [10]: same_integer_type(x::T, y::T) where {T&lt;:Integer} = true\nOut[10]: same_integer_type (generic function with 1 method)\n\nIn [11]: same_integer_type(x, y) = false\nOut[11]: same_integer_type (generic function with 2 methods)\n\nIn [12]: same_integer_type(3, 4)\nOut[12]: true\n\nIn [13]: same_integer_type(UInt8(3), 4)\nOut[13]: false\n\nIn [14]: same_integer_type(3, 4.0)\nOut[14]: false\n두 변수 x, y 가 같은 종류의 정수 타입이 아니면 false 를 리턴합니다. 즉 다른 종류의 정수타입에도 false 를 반환합니다.\n\n\n함수 안에서의 타입매개변수\n함수에 타입 매개변수를 쓰는 또하나의 중요한 경우는 타입매개변수를 함수 안에서 사용하는 것입니다. 우리는 기본타입의 경우 타입 이름이 함수로 사용 될 수 있다는 것을 앞에서 보았습니다. 예를 들어 Float64(3) 에서 Float64 는 Int64 타입의 3 을 Float64 타입으로 변환시키는 함수로 사용되었습니다. 다음 함수를 봅시다.\nIn [1]: function myconvert(a::T, b) where {T}\n        return T(b)\n        end\nOut[1]: myconvert (generic function with 1 method)\n\nIn [2]: myconvert(2.0, 4)\nOut[2]: 4.0\n이 myconvert 함수는 두개의 인자를 받아 두번째 인자를 첫번째 인자의 타입으로 변환시켜 반환하는 함수입니다. 이 때 함수 시그니쳐의 타입 매개변수 T 가 함수의 몸체에서 사용되었습니다.\n\n\n\n아무것도 아닌 함수\n여러 메서드를 가지는 함수를 작성할 때 일단은 이름을 갖고 코드가 에러를 발생시키지는 않지만 실행은 안되는 함수가 필요할 때가 있습니다. 실용적으로 필요한 것이 아니라 문서화 작업 혹은 앞으로 작성할 함수라고 흔적을 남기기 위해 사용되기도 합니다.\nfunction great_function_with_many_methods end\ngreat_function_with_many_methods 은 함수로서 이름공간 포함되지만 아무 일도 할 수 없습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "타입의 계층구조와 메서드 디스패치"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html",
    "href": "src/introduction_to_julia/07_module_package.html",
    "title": "이름공간, 모듈, 패키지",
    "section": "",
    "text": "프로그래밍할 때에는 많은 변수, 함수, 자료형의 이름이 필요합니다. 보통은 이름이 중복된다면 에러가 발생하거나 나중에 나오는 것이 앞에 나온 것을 삭제시키고 그 자리를 대신하게 되는데 이것은 큰 문제를 발생시킬 수 있습니다. 이런 것을 막기 위해 중복되지 않은 이름을 사용해야 하지만 코드가 길어지면 이것도 아주 골치아픈 일이 될 수 있습니다. 그래서 많은 프로그래밍 언어들이 이름공간(namespace)과 변수가 유효한 범위를 구현합니다. Julia 에서 이름공간은 뒤에 설명할 모듈(module) 마다 생성됩니다. Julia 가 실행될 때 Main 모듈로 실행되며, julia REPL 이나 Jupyter 에서도 Main 이 최상위 모듈입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#이름-공간과-변수의-범위",
    "href": "src/introduction_to_julia/07_module_package.html#이름-공간과-변수의-범위",
    "title": "이름공간, 모듈, 패키지",
    "section": "",
    "text": "프로그래밍할 때에는 많은 변수, 함수, 자료형의 이름이 필요합니다. 보통은 이름이 중복된다면 에러가 발생하거나 나중에 나오는 것이 앞에 나온 것을 삭제시키고 그 자리를 대신하게 되는데 이것은 큰 문제를 발생시킬 수 있습니다. 이런 것을 막기 위해 중복되지 않은 이름을 사용해야 하지만 코드가 길어지면 이것도 아주 골치아픈 일이 될 수 있습니다. 그래서 많은 프로그래밍 언어들이 이름공간(namespace)과 변수가 유효한 범위를 구현합니다. Julia 에서 이름공간은 뒤에 설명할 모듈(module) 마다 생성됩니다. Julia 가 실행될 때 Main 모듈로 실행되며, julia REPL 이나 Jupyter 에서도 Main 이 최상위 모듈입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#모듈",
    "href": "src/introduction_to_julia/07_module_package.html#모듈",
    "title": "이름공간, 모듈, 패키지",
    "section": "2 모듈",
    "text": "2 모듈\n모듈은 어떤 기능과 관련된 값, 함수, 자료형 등의 모음입니다. 추상적인 개념이 아닌 julia 에 그 문법이 정의된 기능으로 아래의 예제 코드와 같이 module 로 시작해서 end 로 끝납니다. 모듈 안에는 다른 모듈이 포함 될 수 있습니다. 하나의 파일에 여러개의 모듈이 같이 있을 수도 있습니다.\nmodule mymodule1\n\nexport a, mf\na=2\nb=3\nfunction mf(x)\n    return x*2\nend\n\nend\n앞서 설명했듯이 모듈은 새로운 전역적인 이름공간을 만들 수 있습니다. 그 안에서 정의된 이름들은 다른 이름공간의 이름과 충돌할 염려 없이 사용 할 수 있습니다. 다른 이름공간에서 모듈의 이름을 사용하기 위해서는 우선 모듈 내에서 export 명령어를 통해 밖에서 사용 할 수 있는 이름을 지정해 줘야 합니다. 예를 들어\nIn [1]: module mymodule1\n        export a, mf\n        a=2\n        b=3\n        function mf(x)\n            return x*2\n        end\n        end\nOut[1]: Main.mymodule1\n이 모듈은 REPL 이 실행될 때 만들어지는 Main 이라는 전역적인 이름공간 내에 mymodule1 이라는 이름이 붙은 부분적인 이름공간을 만듭니다. 부분적 이름공간의 이름에 접근할 때는 . 으로 구분하여 Main.mymodule1.a 와 같이 접근하거나 전역적 이름공간을 제외한 mymodule1.a 와 같이 접근합니다. 예를 들어\nIn [2]: mymodule1.mf(3)\nOut[2]: 6\n는 mymodule1 모둘의 함수 mf 를 의미합니다.\n\n\nusing\nusing 명령어는 module 에서 export 명령어를 통해 지정한 이름들을 전역적 이름공간에서 사용 할 수 있게 해 줍니다.\nIn [6]: using .mymodule1\n\nIn [7]: a\nOut[7]: 2\n\nIn [8]: mf(3)\nOut[8]: 6\n\nIn [9]: mymodule1.b\nOut[9]: 3\n\nIn [10]: b\nERROR: UndefVarError: `b` not defined\nexport 를 통해 지정되지 않은 b 는 전역 이름공간에서 사용 할 수 없으며 굳이 접근하고자 하면 mymodule1.b 와 같이 접근해야 합니다.\n\n\n\nimport\nusing 명령어는 모듈 내의 이름을 전역적인 이름공간으로 가져오는데 비해 import 명령어는 모듈 이름만을 전역적인 이름공간으로 가져옵니다. 즉 import mymodule1 을 하면 mymodule1.a 나 mymodule1.mf 를 통해 접근해야 합니다. 그렇다면 단순히 REPL 에서 사용할 때는 차이가 없게 됩니다. 이 차이를 알기 위해 다음과 같은 내용을 mymodule.jl 파일로 저장합니다.\nmodule mymodule1\nexport a, mf\na=2\nb=3\nfunction mf(x)\n    return x*2\nend\nend\n\nmodule mymodule2\nexport b, mf\na=4\nb=5\nfunction mf(x)\n    return x*a*b\nend\n두 모듈 모두 mf 란 함수가 존재하며 export 되므로 충돌의 가능성이 있습니다.. 이제 julia REPL 에서 모듈이 있는 파일을 읽고 mf 함수를 실행시켜 봅니다.\nIn [1]: include(\"mymodule.jl\")\nOut[1]: Main.mymodule2\n\nIn [2]: using .mymodule1\n\nIn [3]: mf(1)\nOut[3]: 2\nIn [2] 에서는 mymodule1 모듈만을 반입했으므로 mf 함수는 mymodule1 모듈의 그것입니다.\nIn [4]: using .mymodule2\nWARNING: using mymodule2.mf in module Main conflicts with an existing identifier.\n\nIn [5]: b\nOut[5]: 5\n\nIn [6]: mf(3)\nOut[6]: 6\nusing .mymodule2 를 하면 충돌이 발생하기 때문에 julia 인터프리터는 경고합니다. b 는 mymodule2 에서 반입된 5 가 사용되며 mf 함수는 먼저 반입된 mymodule1 의 그것입니다. 이렇게 이름이 충돌하는 것은 중요한 오류를 발생시킬 수 있으므로 절대로 피해야 합니다. 이런 경우에는 import 를 사용하는 것이 하나의 방법입니다. 아래와 같이 import 다음에 . 을 앞에 붙이고 모듈 이름을 써서 반입하면 모듈 이름과 모듈 내의 이름을 . 으로 구분하여 사용 할 수 있습니다.\nIn [1]: include(\"mymodule.jl\")\nOut[1]: Main.mymodule2\n\nIn [2]: import .mymodule1\n\nIn [3]: import .mymodule2\n\nIn [4]: mymodule1.mf(1)\nOut[4]: 2\n\nIn [5]: mymodule2.mf(2)\nOut[5]: 40\n\n\n\nusing ... as, import ... as\n또 하나의 방법은 이름을 바꾸는 것입니다. usimg .mymodule1: a as a1, mf as mf1 이라고 하면 mymodule1 모듈의 a 를 전역적인 이름영역으로 반입하면서 그 이름을 a1 으로 바꾸며, mf 를 mf1 으로 이름을 바꿉니다. 이름울 바꾸지 않고 반입할 경우는 as ... 없이 이름만 쓰면 됩니다. 아래 코드의 In [2] 처럼 하면 됩니다.\nIn [1]: include(\"mymodule.jl\")\nOut[1]: Main.mymodule2\n\nIn [2]: using .mymodule1: a, mf as mf1\n\nIn [3]: a\nOut[3]: 2\n\nIn [4]: mf\nERROR: UndefVarError: `mf` not defined\n...\n\nIn [5]: mf1\nOut[5]: mf (generic function with 1 method)\n\nIn [6]: using .mymodule2:b, mf as mf2\n\nIn [7]: b\nOut[7]: 5\n\nIn [8]: mf2(a)\nOut[8]: 40\n\nIn [9]: mf1(1)\nOut[9]: 2\n이름을 바꾸는 것은 이름의 중복을 방지하는데도 사용되지만, 긴 이름을 짧게 해서 편리하게 쓰고자 할 경우나, 짧은 이름을 명확하게 하기위해 긴 이름으로 바꿀 때도 사용할 수 있습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#변수의-범위",
    "href": "src/introduction_to_julia/07_module_package.html#변수의-범위",
    "title": "이름공간, 모듈, 패키지",
    "section": "3 변수의 범위",
    "text": "3 변수의 범위\n모듈을 통해 이름공간과 다른 이름공간을 현재의 이름공간으로 반입하는 법을 알아보았습니다. 이름공간 내에서 사용 할 수 있는 변수를 전역적(global) 이라고 합니다. 반대로 이름공간 내의 특정 부분에서만 사용할 수 있는 변수를 지역적(local) 이라고 합니다. 변수가 유효한 지역적인 범위를 만들어 낼 수 있는 코드 영역을 블럭 (block)이라고 합시다. 대표적으로 함수를 정의하는 function ... end 구문이나 흐름 제어문인 for ... end 구문입니다. 이들은 그 내에서만 유효한 변수를 선언 할 수 있습니다.\n이제 이름 공간 내에서 변수의 범위를 알아봅시다. 아래 코드를 수행하기 전에 i 와 j 라는 변수를 할당하지 않았다고 합시다.\nfor i in 1:10\n    j=i+1\nend\n이 때 i 나 j 는 for ... end 블럭 밖에서는 접근 할 수 없으며, 접근하려고 하면 ERROR: UndefVarError 에러가 발생합니다.\n그러나 아래 코드와 같이 미리 j 변수를 정해둔 경우에는 j 변수는 for ... end 블럭 안에서 그대로 적용됩니다.\nj=0\nfor i in 1:10\n    j=i+1\nend\nprintln(\"j=$j\")\n\n이젠 함수의 경우를 봅시다.\nIn [1]: j=4\nOut[1]: 4\n\nIn [2]: function mf1(x)\n        k = x+j\n        return k\n        end\nOut[2]: mf1 (generic function with 1 method)\n\nIn [3]: mf1(5)\nOut[3]: 9\n\nIn [4]: k\nERROR: UndefVarError: `k` not defined\n위의 코드에서 j 는 전역적 범위에서 4 를 할당받았습니다\\(^\\ast\\). mf1 이라는 함수 안의 k 라는 변수는 함수 내부에만 영항을 끼칠 수 있습니다. 그러나 j 는 전역변수이므로 함수 내의 j 는 함수 밖의 j 와 동일합니다. \\(^\\ast\\) 함수 내에서 인자로 주어지지 않은 함수 밖의 변수를 사용하는 것은 대부분의 경우 피해야 할 습관입니다. 이 경우는 무조건 인자로 전달해서 함수에서 처리해야 하지만, 변수 범위를 설명하기 위해 억지로 예를 든 것입니다.\n\nIn [4]: function mf2(x)\n        k = x+1\n            function mf3(y)\n                return (k+1)\n            end\n            return mf3(x+1)\n        end\n\nOut[4]: mf2 (generic function with 1 method)\n\nIn [5]: mf2(3)\nOut[5]: 5\nmf2 함수 정의 안에서는 새로운 지역적 변수들을 정의 할 수 있으며 mf3 는 mf2 안에서 더 지역적인 변수들을 만들 수 있습니다. k 는 mf2 함수 내에서 정의되었기 때문에 mf3 함수 정의 내에서 사용 할 수 있습니다. 이렇게 변수의 범위는 계층적입니다. 최상위에 전역적인 이름들이 있으며, 그 하위 범위마다 지역적인 변수를 사용 할 수 있습니다. 하위의 블럭에서는 상위의 변수를 사용 할 수 있습니다. 필요하다면 지역적 블럭에서 전역적인 혹은 상위의 블럭의 변수와 같은 이름을 갖지만 별도로 동작하는 이름을 만들 수 있습니다\\(^\\ast\\).  하지만 혼동을 일으키며, 이러한 혼동은 에러의 큰 원인이 되기 때문에 되도록이면 피해야 할 것입니다.\\(^\\ast\\) 이렇게 상위 이름공간에서 정의된 이름을 하위 이름공간에서 별도로 사용할 때, 해당하는 상위 이름공간의 이름의 효과를 일시적으로 멈추는 것을 shadowing 이라고 합니다.\n\n\n영역 타입\n전역적 혹은 지역적 범위의 변수를 생성 할 수 있는 블럭은 다음과 같습니다.\n\n\n\n\n\n\n\n\nConstruct\n영역 타입\n혀용되는 이름공간\n\n\n\n\nmodule, baremodule\n전역\n전역\n\n\nstruct\n지역 (soft)\n전역\n\n\nfor, while, try\n전역, 지역 (soft)\n전역\n\n\nmacro\n지역 (hard)\n전역\n\n\nfunctions, do 블럭, let 블럭, comprehensions, generators\n지역 (hard)\n전역, 지역\n\n\n\n여기에 빠진 begin 블럭과, if 블럭은 영역 변수를 만들 수 없습니다. 즉 이 두 블럭 내에서 변수를 선언하더라도 상위 영역의 변수에 포함됩니다.\n상위 범위의 이름은 하위 범위에서 사용 할 수 있습니다. 문제는 상위 범위에 있는 이름과 같은 이름을 하위 범위에서 사용할 때 이며 크게 두가지로 나눌 수 있겠습니다.\n\n상위 범위 변수를 그대로 사용하고 싶을 때.\n상위 변수와 같은 이름을 가진 변수를 별도로 하위 범위에서 사용하고 싶을 때.\n\n2번의 경우는 굳이 상위 변수와 같은 이름을 사용한다기 보다는, 상위 범위에 많은 변수명과 연산이 얽혀 있는데 그것을 일일이 확인하고 싶지 않을 때에 발생한다고 볼 수 있겠습니다. 이때는 local 을 사용하면 되는데 이후 설명하겠습니다.\n상위 범위에서 v=1 이라고 이름을 할당 했다고 합시다. 하위 범위에서 v=2 라고 변수를 명시적으로 할당 했다면 하위 이름공간의 영역에서는 v==2 이며 상위 이름공간의 v 는 가려집니다. 그런데 변수에 값을 할당 하지 않고 w=v+2 와 같이 v 의 값을 사용 할 때의 성질에 따라 hard scope 와 soft scope 로 나뉩니다.\n\nHard scope 의 경우 : 해당 하위 이름공간에 지역적 범위의 변수 v 가 생성됩니다.\n\nIn [1]: v=1\nOut[1]: 1\n\nIn [2]: function myfunc1(x)\n            println(\"in myfunc1, v+x=\", v+x)\n        end\nOut[2]: myfunc1 (generic function with 1 method)\n\nIn [3]: function myfunc2(x)\n            v=3 # local variable 이 생성됩니다. shadowing !!\n            println(\"in myfunc1, v=3, v+x=\", v+x)\n        end\nOut[3]: myfunc2 (generic function with 1 method)\n\nIn [4]: myfunc1(3)\nin myfunc1, v+x=4\n\nIn [5]: myfunc2(3)\nin myfunc1, v=3, v+x=6\n\nIn [6]: v\nOut[6]: 1\n\nSoft scope 의 경우\n\nJulia REPL 이나 jupyter 와 같이 interactive mode 일 경우에는 상위 범위의 변수 v 가 할당됩니다.\nInteractive mode 가 아닐경우에는 경고가 출력되며 하위 범위의 변수 v 가 생성됩니다.\n\n\n\n\n연습문제 1 for ... end 는 soft scope 입니다. 아래의 코드를 파일로 저장하고 julia 로 실행시켜보고 어떤 경고(Warning) 가 출력되는지 확인해 봅시다. Julia REPL 이나 jupyter 로 실행시켜 봅시다.\nv=10\nfor i in 1:10\n    v=i\nend\n\n\n\n\nlocal\n다음 코드를 봅시다.\nv1 = 0\nv2 = 3\nif v2 &lt; 5 \n    v1 = v2+1\n    x = sin(v1)\nend\n이미 v1=0 라고 선언되었으며 if 문의 분기조건을 충족하기 때문에 위 코드의 실행이 끝나면 v1=4 가 됩니다. 그런데 당신이 실제로 원하는 것은 v1 값을 바꾸는 것이 아니라 단지 sin(v2+1) 을 계산하는 것이었다고 합시다. 코드가 길거나 많은 변수가 복잡하게 계산되고 있다면 이런 일이 벌어질 수 있습니다. 이 때 변수 할당 앞에 local 키워드를 놓으면 이 변수는 더 상위 범위의 같은 이름의 변수와 내부적으로 다르게 처리하며, 상위 범위의 미리 선언된 변수의 값에 영향을 주지 않습니다. 즉\nv1 = 0\nv2 = 3\nif v2 &lt; 5 \n    local v1 = v2+1\n    x = sin(v1)\nend\n를 실행시키고 난 뒤에도 v1 == 0 입니다. local 키워드는 전역적으로 어떤 변수가 선언되었더라도 지역적인 변수를 만들어서 그 변수를 사용하며, 전역적인 변수는 건드리지 않도록 합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#패키지",
    "href": "src/introduction_to_julia/07_module_package.html#패키지",
    "title": "이름공간, 모듈, 패키지",
    "section": "4 패키지",
    "text": "4 패키지\n패키지는 모듈들과 모듈들을 관리하고 테스트하기위한 여러 파일들의 모음입니다. 공식적으로 지원되는 패키지들은 https://juliapackages.com 에서 확인 할 수 있습니다.\nJulia 를 설치하면 기본적으로 많은 자료형과 함수들도 같이 설치되지만 이것만으로는 충분하지 않습니다. 어떤 패키지는 Julia 언어와 함께 제공되며, 어떠 패키지는 패키지 관리자 Pkg.jl 을 이용하여 설치할 수 있습니다. Julia 의 패키지들은 Github 저장소에서 관리됩니다.\n\n패키지 추가\n패키지를 추가하는 방법은 두가지가 있습니다. 우선은\nusing Pkg\n를 실햄합니다. Pkg 는 패키지를 관리해주는 패키지로 기본적으로 julia 에 포함된 패키지 입니다. using Pkg 는 이제 Pkg 패키지에 포함된 여러 값, 함수, 자료형 등을 사용수 있도록 julia 에게 준비하라는 뜻입니다. 패키지 설치는 Pkg.add 함수를 사용합니다. 예를 들어 코드의 수행을 분석해주는 BenchmarkTools 를 설치한다면\nPkg.add(\"BenchmarkTools\")\n를 실행시키면 됩니다. 보통 하나의 패키지는 다른 패키지를 필요로 하는데 이 필요성 관계를 의존성(dependency) 이라고 합니다. Julia 는 자동적으로 이 패키지를 설치하는데 필요한 다른 패키지도 설치합니다. 패키지 설치가 성공하면\nusing BenchmarkTools\n명령문을 통해 BenchmarkTools 패키지의 여러 기능을 사용 할 수 있습니다.\n\n\n\n패키지 update\n보통 널리 사용되는 패키지는 끊임없이 개선됩니다. 이것을 update 라고 하며\nPkg.update()\n명령어는 이미 설치된 패키지 전체를 자동적으로 업데이트 합니다. 설치된 패키지가 많으면 몇분 정도의 시간이 걸릴 수도 있습니다.\n\n\n\n패키지 제거\nBenchmarkTools 패키지를 제거할때는 Pkg.rm(\"BenchmarkTools\") 명렬어를 수행하면 됩니다. 만약 제거하고자 하는 패키지에 의존하는 다른 패키지가 존재한다면 제거 할 수 없습니다. 억지로 제거할 수는 있지만 추천하지 않습니다. 다른 패키지를 먼저 제거하고 제거하십시요.\n\n\n\n패키지의 사용\n앞의 모듈의 사용과 마찬가지로 using 혹은 import 명령문을 사용합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html",
    "href": "src/introduction_to_julia/06_arrays.html",
    "title": "배열",
    "section": "",
    "text": "Julia 는 0 차원 배열부터 임의의 차원(dimension)의 배열을 지원합니다. 1차원 배열은 Vector, 2차원 배열은 Matrix 라는 별명(alias)을 가지고 있습니다. 0 차원 배열은 성분을 하나 가지고 있는 배열입니다. 각 차원을 축(axis) 이라고 부릅니다. 배열의 형태(shape) 는 각 차원마다 몇개의 성분을 가지는지를 말합니다. 예를 들어 배열의 형태가 (3, 4, 5) 라면 3차원 배열이고 첫번째 차원으로는 3개, 두번째 차원으로는 4개, 세번째 차원으로는 5개의 성분을 가져야 합니다.\n1 차원 배열과 2차원 배열은 다음과 같이 선언됩니다.\nIn [1]: arr1 = [1.0, 2.0, 3.0, 4.0]\nOut[1]: 4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\nIn [2]: arr2 = [4.0; 5; 6]\nOut[2]: 3-element Vector{Float64}:\n 4.0\n 5.0\n 6.0\n\nIn [3]: arr3 = [1 2 3 4]\nOut[3]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [4]: arr4=[3 2;4 5]\nOut[4]: 2×2 Matrix{Int64}:\n 3  2\n 4  5\narr1 과 같이 [ ] 안에 콤마로 분리된 경우와 arr2 와 같이 ; 로 분리된 경우는 1 차원 벡터입니다. Out[1] 의 Vector{Float64} 는 성분이 Float64 타입인 1차원 배열이라는 의미입니다. 앞서 말했듯이 Vector 는 1차원 배열과 같은 의미이며 (alias 라고 하며 본질적으로 같고, 부르는 이름이 다르다는 의미입니다.) Matrix 는 2차원 배열의 alias 입니다. arr3 와 같이 공백으로 분리되는 경우는 2차원 배열입니다. 즉 [1 2] 와 [1, 2] 는 다릅니다. arr4 를 보면 알겠지만 2차원 배열은 행 순서대로 나열하되 같은 행에서는 공백으로 열을 구분하며, 행의 구분은 ; 를 사용합니다. 배열의 각 성분에 접근할 때는 arr2[3] 이나 arr3[1, 1] 과 같이 접근합니다. 이 때 배열의 위치를 나타내는 숫자 혹은 숫자들을 인덱스라고 부릅니다. 인덱스에 대해서는 잠시후 배열의 인덱스 에서 좀 더 자세히 다룹니다.\n; 를 여러 개 겹쳐서 다차원 배열을 선언하는데 사용 할 수 있습니다.\n\nIn [5]: arr3d = [1; 2;; 3; 4;; 5; 6;;; 7; 8;; 9; 10;; 11; 12]\nOut[5]: 2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\nIn [6]: arr5 = [1;;2;;3;;4]\nOut[6]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [7]: arr6 = [1;;;2;;;3;;;4]\nOut[7]: 1×1×4 Array{Int64, 3}:\n[:, :, 1] =\n 1\n\n[:, :, 2] =\n 2\n\n[:, :, 3] =\n 3\n\n[:, :, 4] =\n 4\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\nIn [8]: ndims(arr5)\nOut[8]: 2\n\nIn [9]: size(arr6)\nOut[9]: (1, 1, 4)\n\nIn [10]: sizeof(arr3d)\nOut[10]: 96\n\nIn [11]: length(arr3d)\nOut[11]: 12\nIn [8] 에서 ndims() 함수는 배열의 차원을 반환합니다. 배열의 형태는 size() 함수로 알 수 있습니다. sizeof() 함수는 배열의 크기를 바이트(bytes) 로 나타냅니다. arr3d 는 Int64 타입의 성분으로 이루어져 있으며, Int64 는 8바이트 이고 모두 12 개의 성분을 가지므로 96 바이트를 차지합니다. 일반적인 컨테이너와 같이 length() 함수를 통해 배열에 속하는 모든 성분의 갯수를 알 수 있습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-array",
    "href": "src/introduction_to_julia/06_arrays.html#sec-array",
    "title": "배열",
    "section": "",
    "text": "Julia 는 0 차원 배열부터 임의의 차원(dimension)의 배열을 지원합니다. 1차원 배열은 Vector, 2차원 배열은 Matrix 라는 별명(alias)을 가지고 있습니다. 0 차원 배열은 성분을 하나 가지고 있는 배열입니다. 각 차원을 축(axis) 이라고 부릅니다. 배열의 형태(shape) 는 각 차원마다 몇개의 성분을 가지는지를 말합니다. 예를 들어 배열의 형태가 (3, 4, 5) 라면 3차원 배열이고 첫번째 차원으로는 3개, 두번째 차원으로는 4개, 세번째 차원으로는 5개의 성분을 가져야 합니다.\n1 차원 배열과 2차원 배열은 다음과 같이 선언됩니다.\nIn [1]: arr1 = [1.0, 2.0, 3.0, 4.0]\nOut[1]: 4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\nIn [2]: arr2 = [4.0; 5; 6]\nOut[2]: 3-element Vector{Float64}:\n 4.0\n 5.0\n 6.0\n\nIn [3]: arr3 = [1 2 3 4]\nOut[3]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [4]: arr4=[3 2;4 5]\nOut[4]: 2×2 Matrix{Int64}:\n 3  2\n 4  5\narr1 과 같이 [ ] 안에 콤마로 분리된 경우와 arr2 와 같이 ; 로 분리된 경우는 1 차원 벡터입니다. Out[1] 의 Vector{Float64} 는 성분이 Float64 타입인 1차원 배열이라는 의미입니다. 앞서 말했듯이 Vector 는 1차원 배열과 같은 의미이며 (alias 라고 하며 본질적으로 같고, 부르는 이름이 다르다는 의미입니다.) Matrix 는 2차원 배열의 alias 입니다. arr3 와 같이 공백으로 분리되는 경우는 2차원 배열입니다. 즉 [1 2] 와 [1, 2] 는 다릅니다. arr4 를 보면 알겠지만 2차원 배열은 행 순서대로 나열하되 같은 행에서는 공백으로 열을 구분하며, 행의 구분은 ; 를 사용합니다. 배열의 각 성분에 접근할 때는 arr2[3] 이나 arr3[1, 1] 과 같이 접근합니다. 이 때 배열의 위치를 나타내는 숫자 혹은 숫자들을 인덱스라고 부릅니다. 인덱스에 대해서는 잠시후 배열의 인덱스 에서 좀 더 자세히 다룹니다.\n; 를 여러 개 겹쳐서 다차원 배열을 선언하는데 사용 할 수 있습니다.\n\nIn [5]: arr3d = [1; 2;; 3; 4;; 5; 6;;; 7; 8;; 9; 10;; 11; 12]\nOut[5]: 2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\nIn [6]: arr5 = [1;;2;;3;;4]\nOut[6]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [7]: arr6 = [1;;;2;;;3;;;4]\nOut[7]: 1×1×4 Array{Int64, 3}:\n[:, :, 1] =\n 1\n\n[:, :, 2] =\n 2\n\n[:, :, 3] =\n 3\n\n[:, :, 4] =\n 4\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\nIn [8]: ndims(arr5)\nOut[8]: 2\n\nIn [9]: size(arr6)\nOut[9]: (1, 1, 4)\n\nIn [10]: sizeof(arr3d)\nOut[10]: 96\n\nIn [11]: length(arr3d)\nOut[11]: 12\nIn [8] 에서 ndims() 함수는 배열의 차원을 반환합니다. 배열의 형태는 size() 함수로 알 수 있습니다. sizeof() 함수는 배열의 크기를 바이트(bytes) 로 나타냅니다. arr3d 는 Int64 타입의 성분으로 이루어져 있으며, Int64 는 8바이트 이고 모두 12 개의 성분을 가지므로 96 바이트를 차지합니다. 일반적인 컨테이너와 같이 length() 함수를 통해 배열에 속하는 모든 성분의 갯수를 알 수 있습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-array_initialization",
    "href": "src/introduction_to_julia/06_arrays.html#sec-array_initialization",
    "title": "배열",
    "section": "2 배열의 생성",
    "text": "2 배열의 생성\n앞에서와 같이 각각 배열의 성분을 입력 할 수도 있겠지만, 배열이 클 경우는 거의 불가능한 방법입니다. Julia 는 배열을 생성하고 초기화 할 수 있는 다양한 방법을 제공합니다.\n\n\nArray comprehension 을 이용한 배열의 생성\n[ ] 안에 루프를 사용하여 배열을 만들 수 있으며 이렇게 배열을 만드는 것을 Array comprehension 이라고 합니다. 1 부터 10 까지의 정수의 제곱을 순서대로 포함하는 배열은 아래와 같이 만들 수 있습니다.\nac1 = [x^2 for x in 1:10]\n다차원 배열도 다음과 같이 만들 수 있습니다.\nIn [6]: [x+y for x = 1:3, y = 1:2]\nOut[6]: 3×2 Matrix{Int64}:\n 2  3\n 3  4\n 4  5\n[ ] 안에 조건을 넣을 수도 있습니다. 예를 들어 앞의 2차원 배열에서 x+y&gt;3 인 경우에는 0 으로 채우고 싶다면,\nIn [7]: [if x+y &gt; 3 0 else x+y end for x = 1:3, y = 1:2]\nOut[7]: 3×2 Matrix{Int64}:\n 2  3\n 3  0\n 0  0\n와 같이 쓸 수 있습니다. 3항 연산자를 사용하여 다음과 같이 쓸 수도 있습니다.\nIn [8]: [(x+y &gt; 3) ? 0 : x+y  for x = 1:3, y = 1:2]\nOut[8]: 3×2 Matrix{Int64}:\n 2  3\n 3  0\n 0  0\n그런데 if 문이 뒤에 가면 전혀 다른 결과가 발생합니다.\nIn [9]: [x for x in 1:10 if x&gt;4]\nOut[9]: 6-element Vector{Int64}:\n  5\n  6\n  7\n  8\n  9\n 10\n\nIn [10]: [x+y for x = 1:3, y = 1:2 if x+y&gt;3]\nOut[10]: 3-element Vector{Int64}:\n 4\n 4\n 5\nIn[7] 과 같이 for 가 if 뒤에 있으면, 중첩된 for 의 갯수에 따라 다차원 배열을 만든 후 연산을 수행합니다. 반대로 In[9] 나 In [10] 과 같이 if 가 for 의 뒤에 있다면 1차원 배열에 대해 if 문이 일종의 filter 함수 역할을 수행하며 이 filter 에 대해 true 인 경우 1차원 배열에 삽입합니다.\n\n간단한 규칙으로 배열을 생성하는 경우 Array comprehension 을 사용하는 것이 for 를 이용하는 것보다 빠른 경우가 많습니다. 예를 들어 \\(A_{ij} = i^{j-1}\\) 의 규칙으로 생성되는 배열을 두가지 방법으로 만들어 봅시다.\n# for loop\nV1 = zeros(Int64,(10, 10))\nfor i ∈ 1:10, j ∈ 1:10\n    V1[i, j] = i^(j-1)\nend\n\n# Array comprehension\nV2 = [i^(j-1) for i ∈ 1:10, j ∈ 1:10]\n두 결과는 같은 결과를 냅니다. BenchmarkTools 패키지의 @btime 매크로로 수행 시간을 측정해보면\nusing BenchmarkTools\n\nV1 = zeros(Int64,(10, 10))\n@btime begin\nfor i ∈ 1:10, j ∈ 1:10\n    V1[i, j] = i^(j-1)\nend\nend\n\n@btime V2 = [i^(j-1) for i ∈ 1:10, j ∈ 1:10]\n두번째 경우가 첫번째 경우보다 6배 이상 빠릅니다. 하지만 배열 작성 규칙이 복잡해지고 배열의 크기가 커질수록 역전되며 array comprehenshion 에서는 복잡한 과정을 넣기 힘들기 때문에 오히려 for 문을 사용하는 것이 좋습니다.\n\n\n\n특정 값으로만 이루어진 배열의 생성\nzeros(), ones(), fill() 함수가 대표적으로 배열을 초기화 하는 함수입니다. zeros(T, dims) 는 T 의 타입에서의 0 값(zero(T))으로 채워진 dims 차원의 배열을 반환합니다. ones(T, dims) 은 one(T) 로 채워진 배열의 형상이dims 인 배열을 반환하며 fill(v, dims) 는 값 v 로 채워진 dims 형상의 배열을 반환합니다. T 가 주어지지 않을 경우는 Float64 타입으로 정해지며 dims 는 1차원 배열의 경우는 정수, 다차원 배열의 경우는 튜플, 혹은 연속적인 정수입니다.\nIn [1]: zeros(Float32, (2, 3))\nOut[1]: 2×3 Matrix{Float32}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\nIn [2]: ones(UInt8, (2,2,2)) # == ones(UInt8, 2,2,2)\nOut[2]: 2×2×2 Array{UInt8, 3}:\n[:, :, 1] =\n 0x01  0x01\n 0x01  0x01\n\n[:, :, 2] =\n 0x01  0x01\n 0x01  0x01\n\nIn [3]: fill(2.0, 1, 3)  # == fill(2.0, (1, 3))\nOut[3]: 1×3 Matrix{Float64}:\n 2.0  2.0  2.0\n\nundef 키워드를 사용하여 타입과 크기만을 지정하고 값을 정하지 않고 초기화 할 수도 있습니다.\nA1 = Vector{Int8}(undef, 4) # 1차원 배열 초기화\nA2 = Matrix{Float64}(undef,10,10) # 2차원 배열 초기화\nA3 = Array{Float32}(undef, 2, 2, 2) #3차원 배열 초기화\n이 경우 배열의 성분은 임의의 값이 정해집니다. 이렇게 임의의 값이 채워진 배열을 초기화 하는 이유는 이렇게 배열을 만드는 것이 특정 값으로 채워서 초기화 하는 것보다 훨씬 빠르기 때문입니다. 제 컴퓨터에서는 Float64 타입의 \\(10000 \\times 10000\\) 배열을 만드는데 zeros 함수를 사용하는 것보다 undef 를 사용하는 것이 50000 배 정도 빨랐습니다. 만약 배열의 모든 성분이 이후의 계산과정에서 채워지는것이 확실하다면 굳이 특정 값으로 초기화 시키지 않고 undef 를 사용하여 배열을 생성하는 것이 좋습니다.\n\n\n\n이미 존재하는 배열과 같은 크기의 배열 생성\n배열의 타입과 크기를 지정하지 않고 이미 존재하는 배열을 이용하여 초기화 할 수 있습니다. 예를 들어 어떤 배열 A 와 같은 크기와 타입을 갖지만 모든 성분이 0 인 배열을 만들 때 zero(A) 를 사용 할 수 있습니다. (zeros(A) 가 아닙니다) A 가 정사각 행렬일 경우 one(A) 는 A 와 같은 크기와 타입을 갖는 항등행렬을 리턴합니다.\nIn [1]: A=[1.0 -2.0 3.0;4.0 -3.0 -1.0]\nOut[1]: 2×3 Matrix{Float64}:\n 1.0  -2.0   3.0\n 4.0  -3.0  -1.0\n\nIn [2]: zero(A)\nOut[2]: 2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\nIn [3]: B=[1 2;3 4]\nOut[3]: 2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nIn [4]: one(B)\nOut[4]: 2×2 Matrix{Int64}:\n 1  0\n 0  1\n\n배열을 초기화 할 때 undef 키워드를 사용하는 것처럼 일단 주어진 배열과 같은 크기와 타입을 갖는, 하지만 그 안에 채워지는 값을 보장하지 않는 배열을 similar() 함수를 통해 만들 수 있습니다. similar() 를 사용하는 이유도 속도 때문이며, undef 키워드로 배열을 만드는 것과 같이, 이후 연산으로 그 값이 다 채워진다면 충분히 사용할 만 합니다.\nIn [8]: C=[1.0 3.0;2.0 -1.0]\nOut[8]: 2×2 Matrix{Float64}:\n 1.0   3.0\n 2.0  -1.0\n\nIn [9]: similar(C)\nOut[9]: 2×2 Matrix{Float64}:\n 0.0           2.39288e-314\n 2.39288e-314  0.0\n\n\n\n배열을 확장하여 생성\n2차원 배열을 생성할 때 [1 3;2 4] 와 같이 열 구별은 공백을, 행 구별은 ; 을 이용하여 생성하는 방법을 이미 알아 보았습니다. 이 방법은 스칼라 뿐만 아니라 배열을 사용 할 수도 있는데 예를 들면\nIn [1]: A=[1 2;3 4];B=[5 ; 6]; C = [7 8]; D=[9]\nOut[1]: 1-element Vector{Int64}:\n 9\n\nIn [2]: A=[1 2;3 4];B=[5 ; 6]; C = [7 8]; D=[9]\nOut[2]: 1-element Vector{Int64}:\n 9\n\nIn [3]: F1=[A B]\nOut[3]: 2×3 Matrix{Int64}:\n 1  2  5\n 3  4  6\n\nIn [4]: F2=[A;C]\nOut[4]: 3×2 Matrix{Int64}:\n 1  2\n 3  4\n 7  8\n\nIn [5]: F3=[A B;C D]\nOut[5]: 3×3 Matrix{Int64}:\n 1  2  5\n 3  4  6\n 7  8  9\n와 같습니다. 즉 부분 행렬을 모아 더 큰 행렬을 만들 때 행 방향으로의 확장은 공백으로, 열 방향으로의 확장은 ; 를 이용합니다. 이렇게 작은 배열을 모아 큰 배열을 만드는 것을 concatenation 이라고 합니다. Concatenation 을 이용할 때는 각 부분행렬의 행과 열의 갯수가 서로 잘 맞도록 해줘야 합니다. [A B; C D] 형태로 concatenation 을 할 때는 A 와 B 의 행의 갯수가 같아야 하며 A 와 C 의 열의 갯수가 같아야 하고 B 의 열의 갯수와 D 의 열의 갯수도 같아야 하며 C 와 D 의 행의 갯수가 같아야 합니다. 복잡하게 설명했지만 결국 크기가 다른 타일을 빈 틈 없이 맞추는 경우로 생각할 수 있겠습니다.\nConcatenation 을 해 주는 함수로는 cat, vcat, hcat, hvcat, hvncat 이 있습니다.\nIn [1]: A=[1 2;3 4];B=[5 6;7 8];C=[-1 -2; -3 -4];\n\nIn [2]: vcat(A, B)\nOut[2]: 4×2 Matrix{Int64}:\n 1  2\n 3  4\n 5  6\n 7  8\n\nIn [3]: hcat(A, B, C)\nOut[3]: 2×6 Matrix{Int64}:\n 1  2  5  6  -1  -2\n 3  4  7  8  -3  -4\n\nIn [4]: hvcat((2, 3), [1 2;3 4], [-1;-2], [5; 6], [7;8], [9;10])\nOut[4]: 4×3 Matrix{Int64}:\n 1  2  -1\n 3  4  -2\n 5  7   9\n 6  8  10\n\nIn [5]: [[1 2;3 4] [-1;-2] ; [5; 6] [7;8] [9;10]]\nOut[5]: 4×3 Matrix{Int64}:\n 1  2  -1\n 3  4  -2\n 5  7   9\n 6  8  10\n\nIn [6]: hvcat(2, [1 2;3 4], [5;6])\nOut[6]: 2×3 Matrix{Int64}:\n 1  2  5\n 3  4  6\nvcat(A, B) 는 [A; B] 와 같으며 hcat(A, B) 는 [A B] 와 같습니다. 즉 vcat 은 배열을 수직으로 위에서 아래로 쌓으며, hcat 은 왼쪽에서 오른쪽으로 쌓습니다. vcat 이나 hcat 의 인자로는 다수의 배열 혹은 숫자가 올 수 있습니다. hvcat 은 인자로서 처음에 정수 혹은 정수의 터플이 오며, 그 다음부터 다수의 배열이 위치합니다. In [4] 의 hcat 함수의 첫번째 인자 (2, 3) 는 첫번째 블록열은 2개의 행렬로, 두번째 블록열은 그 다음 세개의 행렬로 이루어진다는 것을 의미합니다. 즉 [1 2;3 4], [-1;-2] 가 첫번째 열을 이루고, [5; 6], [7;8], [9;10] 가 두번째 열을 이룹니다. 따라서 In [5] 와 같습니다. hvcat 의 첫번째 인자로 정수만 있을 때는 첫번째 블록열로만 이루어집니다.\ncat 함수는 좀 많이 복잡합니다. 우리는 여기서는 1차원과 2차원 배열에 대해서만 다루겠습니다. 우선 cat 함수의 시그너쳐는 다음과 같습니다.\ncat(A...; dims)\ndims 는 자연수, 혹은 자연수의 터플이 올 수 있습니다. Julia 1.8 부터는 Val{x} 타입도 가능하지만 여기서는 다루지 않겠습니다. 자연수가 올 때는 그 차원 방향으로 확장합니다.\nIn [1]: cat(1, [2;3], dims=1)\nOut[1]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\nIn [2]: cat([1;2], [3;4], dims=2)\nOut[2]: 2×2 Matrix{Int64}:\n 1  3\n 2  4\ndims 에 자연수의 컨테이너가 올 때는 마치 블록 대각 행렬을 만드는 것 처럼 확장됩니다. 다음을 봅시다.\nIn [3]: cat(1, [2;3], [4 5; 6 7], dims=(1, 2))\nOut[3]: 5×4 Matrix{Int64}:\n 1  0  0  0\n 0  2  0  0\n 0  3  0  0\n 0  0  4  5\n 0  0  6  7\ndims=(1, 2) 이므로 첫번째 차원(수직) 과 두번째 차원 (수평) 으로 확장되며 주어진 배열 (스칼라는 0차원 배열로 간주됩니다) 대각으로 놓게 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-index_of_array",
    "href": "src/introduction_to_julia/06_arrays.html#sec-index_of_array",
    "title": "배열",
    "section": "3 배열의 인덱스",
    "text": "3 배열의 인덱스\n프로그래밍 언어에서 배열을 다룰 때 첫번째 인덱스가 0 인 언어가 있으며(C/C++, Java, Python, Javascript 등), 1 인 언어(Fortran, Matlab, R 등) 가 있습니다. Julia는 1부터 시작합니다. end 는 각 차원의 마지막 인덱스를 의미하는 키워드입니다. 물론 배열의 차원과 형태를 알고 있다면 인덱스를 직접 써도 됩니다.\nIn [1]: A = [1 4 7 10;2 5 8 11;3 6 9 12] \nOut[1]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [2]: A[1, 1] # a의 1 행 1열\nOut[2]: 1\n\nIn [3]: A[2, end] # a의 2 행 마지막 열\nOut[3]: 11\n\nIn [4]: A[end, end] # a 의 마지막 행 마지막 열\nOut[4]: 12\n\n\n인덱스를 이용한 배열 연산\n인덱스의 범위를 지정할 수도 있습니다. 전체 볌위는 : 로 표기하며, 벡터나 튜플, StepRange 를 사용하여 선택적으로 지정할 수도 있습니다.\nIn [5]: A[:, 1]   # 전체 행, 1 열\nOut[5]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\nIn [6]: A[2, 1:2:end]  # 2행 의 1열부터 끝열까지 2열 간격으로\nOut[6]: 2-element Vector{Int64}:\n 2\n 8\n\nIn [7]: A[3, [2, 3]] # 3행 의 2열과 3열\nOut[7]: 2-element Vector{Int64}:\n 6\n 9\n\nB=A[:, 1] 라고 하면 B 는 A 의 1 행과 같은 값을 갖는 벡터이며 A 의 1행이 아닙니다. 즉 B=A[:, 1] 을 수행하고 B 벡터의 성분을 바꾼다고 해도 A 가 변하지 않습니다. 이에 대해서는 배열의 복사 와 view 와 @view 를 참고하시기 바랍니다.\nIn [9]: B=A[:, 1]\nOut[9]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\nIn [10]: B[2]=-3\nOut[10]: -3\n\nIn [11]: A\nOut[11]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [12]: B\nOut[12]: 3-element Vector{Int64}:\n  1\n -3\n  3\n\n\n\n행렬의 열/행 우선 방식\n예를 들어 \\(\\boldsymbol{A} =\\begin{bmatrix} 1&2\\\\3&4\\end{bmatrix}\\) 를 메모리상에 저장할 때 1행 1열, 1행 2열,… 1행 마지막열, 2행 1열, … 순으로 저장하는 것을 행 우선 순서(row-major order) 라고 하고 1행 1열 2행 1열,…, 마지막행 1열, 2행 1열, 2행 2열,… 순으로 저장하는 것을 열 우선 방식(column-major order)이라고 합니다. 행 우선 방식에서는 배열 A 가 1 2 3 4 의 순으로 저장이 되며 열 우선방식에서는 1 3 2 4 순으로 저장이 됩니다. 행 우선 방식을 쓰는 언어로는 C/C++ 과 Python 의 numpy 가 있고 열 우선 방식을 쓰는 언어로는 Fortran, MATLAB, Julia, R 등이 있습니다. 또한 언어에서 사용하는 자료구조나 함수에 따라 달라질 수 있습니다.\n\n\n\n\n\n\n경고\n\n\n\n이것이 문제가 될 수 있는 경우는 우선순위가 다른 언어나 라이브러리간에 데이터를 교환 할 때 입니다. 예를 들어 julia 의 배열을 파일로 저장 한 후 python 의 numpy 로 읽으면 행과 열이 바뀔 수 있습니다.\n\n\n열/행 우선 방식이 본질적으로 동일한 계산의 계산 속도에 영향을 줄 수 있습니다. 아래의 코드는 \\(10000 \\times 10000\\) 배열의 합을 두가지 방법으로 구하는 코드입니다. 우선 각 행에대헤 열을 순회하며 합을 구하였고, 그 다음은 각 열에 대해 행을 순회하며 합을 구하였습니다.\nusing BenchmarkTools\nM = 10000\nmat= rand(M, M)\n\n@btime begin\n    r1  =0.0\n    for i ∈ 1:M, j ∈ 1:M\n        r1 += mat[i, j]\n    end\nend\n\n@btime begin\n    r2 =  0.0\n    for j ∈ 1:M, i ∈ 1:M\n        r2 += mat[i, j]\n    end\nend\n그 결과는\n  13.454 s (489818979 allocations: 8.79 GiB)\n  8.744 s (489818979 allocations: 8.79 GiB)\n로 아래의 방법이 훨씬 빨랐습니다. 이것은 julia 에서는 배열이 열 우선방식으로 정렬되기 때문이며, 행보다 열을 많이 변화시키는 것이 전체적으로 더 빠릅니다. 같은 열에서 다음 행으로 넘어갈 때는 바로 다음칸으로 넘어가면 되지만, 같은 행에서 다음 열로 넘어갈 때 열의 갯수 +1 만큼 넘어가야 하기 때문입니다. 예를 들어 첫번째 합 계산의 경우, 행이 10000 번 변할 동안 열은 1억번 변하는데, 두번째 계산의 경우는 열이 10000 번 변할 동안 행이 1억번 변합니다. 이 차이가 계산 속도의 차이를 만들어 냅니다.\n\n\n\n데카르트 인덱스와 선형 인덱스\n지금까지 2차원 배열A 의 2행 3열 성분을 A[2, 3] 으로 접근했습니다. 이와 같이 배열의 차원의 갯수만큼의 자연수로 접근하는 것을 데카르트 인덱스(Cartesian index) 혹은 카르테시안 인덱스 라고 합니다. 다른 접근 방법도 있는데, 다차원 배열의 각 성분을 1부터 하나의 자연수로 접근하는 방법도 사용합니다. 이것을 선형 인덱스(linear index) 라고 합니다. 앞서 알아본 열 우선 방식에서 배열을 나열할 때의 차례입니다. 예를 들어 A=[1 3;2 4] 의 경우 A[3]=3 이며 A[4]=4 입니다.프랑스의 철학자이자 과학자인 르네 데카르트(René Descartes) 의 이름에서 따왔습니다. 데카르트의 라틴어명이 Renatus Cartesius 이기 때문에 영어로는 Cartesian index 라고 씁니다.\nIn [13]: A=[1 2;3 4]\nOut[13]: 2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nIn [14]: A[3]\nOut[14]: 2\n데카르트 인덱스로부터 선형 인덱스를, 선형 인덱스로부터 데카르트 인덱스르 얻는 방법이 존재합니다. 배열 A 에 대해 CartesianIndices(A)[10] 은 배열 A 의 선형 인덱스 10 에 대한 데카르트 인덱스를 리턴합니다. A 가 삼차원 배열일 경우 LinearIndices(A)[1, 2, 3] 은 배열 A 의 데카르트 인덱스(1, 2, 3) 에 대한 선형 인덱스를 리턴합니다. 고차원 배열에대해서도 차원의 갯수만큼의 데카르트 인덱스를 받아 선형 인덱스를 리턴합니다.\nIn [1]: A=Array(reshape(1:2*3*4, (2, 3, 4)))\nOut[1]: 2×3×4 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\n[:, :, 3] =\n 13  15  17\n 14  16  18\n\n[:, :, 4] =\n 19  21  23\n 20  22  24\n\nIn [2]: CartesianIndices(A)[10]\nOut[2]: CartesianIndex(2, 2, 2)\n\nIn [3]: LinearIndices(A)[1, 2, 3]\nOut[3]: 15",
    "crumbs": [
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-copy_of_array",
    "href": "src/introduction_to_julia/06_arrays.html#sec-copy_of_array",
    "title": "배열",
    "section": "4 배열의 복사",
    "text": "4 배열의 복사\n배열을 복사할 때는 copy() 혹은 deepcopy() 명령어를 사용합니다. 주의해야 할 것은 배열 A 에 대해 B=A 와 B=copy(A) 는 다르다는 것입니다. 아래 코드를 봅시다.\nIn [13]: A=[1 2]\nOut[13]: 1×2 Matrix{Int64}:\n 1  2\n\nIn [14]: B=A;C=copy(A)\nOut[14]: 1×2 Matrix{Int64}:\n 1  2\n\nIn [15]: B[1, 1]=3\nOut[15]: 3\n\nIn [16]: A\nOut[16]: 1×2 Matrix{Int64}:\n 3  2\n\nIn [17]: C\nOut[17]: 1×2 Matrix{Int64}:\n 1  2\n\nIn [18]: C[1, 2]=-1\nOut[18]: -1\n\nIn [19]: A\nOut[19]: 1×2 Matrix{Int64}:\n 3  2\nB=A 라는 표현식은 B 와 A 변수가 같은 행렬에 대한 변수라는 뜻입니다. 따라서 B 라는 변수를 이용해 행렬 값을 변화시키면 A 변수로 접근하더더라도 변화된 행렬에 접근하게 됩니다. B=copy(A) 는 A 복사본을 만들어 B 라는 변수에 지정합니다. 따라서 B 변수를 이용해 행렬을 바꾸더라도 A 변수에 지정된 행렬은 변화하지 않습니다. B=A[:] 는 B=A 가 아닌 copy(A) 를 의미합니다.\n객체를 복사하는 deepcopy() 함수 가 있습니다. 다음 예를 봅시다.\nIn [1]: A = [1, 2, 3, [4, 5, 6]]\nOut[1]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, 5, 6]\n\nIn [2]: B = A[:]; C=copy(A); D=deepcopy(A);\n\nIn [3]: A[4][2]=-1\nOut[3]: -1\n\nIn [4]: B\nOut[4]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, -1, 6]\n\nIn [5]: C\nOut[5]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, -1, 6]\n\nIn [6]: D\nOut[6]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, 5, 6]\nA = [1, 2, 3, [4, 5, 6]] 는 벡터이며 정수와 벡터를 성분으로 갖기 때문에 Any 타입에 대한 벡터가 됩니다. A 의 네번째 성분은 벡터이며 실제로 A 변수에 내부적으로 저장되는것은 벡터 [4, 5, 6] 에 대한 주소입니다. C=copy(A) 명령어는 값 1, 2, 3 과 벡터 [4, 5, 6] 의 복사본을 만들지 않고 단지 주소만을 복사하여 변수 C 에 할당합니다. deepcopy 함수는 벡터 [4, 5, 6] 에 대해서도 복사본을 만들기 때문에 D=deepcopy(A) 명령어로 D 에 할당된 배열은 A 와는 같은 값을 갖는 완전히 별개인 배열이 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#배열에-대한-함수",
    "href": "src/introduction_to_julia/06_arrays.html#배열에-대한-함수",
    "title": "배열",
    "section": "5 배열에 대한 함수",
    "text": "5 배열에 대한 함수\n\n인덱스 순회에 대한 함수들 : eachindex, CartesianIndex\n배열의 인덱스, 혹은 성분 각각에 대해 for ... end 루프를 수행하는 방법은 여러가지가 있습니다. 배열의 선형 인덱스를 이용하여 순회할 때는 eachindex 를 씁니다.\nIn [1]: A = [1 2; 3 4];\n\nIn [2]: for i in eachindex(A)\n        @show i, A[i]\n        end\n(i, A[i]) = (1, 1)\n(i, A[i]) = (2, 3)\n(i, A[i]) = (3, 2)\n(i, A[i]) = (4, 4)\n\nIn [3]: for i in CartesianIndices(A)\n        @show i, A[i]\n        end\n(i, A[i]) = (CartesianIndex(1, 1), 1)\n(i, A[i]) = (CartesianIndex(2, 1), 3)\n(i, A[i]) = (CartesianIndex(1, 2), 2)\n(i, A[i]) = (CartesianIndex(2, 2), 4)\n위에서 알 수 있듯이 eachindex(A) 는 배열 A 에 대한 선형 인덱스를 사용하여 순회하도록 하며 CartesianIndices(A) 는 데카르트 인덱스를 이용하여 순회합니다.\n\n\n\n타입과 모양의 변환\n우리는 앞서 타입이름이 타입 변환함수로 사용될 수 있다는 것을 보았습니다. 예를 들어 Float32(6) 은 Int64 타입의 6 을 4바이트 부동소수 타입인 Float32 타입으로 변환시킵니다. 또한 우리는 . 연산자를 통해 컨테이너의 각각의 성분에 대해 함수를 적용시킬 수 있다는 것을 알았습니다. 따라서 Float32.([1, 2, 3, 4]) 는 Float32 타입의 성분을 갖는 [1.0f0, 2.0f0, 3.0f0, 4.0f0] 입니다.\n\\(3\\times 5\\) 배열을 \\(5 \\times 3\\) 배열로 바꾸거나 \\(12 \\times 5\\) 배열을 \\(3\\times 4 \\times 5\\) 로 바꾸는 것과 같이 그 크기를 유지하지만 배열의 모양을 바꾸는 함수는 reshape 입니다. 예를 들어 보겠습니다.\nIn [1]: A = Array(1:6)\nOut[1]: 6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nIn [2]: reshape(A, (2, 3))\nOut[2]: 2×3 Matrix{Int64}:\n 1  3  5\n 2  4  6\nIn[1] 에서의 A 는 6개의 성분을 갖는 1차원 벡터였지만 reshape(A, (2, 3)) 를 통해 \\(2 \\times 3\\) 행렬이 되었습니다. 다시 말하지만 원래의 행렬과 변환된 행렬의 총 성분 수는 같아야 합니다. 즉 length 가 같아야 합니다. reshape 는 원래 행렬과 변환 행렬의 선형 인덱스가 같도록 변환됩니다.\n\n\n\nview 와 @view\nview 는 이미 존재하는 배열로부터 특정 부분을 추출하여 만든 배열에 대한 타입이며, 이런 연산을 하는 함수이기도 합니다. 배열 A 에 대해 a=view(A, 1) 은 배열 A 의 첫번째 성분을 가리킵니다. 가리킨다라고 표현한 것은 단지 같은 값을 가질 뿐만 아니라 a 를 변경시키면 A 도 변경되기 때문입니다.\nIn [4]: A= [1 2;3 4];\n\nIn [5]: a = view(A, 1)\nOut[5]: 0-dimensional view(::Vector{Int64}, 1) with eltype Int64:\n1\n\nIn [6]: a[1]=3;\n\nIn [7]: A\nOut[7]: 2×2 Matrix{Int64}:\n 3  2\n 3  4\n다차원 배열의 경우 인덱스를 쓰거나 : 나 배열을 이용하여 범위를 특정 할 수 있습니다.\nIn [8]: B=reshape(Array(1:12), (3, 4))\nOut[8]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [9]: b=view(B, [1, 3], :)  # 1행과 3행, 그리고 열 전체에 대한 view\nOut[9]: 2×4 view(::Matrix{Int64}, [1, 3], :) with eltype Int64:\n 1  4  7  10\n 3  6  9  12\n\nIn [10]: b[2, 2]=-6 # view 의 변경\nOut[10]: -6\n\nIn [11]: B\nOut[11]: 3×4 Matrix{Int64}:\n 1   4  7  10\n 2   5  8  11\n 3  -6  9  12\n앞서 B[:, 3] 과 같이 이미 존재하는 배열로부터 그 부분을 성분으로 갖는 배열을 생성하는 방법을 보았습니다. @view 매크로는 view 함수를 쓰지 않고 B[:, 3] 과 같은 방법으로 view 를 생성합니다. 매크로에 대해서는 메타프로그래밍과 매크로 를 참고하시기 바랍니다. 일단은 @ 로 시작하는 명령문은 매크로 라고 하며 명령문 뒤에 주어진 인자나 함수에 대한 특별한 기능을 한다는 정도만 알아 둡시다\nIn [21]: B=reshape(Array(1:12), (3, 4))\nOut[21]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [22]: B[:, [2, 3]]\nOut[22]: 3×2 Matrix{Int64}:\n 4  7\n 5  8\n 6  9\n\nIn [23]: @view B[:, [2, 3]]\nOut[23]: 3×2 view(::Matrix{Int64}, :, [2, 3]) with eltype Int64:\n 4  7\n 5  8\n 6  9\nB[:, [2, 3]] 은 B 의 2행과 3행만을 선택하여 새로운 배열을 만들기 때문에, 일단 만든 다음에는 원래의 B 값과 무관하게 변경시킬 수 있습니다. @view B[:, [2, 3]] 는 B 의 부분에 대한 view 를 만들기 때문에 C=@view B[:, [2, 3]] 를 통해 C 에 할당한다면 C 를 변경하는 것은 B 를 변경하는 것이 됩니다.\nIn [24]: C=@view B[:, [2, 3]]\nOut[24]: 3×2 view(::Matrix{Int64}, :, [2, 3]) with eltype Int64:\n 4  7\n 5  8\n 6  9\n\nIn [25]: C[1, 1]=-1;\n\nIn [26]: B\nOut[26]: 3×4 Matrix{Int64}:\n 1  -1  7  10\n 2   5  8  11\n 3   6  9  12\nview 나 @view 가 필요한 이유는 메모리와 시간을 절약해 주기 때문입니다. 아주 큰 배열을 다룰 때 그 부분 배열에 대해 연산이 필요하다고 합시다. 배열을 새로 생성한다면 그만큼의 메모리와 배열의 생성과 복사를 위한 시간이 필요하지만 view 를 사용한다면 이미 존재하는 배열을 사용하기 때문에 약간의 메모리에서의 빈 공간만으로 연산을 수행 할 수 있습니다. 다만 view 나 @view 를 이용해 얻은 부분배열을 변경할 경우 원래의 배열도 변경된다는 사실을 명심해야 합니다.\n\n\n\n다차원 배열에서의 도트연산\n앞서 컨테이너 에서 도트 연산, 즉 연산자 앞이나 함수 뒤에 . 를 붙여 성분별 연산을 수행하는 것을 다루었습니다. 다차원 배열의 경우 차원이 같으면(즉 차원의 갯수와, 각 차원별 원소의 갯수가 같으면) 도트 연산을 수행할 수 있지만 차원이 다를 경우에는 차원을 확장하여 수행합니다.\n\n도트 연산에서의 차원 확장은 그 차원이 정의되어 있지 않거나 차원의 성분의 갯수가 1개 일때만 이루어집니다. 즉 [1 2] .+ [1 2; 3 4] 나 [1 2;] .+ [1 2; 3 4]는 가능하지만 [1 2;3 4] .+ [1 2 3; 2 3 4] 는 에러를 발생시킵니다.\n차원 확장은 차원이 없거나 1차원인 차원으로 원래의 배열을 반복합니다. [1 2] .+ [1 2; 3 4] 의 경우는 [1 2] 를 배열로 변환시킬 때 \\(1 \\times 2\\) 배열이 되며 첫번째 차원이 하나의 성분을 가지므로 첫번째 차원에 대해 두번 반복한 [1 2;1 2] 와 [1 2;3 4] 의 연산을 수행하게 됩니다.\n따라서 스칼라나 영차원 배열은 모든 차원의 다차원 배열에 대해 도트 연산이 가능합니다.\n\nIn [1]: [1;;2] .+ [1 2;3 4]\nOut[1]: 2×2 Matrix{Int64}:\n 2  4\n 4  6\n\nIn [2]: [1; 2] .+ [1 2;3 4]\nOut[2]: 2×2 Matrix{Int64}:\n 2  3\n 5  6\n\nIn [3]: [3] .* [1 2; 3 4]\nOut[3]: 2×2 Matrix{Int64}:\n 3   6\n 9  12\n[1;;2] 는 \\(1 \\times 2\\) 배열이므로 \\(2 \\times 2\\) 배열과 연산할 때는 [1 2; 1 2] 로 바뀌어 연산됩니다. [1 ; 2] 는 \\(2 \\times 1\\) 배열이므로 \\(2 \\times 2\\) 배열과 연산할 때는 [1 1; 2 2] 로 바뀌어 연산됩니다.\n컨테이너에서의 도트 연산과 같이 @. 매크로도 동작합니다. @. 매크로를 앞에 붙이면 뒤에 나오는 함수나 연산자에 . 를 붙이지 않아도 julia 가 알아서 연산을 해 줍니다.\n\n\n\nbroadcast\nbroadcast(f, As...) 함수는 하나 이상의 값 혹은 컨테이너인 As... 에 함수 혹은 연산자 f 를 적용합니다. map 함수와 같은것이라고 생각 할 수 있지만, 실제로는 julia 에서 차원과 크기가 다른 컨테이너에 함수를 적용할 때는 이 함수가 기본이 되기 때문에 다차원 배열의 연산을 이해하기 위해서는 이 함수를 이해해야 합니다.\n\nf 를 제외한 인자가 스칼라나 0차원 배열일 경우 스칼라를 반환합니다.\nf 를 제외한 인자에 튜플이 포함되며, 튜플을 제외한 나머지 인자가 스칼라이면 튜플을 반환합니다.\nf 를 제외한 인자가 위의 두 경우와 다르다면 배열을 반환합니다.\nf 를 제외한 인자가 배열이나 스칼라라면 위의 도트 연산시의 차원 확장 규칙에 따라 차원을 확장하여 도트 연산으로 계산합니다.\n\nIn [1]: broadcast(+, 2, 3)\nOut[1]: 5\n\nIn [2]: ones()\nOut[2]: 0-dimensional Array{Float64, 0}:\n1.0\n\nIn [3]: broadcast(+, 1, ones())\nOut[3]: 2.0\n\nIn [4]: broadcast(*, 2, (1, 2, 3))\nOut[4]: (2, 4, 6)\n\nIn [5]: broadcast(*, (1, 2, 3), [-1, 1, 0])\nOut[5]: 3-element Vector{Int64}:\n -1\n  2\n  0\nIn [6]: broadcast(sin, range(0, π, length = 5))\nOut[6]: 5-element Vector{Float64}:\n 0.0\n 0.7071067811865475\n 1.0\n 0.7071067811865476\n 1.2246467991473532e-16\n크기가 다른 배열의 경우 다차원 배열의 도트 연산 과 같은 규칙으로 계산됩니다. 실제로는 도트 연산의 자체가 broadcast 함수를 사용하여 정의되었으므로 당연한 것입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html",
    "href": "src/introduction_to_julia/05_control_flows.html",
    "title": "흐름 제어",
    "section": "",
    "text": "컨테이너를 순회하며 컨테이너에 포함된 아이템 만큼의 어떤 일을 수행하기 위한 구문입니다. 또한 컨테이너의 각 아이템을 이용한 계산과 명령을 수행 할 수 있습니다. 예를 들어 아래는 1 부터 100 까지의 합을 구하는 코드인데 for i ∈ 1:100 은 StepRange 타입인 1:100 의 각 성분들을 순서대로 i 라는 변수로 받아 end 까지의 명령을 수행한다는 의미입니다. 여기서 ∈ 는 in 으로 대체할 수 있습니다.\nnsum = 0\nfor i ∈ 1:100\n    nsum+= i\nend\n같은 크기의 컨테이너를 zip 명령어로 묶어서 동시에 순회할 수도 있습니다.\naa=(\"a\", \"b\", \"c\", \"d\")\nfor (a, v) in zip(aa, 1:4)\n    println(\"$a, $v\")\nend\n그 결과는 아래와 같습니다.\na, 1\nb, 2\nc, 3\nd, 4\n\nenumerate() 함수를 통해 인덱스 와 포함된 아이템을 같이 순회할 수도 있습니다다.\nfor (i, v) in enumerate(aa)\n    println(\"Index = $i, value = $v\")\nend\nIndex = 1, value = a\nIndex = 2, value = b\nIndex = 3, value = c\nIndex = 4, value = d\n\n사전 타입의 경우 key 와 value 를 다음과 같이 순회할 수 있습니다. 사전은 순서가 없으므로, 아래와 같은 경우에는 key 와 value 가 나오는 순서는 임의적이라고 생각해야 합니다.\ndict1 = Dict(\"a\"=&gt;1, \"b\"=&gt;2, \"c\"=&gt;3.3)\nfor (k, v) in dict1\n    println(\"Key = $k, value = $v\")\nend\nKey = c, value = 3.3\nKey = b, value = 2\nKey = a, value = 1\n\n컨테이너에 포함된 아이템의 수만큼 1부터 순회하고 싶다면 eachindex() 를 사용할 수 있습니다.\nfor i in eachindex((\"a\", \"b\", \"c\", \"d\"))\n    println(i)\nend\n\n\n\n구구단을 for 문을 써서 출력한다면 우선 다음과 같이 코드를 짤 수 있습니다.\nfor i in 2:9 \n    for j in 1:9\n        println(\"$i x $j = $(i*j)\")\n    end\nend\n하나의 for 문마다 하나의 end 가 필요합니다. Julia 는 다중 루프를 한 줄에 처리할 수 있게 해 줍니다. 아래의 코드는 위의 코드와 같은 일을 합니다.\nfor i in 2:9, j in 1:9\n    println(\"$i x $j = $(i*j)\")\nend",
    "crumbs": [
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#for-...-end",
    "href": "src/introduction_to_julia/05_control_flows.html#for-...-end",
    "title": "흐름 제어",
    "section": "",
    "text": "컨테이너를 순회하며 컨테이너에 포함된 아이템 만큼의 어떤 일을 수행하기 위한 구문입니다. 또한 컨테이너의 각 아이템을 이용한 계산과 명령을 수행 할 수 있습니다. 예를 들어 아래는 1 부터 100 까지의 합을 구하는 코드인데 for i ∈ 1:100 은 StepRange 타입인 1:100 의 각 성분들을 순서대로 i 라는 변수로 받아 end 까지의 명령을 수행한다는 의미입니다. 여기서 ∈ 는 in 으로 대체할 수 있습니다.\nnsum = 0\nfor i ∈ 1:100\n    nsum+= i\nend\n같은 크기의 컨테이너를 zip 명령어로 묶어서 동시에 순회할 수도 있습니다.\naa=(\"a\", \"b\", \"c\", \"d\")\nfor (a, v) in zip(aa, 1:4)\n    println(\"$a, $v\")\nend\n그 결과는 아래와 같습니다.\na, 1\nb, 2\nc, 3\nd, 4\n\nenumerate() 함수를 통해 인덱스 와 포함된 아이템을 같이 순회할 수도 있습니다다.\nfor (i, v) in enumerate(aa)\n    println(\"Index = $i, value = $v\")\nend\nIndex = 1, value = a\nIndex = 2, value = b\nIndex = 3, value = c\nIndex = 4, value = d\n\n사전 타입의 경우 key 와 value 를 다음과 같이 순회할 수 있습니다. 사전은 순서가 없으므로, 아래와 같은 경우에는 key 와 value 가 나오는 순서는 임의적이라고 생각해야 합니다.\ndict1 = Dict(\"a\"=&gt;1, \"b\"=&gt;2, \"c\"=&gt;3.3)\nfor (k, v) in dict1\n    println(\"Key = $k, value = $v\")\nend\nKey = c, value = 3.3\nKey = b, value = 2\nKey = a, value = 1\n\n컨테이너에 포함된 아이템의 수만큼 1부터 순회하고 싶다면 eachindex() 를 사용할 수 있습니다.\nfor i in eachindex((\"a\", \"b\", \"c\", \"d\"))\n    println(i)\nend\n\n\n\n구구단을 for 문을 써서 출력한다면 우선 다음과 같이 코드를 짤 수 있습니다.\nfor i in 2:9 \n    for j in 1:9\n        println(\"$i x $j = $(i*j)\")\n    end\nend\n하나의 for 문마다 하나의 end 가 필요합니다. Julia 는 다중 루프를 한 줄에 처리할 수 있게 해 줍니다. 아래의 코드는 위의 코드와 같은 일을 합니다.\nfor i in 2:9, j in 1:9\n    println(\"$i x $j = $(i*j)\")\nend",
    "crumbs": [
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#while-...-end",
    "href": "src/introduction_to_julia/05_control_flows.html#while-...-end",
    "title": "흐름 제어",
    "section": "2 while ... end",
    "text": "2 while ... end\nwhile 이후에 조건이 오고 그 조건이 참이면 end 까지 실행합니다. 1 부터 100 까지의 합을 구하는 코드를 while ... end 를 이용하여 구현해 봅시다.\nnsum = 0\nnn = 1\nwhile nn&lt;=100\n    nsum += nn\n    nn += 1\nend\nwhile ... end 를 쓸 때 조심할 것은 종료조건이 충족되지 않는 것입니다. for ... end 의 경우는 정해진 수의 컨테이너의 아이템만을 순회하므로 어쨌든 무조건 종료되지만 while ... end 의 경우는 종료되지 않는 무한루프에 빠질 수 있습니다.\n\n\n루프에서 벗어나기\n루프 수행 도중 벗어나고자 할 때는 break 를 씁니다. 예를 들어 1, 1/2, 1/3 과 같이 자연수의 역수를 계속 곱하다가 1/10000 보다 작아지는 첫번째 자연수를 구한다면, 1 부터 충분히 큰 수 (그 역수가 1/10000 보다 작은 수를 선택 할 수도 있다) 까지 루프를 수행하고 그 누적곱이 1/10000 보다 작을 때 break 로 루플에서 빠져나오면 됩니다.\nresult = 1.0\nfor n in 1:10000\n    result *=(1/n)\n    if result &lt; 1.0/10000\n        print(\"$n is the value\")\n        break\n    end\nend\nbreak 는 전체 루프에서 벗어나는 것이 아니라 break 를 포함하는 가장 인접한 루프로부터만 벗어납니다. 예를 들어,\nfor i in 1:10\n    for j in 1:10\n        println(\"i=$i, j=$j\")\n        if j &gt; 5\n            break\n        end\n    end\nend\n코드의 break 는 j&gt;5 일 때 break 되며, i 루프는 벗어나지 못하고 1 부터 10 까지 진행됩니다. 그러나,\nfor i in 1:10, j in 1:10\n    println(\"i=$i, j=$j\")\n    if j &gt; 5\n        break\n    end\nend\n는 i=1, j=6 에서 break 되어 멈춥니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#if-분기문",
    "href": "src/introduction_to_julia/05_control_flows.html#if-분기문",
    "title": "흐름 제어",
    "section": "3 if 분기문",
    "text": "3 if 분기문\n어떤 조건이 충족되는 지 여부를 따질 때 if ... elseif ... end 구문을 사용합니다. 어떤 수 x 에 대해 x&gt;0 이면 1 을 x&lt;0 이면 -1 을, x=0 이면 0 을 리턴하는 함수 msign(x) 를 만들어 봅시다.\nfunction msign(x)\n    if x&gt;zero(x)\n        return one(x)\n    elseif x&lt;zero(x) \n        return -one(x)\n    else\n        return zero(x)\n    end\nend\nzero(x) 는 x 의 타입에서의 0 값을 리턴하는 함수이며, one(x) 는 x 타입의 1 값을 리턴하는 함수입니다. x 는 어떤 값일 수도 있고 타입일 수도 있습니다. zero(1) 은 Int64 타입의 1 이며, one(Float32) 는 Float32 타입의 0.0 입니다. for, while 과 같이 if 블럭도 end 로 끝내야 합니다.\nif 블록에서 elseif 나 else 는 필요 없다면 생략해도 됩니다. 예를 들어 1 부터 100 까지의 정수 가운데 3의 배수만을 더한 합을 구한다고 하면,\nresult = 0\nfor i in 1:100\n    if i % 3 == 0\n        result += i\n    end\nend\n와 같이 사용 할 수 있습니다. i % 3 == 0 일 때만 result += i 를 수행하고 다른 경우는 아무 일도 수행하지 않습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#삼항-연산자-a-b-c",
    "href": "src/introduction_to_julia/05_control_flows.html#삼항-연산자-a-b-c",
    "title": "흐름 제어",
    "section": "4 삼항 연산자 a ? b : c",
    "text": "4 삼항 연산자 a ? b : c\na 는 true/false 를 따질 수 있는 조건이며, true 이면 b 를 실행시키고 false 이면 c 를 실행 시킵니다. 예를 들어, 절대값을 리턴하는 함수 mabs() 를 다음과 같이 짧게 구현 할 수 있습니다.\nmabs(x) = (x&gt;0) ? x : -x\n여기서 주의해야 할 것은 ? 와 : 각각의 앞, 뒤에 공백이 존재해야 한다는 것입니다. (x&gt;0)? x : -x 나 (x&gt;0)? x: -x 같은 것들은 에러를 발생시킵니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#begin-...-end-블럭",
    "href": "src/introduction_to_julia/05_control_flows.html#begin-...-end-블럭",
    "title": "흐름 제어",
    "section": "5 begin ... end 블럭",
    "text": "5 begin ... end 블럭\nJulia 에서 한줄에 여러 명령을 처리하기 위해 ; 을 사용 할 수 있습니다. 예를 들어\nx=3;y=5;z=x+y\n는 세가지 명렁을 차례로 입력한 것과 같습니다. 이것을 begin ... end 블럭으로 묶을 수 있습니다.\nz = begin\n    x=3\n    y=5\n    x+y\nend",
    "crumbs": [
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04I_splat_operator.html",
    "href": "src/introduction_to_julia/04I_splat_operator.html",
    "title": "Interlude : ... 연산자",
    "section": "",
    "text": "… 연산자 에서 튜플이나 배열의 첫번째 몇개만 취할 때 ... 연산자를 사용 할 수 있다는 것을 알아보았습니다. Julia 에서 ... 연산자는 두가지 용법으로 사용됩니다.\n\n\n\n튜플이나 StepRange 혹은 1차원 배열과 같이 순서가 있는 컨테이너에 대해서는 직관적으로 알 수 있습니다.\nIn [1]: a1, a2, a3... = (1, \"a\", (2, 3), 4, sin)\nOut[1]: (1, \"a\", (2, 3), 4, sin)\n\nIn [2]: a1, a2\nOut[2]: (1, \"a\")    \n\nIn [3]: b1, b2, b3... = 1:10\nOut[3]: 1:10\n\nIn [4]: b1, b2\nOut[4]: (1, 2)\n\nIn [5]: c1, c2, c3... = [1, 2, 3, 4, 5];\n\nIn [6]: c1, c2\nOut[6]: (1, 2)\n\n집합이나 사전과 같은 순서가 없는 컨테이너에 대해서는 에러를 발생시키지는 않지만 그 결과의 일관성을 보장할 수 없습니다.\nIn [14]: d1, d2, d3... = Set([1, 2, 3, 4]);\n\nIn [15]: d1, d2\nOut[15]: (4, 2)\n\nIn [16]: d1, d2, d3... = Set([1, 2, 3, 4, 5]);\n\nIn [17]: d1, d2\nOut[17]: (5, 4)\n\nIn [18]: a, b, c... = Dict(\"A\"=&gt;1, \"B\"=&gt;2, \"C\"=&gt;3, \"D\"=&gt;4)\nOut[18]: Dict{String, Int64} with 4 entries:\n  \"B\" =&gt; 2\n  \"A\" =&gt; 1\n  \"C\" =&gt; 3\n  \"D\" =&gt; 4\n\nIn [19]: a\nOut[19]: \"B\" =&gt; 2\n\nIn [20]: b\nOut[20]: \"A\" =&gt; 1\n\nIn [21]: c\nOut[21]: Base.Iterators.Rest{Dict{String, Int64}, Int64}(Dict(\"B\" =&gt; 2, \"A\" =&gt; 1, \"C\" =&gt; 3, \"D\" =&gt; 4), 4)\n\n다차원 배열의 경우 선형 인덱스에 따라 일차원 배열로 변환됩니다.\nIn [18]: x1, x2, x3... = [1 2;3 4; 5 6];\n\nIn [19]: x1\nOut[19]: 1\n\nIn [20]: x2\nOut[20]: 3\n\nIn [21]: x3\nOut[21]: 4-element Vector{Int64}:\n 5\n 2\n 4\n 6\n\n\n\n\n정해진 수의 인자를 받는 것이 아니라 다양한 수의 인자를 받는 함수를 가변 인자 함수 (function of variable number of arguments) 라고 하며 ... 연산자를 사용합니다. 다음을 봅시다.\nIn [6]: function ps(xs...)\n        println(typeof(xs))\n        return xs[1], xs[2]\n        end\nOut[6]: ps (generic function with 1 method)\n\nIn [7]: ps(1,2,3,\"c\")\nTuple{Int64, Int64, Int64, String}\nOut[7]: (1, 2)\n함수 정의에서 인자로 xs... 가 사용되었습니다. 이것은 인자를 모두 xs 라는 변수의 튜플로 받는다는 뜻입니다. 즉 In [7] 에서 함수 내부적으로 인자는 (1, 2, 3, \"c\") 입니다. 일부의 인자에 대해서만 사용할 경우에는 다음과 같습니다.\nIn [9]: function ps2(x1, xs...)\n        return xs[1], xs[2]\n        end\nOut[9]: ps2 (generic function with 1 method)\n\nIn [10]: ps2(1,2,3,4,5,6)\nOut[10]: (2, 3)\n키워드 인자도 역시 ... 를 사용하여 받을 수 있습니다. 다음의 함수를 봅시다. 예를 들어,\nfunction ps3(xs...;vs...)\n   ...         \nend\n와 같은 함수는 키워드가 없는 인자들은 xs 라는 변수의 튜플로, 키워드로 제시된 인자들은 vs 라는 기명 튜플(NamedTuple) 인자로 받습니다.\nIn [6]: function ps3(xs...; vs...)\n        return vs\n        end\nOut[6]: ps3 (generic function with 1 method)\n\nIn [7]: ps3(color=\"red\", number=4, location=\"Daejeon\")\nOut[7]: pairs(::NamedTuple) with 3 entries:\n  :color    =&gt; \"red\"\n  :number   =&gt; 4\n  :location =&gt; \"Daejeon\"\n\n\n\n\n함수의 정의에서는 인자를 튜플로 묶는다면 함수를 사용할 때는 컨테이너를 풉니다. 예를 들어,\nIn [12]: function ps3(a1, a2, a3)\n         return a1+(a2*a3)\n         end\n와 같은 함수를 사용해야 한다고 합시다. 그런데 다른 함수의 계산 결과로 aa=(a1, a2, a3) 를 얻었다고 합시다. ps3(aa[1], aa[2], aa[3]) 와 같이 실행 시킬 수도 있지만\nIn [13]: aa=(2, 3, 4)\nOut[13]: (2, 3, 4)\n\nIn [14]: ps3(aa...)\nOut[14]: 14\n처럼 ps3 함수를 실행 시킬 때 인자로 a... 를 쓰면 튜플이 풀려서 ps3(aa[1], aa[2], aa[3]) 를 실행시킨 것과 같게됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : `...` 연산자"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_for_containers",
    "href": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_for_containers",
    "title": "Interlude : ... 연산자",
    "section": "",
    "text": "튜플이나 StepRange 혹은 1차원 배열과 같이 순서가 있는 컨테이너에 대해서는 직관적으로 알 수 있습니다.\nIn [1]: a1, a2, a3... = (1, \"a\", (2, 3), 4, sin)\nOut[1]: (1, \"a\", (2, 3), 4, sin)\n\nIn [2]: a1, a2\nOut[2]: (1, \"a\")    \n\nIn [3]: b1, b2, b3... = 1:10\nOut[3]: 1:10\n\nIn [4]: b1, b2\nOut[4]: (1, 2)\n\nIn [5]: c1, c2, c3... = [1, 2, 3, 4, 5];\n\nIn [6]: c1, c2\nOut[6]: (1, 2)\n\n집합이나 사전과 같은 순서가 없는 컨테이너에 대해서는 에러를 발생시키지는 않지만 그 결과의 일관성을 보장할 수 없습니다.\nIn [14]: d1, d2, d3... = Set([1, 2, 3, 4]);\n\nIn [15]: d1, d2\nOut[15]: (4, 2)\n\nIn [16]: d1, d2, d3... = Set([1, 2, 3, 4, 5]);\n\nIn [17]: d1, d2\nOut[17]: (5, 4)\n\nIn [18]: a, b, c... = Dict(\"A\"=&gt;1, \"B\"=&gt;2, \"C\"=&gt;3, \"D\"=&gt;4)\nOut[18]: Dict{String, Int64} with 4 entries:\n  \"B\" =&gt; 2\n  \"A\" =&gt; 1\n  \"C\" =&gt; 3\n  \"D\" =&gt; 4\n\nIn [19]: a\nOut[19]: \"B\" =&gt; 2\n\nIn [20]: b\nOut[20]: \"A\" =&gt; 1\n\nIn [21]: c\nOut[21]: Base.Iterators.Rest{Dict{String, Int64}, Int64}(Dict(\"B\" =&gt; 2, \"A\" =&gt; 1, \"C\" =&gt; 3, \"D\" =&gt; 4), 4)\n\n다차원 배열의 경우 선형 인덱스에 따라 일차원 배열로 변환됩니다.\nIn [18]: x1, x2, x3... = [1 2;3 4; 5 6];\n\nIn [19]: x1\nOut[19]: 1\n\nIn [20]: x2\nOut[20]: 3\n\nIn [21]: x3\nOut[21]: 4-element Vector{Int64}:\n 5\n 2\n 4\n 6",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : `...` 연산자"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_in_function_definition",
    "href": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_in_function_definition",
    "title": "Interlude : ... 연산자",
    "section": "",
    "text": "정해진 수의 인자를 받는 것이 아니라 다양한 수의 인자를 받는 함수를 가변 인자 함수 (function of variable number of arguments) 라고 하며 ... 연산자를 사용합니다. 다음을 봅시다.\nIn [6]: function ps(xs...)\n        println(typeof(xs))\n        return xs[1], xs[2]\n        end\nOut[6]: ps (generic function with 1 method)\n\nIn [7]: ps(1,2,3,\"c\")\nTuple{Int64, Int64, Int64, String}\nOut[7]: (1, 2)\n함수 정의에서 인자로 xs... 가 사용되었습니다. 이것은 인자를 모두 xs 라는 변수의 튜플로 받는다는 뜻입니다. 즉 In [7] 에서 함수 내부적으로 인자는 (1, 2, 3, \"c\") 입니다. 일부의 인자에 대해서만 사용할 경우에는 다음과 같습니다.\nIn [9]: function ps2(x1, xs...)\n        return xs[1], xs[2]\n        end\nOut[9]: ps2 (generic function with 1 method)\n\nIn [10]: ps2(1,2,3,4,5,6)\nOut[10]: (2, 3)\n키워드 인자도 역시 ... 를 사용하여 받을 수 있습니다. 다음의 함수를 봅시다. 예를 들어,\nfunction ps3(xs...;vs...)\n   ...         \nend\n와 같은 함수는 키워드가 없는 인자들은 xs 라는 변수의 튜플로, 키워드로 제시된 인자들은 vs 라는 기명 튜플(NamedTuple) 인자로 받습니다.\nIn [6]: function ps3(xs...; vs...)\n        return vs\n        end\nOut[6]: ps3 (generic function with 1 method)\n\nIn [7]: ps3(color=\"red\", number=4, location=\"Daejeon\")\nOut[7]: pairs(::NamedTuple) with 3 entries:\n  :color    =&gt; \"red\"\n  :number   =&gt; 4\n  :location =&gt; \"Daejeon\"",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : `...` 연산자"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_in_function_argument",
    "href": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_in_function_argument",
    "title": "Interlude : ... 연산자",
    "section": "",
    "text": "함수의 정의에서는 인자를 튜플로 묶는다면 함수를 사용할 때는 컨테이너를 풉니다. 예를 들어,\nIn [12]: function ps3(a1, a2, a3)\n         return a1+(a2*a3)\n         end\n와 같은 함수를 사용해야 한다고 합시다. 그런데 다른 함수의 계산 결과로 aa=(a1, a2, a3) 를 얻었다고 합시다. ps3(aa[1], aa[2], aa[3]) 와 같이 실행 시킬 수도 있지만\nIn [13]: aa=(2, 3, 4)\nOut[13]: (2, 3, 4)\n\nIn [14]: ps3(aa...)\nOut[14]: 14\n처럼 ps3 함수를 실행 시킬 때 인자로 a... 를 쓰면 튜플이 풀려서 ps3(aa[1], aa[2], aa[3]) 를 실행시킨 것과 같게됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : `...` 연산자"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html",
    "href": "src/introduction_to_julia/02_variables_basic_types.html",
    "title": "변수와 기본 타입",
    "section": "",
    "text": "많은 프로그래밍 언어처럼 변수에 어떤 값을 지정할 수 있습니다. 이것을 변수 할당이라고 하며 = 기호를 사용합니다. a 문자에 3 이라는 값을 값을 할당하고, 거기에 2 를 곱한 결과를 얻는 것은 다음과 같이 할 수 있습니다. 이 때 변수는 = 기호의 왼쪽에, 값은 오른쪽에 위치해야 합니다.\nIn [1]: a=3\nOut[1]: 2\n수학에서처럼 값이 할당된 변수는 계산에 사용되거나 함수에 인자로 사용 될 수 있습니다.\nIn [2]: a*2\nOut[2]: 6\n\nIn [3]: abs(a)\nOut[3]: 3\n변수에 할당 될 수 있는 것은 수(number) 뿐만이 아닙니다. 앞으로 배울 거의 모든 것이 변수에 할당 될 수 있습니다. 예를 들어 sin(x) 은 짐작 할 수 있듯이 x 에 대한 sin 함수값을 반환하는 함수입니다. 그런데 myfunc = sin 하면 어떻게 될까요?\nIn [1]: myfunc = sin\nOut[1]: sin (generic function with 14 methods)\n\nIn [2]: myfunc(π)\nOut[2]: 0.0\n\nIn [3]: myfunc(2π)\nOut[3]: -2.4492935982947064e-16\nmyfunc 가 sin 함수가 되어 버렸습니다. 이것에 대해 길게 이야기 할 수 있겠지만 일단은 함수도 변수에 할당 될 수 있다는 것을 알아두면 좋겠습니다.\n\n\n\n\n변수 이름에는 제한이 있습니다. 우선 첫문자는 알파벳 대문자(A-Z) 혹은 소문자(a-z) 나 밑줄 _ 혹은 00A0 보다 큰 유니코드 문자 가운데 특정 범주에 속하는 문자들이 와야 합니다. 유니코드 및 수학 기호 지원 를 참고하시기 바랍니다. 한글은 허용됩니다. 자세한 것은 julia 공식 문서 가운데 Variables 을 참고 하십시요. 두번째 글자부터는 첫번째 글자로 허용된 문자에 ! 나 숫자가 올 수 있습니다.\nIn [4]: 파이 = π\nOut[4]: π = 3.1415926535897...\n\nIn [5]: 2*파이\nOut[5]: 6.283185307179586\n\nIn [6]: 맑뚫 = 3; 맑뚫*3\nOut[6]: 9\n\n앞서 유니코드 및 수학 기호 지원 에서 언급했듯이 π 나 ℯ 는 이미 값이 지정되어 있습니다. 그 외의 θ(\\theta + [tab]), φ(\\varphi + [tab]), ϕ(\\phi + [tab]), Γ(\\Gamma + [tab]) 와 같이 수학, 과학, 공학에서 많이 사용되는 기호들을 변수로 사용 할 수 있습니다.\nIn [1]: θ = π/4; cos(θ)\nOut[1]: 0.7071067811865476",
    "crumbs": [
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#변수",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#변수",
    "title": "변수와 기본 타입",
    "section": "",
    "text": "많은 프로그래밍 언어처럼 변수에 어떤 값을 지정할 수 있습니다. 이것을 변수 할당이라고 하며 = 기호를 사용합니다. a 문자에 3 이라는 값을 값을 할당하고, 거기에 2 를 곱한 결과를 얻는 것은 다음과 같이 할 수 있습니다. 이 때 변수는 = 기호의 왼쪽에, 값은 오른쪽에 위치해야 합니다.\nIn [1]: a=3\nOut[1]: 2\n수학에서처럼 값이 할당된 변수는 계산에 사용되거나 함수에 인자로 사용 될 수 있습니다.\nIn [2]: a*2\nOut[2]: 6\n\nIn [3]: abs(a)\nOut[3]: 3\n변수에 할당 될 수 있는 것은 수(number) 뿐만이 아닙니다. 앞으로 배울 거의 모든 것이 변수에 할당 될 수 있습니다. 예를 들어 sin(x) 은 짐작 할 수 있듯이 x 에 대한 sin 함수값을 반환하는 함수입니다. 그런데 myfunc = sin 하면 어떻게 될까요?\nIn [1]: myfunc = sin\nOut[1]: sin (generic function with 14 methods)\n\nIn [2]: myfunc(π)\nOut[2]: 0.0\n\nIn [3]: myfunc(2π)\nOut[3]: -2.4492935982947064e-16\nmyfunc 가 sin 함수가 되어 버렸습니다. 이것에 대해 길게 이야기 할 수 있겠지만 일단은 함수도 변수에 할당 될 수 있다는 것을 알아두면 좋겠습니다.\n\n\n\n\n변수 이름에는 제한이 있습니다. 우선 첫문자는 알파벳 대문자(A-Z) 혹은 소문자(a-z) 나 밑줄 _ 혹은 00A0 보다 큰 유니코드 문자 가운데 특정 범주에 속하는 문자들이 와야 합니다. 유니코드 및 수학 기호 지원 를 참고하시기 바랍니다. 한글은 허용됩니다. 자세한 것은 julia 공식 문서 가운데 Variables 을 참고 하십시요. 두번째 글자부터는 첫번째 글자로 허용된 문자에 ! 나 숫자가 올 수 있습니다.\nIn [4]: 파이 = π\nOut[4]: π = 3.1415926535897...\n\nIn [5]: 2*파이\nOut[5]: 6.283185307179586\n\nIn [6]: 맑뚫 = 3; 맑뚫*3\nOut[6]: 9\n\n앞서 유니코드 및 수학 기호 지원 에서 언급했듯이 π 나 ℯ 는 이미 값이 지정되어 있습니다. 그 외의 θ(\\theta + [tab]), φ(\\varphi + [tab]), ϕ(\\phi + [tab]), Γ(\\Gamma + [tab]) 와 같이 수학, 과학, 공학에서 많이 사용되는 기호들을 변수로 사용 할 수 있습니다.\nIn [1]: θ = π/4; cos(θ)\nOut[1]: 0.7071067811865476",
    "crumbs": [
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#sec-primary_number_types",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#sec-primary_number_types",
    "title": "변수와 기본 타입",
    "section": "2 기본적인 수 타입",
    "text": "2 기본적인 수 타입\n수(number) 를 포함하는 julia 에서 사용하는 모든 값(value) 은 타입(type) 을 갖습니다. 여기서는 julia 언어 자체에서 정의된 기본 타입 가운데 수(number) 에 관련된 타입은 아래와 같습니다.\n\n\n\n\n\n\n\n타입 종류\n타입들\n\n\n\n\n부호 없는 정수 타입\nUInt8, UInt16, UInt32, UInt64, UInt128\n\n\n정수 타입\nInt8, Int16, Int32, Int64, Int128, BigInt\n\n\n유리수 타입\nRational\n\n\n부동소수 타입\nFloat16, Float32, Float64, BigFloat\n\n\n무리수 타입\nIrrational\n\n\n복소수 타입\nComplex\n\n\n불 타입\nBool\n\n\n\n\n부호 없는 정수는 0 과 양의 정수를 말합니다.\n앞서 언급한 π (\\(\\pi\\), 원주율) 나 ℯ (\\(e\\), 자연로그의 밑) 는 무리수 타입으로, 연산할 때 가장 적절한 타입으로 변환되어 계산됩니다.\n타입 이름은 다른 타입의 값을 타입으로 변환시키는 함수처럼 사용 할 수 있습니다. Float64(1) 은 1 을 Float64 타입으로 변환시킵니다.\n실제 Julia 의 타입 구조는 이보다 훨씬 복잡합니다. 이후 타입 계층 구조 에서 좀 더 자세히 설명하도록 하겠습니다.\n\n\n어떤 변수나 값의 타입을 알기 위해서는 typeof() 함수를 사용 할 수 있습니다.\nIn [4]: typeof(UInt8(2))\nOut[4]: UInt8\n\n\n정수형 타입\n우선 부호 없는 정수타입, 정수타입, 부동소수 타입의 이름의 끝부분에 붙는 8, 16, 32, 64, 128 은 각 타입의 값이 차지하는 비트(bit) 수 입니다. 비트는 on/off 혹은 0/1 로 구분되는 정보 단위입니다. 예를 들어 UInt8 의 경우는 8개의 비트로 수를 표현합니다. 2진수로 00000000 은 0 이며 2진수 11111111 은 255 입니다. UInt8 은 이렇게 0 부터 255 까지의 값을 표현 할 수 있습니다. UInt64 는 64 개의 비트로 숫자를 저장하며, 따라서 0부터 264-1 까지의 숫자를 표현 할 수 있습니다.\nInt8 의 경우는 8비트로 정수를 저장하지만 한 비트는 음수/양수 를 구분하기 위해 사용됩니다. -128 부터 127 까지의 정수를 표현 할 수 있습니다. Int64 는 -232 부터 232-1 까지의 숫자를 표현 할 수 있습니다.\n\n\n\n타입\n부호\n비트수\n최소값\n최대값\n\n\n\n\nInt8\no\n8\n-27\n27 - 1\n\n\nUInt8\nx\n8\n0\n28 - 1\n\n\nInt16\no\n16\n-215\n215 - 1\n\n\nUInt16\nx\n16\n0\n216 - 1\n\n\nInt32\no\n32\n-231\n231 - 1\n\n\nUInt32\nx\n32\n0\n232 - 1\n\n\nInt64\no\n64\n-263\n263 - 1\n\n\nUInt64\nx\n64\n0\n264 - 1\n\n\nInt128\no\n128\n-2127\n2127 - 1\n\n\nUInt128\nx\n128\n0\n2128 - 1\n\n\nBool\nN/A\n8\nfalse (0)\ntrue (1)\n\n\n\n\nmyint=3 처럼 변수를 할당하면 시스템 마다 지정된 기본 타입으로 처리됩니다. 보통의 경우는 Int64 이며 시스템에 따라 Int32 나 다른 타입일 수 있습니다. 보통 Int 가 기본 정수형과 같은 의미로 사용되므로 다음과 같은 입력을 통해 기본 정수형을 알 수 있습니다.\nIn [1]: Int\nOut[1]: Int64\n긴 숫자를 표현할 때 오류를 줄이는 방법으로 밑줄 _ 을 사용할 수 있습니다. 예를 들어 a=123_4567_89_12 는 밑줄을 없엔 a=12345678912 와 같습니다. 다만 두개 이상의 밑줄을 연속적으로 사용 할 수는 없습니다. 1_2 는 사용 할 수 있지만 1__2는 에러를 냅니다.\nIn [2]: a=123_4567_89_12\nOut[2]: 12345678912\n\n\nOverflow\n타입이 허용하는 범위의 값을 넘어서는 값을 할당하려 할 때에는 에러가 발생합니다.\nIn [1]: a::UInt8 = 300\nERROR: InexactError: trunc(UInt8, 300)\n...\na::UInt8 = 300 은 UInt8 타입의 변수 a 에 값 300 을 할당하는 명령어입니다. 만얄 a::UInt8=2 라면 2 는 UInt8 범위 내의 수이기 때문에 문제가 발생하지 않지만 300 은 UInt8 의 범위를 벗어나기 떼문에 에러가 발생합니다. 아래의 경우는 에러가 발생되지 않고 틀린 결과가 나옵니다.\nIn [2]: b = UInt8(200)+UInt8(56)\nOut[2]: 0x00\n200 과 56 은 모두 UInt8 의 범위 안이지만 그 합 256 은 범위를 벗어납니다. 이렇게 정수 타입에서 범위를 넘어서는 값이 할당되거나 계산될 때 실제 계산되어야 할 값과는 다른 값이 나오는 것을 overflow 라고 합니다. 해결책은 연산을 잘 조작하여 타입의 범위 내에서 원하는 결과를 얻을 수 있게 하거나, 당신의 변수가 가질 수 있을 가능성이 있는 값을 모두 포함하는 타입을 쓰는 것 밖에는 없습니다. Overflow 시 결과가 어떻게 나오는 지 알고 싶다면 공식 매뉴얼의 Overflow behavior 를 참고하시기 바랍니다.\n\n\n\n\n부동소수 타입\n부동소수는 일반적인 실수 (real number) 를 표현하기 위한 타입으로 가장 많이 사용하며, 부동소수의 기본타입인 Float64 타입의 경우 fn1 = 3.33 나 fn2=2.3e-4 처럼 사용합니다. 후자의 경우는 2.3 × 10-4 와 같습니다. 그리고 e 대신 E 를 사용해도 됩니다. e 나 E 대신 f 를 사용하면 Float32 타입으로 지정됩니다.(F 는 사용 할 수 없습니다.) 2.3f0 의 경우는 Float32 타입의 2.3 을 의미하며 2.3f2 와 2.3f-2 의 경우는 각각 Float32 타입의 2.3 × 102 와 2.3 × 10-2 를 의미합니다. 부동정수형과 마찬가지로 숫자 사이에 밑줄을 넣어서 사용 할 수 있습니다. 혹은 정수에서와 같이 a::Float32=3.3 처럼 변수에 타입을 지정할 수 있습니다. 이 경우 할당되는 값이 지정된 타입(여기서는 Float32)으로 변환됩니다.\nIn [1]: 3.14_1592\nOut[1]: 3.141592\n\nIn [2]: c::Float32=3.3\nOut[2]: 3.3\n\nIn [3]: typeof(c)\nOut[3]: Float32\n\nIn [4]: c\nOut[4]: 3.3f0\n\n\n\n유리수 타입 (Rational) 과 복소수 타입 (Complex)\n유리수 타입은 두개의 정수 타입을 이용하여 하나는 분모, 하나는 분자로 사용하여 유리수를 표현합니다. 복소수 타입은 두개의 실수를 이용하여 하나는 실수부, 하나는 허수부로 사용하여 복소수를 표현합니다.\nRational 타입의 경우 // 연산자를 이용하거나 Rational(3, 4) 와 같이 할당합니다.. a=1//3 는 Rational(1, 3) 과 같고, a 라는 변수에 \\(\\frac{1}{3}\\) 을 저장합니다. 유리수값끼리의 혹은 유리수값과 정수의 사칙연산은 유리수가 되며, 자동적으로 약분하여 가장 간단한 값으로 처리됩니다.\nIn [1]: 6//5 + 1 # 유리수와 정수의 연산\nOut[1]: 11//5\n\nIn [2]: 1//2 + 1.0 # 유리수와 실수의 연산\nOut[2]: 1.5\n\nIn [3]: 27//12   # 유리수 입력은 자동으로 약분된다.\nOut[3]: 9//4\n\nIn [4]: 1//12 + 2//12 # 유리수 연산 후 약분된다.\nOut[4]: 1//4\n\nComplex 타입의 경우는 2.0 + 3.0im 혹은 Complex(2.0, 3.0) 과 같이 할당합니다. Julia 에서 im 은 \\(\\sqrt{-1}\\) 로 정의되었으며 i 나 j 와 같은 문자를 사용하지 않습니다. conj() 함수는 켤레복소수를 반환합니다.\nIn [7]: (1.0+1.0im)*(1.0-1.0im)\nOut[7]: 2.0 + 0.0im\n\nIn [8]: conj(Complex(1.0, 1.0))\nOut[8]: 1.0 - 1.0im\n\n\n\n불(Bool) 타입\n불(Bool) 타입은 참을 나타내는 true 와 거짓을 나타내는 false 의 두 값만을 표현하는 정수형 타입입니다. 수로 변환하면 true 는 1 이며 false 는 0 입니다. 거꾸로 수를 불 타입으로 변환하는 경우 1 혹은 1 과 같다고 평가되는 1.0f0 와 같은 수는 true 로 0 혹은 0 과 같다고 평가되는 0.0 은 false 로 변환됩니다. Python 과 같은 언어에서는 0 혹은 0 과 같다고 평가되는 수만 False 이고 나머지 수는 모두 True 로 평가됩니다.\nIn [1]: Bool(-3)\nERROR: InexactError: Bool(-3)\n...\n\nIn [2]: Bool(1.0)\nOut[2]: true\n\nIn [3]: Bool(1.0f0)\nOut[3]: true\n\nIn [4]: Bool(3//3)\nOut[4]: true\n\nIn [5]: Bool(0//1)\nOut[5]: false\n\n\n\n타입 확인\n변수의 값이 특정 타입인지를 비교해야 할 때 가장 간단하게 사용할 수 있는 함수는 isa 입니다. isa 는 함수이기도 하지만 연산자이기도 합니다.\nIn [1]: isa(3.3f0, Float32)   # isa 를 함수처럼 사용할 경우\nOut[1]: true\n\nIn [2]: 3.3f0 isa Float64     # isa 를 연산자처럼 사용할 경우\nOut[2]: false\n\n\n\n타입 변환\n앞서 언급했듯이 타입 이름은 그 타입으로 변환시키는 함수처럼 사용 할 수 있습니다.\nIn [5]: Float32(3.32)\nOut[5]: 3.32f0\n어떤 언어에서는 실수를 정수로 변환할 때 억지로라도 변환시켜주지만 julia 에서는 실수가 정수와 같지 않으면 에러가 발생합니다.\nIn [6]: Int64(2.0)\nOut[6]: 2\n\nIn [7]: Int64(2.001)\nERROR: InexactError: Int64(2.001)\n...\n이때는 반올림 (round), 내림(floor), 올림(ceil) 함수를 사용 할 수 있습니다. 이 함수들은 입력값의 타입으로 반올림한 값을 반환합니다. round(3.3) 처럼 사용해도 되지만 특정 정수 타입으로 변환할때는 ceil(UInt16, 4.2) 처럼 타입을 명시하여 변환해야 합니다.\nIn [8]: round(2.3)\nOut[8]: 2.0\n\nIn [9]: floor(4.3f0)\nOut[9]: 4.0f0\n\nIn [10]: ceil(UInt16, 4.2)\nOut[10]: 0x0005",
    "crumbs": [
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#sec-char_and_string_types",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#sec-char_and_string_types",
    "title": "변수와 기본 타입",
    "section": "3 문자와 문자열, 기호 타입",
    "text": "3 문자와 문자열, 기호 타입\n\nChar 와 String 타입\nChar 는 ascii 나 유니코드 하나의 문자에 대한 타입이며 String 은 하나 이상의 문자를 포함하는 문자열에 대한 타입입니다. Char 타입은 'a' 와 같이 따옴표 ' 로 감싸서 선언합니다. 한줄 문자열은 겹따옴표(\") 로 감싸고 여러줄 문자열은 겹따옴표 세개(\"\"\")로 감쌉니다. 문자열을 출력할때는 println 함수를 사용합니다. println 함수의 경우 인자를 , 로 분리하여 계속 써 주면 각각의 인자를 문자열로 변환하여 연결시켜 하나의 문자열을 출력합니다.\nIn [11]: char1='가'\nOut[11]: '가': Unicode U+AC00 (category Lo: Letter, other)\n\nIn [12]: str1 = \"Hello, world.\\n\"\nOut[12]: \"Hello, world.\\n\"\n\nIn [13]: str2 = \"\"\"Julia is\n                a good programing\n                language\"\"\"\nOut[13]: \"Julia is\\na good programing\\nlanguage\"\n\nIn [14]: println(str2)\nJulia is\na good programing\nlanguage\n\nIn [15]: println(1, \"ab\", \" c_d \", 3.3)\n1ab c_d 3.3\n문자열 내의 \\n 은 개행문자라고 해서 출력할 때 줄바꿈을 해 주는 문자입니다. asciii 는 컴퓨터 자판에서 보이는 숫자, 영어 알파벳과 기호를 포함하며 각 문자가 1바이트를 차지합니다. ascii 문자로 이루어진 문자열은 1부터 시작하는 인덱스로 접근 할 수 있습니다.\nIn [16]: str3 = \"I love Julia language !!!\"\nOut[16]: \"I love Julia language !!!\"\n\nIn [17]: str3[1], str3[end], str3[end-4]\nOut[17]: ('I', '!', 'e')\n인덱스에서 end 는 맨 마지막 인덱스를 의미하며 end-4 은 마지막에서 다섯번째 글자를 의미합니다. end-2 는 마지막에서 세번째입니다. 정확히 말하면 str3[3] 은 문자열 str3 에서 세번째 글자가 아니라 세번째 바이트에서 시작하는 문자를 의미합니다. ascii 에서는 각 문자가 1 바이트를 차지하기 때문에 세번째 바이트에서 시작하는 문자와 세번째 문자가 같지만 2 바이트 이상을 차지하는 문자에서는 다른 의미가 됩니다.\n\n\n\n유니코드(Unicode)\n유니코드(unicode) 는 전 세계의 모든 문자를 다룰 수 있도록 제정된 표준 문자 처리 방식입니다. 유니코드를 표기할때는 U+0A03 처럼 U+ 와 16진수의 결합으로 표현합니다. 앞서 언급한 Unicode Input 에 julia 에서 표현 할 수 있는 문자들이 나열되어있습니다.\n유니코드를 문자열로 표현할 때는 탭으로 완성되는 문자를 사용 할 수도 있고 다음처럼 \\u 혹은 \\U 로 시작되는 문자로 표현 할 수도 있습니다. \\u 다음에는 4개까지의 16진수 문자가 올 수 있으며 \\U 다음에는 8개까지의 16진수 문자가 올 수 있고 \\u 를 포함하여 더 많은 문자를 표현 할 수 있습니다. \\u 나 \\U 다음에 오는 숫자 가운데 자릿수를 차지하는 0 은 생략 할 수 있습니다. 예를 들어 \\u0033 은 \\u33 과 같습니다. 그리고 \\U000000 부터 \\U00FFFF 까지는 \\u0000 과 \\uffff 까지와 같습니다. 유니코드는 다음과 같이 사용합니다.\nIn [18]: unistr = \"\\u2200 x \\u2203 y\"\nOut[18]: \"∀ x ∃ y\"\nJulia 에서 유니코드는 UTF-8 로 인코딩 되어 있습니다. UTF-8 에서는 각 문자당 차지하는 바이트수가 다르기 때문에 ascii 와 같은 인덱스를 사용 할 수 없습니다. 앞서 설명했듯이 unistr[2] 는 문자열 unistr 의 2번째 바이트에서 시작하는 문자를 의미하는데 \\u2200 은 3 바이트 문자이므로 2번째 바이트에서 시작하는 문자가 없으므로 에러가 발생합니다.\nIn [19]: unistr[1]\nOut[19]: '∀': Unicode U+2200 (category Sm: Symbol, math)\n\nIn [20]: unistr[2]\nERROR: StringIndexError: invalid index [2], valid nearby indices [1]=&gt;'∀', [4]=&gt;' '\n...\n\nIn [21]: unistr[4]\nOut[21]: ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n그렇다면 문자열의 \\(n\\) 번째 문자는 어떻게 추출할까요? 불편하긴 하지만 collect 함수를 사용할 수 있습니다. collect 함수는 문자열을 분리하여 배열(Array) 로 만듭니다. 즉 unistr[2] 는 문자가 아니지만 collect(unistr)[2] 는 unistr 문자열의 두번째 문자입니다.\n\n\n\n\n\n\n\n유니코드 문자열의 인덱스\n\n\n\n유니코드 문자열을 다룰 때 인덱스의 의미는 언어마다 다릅니다. 예를 들어 Python 에서는 인덱스 가 i 일 때 i 번째 문자를 의미합니다. 아래는 Python shell 에서 같은 일을 한 결과입니다. 참고로 julia 는 인덱스가 1부터 시작하지만 python 은 0 부터 시작하기 때문에 인덱스가 차이가 납니다.\n&gt;&gt;&gt; unistr = \"\\u2200 x \\u2203 y\"\n&gt;&gt;&gt; unistr\n'∀ x ∃ y'\n&gt;&gt;&gt; unistr[0]\n'∀'\n&gt;&gt;&gt; unistr[1]\n' '\n&gt;&gt;&gt; unistr[2]\n'x'\n\n\n\n\n\n문자열 연산과 함수\n\n결합과 반복\n문자열을 합칠 때는 * 연산자를 이용하거나 string() 함수를 이용하며, 여러번 반복할때는 ^ 연산자 나 repeat() 함수를 이용합니다. 실제로 string() 함수는 인자를 차례대로 문자열로 바꾸어 주는 함수입니다.\nIn [1]: \"가나다라\"*\"마바사\" # 문자열 합치기\nOut[1]: \"가나다라마바사\"\n\nIn [2]: string(\"가나다라\", \"abc\", 'π', 5) # 문자열 합치기\nOut[2]: \"가나다라abcπ5\"\n\nIn [3]: \"αβγ\"^3 # 문자열 반복\nOut[3]: \"αβγαβγαβγ\"\n\nIn [4]: repeat(\"Δ=\", 5) # 문자열 반복\nOut[4]: \"Δ=Δ=Δ=Δ=Δ=\"\n문자열의 길이는 length() 함수를 사용하며 문자열에 접근할 때는 str1[3] 과 같이 인덱스를 사용합니다. Julia 에서는 처음 인덱스는 0 이 아닌 1 입니다.\nIn [5]: str3=\"abcdefg\";str3[2]\nOut[5]: 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n\n\n\n문자열 보간(Interpolation)\n문자열에 $ 기호를 통해 이미 정의된 변수를 사용하여 문자열을 구성 할 수 있습니다.\nIn [6]: aa=1;bb=22.2;cc=\"C12\";\n\nIn [7]: \"\"\"aa=$aa, bb=$bb, cc=$cc\"\"\"\nOut[7]: \"aa=1, bb=22.2, cc=C12\"\n보간 이전에 값을 평가해야 할 경우에는 괄호(( )) 안에 식을 넣을 수 있습니다. 예를 들어 \"$sin(π)\" 는 문자열 \"sin(π)\" 지만 \"$(sin(π))\" 는 sin(π) 를 평가한 0.0 이 문자열로 입력됩니다.\nIn [9]: \"$sin(π)\"\nOut[9]: \"sin(π)\"\n\nIn [10]: \"$(sin(π))\"\nOut[10]: \"0.0\"\n\n\n\n비교\n문자열을 사전순으로 비교 할 수 있습니다. 즉 'a' &lt; 'b' 이며 \"aa\" &lt; \"ab\" 입니다.\nIn [11]: \"abracadabra\" &lt; \"xylophone\"\nOut[11]: true\n\nIn [12]: \"abracadabra\" == \"xylophone\"\nOut[12]: false\n\nIn [13]: \"Hello, world.\" != \"Goodbye, world.\"\nOut[13]: true\n\nIn [14]: \"1 + 2 = 3\" == \"1 + 2 = $(1 + 2)\"\nOut[14]: true\n\n\n\n문자열 함수\nfindfirst(a, str) 은 문자열 str 에서 문자 혹은 문자열 a 가 나타는 첫번째 인덱스를 리턴합니다. findlast(a, str) 는 마지막 인덱스를 리턴합니다. findprev(a, str, i) 는 문자열 str 에서 문자 혹은 문자열 a 를 찾는데 인덱스 i 부터 앞으로 찾아가서 나오는 첫번째 인덱스를 반환합니다. findnext(a, str, i) 는 인덱스 i 부터 뒤로 찾아가서 나오는 첫번째 인덱스를 반환합니다. 네가지 경우 모두 찾지 못한다면 nothing 을 반환합니다. a 가 문자열일 경우는 a 와 일치하는 인덱스의 범위를 리턴합니다. 6:7 은 인덱스 6에서 인덱스 7 까지란 의미입니다. occursin(a, str) 은 문자 혹은 문자열 a 가 문자열 str 에 포함되어 있는지만을 확인하여 true 나 false 를 리턴합니다.\nIn [15]: findfirst('a', \"biography\")\nOut[15]: 6\n\nIn [16]: findfirst(\"ap\", \"biography\")\nOut[16]: 6:7\n\nIn [17]: occursin(\"gr\", \"biography\")\nOut[17]: true\n\nIn [18]: occursin(\"rp\", \"biography\")\nOut[18]: false\n\nrepeat(a, n) 은 문자열 a 를 n 번 반복한 문자열을 반환합니다. 여러 문자열을 결합할 때는 join() 함수를 사용합니다.\nIn [19]: repeat(\".:Z:.\", 10)\nOut[19]: \".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.\"\n\nIn [20]: join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\nOut[20]: \"apples, bananas and pineapples\"\njoin 함수의 두번째 인자 \", \" 는 결합하는 문자열 사이에 \", \" 를 끼워 결합하라는 의미입니다. 세번째 인자 \" and \" 는 마지막 두 문자열을 결합할때는 \", \" 대신에 \" and \" 를 사용하라는 의미입니다. 자세한 것은 julia 의 공식 도움말을 참고하시기 바랍니다.\n\n\n\n\n심볼 타입\n심볼(Symbol) 타입은 문자열과 비슷하지만 다릅니다. 심볼(Symbol) 타입은 : 다음의 문자열, 혹은 Symbol 이라는 타입 이름을 함수로 사용하여 다음과 같이 선언할 수 있습니다.\nIn [21]: a=Symbol(\"bc\") # `Symbol` 함수를 이용한 선언\nOut[21]: :bc\n\nIn [22]: b=:bc # 콜론 `:` 을 이용한 선언\nOut[22]: :bc\n\nIn [23]: a==b # 두 선언은 같다.\nOut[23]: true\n심볼 타입은 Julia 에서 소위 메타 프로그래밍 개념의 핵심이지만 여기서는 자세히 다루지 않겠습니다. 심볼 타입이 많이 쓰이는 다른 경우는 함수에 인자로 전달할 때 입니다. 예를 들어 그래프를 빨간 색으로 그리고 싶을 때, 다른 언어라면 \"red\" 라는 문자열을 함수의 인자로 입력하는 경우가 많은데, Julia 에서는 이렇게 문자열을 쓸 수도 있지만 :red 라는 심볼 타입을 전달하는 경우가 많습니다. 이 경우 비교가 문자열보다 빠릅니다.\n\n\n\n변수의 타입 지정과 타입 유니온\n\n변수의 타입 지정\n예를 들어 변수 a 에 UInt8 타입의 3 을 할당한다고 해 봅시다. a=UInt8(3) 와 a::UInt8=3 과 같은 두가지 방법을 사용 할 수 있습니다. 그러나 두번째 경우에는 a 라는 변수가 UInt8 타입으로 지정되기 때문에 UInt8 타입 이외의 값으로 변경할 수 없습니다.\nIn [1]: a::UInt8=3\nOut[1]: 3\n\nIn [2]: a=4\nOut[2]: 4\n\nIn [3]: a=-1\nERROR: InexactError: trunc(UInt8, -1)\nStacktrace:\nIn [2] 에서는 4 가 UInt8 타입으로 a 에 저장됩니다. 그러나 UInt8 은 음수를 저장 할 수 없으므로 In [3] 의 입력은 에러를 냅니다. 그러나 b=UInt8(3) 과 같이 할당하면 a 변수에 대한 타입 제한은 없습니다.\nIn [4]: b=UInt8(3)\nOut[4]: 0x03\n\nIn [5]: b=-1\nOut[5]: -1\n\n\n\n타입 유니온\n타입 유니온은 변수가 가질 수 있는 타입을 하나가 아닌 여러개중 하나로 할 때 사용되며 Union{T1, T2} 처럼 사용됩니다. T1, T2 는 변수가 가질 수 있는 타입이며 두개 이상일 경우에는 , 로 구분하여 나열합니다. 다음 보기를 봅시다.\nIn [1]: a::Union{Int, AbstractString}=\"a\"\nOut[1]: \"a\"\n\nIn [2]: b::Union{Int, AbstractString}=3\nOut[2]: 3\n\nIn [3]: c::Union{Int, AbstractString, Nothing}=nothing\n\nIn [4]: (a, b, c)\nOut[4]: (\"a\", 3, nothing)\nIn [1] 의 경우는 입력값이 문자열이므로 a 는 문자열 타입이 되고, b 는 입력값이 정수이므로 정수 타입이 되었습니다. c 는 세가지 타입중에 선택하도록 하는 것입니다. 이런 방법 역시 일반적인 변수에 값을 할당할 때 보다 함수의 인자의 타입을 제한 할 때 사용됩니다. 그리고 nothing 은 값이고 Nothing 은 nothing 에 대한 타입입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/00_part1.html",
    "href": "src/introduction_to_julia/00_part1.html",
    "title": "I. Introduction to Julia",
    "section": "",
    "text": "I. Introduction to Julia",
    "crumbs": [
      "Julia 언어의 기초",
      "I. Introduction to Julia"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/random.html",
    "href": "src/ecosystem_of_julia/random.html",
    "title": "난수 발생",
    "section": "",
    "text": "Random 모듈에 대해서는 자세한 사항은 공식 매뉴얼 Random Numbers 를 참고하라.",
    "crumbs": [
      "Julia 언어 생태계",
      "난수 발생"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/random.html#rand-함수",
    "href": "src/ecosystem_of_julia/random.html#rand-함수",
    "title": "난수 발생",
    "section": "1 rand 함수",
    "text": "1 rand 함수\nrand 함수는 추가 모듈 호출 없이 사용 할 수 있으며 기본적인 난수 기능을 제공한다.\n\n1.1 기본적인 사용\n기본적인 난수 발생 함수이다. rand() 는 \\([0,\\,1)\\) 범위, 즉 \\(0\\le x &lt; 1\\) 범위의 의 난수를 하나 발생시킨다. rand(3,3) 은 \\([0,\\,1)\\) 범위의 난수를 \\(3\\times 3\\) 배열꼴로 발생시킨다.\nIn [1]: rand()\nOut[1]: 0.8828172727992498\n\nIn [2]: rand(3,3)\nOut[2]: 3×3 Matrix{Float64}:\n 0.184347   0.367585  0.487483\n 0.0646924  0.306758  0.0969628\n 0.395878   0.802534  0.682208\n\n\n\n1.2 컬렉션을 이용한 난수 생성\nrand() 함수의 첫번째 인자로 컬렉션을 주고, 두번째 인자로 배열의 차원을 주면 컬렉션에서 배열의 차원에 맞게 임의로 뽑은 배열을 반환한다.\nIn [4]: rand(1:10, (2, 2))\nOut[4]: 2×2 Matrix{Int64}:\n 3  5\n 2  1\n\nIn [5]: rand(\"abcdefgh\", (3, 1))\nOut[5]: 3×1 Matrix{Char}:\n 'f': ASCII/Unicode U+0066 (category Ll: Letter, lowercase)\n 'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n 'f': ASCII/Unicode U+0066 (category Ll: Letter, lowercase)\n\n\n\n1.3 부동소수, 복소수형 난수 발생\nrand() 함수의 첫번째 인자로 부동소수형 타입(Float32, Float64 등) 두번째 인자로 배열의 크기를 입력 하면 지정된 부동소수 타입에 맞도록 \\([0,\\,1)\\) 범위의 난수를 반환한다.\nIn [7]: rand(Float32, (2, 3))\nOut[7]: 2×3 Matrix{Float32}:\n 0.15381   0.329045  0.566583\n 0.543246  0.985837  0.49038\n부동소수 타입 대신에 복소수 타입(ComplexF32,ComplexF64` 등) 을 입력하면 실수부와 허수부가 각각 \\([0,\\,1)\\) 범위인 난수 배열을 반환한다.\nIn [11]: rand(ComplexF64, (3, 3))\nOut[11]: 3×3 Matrix{ComplexF64}:\n 0.714389+0.362708im  0.181131+0.355622im  0.246163+0.414729im\n 0.970722+0.402822im   0.71223+0.460335im  0.833319+0.389379im\n 0.100495+0.14951im   0.333517+0.47611im   0.981335+0.175562im\n\n\n\n1.4 정수형 난수 발생\n타입에 정수형 타입(UInt64, Int32 등) 을 입력하면 정수 범위 내에서의 주어진 배열 크기에 맞는 난수를 반환한다.\nIn [12]: rand(Int32, (4, 4))\nOut[12]: 4×4 Matrix{Int32}:\n 1196699858  -1854481187    772846765  -1708392714\n 1188189451   -465314003   -575000325   1969484502\n  754045126  -1342873240   -776187378  -2017122961\n -134558519    576240888  -1734804352   -613011413\n어떤 범위에 대한 난수를 발생시키고 싶으면 컬렉션을 지정하면 된다. 예를 들어 -100 에서 100 사이의 난수를 발생시키고 싶다면 다음과 같이 하면 된다.\nIn [16]: rand(-100:1:100, (3, 3))\nOut[16]: 3×3 Matrix{Int64}:\n  5  -88   28\n 52   28  -52\n 26  -68  -87",
    "crumbs": [
      "Julia 언어 생태계",
      "난수 발생"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/random.html#random-모듈",
    "href": "src/ecosystem_of_julia/random.html#random-모듈",
    "title": "난수 발생",
    "section": "2 Random 모듈",
    "text": "2 Random 모듈\n다양한 난수 발생가와 난수 기능을 사용하기 위해서는 Random 모듈을 사용한다. Julia 기본 패키지이므로 추가로 설치할 필요 없이 using Random 과 같이 사용하면 된다.\n\n\n2.1 의사 난수 발생기(Pseudo random number generator)\n실제 자연 현상으로부터 난수를 발생시키는 난수 발생기(Hardware random number generator, HRNG) 와 달리 컴퓨터 알고리즘으로 난수를 발생시키는 것을 의사 난수 발생기(Pseudo random number generator, PRNG) 라고 하며, julia 언어는 기본값으로 Xoshiro256++ 난수 발생기를 사용한다. 둘을 핲텨 난수발생기(RNG) 라고 하며 앞에서의 난수발생은 바로 이 RNG 를 사용한 것이다. 참고로 Xoshiro 는 XOR, Shift, Rotation 에서 순서대로 두문자를 따온 것이라고 한다.\nJulia 언어의 Random 모듈은 4가지 의사난수발생기를 지원한다 : TaskLocalRNG, Xoshiro, RandomDevice, MersenneTwister 자세한 사항은 공식 매뉴얼을 참고하라.\n\n\n\n2.2 seed\nSeed 는 의사난수발생기를 초기화 하는데 사용되는 숫자이다. 모든 RNG 가 seed 를 필요로 하는 것은 아니다. 예를 들어 RandomDevice RNG 의 경우는 seed 를 필요로 하지 않는다. 서로 다른 시드로 생성된 RNG 는 다른 난수발생기로 간주된다. Seed 가 필요한 난수발생기에 Seed 가 주어지지 않았다면 내부적으로 생성된 seed 를 사용한다.\nSeed 를 사용하면 동일한 난수를 발생시킬 수 있다. 예를 들어 Xoshiro 난수발생기에 seed 를 11 로 입력하면\nIn [1]: using Random\n\nIn [2]: rand(Xoshiro(11), 2,2)\nOut[2]: 2×2 Matrix{Float64}:\n 0.58051   0.862848\n 0.714139  0.702579\n\nIn [3]: rand(Xoshiro(11), 2,2)\nOut[3]: 2×2 Matrix{Float64}:\n 0.58051   0.862848\n 0.714139  0.702579\n이 된다. 그러나 일단 난수발생기를 생싱시키면 그 난수발생기는 지속적으로 다른 난수를 발생한다. 다음을 보라. Out[4] 와 Out[5] 는 다르다.\nIn [3]: rng = Xoshiro(11)\nOut[3]: Xoshiro(0x0991231718e930cb, 0x28e1460087a5d0ff, 0x4d62c780da1946f0, 0x764f51fefd621192, 0x434e1895e0078176)\n\nIn [4]: rand(rng, 2,2)\nOut[4]: 2×2 Matrix{Float64}:\n 0.58051   0.862848\n 0.714139  0.702579\n\nIn [5]: rand(rng, 2, 2)\nOut[5]: 2×2 Matrix{Float64}:\n 0.861659   0.919821\n 0.0130147  0.901326\n\n다른 julia 나 Random 버젼에서도 rand(Xoshiro(11), 2,2) 의 값이 유지되는 것을 기대하면 안된다. 즉 위에 나온 난수는 현재 저자가 사용하는 버젼에서의 랜덤값이며, 다른 버젼에서 작동한다면 그 버젼 내의 일관성은 유지되더라도 서로 다른 버젼간의 일관성을 보장할 수 없다. 즉 특정 난수 생성기와 seed 값에 의존하는 코드를 짜면 안된다.",
    "crumbs": [
      "Julia 언어 생태계",
      "난수 발생"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/random.html#distributions.jl",
    "href": "src/ecosystem_of_julia/random.html#distributions.jl",
    "title": "난수 발생",
    "section": "3 Distributions.jl",
    "text": "3 Distributions.jl\n지금까지의 난수는 모든 값에 대해 동일한 확률을 갖는 난수였다. 즉 rand() 함수로 발생되는 난수는 모든 \\([0,\\,1)\\) 범위내의 모든 작은 \\(dx\\) 에 대해 \\([a, a+dx)\\) 구간의 값이 나올 확률과 \\([b, b+dx)\\) 구간의 값이 나올 확률이 동일하다. 특정 분포를 따르는 난수가 필요할 경우 대표적으로 Distributions.jl 패키지를 사용 할 수 있다. 이것은 기본 패키지가 아니므로 추가 설치가 필요하다. 설치는 ]add Distributions.\n\n\n3.1 정규 분포\nNormal(μ, σ) 은 평균 μ, 표준편차 σ 인 정규분포를 생성하며, rand 함수를 통해 난수를 생성한다.\nusing CairoMakie, Random, Distributions\n\nnorm1 = Normal(3, 5)\nx = rand(norm1, 1000000)\nx 는 평균이 3, 표준편차가 5 인 정규분포를 따르는 난수 백만개를 가진 벡터이다. 난수에 대한 평균과 표준편차를 확인 할 수 있다.\nprintln(\"mean = $(mean(x)), std = $(std(x))\")\n실제 분포를 보자.\nhist(x, bins=100)\n\n\n\n\n\n\n그림 1: 정규 분포",
    "crumbs": [
      "Julia 언어 생태계",
      "난수 발생"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/multithreads.html",
    "href": "src/ecosystem_of_julia/multithreads.html",
    "title": "다중스레딩",
    "section": "",
    "text": "프로그램은 최소한 하나의 프로세스로 실행되며, 프로세스는 최소한 하나의 쓰레드로 실행됩니다. 프로그램이 여러개의 프로세스로 실행되는 것을 멀티 프로세싱(multi-processing) 이라고 하며, 하나의 프로세스가 여려개의 쓰레드로 실행되는 것을 다중 스레딩(multi-threading) 이라고 합니다. Julia 에서의 다중스레딩에 대한 다음의 블로그 Announcing composable multi-threaded parallelism in Julia 는 줄리아의 창시자들의 블로그로 많은 도움이 됩니다.\n하나의 프로세스는 메모리상에 독립적으로 실행 코드와 데이터가 함께 기록됩니다. 쓰레드는 프로세스에 종속되며 프로세스상의 공통 자원에 접근 할 수 있습니다. 그러나 프로세스간에는 자원을 공유 할 수 없으며 IPC(inter-process communication) 를 통해 데이터를 주고 받을 수 있을 뿐입니다. 데이터를 주고 받는 것일 뿐 이 데이터는 각각의 프로세스에서 각각의 메모리 공간에 기록될 뿐 한 프로세스에서 다른 프로세스의 자원에 접근 할 수 있는 것은 아닙니다.\nJulia 는 실행시킬 때나 사용자 환경변수(JULIA_NUM_THREADS)로 지정하지 않았을 때는 단일 쓰레드로 실행됩니다. 현재의 Julia 에서 사용할 수 있는 스레드의 갯수는 Threads.nthreads() 함수로 확인 할 수 있는데, 저자의 경우 환경변수로 지정했기 때문에 Julia 가 실행 될 때 마다 12 개의 스레드로 시작합니다.\nJulia REPL 을 시작할 때 julia --thread 4 혹은 julia -t 4와 같이 스레드 갯수를 지정할 수 있습니다. 혹은 환경변수로 지정하여 자동으로 스레드 수를 정하는 방법이 있습니다. 환경변수로 지정하는 것은 운영체제마다, 혹은 당신이 사용하는 shell 마다 다를 수 있기 때문에 여기서는 다루지 않겠습니다. Sys.CPU_THREADS 변수는 최대로 사용할 수 있는 쓰레드의 갯수를 보여줍니다. 이 값보다 약간 작은 값을 사용하는것이 좋습니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "다중스레딩"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/multithreads.html#for-루프에서의-theads.threads",
    "href": "src/ecosystem_of_julia/multithreads.html#for-루프에서의-theads.threads",
    "title": "다중스레딩",
    "section": "1 for 루프에서의 Theads.@threads",
    "text": "1 for 루프에서의 Theads.@threads\nfor 루프 앞에 Threads.@threads 를 쓰면 자동적으로 다중스레딩으로 수행합니다.. 아래 코드는 \\([0, 1)\\) 구간에서의 임의의 수로 이루어진 10000 × 10000 행렬을 만든 후 각행과 열에에 대한 합을 구하는 코드를 싱글 스레드와 다중스레드로 구현한 것입니다.\nusing BenchmarkTools\n\nN = 1000\nbb = rand(N, N)\n\n# 행에 대한 합, 단일스레드\nr1 = zeros(N)\n@btime begin\n    for i in 1:N\n        r1[i] = sum(bb[i, : ])\n    end\nend\n\n# 행에 대한 합, 다중스레드\nr2 =  zeros(N)\n@btime begin\n    Threads.@threads for i in 1:N\n        r2[i] = sum(bb[i, :])\n    end\nend\n\n# 열에 대한 합, 단일스레드\nr3 =  zeros(N)\n@btime begin\n    for i in 1:N\n        r3[i] = sum(bb[:, i])\n    end\nend\n\n# 열에 대한 합, 다중스레드\nr4 =  zeros(N)\n@btime begin\n    Threads.@threads for i in 1:N\n        r4[i] = sum(bb[:, i])\n    end\nend\n결과는 다음과 같습니다.\n  3.375 ms (5957 allocations: 7.84 MiB)\n  635.961 μs (5030 allocations: 7.82 MiB)\n  1.744 ms (5957 allocations: 7.84 MiB)\n  393.205 μs (5028 allocations: 7.82 MiB)\n12개의 스레드를 이용했을 때 단일 스레드보다 약 4~5배 이상 빨라졌으며, 행에 대한 합보다 열에 대한 합이 더 빠릅니다. 열에 대한 합이 더 빠른 것은 julia 가 배열에서 행 우선 방식을 사용하기 때문입니다. 행렬의 열/행 우선 방식 를 참고하십시요.",
    "crumbs": [
      "Julia 언어 생태계",
      "다중스레딩"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/multithreads.html#안전한-스레드",
    "href": "src/ecosystem_of_julia/multithreads.html#안전한-스레드",
    "title": "다중스레딩",
    "section": "2 안전한 스레드",
    "text": "2 안전한 스레드\n다음의 코드를 봅시다.\ns = 1\nThreads.@threads for i in 1:5\n    global s += (-1)^(s+i)\n    @show i, s\nend\nprintln(s)\n실행시킬 때마다 i 값과 s 값, 그리고 결과로서 나오는 s 값이 달라진다는 것을 확인 할 수 있습니다. 즉 1 에서 5 사이에 있는 i 값중 어떤 값을 가진 스레드가 먼저 실행되어 s 값을 결정하는지에 대한 순서는 무작위적이며, 따라서 결과로서 나오는 s 값도 그때 그때 달라집니다. 이렇게 여러 스레드 혹은 프로세스가 공유하는 값(여기서는 s) 에 접근하는데 그 접근 순서가 결과값에 영항을 줄 수 있는 상태를 경쟁 상태 (race condition) 라고 하며 실제제로 데이터 값이 변하는 것을 데이터 레이스 (data race) 라고 합니다.\n데이터 레이스가 발생하는 더 심각한 상태는 여러 개의 스레드가 동시에 접근하여 동시에 읽거나 쓸 때 입니다. 다음의 코드를 봅시다.\nBase.@kwdef mutable struct ms\n    a::Int\n    b::Int\nend\n\nc=ms(1, 1)\nThreads.@threads for i in 1:30\n    c.a = i\n    c.b +=round(Int64, c.a*cos(i))\nend\n\nprintln(c)\n만약 한 스레드가 ms 객체를 읽고 쓸 때 다른 스레드가 멈추고 있다면 이 객체의 값은 항상 같을 것입니다. 이 코드를 여러번 실행시켜봐 가며 확인해보면 알듯이 그 값이 실행시킬 때마다 다릅니다. 그것은 여러 스레드가 동시에 읽고 쓰고 있다는 의미입니다. 그것을 막기 위해 Threads.ReentrantLock() 함수를 이용하여 다음과 같이 할 수 있습니다.\nlk = Threads.ReentrantLock()\nd=ms(1, 1)\nThreads.@threads for i in 1:30\n    lock(lk) do\n        d.a = i\n        d.b +=round(Int64, d.a*cos(i))\n    end\nend\nprintln(d)\n이 때 최종적으로 d 객체에 접근하는 스레드는 다르기 때문에 d.a 값은 다르지만, 한 스레드가 읽고 쓰는 동안 다른 스레드가 읽고 쓸 수 없기때문에 d.b 의 값은 항상 같게 됩니다.\n최종적으로 데이터 레이스에 대한 책임은 전적으로 여러분에게 있습니다. 위의 방법은 도움이 될 수 있지만 모든 경우에 적용될 수 있는 것도 아닙니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "다중스레딩"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/leastsquarefit.html",
    "href": "src/ecosystem_of_julia/leastsquarefit.html",
    "title": "비선형 최소제곱 피팅",
    "section": "",
    "text": "어떤 실험 결과가 \\(m\\) 개의 독립 변수에 대해 \\(n\\) 차원 벡터로 발생한다고 하자. 이에 대해 모델 함수 \\(\\boldsymbol{F}:\\mathbb{R}^m \\to \\mathbb{R}^n\\)",
    "crumbs": [
      "Julia 언어 생태계",
      "비선형 최소제곱 피팅"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/dataframes.html",
    "href": "src/ecosystem_of_julia/dataframes.html",
    "title": "DataFrames.jl",
    "section": "",
    "text": "DataFrames.jl 은 2차원 데이터 테이블을 다루는 DataFrame 타입을 지원한다. DataFrame 타입은 파이썬의 pandas 의 DataFrame 이나 R 의 DataFrame 과 같이 테이블 형태의 데이터를 표현하는 데이터 구조이다. 엑셀 sheet 의 각 열과 행을 프로그래밍으로 다루기 위한 데이터 구조라고 생각할 수 있다.",
    "crumbs": [
      "Julia 언어 생태계",
      "DataFrames.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/dataframes.html#설치",
    "href": "src/ecosystem_of_julia/dataframes.html#설치",
    "title": "DataFrames.jl",
    "section": "1 설치",
    "text": "1 설치\n다른 julia 패키지와 마찬가지로 REPL 이나 jupyter 에서\nusing Pkg\nPkg.add(\"DataFrames\")\n를 통해 설치 할 수 있다. 물론 REPL 에서 ] 를 통해 패키지 모드로 진입한 후\n(@v1.10) pkg&gt; add DataFrames\n로 설치할 수도 있다.",
    "crumbs": [
      "Julia 언어 생태계",
      "DataFrames.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/dataframes.html#dataframe",
    "href": "src/ecosystem_of_julia/dataframes.html#dataframe",
    "title": "DataFrames.jl",
    "section": "2 DataFrame",
    "text": "2 DataFrame\n\n시작하기\nDataFrame 타입 인스턴스는 다음과 같이 만들 수 있다.\nIn [1]: using DataFrames\n\nIn [2]: df=DataFrame(a=1:3, b=[\"A\", \"B\", \"C\"])\nOut[2]: 3×2 DataFrame\n Row │ a      b\n     │ Int64  String\n─────┼───────────────\n   1 │     1  A\n   2 │     2  B\n   3 │     3  C\n출력은 REPL 의 모습이며 jupyter 에서는 약간 다르다. DataFrames 는 모듈 이름이며 타입 이름은 마지막 s 가 빠진 DataFrame 이다. df 은 \"a\" 와 \"b\" 의 두 칼럼으로 구성되었으며 각 칼럼은 같은 수의 성분을 갖는 1차원 배열이다. names() 함수를 통해 칼렴 이름(여기서는 “a”, “b”) 를 얻을 수 있다. 칼럼에 대해 접근할 때는 df.a, df.\"a\", df[!, :a], df[!, \"a\"] 와 같이 접근 할 수 있다. 칼럼의 이름은 names(df) 와 propertynames(df) 함수로 얻을 수 있다. names()는 칼럼의 이름을 문자열로 반환하며, propertynames() 는 Symbol 로 반환한다.\nIn [3]: df.a[1]\nOut[3]: 1\n\nIn [4]: df.\"a\"[2]\nOut[4]: 2\n\nIn [5]: df[!, :b][1]\nOut[5]: \"A\"\n\nIn [6]: df[:, \"b\"][2]\nOut[6]: \"B\"\n\nIn [7]: names(df)\nOut[7]: 2-element Vector{String}:\n \"a\"\n \"b\"\n\nIn [8]: propertynames(df)\nOut[8]: 2-element Vector{Symbol}:\n :a\n :b\n\nIn [9]: size(df)\nOut[9]: (3, 2)\n\nIn [10]: size(df, 1)\nOut[10]: 3\nIn [9] 와 In [10] 은 df 의 크기를 알아내는 함수 size() 를 사용하였다. DataFrame 객체만을 전달할 경우 열수와 칼럼수를 반환하며, 두번째 인자로 칼럼 인덱스를 전달할 경우 그 칼럼의 데이터 갯수를 반환한다.\n\n\n\n비어있는 DataFrame 으로부터 시작하기\n비어있는 데이터 프레임으로부터 아래와 같이 시작 할 수 있다.\ndf = DataFrame()\ndf.t = 0:0.1:10\ndf.N = exp.(-df.t./0.3) .+ 0.3\ndf.err = sqrt.(df.N)\nnames(df) 로 확인해보면 t, N, err 라는 세개의 칼럼을 확인 할 수 있다. DataFrame 은 mutable 이므로 각각의 칼럼을 수정 할 수 있다.\ndf.N = exp.(-df.t./0.56) .+ 0.13\n\n\n\n칼럼 별로 다루기",
    "crumbs": [
      "Julia 언어 생태계",
      "DataFrames.jl"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Preface",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Introduction\nThis is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\n\n참고문헌\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "src/ecosystem_of_julia/00_part2.html",
    "href": "src/ecosystem_of_julia/00_part2.html",
    "title": "II. Application of Julia",
    "section": "",
    "text": "II. Application of Julia",
    "crumbs": [
      "Julia 언어 생태계",
      "II. Application of Julia"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/fileio.html",
    "href": "src/ecosystem_of_julia/fileio.html",
    "title": "파일시스템과 파일입출력",
    "section": "",
    "text": "Julia 스크립트가 실행 될 때 몇가지 파일과 경로에 대한 정보를 가지고 실행됩니다. 예를 들어 다음의 julia 스크립트 파일로 저장하고 실행시켜봅시다\n#! /usr/bin/env julia\n\nprintln(homedir())\nprintln(pwd())\nprintln(@__DIR__)\nprintln(@__FILE__)\nJulia 스크립트는 보통 확장자로 jl 을 사용합니다. 위의 코드를 pathes.jl 로 저장해 봅시다. 맨 앞줄의 #! /usr/bin/env julia 는 Shebang 이라고 하며 일반적으로 셸스크립트나 파이썬스크립트와 같은 스크립트의 실행 정보를 담고 있습니다. Linux 나 맥 OSX 같은 유닉스 계열의 OS 라면 터미널에서\njulia pathes.jl\n명령어로서 실행합니다. 실행이 제대로 된다면 4줄을 출력할 것입니다.\n\nhomedir() 은 사용자의 홈 디렉토리의 경로를 문자열로 반환하는 함수입니다.\npwd() 는 스크립트가 어떤 작업을 할 때의 기준 디렉토리 즉 작업디렉토리를 문자열로 반환하는 함수입니다.\n@__DIR__ 은 매크로로 이 매크로를 호출한 파일의 디렉토리를 반환합니다.\n@__FILE__ 역시 매크로로 이 매크로를 호출한 파일의 파일명을 포함하는 전체 경로를 반환합니다.\n\n\n\n\n\n여기서는 함수 이름만 나열합니다. 자세한 사용법은 Julia 의 도움말을 확인하기 바랍니다.\n\n\n\n표 1: 파일 입출력 함수\n\n\n\n\n\n기능\n함수\n\n\n\n\nhome directory\nhomedir()\n\n\nworking directory 확인\npwd()\n\n\nworking directory 변경\ncd()\n\n\nworking directory를 home directory로 변경\ncd()\n\n\ndirectory내 파일 및 폴더 리스트 확인\nreaddir()\n\n\ndirectory 만들기\nmkpath()\n\n\n파일/폴더 이동\nmv()\n\n\n파일/폴더 삭제\nrm()\n\n\n폴더인지 확인\nisdir()\n\n\n파일인지 확인\nisfile()\n\n\n유효한 경로인지 확인\nispath()\n\n\n절대경로 확인\nabspath()\n\n\n절대경로인지 확인\nisabspath()\n\n\n경로 합성\njoinpath()\n\n\n디렉토리 이름과 파일 이름으로 분할\nsplitdir()\n\n\n경로를 세부 단위로 분할\nsplitpath()\n\n\n파일크기 확인\nfilesize()\n\n\n파일의 세부 정보 얻기\nstat()",
    "crumbs": [
      "Julia 언어 생태계",
      "파일시스템과 파일입출력"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/fileio.html#파일-시스템",
    "href": "src/ecosystem_of_julia/fileio.html#파일-시스템",
    "title": "파일시스템과 파일입출력",
    "section": "",
    "text": "Julia 스크립트가 실행 될 때 몇가지 파일과 경로에 대한 정보를 가지고 실행됩니다. 예를 들어 다음의 julia 스크립트 파일로 저장하고 실행시켜봅시다\n#! /usr/bin/env julia\n\nprintln(homedir())\nprintln(pwd())\nprintln(@__DIR__)\nprintln(@__FILE__)\nJulia 스크립트는 보통 확장자로 jl 을 사용합니다. 위의 코드를 pathes.jl 로 저장해 봅시다. 맨 앞줄의 #! /usr/bin/env julia 는 Shebang 이라고 하며 일반적으로 셸스크립트나 파이썬스크립트와 같은 스크립트의 실행 정보를 담고 있습니다. Linux 나 맥 OSX 같은 유닉스 계열의 OS 라면 터미널에서\njulia pathes.jl\n명령어로서 실행합니다. 실행이 제대로 된다면 4줄을 출력할 것입니다.\n\nhomedir() 은 사용자의 홈 디렉토리의 경로를 문자열로 반환하는 함수입니다.\npwd() 는 스크립트가 어떤 작업을 할 때의 기준 디렉토리 즉 작업디렉토리를 문자열로 반환하는 함수입니다.\n@__DIR__ 은 매크로로 이 매크로를 호출한 파일의 디렉토리를 반환합니다.\n@__FILE__ 역시 매크로로 이 매크로를 호출한 파일의 파일명을 포함하는 전체 경로를 반환합니다.\n\n\n\n\n\n여기서는 함수 이름만 나열합니다. 자세한 사용법은 Julia 의 도움말을 확인하기 바랍니다.\n\n\n\n표 1: 파일 입출력 함수\n\n\n\n\n\n기능\n함수\n\n\n\n\nhome directory\nhomedir()\n\n\nworking directory 확인\npwd()\n\n\nworking directory 변경\ncd()\n\n\nworking directory를 home directory로 변경\ncd()\n\n\ndirectory내 파일 및 폴더 리스트 확인\nreaddir()\n\n\ndirectory 만들기\nmkpath()\n\n\n파일/폴더 이동\nmv()\n\n\n파일/폴더 삭제\nrm()\n\n\n폴더인지 확인\nisdir()\n\n\n파일인지 확인\nisfile()\n\n\n유효한 경로인지 확인\nispath()\n\n\n절대경로 확인\nabspath()\n\n\n절대경로인지 확인\nisabspath()\n\n\n경로 합성\njoinpath()\n\n\n디렉토리 이름과 파일 이름으로 분할\nsplitdir()\n\n\n경로를 세부 단위로 분할\nsplitpath()\n\n\n파일크기 확인\nfilesize()\n\n\n파일의 세부 정보 얻기\nstat()",
    "crumbs": [
      "Julia 언어 생태계",
      "파일시스템과 파일입출력"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/fileio.html#저수준-파일-입출력",
    "href": "src/ecosystem_of_julia/fileio.html#저수준-파일-입출력",
    "title": "파일시스템과 파일입출력",
    "section": "2 저수준 파일 입출력",
    "text": "2 저수준 파일 입출력\n\n파일 열고 닫기\n일반적인 프로그래밍 언어에서 기본적으로 파일을 다루는 것은 파일을 열고(open), 읽거나(read) 쓰고(write), 닫는(close) 절차로 이루어집니다. 파일을 연다는 것은 특정 파일을 지정하여 그 파일에 접근할 수 있는 통로의 문을 여는 것으로 이해 할 수 있습니다. 워드나 편집기 프로그램과 다른것은 파일을 연다는 것이 여기서는 파일의 내용을 읽는것이 아니라는 것입니다. 파일을 닫는것은 이제 그 파일에 접근할 필요가 없으므로 그 통로를 닫는다는 것으로 이해 할 수 있습니다. 파일을 지우거나 고치거나 하지 않습니다.\nJulia 에서 파일을 열고 닫는 방법은 보통 두가지가 많이 쓰입니다. 하나는 open() 함수로 명시적으로 열고 close() 함수로 명시적으로 닫는 것입니다. 예를 들어 앞의 pathes.jl 파일의 절대경로가 /Users/juliano/pathes.jl 라고 하면 다음과 같이 합니다. 현재 디렉토리(pwd() 명령어로 확인할 수 있습니다) 에 대한 상대경로를 사용할 수도 있습니다.\nf = open(\"/Users/juliano/pathes.jl\")\n    # f 를 이용하여 일을 한다.\nclose(f)\n나머지 하나는 do 블럭을 이용하는 것입니다. 이 방법은 close() 함수를 명시적으로 호출할 필요가 없습니다.\nopen(\"/Users/juliano/pathes.jl\") do f\n    # f 를 이용하여 일을 한다.\nend\n\n\n\n파일 접근 모드\n파일을 열 때는 몇가지 모드가 있으며 open 함수의 두번째 인자로 전달되거나 키워드 인자로 전달됩니다. 어떤 모드도 지정되지 않았다면 \"r\" 모드입니다. 아래의 표는 가능한 모드들입니다. 아래의 표에서 [truncate] 는 기존의 파일이 있다면 그 파일의 내용을 지우고 빈 파일로 만든다는 의미입니다. 따라서 파일이 지워져서는 안되는 파일이라면 미리 확인해야 합니다.(ispath(), 나 isfile() 함수로 확인 할 수 있습니다.) [새로 만들기] 는 지정된 경로에 파일이 없다면 파일을 새로 만든다는 뜻입니다. [새로 만들기] 모드가 없고 지정된 경로에 파일이 없다면 에러가 발생합니다. [덧붙이기] 는 기존의 파일을 유지하면서 기존 파일의 끝부터 내용을 쓴다는 의미입니다.\n\n\n\n표 2: 파일 접근 모드\n\n\n\n\n\n\n\n\n\n\n모드\n키워드 인자\n설명\n\n\n\n\n\"r\"\n\n읽기\n\n\n\"w\"\nwrite = true\n쓰기, 새로 만들기, 제거하기\n\n\n\"a\"\nappend = true\n쓰기, 새로 만들기, 덧붙이기\n\n\n\"r+\"\nread = true, write = true\n읽기, 쓰기\n\n\n\"w+\"\ntruncate = true, read = true\n읽기, 쓰기, 새로 만들기, 제거하기\n\n\n\"a+\"\nappend = true, read = true\n읽기, 쓰기, 새로 만들기, 덧붙이기\n\n\n\n\n\n\n\n다음의 명령어는 동일합니다.\nopen(\"/Users/juliano/pathes.jl\")\nopen(\"/Users/juliano/pathes.jl\", \"r\")\n아래의 두 명령어도 동일합니다.\nopen(\"/Users/juliano/pathes/jl\", \"w\")\nopen(\"/Users/juliano/pathes/jl\"; write = true)\n\n\n\n파일 읽기\n앞에서 open 파일은 실제로 파일에서 내용을 읽지 않는다고 언급했습니다. 파일을 열게 되면 IOStream 객체가 생성 됩니다. 이 객체에 대한 정보는 stat() 함수를 통해 얻을 수 있습니다. IOStream 객체는 바이트별로 데이터를 처리할 수 있으며 현재의 위치를 기억합니다. 현재의 위치는 position() 함수를 통해 알 수 있으며, 파일을 읽거나 쓰면 그만큼 현재의 위치가 이동합니다. 위치는 사용자가 바이트 단위로 옮길 수가 있는데 0 이 시작위치이며 끝 위치는 filesize() 함수로 얻을 수 있습니다.\nIn [1]: f1=open(\"pathes.jl\")\nOut[1]: IOStream(&lt;file pathes.jl&gt;)\n\nIn [2]: stat(f1)\nOut[2]: StatStruct for RawFD(20)\n   size: 93 bytes\n device: 16777220\n  inode: 49833799\n   mode: 0o100755 (-rwxr-xr-x)\n  nlink: 1\n    uid: 501 (jiyong)\n    gid: 20 (staff)\n   rdev: 0\n  blksz: 4096\n blocks: 8\n  mtime: 2023-12-04T18:11:59+0900 (19 hours ago)\n  ctime: 2023-12-04T18:11:59+0900 (19 hours ago)\n\nIn [3]: position(f1)\nOut[3]: 0\n\nIn [4]: read(f1, 3)\nOut[4]: 3-element Vector{UInt8}:\n 0x23\n 0x21\n 0x20\n\nIn [5]: position(f1)\nOut[5]: 3\n\nIn [6]: seek(f1, 0)\nOut[6]: IOStream(&lt;file pathes.jl&gt;)\n\nIn [7]: position(f1)\nOut[7]: 0\n파일에서 내용을 읽는 것은 read(), readline(), readlines() 함수를 이용합니다. read() 함수는 현재의 위치부터 인자로 전달되는 바이트 수 만큼을 읽고 Vector{UInt8} 로 반환합니다. 인자가 없다면 현재의 위치부터 끝까지 읽습니다. readline() 함수는 현재의 위치부터 다음 개행문자까지 읽고 문자열로 반환합니다. readlines() 함수는 현재의 위치부터 끝까지 읽고, 개행문자로 분할하여 문자열의 1차원 배열로 반환합니다. 개행문자는 일반 아스키나 유니코드 텍스트 파일에서 줄바꿈을 나타내는 문자이며 운영체제마다 다르지만 지금 사용하는 함수에서는 알아서 구분하여 분할해 줍니다.\n\n그런데 위의 세 함수 read, readline, readlines 는 open 함수를 통해 파일에 접근하는 IOStream 객체를 만들지 않고 직접 파일 이름을 첫번째 인자로 입력하여 똑같은 일을 할 수 있습니다. 차이가 있다면 IOStream 을 통해 접근하면 파일에서의 현재위치(position 함수로 알 수 있는)가 유지되는 반면에 read 함수 등으로 직접 접근하면 함수를 호출할 때마다 파일의 현재위치가 초기화 된다는 것입니다.\n\n\n텍스트 파일 읽고 쓰기\n이제 실제로 읽고 써 봅시다. 다음의 내용을 담은 파일을 기록한다고 해 봅시다.\n# 실험자 : 홍길동\n# 실험 일시 : 2023년 12월 10일\n# 데이터\n\n10\n4\n7\n6\n33\n5\n2\n하나의 문자열로 만든 다음에 통째로 data1.txt 파일로 적겠습니다. 현재 디렉토리가 파일로 저장하고자 하는 디렉토리라고 하고 상대경로를 사용하겠습니다.\nIn [1]: p=\"\"\"\n        # 실험자 : 홍길동\n        # 실험 일시 : 2023년 12월 10일\n        # 데이터\n\n        10\n        4\n        7\n        6\n        33\n        5\n        2\"\"\"\nOut[1]: \"# 실험자 : 홍길동\\n# 실험 일시 : 2023년 12월 10일\\n# 데이터\\n\\n10\\n4\\n7\\n6\\n33\\n5\\n2\"\n\nIn [2]: open(\"data1.txt\", \"w\") do f\n        f.write(p)\n        end\n이제 data1.txt 에 위의 내용이 기록되어 있음을 확인 할 수 있을 것입니다. 이제 이 파일을 읽고 처리하도록 하겠습니다. 가장 쉬운 방법은 readlines()로 통째로 줄 단위로 읽는 것입니다. 파일 전체를 읽을 것이므로 readlines() 함수를 통해 읽겠습니다.\nIn [1]: p = readlines(\"data1.txt\")\nOut[1]: 11-element Vector{String}:\n \"# 실험자 : 홍길동\"\n \"# 실험 일시 : 2023년 12월 10일\"\n \"# 데이터\"\n \"\"\n \"10\"\n \"4\"\n \"7\"\n \"6\"\n \"33\"\n \"5\"\n \"2\"\n문자열의 베열을 얻었으며, 빈 줄 역시 \"\" 로 표현됩니다. 네번째 줄부터 데이터이므로 이것을 정수의 배열로 바꾸겠습니다. parse(T, x) 는 값 x 를 타입 T 로 변경해주는 함수입니다.\nIn [11]: data = [parse(Int64, x) for x in p[5:end]]\nOut[11]: 7-element Vector{Int64}:\n 10\n  4\n  7\n  6\n 33\n  5\n  2\n\n\n\n이진 파일 읽고 쓰기\n텍스트 파일과 이진 파일은 파일 자체로는 본질적으로 차이가 없고 읽을 때 개행문자를 어떻게 처리하는지의 차이가 있을 뿐입니다. 예를 들어 UInt8 타입의 정수 12개를 기록한다고 해 봅시다. 정수 하나가 1바이트이므로 총 8바이트를 기록하게 됩니다.\nIn [1]: p = collect(UInt8, 1:1:8)\nOut[1]: 8-element Vector{UInt8}:\n 0x01\n 0x02\n 0x03\n 0x04\n 0x05\n 0x06\n 0x07\n 0x08\n\nIn [2]: write(\"data2.bin\", p)\nOut[2]: 8\n\nIn [3]: read(\"data2.bin\")\nOut[3]: 8-element Vector{UInt8}:\n 0x01\n 0x02\n 0x03\n 0x04\n 0x05\n 0x06\n 0x07\n 0x08\n\n여기까지는 큰 문제가 없습니다. 만약 Float64 타입의 실수 4개를 기록한다고 합시다.\nIn [4]: nb = collect(Float64, 0.0:1.0:3.0)\nOut[4]: 4-element Vector{Float64}:\n 0.0\n 1.0\n 2.0\n 3.0\n\nIn [6]: write(\"data3.bin\", nb)\nOut[6]: 32\n\nIn [7]: read(\"data3.bin\")\nOut[7]: 32-element Vector{UInt8}:\n 0x00\n 0x00\n 0x00\n 0x00\n 0x00\n...\nFloat64 부동소수는 8바이트이므로 4개의 Float64 부동소수는 32 바이트를 차지합니다. 따라서 우리는 32 개의 UInt8 정수를 얻었으며 이것을 다시 Float64 로 변환해야 합니다. 대신에 데이터가 저장될 배열을 생성하고 read! 함수를 사용해 봅시다.\nIn [12]: v=Vector{Float64}(undef, 4);\n\nIn [13]: read!(\"data3.bin\", v)\nOut[13]: 4-element Vector{Float64}:\n 0.0\n 1.0\n 2.0\n 3.0\nv 는 읽어들일 데이터가 저장될 배열입니다. 데이터를 읽고 배열을 변경하기 때문에 julia 의 관례에 따라 함수 이름 끝에 ! 가 붙었습니다.\n\n지금까지 텍스트 파일과 이진 파일의 저수준 입출력에 관해 간단히 알아보았습니다. 텍스트 파일은 메모장이나 텍스트 편집기로 파일 내용을 읽고 쓸수 있다는 큰 장점이 있습니다. 이진파일은 그 내용을 보더라도 의미를 알기 힘듭니다. 그러나 큰 데이터를 저장할 때 텍스트 파일은 이진 파일보다 몇배의 공간을 차지하기 때문에 큰 데이터를 저장하는데 적합하지 않습니다.\n또하나 생각해야 할 것은 파일에 데이터 뿐만 아니라 데이터에 대한 다양한 정보(이를 메타데이터라고 합니다)까지 같이 저장하는 경우 어디서부터가 어떤 형식의 데이터인지를 정확히 알아야 하며 그것에 맞추어 코딩을 해야 하는데 이것이 때때로 매우 번거롭습니다. 하지만 이미 존재하는 많은 파일 형식들과 그것을 쉽게 읽고 쓸 수 있도록 해주는 많은 라이브러리들이 있습니다. 이제 이것을 알아봅시다.",
    "crumbs": [
      "Julia 언어 생태계",
      "파일시스템과 파일입출력"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/fileio.html#포맷이-정해진-파일의-입출력",
    "href": "src/ecosystem_of_julia/fileio.html#포맷이-정해진-파일의-입출력",
    "title": "파일시스템과 파일입출력",
    "section": "3 포맷이 정해진 파일의 입출력",
    "text": "3 포맷이 정해진 파일의 입출력\nJulia 에서 파일 입출력을 지원하는 FileIO.jl 패키지가 있습니다. 많은 파일 형식에 관한 입출력 함수는 이 패키지의 load 함수와 save 함수를 메소드 디스패치하여 지원됩니다. 예를 들어 아래에 설명될 CSV 파일을 읽기 위해서는 CSV.jl 패키지가 필요한데, 이 CSV.jl 패키지에서 파일 입출력은 FileIO.jl 패키지를 이용하여 구현되었다는 의미입니다. Registry table 에는 FileIO.jl 의 load/save 를 이용하여 읽고 쓸 수 있는 포맷들이 나열되어 있습니다.\n\nCSV\n데이터를 저장하는데 아주 많이 사용되는 포멧입니다. 아래와 같은 테이블을 생각합시다.\n\nFruit prices\n\n\nvalue1\nvalue2\nvalue3\n\n\n\n\n1\n3\n5\n\n\n4\n2\n7\n\n\n\n위의 테이블이 아래와 같은 문자열로 저장되는 것이 CSV 입니다.\nvalue1,value2,value3\n1,3,5\n4,2,7 \n텍스트 포멧이며 모든 값은 “,” 로 구분됩니다. CSV 의 이름 자체가 comma-separated values, 즉 콤마로 구분되는 값들 이라는 의미입니다. 보통은 주 데이터 뿐만 아니라 주 데이터에 대한 설명을 포함합니다. 가장 간단한 방법은 CSV.jl 패키지를 사용하는 것입니다. 링크된 홈페이지에 자세히 설명이 되어 있습니다.\n\n\n\nHDF5\nHDF5 는 단순히 하나 혹은 유사한 데이터의 나열이 아니라 구조적이고 거대한 데이터를 저장하는데 목적을 둔 데이터 포맷입니다. Julia 의 사전 자료형을 생각하면 됩니다. HDF5.jl 을 참고하시기 바랍니다. C/C++ 을 비롯한 많은 언어에서 HDF5 파일을 읽고 쓸 수 있게 해 주는 라이브러리를 지원합니다. 다양한 언어에서 사용할 구조화된 대용량 데이터 포맷으로는 가장 적합합니다.\n\n\n\nJLD2\nHDF5 와 유사하지만 Julia 에서 사용하기 훨씬 편하며 다른 언어에서는 거의 사용할 수 없습니다. Julia 언어 내부에서만 사용할 경우에는 이 포맷이 좋습니다. JLD2.jl 를 참고하시기 바랍니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "파일시스템과 파일입출력"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/makie.html",
    "href": "src/ecosystem_of_julia/makie.html",
    "title": "Makie 로 Plotting",
    "section": "",
    "text": "Jupyter 혹은 vscode notebook 을 사용하여 그래프를 그리거나 혹은 julia script 로 그래프를 파일로 저장할 수 있는 패키지는 여러가지가 있으며, 대표적으로 Plots 와 Makie\\(^1\\), Python 의 matplotlib 을 그대로 쓰게 해주는 PyPlot.jl 가 있다. 여기서는 Makie 를 소개한다.\\(^1\\) Makie.jl 의 공식 홈페이지에 따르면 Mah-kee 로 발음한다고 하며 어원은 일본의 마키에(蒔絵, まきえ) 이다.",
    "crumbs": [
      "Julia 언어 생태계",
      "Makie 로 Plotting"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/makie.html#julia-언어의-plotting-패키지",
    "href": "src/ecosystem_of_julia/makie.html#julia-언어의-plotting-패키지",
    "title": "Makie 로 Plotting",
    "section": "",
    "text": "Jupyter 혹은 vscode notebook 을 사용하여 그래프를 그리거나 혹은 julia script 로 그래프를 파일로 저장할 수 있는 패키지는 여러가지가 있으며, 대표적으로 Plots 와 Makie\\(^1\\), Python 의 matplotlib 을 그대로 쓰게 해주는 PyPlot.jl 가 있다. 여기서는 Makie 를 소개한다.\\(^1\\) Makie.jl 의 공식 홈페이지에 따르면 Mah-kee 로 발음한다고 하며 어원은 일본의 마키에(蒔絵, まきえ) 이다.",
    "crumbs": [
      "Julia 언어 생태계",
      "Makie 로 Plotting"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/makie.html#backends",
    "href": "src/ecosystem_of_julia/makie.html#backends",
    "title": "Makie 로 Plotting",
    "section": "2 Backends",
    "text": "2 Backends\n정확히 말하면 Makie 는 프론트엔드로서 플로팅에 대한 여러가지 내부적인 기능을 가지고 있으며, 실제 그래프가 보여지는 것은 백엔드를 통해서이다. 물론 어떤 기능은 특정한 백엔드에서만 가능하다. 2024년 6월 현재 Makie 는 4가지 백엔드가 존재한다.\n\n\n\n\n\n\n\nPackage\nDescription\n\n\n\n\nGLMakie.jl\n독립적인 윈도우에서 플로팅되며 GPU-기반의 대화형(interactive) 2D, 3D 플로팅에 사용된다.\n\n\nCairoMakie.jl\nCairo.jl 기반의 비대화형(non-interactive) 2D, 3D 플로팅에 사용된다.\n\n\nWGLMakie.jl\nWebGL 기반의 대화형 2D, 3D 플로팅에 사용되며 웹브라우저로 플로팅한다.\n\n\nRPRMakie.jl\n실험적인 ray-tracing 패키지\n\n\n\nWGLMakie.jl 과 RPRMakie.jl 은 아직은 불안정하므로 CairoMakie.jl 이나 GLMakie.jl 을 사용하는 것을 추천한다. 보통 상호작용이 필요할 때는 GLMakie.jl 을 그렇지 않고 고품질의(publication quality) 의 정적인 플로팅을 원할때는 CairoMakie.jl 을 사용한다.",
    "crumbs": [
      "Julia 언어 생태계",
      "Makie 로 Plotting"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/makie.html#cairomakie",
    "href": "src/ecosystem_of_julia/makie.html#cairomakie",
    "title": "Makie 로 Plotting",
    "section": "3 CairoMakie",
    "text": "3 CairoMakie\nJulia REPL 에서 ]add CairoMakie 로 설치한다. Makie.jl 이 설치가 안되었다면 자동으로 설치해준다. Jupyter 환경이나 Pluto 환경에서는 자동적으로 그 환경에서 출력해준다. 가장 간단한 플로팅을 해 보자.\nt = 1:0.1:(4*π)\nlines(t, cos.(t))\n\n\n\n\n\n\n그림 1: Makie Plot 1\n\n\n\nlines 함수는 위의 그림과 같이 선 그래프를 만든다. 다음을 보자.\nt = 1:0.1:(4*π)\nfig, ax, ls = lines(t, cos.(t))\nlines!(ax, t, sin.(t))\nfig\n\n\n\n\n\n\n그림 2: Makie Plot 2\n\n\n\nfig, ax, ls = lines(t, cos.(t)) 에서 fig 는 Figure 타입, ax 는 Axis 타입, ls 는 Lines 타입의 객체이다. Figure 는 우리가 그리고자 하는 전체 그림을 표현한다. Axis 는 우리가 그래프를 그리는 좌표계와 그 좌표계에서 출력되는 선, 도형, 숫자들을 의미한다. Lines 는 우리가 그린 선 그래프의 선을 의미한다. 이 때 Axis 는 Figure 에 포함되어 있으며, Lines 는 Axis 에 포함된다.\nlines!(ax, t, sin.(t)) 를 보자. 앞서 여러번 설명했듯이 Julia 는 관례적으로 어떤 함수가 변수로 입력되는 인스턴스를 변경한다면 함수 이름 끝에 ! 를 붙인다. 이 명령어는 앞의 fig, ax, ls = lines(t, cos.(t)) 로 만들어진 ax 객체를 변경하기 때문에 ! 를 붙였다. 앞서 만들어진 Axis 인스턴스 ax 에 새로은 선그래프를 추가한다. 마지막줄은 fig 를 출력하라는 의미이다. 마지막줄이 없다면 그림이 만들어지긴 하지만 출력되지는 않는다.\n\n이제 좀 더 그럴듯한 그림을 그려보자.\nusing LaTeXStrings\nt=0.0:0.5:25.0\ndata = 4.0 .* exp.(-0.4 .* t) .+ (rand(length(t)) .- 0.5)\nfig = Figure()\nax = Axis(fig[1, 1],\n    title = \"Exponential Decay and Fit\",\n    xlabel = \"Time [Arb. Unit]\",\n    ylabel = \"Value\",\n)\nscatter!(\n    ax,\n    t,\n    data,\n    color = :tomato,\n    label = \"Measurements\"\n)\nlines!(\n    ax,\n    t,\n    4.0 .* exp.(-0.4 .* t),\n    color = :blue,\n    linestyle = :dash,\n    label = L\"f(x) = \\exp(-0.4 t)\",\n)\naxislegend(position = :rt)\nfig\n\n\n\n\n\n\n그림 3: Makie Plot 3\n\n\n\nfig = Figure() 는 Figure 객체를 생성하여 fig 변수에 할당한다. ax 는 Axis 인스턴스로 맨 앞의 fig[1, 1] 은 그림에 포함되는 여러 부분 가운데 첫번째라는 의미이다. 각 Axis 마다 title, xlabel, ylabel 등을 지정 할 수 있다. 그 다음의 scatter! 나 lines! 명령어는 Scatter 그래프와 선그래프를 그리라는 명령어이며, axislegend 함수는 각 그래프의 label 과 모양을 표시하라는 의미아다. position=:rt 는 위치를 Axis 의 오른쪽(right) 위(top) 에 표현하라는 의미이다.",
    "crumbs": [
      "Julia 언어 생태계",
      "Makie 로 Plotting"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/pkg_dev.html",
    "href": "src/ecosystem_of_julia/pkg_dev.html",
    "title": "패키지 개발",
    "section": "",
    "text": "우리는 이미 Pkg.jl 을 통해 패키지를 설치, 제거하거나 업데이트 하는 것을 알고 있습니다. Pkg.jl 은 이것 뿐만 아니라 패키지 개발에 필요한 환경(environment) 를 설정하고 제어 할 수 있도록 해 줍니다. 여기서는 당신이 어떤 julia 패키지를 개발하며 그것을 github 에 올려놓고 관리한다는 것을 가정합니다. github 사용법을 자세히 다루지 않으며, 당신이 이미 github 계정을 가지고 있다는 것을 가정합니다.\n환경이란 julia 에서 제공하는 별도의 실행 공간이라고 생각할 수 있습니다. 각 환경은 julia 인터프리터와 기본 설치되는 패키지만을 공유합니다. 각 환경마다 별도의 패키지를 설치 할 수 있으며 각 환경마다의 출입이 자유롭습니다. 두개의 환경을 동시에 사용하지는 못합니다. 보통은 당신이 패키지를 개발 할 때 패키지마다 하나의 환경을 만들어서 개발합니다. 새로운 디렉토리와 환경을 만들고 관리하는데 필요한 작은 파일들로 인해 당신의 하드디스크를 약간 소비하지만 충분한 이점이 있습니다. 환경과 더불어 중요한 용어가 의존성(dependency) 입니다. 당신이 패키지를 개발하는데 필요한 julia 자체와 julia 의 다른 패키지, 그리고 각각의 버젼을 합쳐서 의존성이라고 합니다.\n새로운 패키지를 개발한다면 github 에 리포지터리를 생성합니다. 리포지터리 이름은 당신이 만들고자 하는 패키지 이름 + “.jl” 로 합니다. 예를 들어 MyAwesomePackage.jl 같은 이름을 사용 할 수 있습니다. 여기서는 NAJ.jl 로 합니다. 간단하게 readme.md 파일을 작성할 수도 있습니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "패키지 개발"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/pkg_dev.html#시작하기",
    "href": "src/ecosystem_of_julia/pkg_dev.html#시작하기",
    "title": "패키지 개발",
    "section": "1 시작하기",
    "text": "1 시작하기\n이제 터미널에서 NAJ.jl 를 시작할 디렉토리에 들어갑니다. 예를 들어 Users\\myacc\\Project 디렉토리에 NAJ.jl 디렉토리를 만들고 이 디렉토리에서 패키지를 만들고 싶다면 Users\\myacc\\Project 로 이동합니다. 그리고 julia REPL 을 실행시키고 ] 키를 통해 pkg 모드에 진입합니다.\n(@v1.10) pkg&gt;\n이제 패키지를 초기화 합니다.\n(@v1.10) pkg&gt; generate NAJ.jl\n  Generating  project NAJ:\n    NAJ.jl/Project.toml\n    NAJ.jl/src/NAJ.jl\nNAJ.jl 디렉토리가 생겼고 그 디렉토리 밑에 Project.toml 파일과 src 디렉토리가 생겼으며, src 디렉토리 밑에 NAJ.jl 파일이 생겼습니다. Project.toml 파일은 프로젝트의 정보와 설정을 담는 파일이고, 패키지 이름과 같은 NAJ.jl 파일은 패키지의 julia 코드를 저장합니다.\njulia 에는 현재 작업 디렉토리라는 개념이 있습니다. julia 인터프리터의 경우 인터프리터를 시작할 때 별도로 지정하지 않았아면 julia 인터프리터를 실행한 디렉토리입니다. julia 인터프리터에서 pwd() 함수로 확인 할 수 있으며, cd() 함수를 통해 현재 작업 디렉토리를 이동 할 수 있습니다. NAJ.jl 로 이동합니다.\nIn [1]: cd(\"NAJ.jl\")\n\nIn [2]: pwd()\nOut[2]: \"/Users/jiyong/development/Projects/NAJ.jl\"\n이제 터미널로 나갑니다. 이제 NAJ.jl 디렉토리와 git 저장소를 동기화합니다.\ngit init\ngit remote add origin https://github.com/Julia-KAERI/NAJ.jl.git\n현재 저장소는 비어 있으므로 이미 존재하는 파일과 디렉토리를 업로드합니다. 브랜치 이름은 main 이나 master 일 것입니다. 터미널에서 git status 명령어로 확인합니다.\ngit add .\ngit commit -m \"first_upload\"\ngit push origin main # main 혹은 master \n여기까지 별 문제가 없었다면 준비가 다 된 것입니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "패키지 개발"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/pkg_dev.html#활성화",
    "href": "src/ecosystem_of_julia/pkg_dev.html#활성화",
    "title": "패키지 개발",
    "section": "2 활성화",
    "text": "2 활성화\nJulia 인터프리터의 pkg 모드에서 activate . 명령은 현재 디렉토리의 환경을 활성화 하라는 명령입니다.\n(@v1.10) pkg&gt; activate .\n  Activating new project at `~/development/Projects/NAJ.jl`\n\n(NAJ.jl) pkg&gt;\n프롬프트가 (NAJ.jl) 로 바뀌었습니다. 즉 여러분의 환경이 변했습니다. activate 만 치면 기본 환경, 즉 julia 가 처음 설치되었을때의 환경으로 돌아갑니다. 실행 후 입력 프롬프트에서 환경을 확인 할 수 잇습니다.\n(NAJ.jl) pkg&gt; activate\n  Activating project at `~/.julia/environments/v1.10`\n(@v1.10) pkg&gt;\n현재까지 당신의 NAJ.jl 디렉토리는 패키지 생성에서 만든 파일, 디렉토리와 github 에서 사용하는 .git 디렉토리를 제외하면 비어있습니다.\nIn [2]: readdir()\nOut[2]: 3-element Vector{String}:\n \".git\"\n \"Project.toml\"\n \"src\"\n환경을 활성화 하는 방법은 REPL 에서 using Pkg 로 Pkg 를 임포트 한후 activate 함수를 사용하는 방법도 있습니다. activate 함수의 인자로는 환경이 설치된 경로가 필요합니다.\nusing Pkg\nPkg.activate(\"~/development/Projects/NAJ.jl\")\nPkg.status() 함수나 pkg 모드의 status 명령어로 현재의 환경을 확인 할 수 있습니다.\nIn [4]: Pkg.status()\nProject NAJ v0.1.0\nStatus `~/development/Projects/NAJ.jl/Project.toml` (empty project)",
    "crumbs": [
      "Julia 언어 생태계",
      "패키지 개발"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/pkg_dev.html#패키지-추가",
    "href": "src/ecosystem_of_julia/pkg_dev.html#패키지-추가",
    "title": "패키지 개발",
    "section": "3 패키지 추가",
    "text": "3 패키지 추가\n당신이 패키지를 개발하는 데 필요한 외부 패키지를 하나 추가해 봅시다. 쉽게 삭제 할 수 있으니 걱정하지 않아도 됩니다. 아직 생각나지 않는다면 Example 패키지를 추가해 봅시다.\n(NAJ) pkg&gt; add Example\n   Resolving package versions...\n    Updating `~/development/Projects/NAJ.jl/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `~/development/Projects/NAJ.jl/Manifest.toml`\n  [7876af07] + Example v0.5.3\nPrecompiling project...\n  1 dependency successfully precompiled in 2 seconds. 1 already precompiled.\n이제 패키지 폴더에 Manifest.toml 파일이 추가되었으며 Pkg.status() 함수를 통해 패키지가 추가되었다는 것을 확인 할 수 있습니다.\nIn [8]: readdir()\nOut[8]: 3-element Vector{String}:\n \".git\"\n \"Manifest.toml\"\n \"Project.toml\"\n\nIn [9]: Pkg.status()\nStatus `~/development/Projects/NAJ.jl/Project.toml`\n  [7876af07] Example v0.5.3",
    "crumbs": [
      "Julia 언어 생태계",
      "패키지 개발"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/pkg_dev.html#project.toml-과-manifest.toml",
    "href": "src/ecosystem_of_julia/pkg_dev.html#project.toml-과-manifest.toml",
    "title": "패키지 개발",
    "section": "4 Project.toml 과 Manifest.toml",
    "text": "4 Project.toml 과 Manifest.toml\ntoml 은 설정을 간편하게 읽고 쓰게 해주는 파일 포멧이며 보통 .toml 확장자를 갖습니다. 텍스트 형식으로 저장하기 때문에 문서편집기에서 직접 편집 할 수 있습니다. 두 파일에 대해 간략히 요약하면 다음과 같습니다.\n\nProject.toml : 프로젝트 파일은 상위 수준에서 프로젝트를 설명합니다. 패키지 작성자 및 이름, 패키지 자체의 버전 정보 및 UUID, 의존성 및 호환성이 이 파일에 나열됩니다.\nManifest.toml : 환경 내의 패키지 상태에 대한 절대적인 기록입니다. 여기에는 프로젝트의 (직접 및 간접) 의존성에 대한 정확한 정보가 포함됩니다. 보통은 환경의 변경 및 패키지 설치/제거 에 따라 자동적으로 생성되며 사용자가 건드리지 않습니다.\n\nProject.toml 과 Manifest.toml 쌍이 주어지면 정확히 동일한 패키지 환경을 복원하거나 생성 할 수 있으며 이는 재현성에 매우 유용합니다. 자세한 내용은 Pkg.instantiate를 참조하기 바랍니다.\n이제 Project.toml 파일에 패키지 정보를 추가합시다. 우선 현재의 파일은 다음과 같을 것입니다.\nname = \"NAJ\"\nuuid = \"3a8672d3-a8d7-4fb7-80dc-526698d5a642\"\nauthors = [\"julia-KAERI &lt;julia.kaeri@gmail.com&gt;\"]\nversion = \"0.1.0\"\n\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nname 은 패키지 이름, authors 는 저자들 정보, versions 는 버젼 정보입니다. 버젼 정보는 .으로 이어진 세개의 수로 구성되며 보통 주버젼, 부버젼, 패치버젼을 말합니다. 보통 정식으로 배포되기전에는 주버젼을 0 으로 합니다. 현재는 초기 상태이므로 버젼이 “0.1.0” 입니다. uuid 는 범용 고유 식별자(universally unique identifier) 의 영어 약자로 여기서는 패키지마다 부여되는 고유한 번호라고 생각할 수 있습니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "패키지 개발"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/pkg_dev.html#패키지-메인-파일",
    "href": "src/ecosystem_of_julia/pkg_dev.html#패키지-메인-파일",
    "title": "패키지 개발",
    "section": "5 패키지 메인 파일",
    "text": "5 패키지 메인 파일\n여기서는 패키지 이름과 같은 NAJ.jl\" 이며src` 디렉토리에 있습니다. 템플릿으로 주어지는 내용은 다음과 같습니다.\nmodule NAJ\n\ngreet() = print(\"Hello World!\")\n\nend # module NAJ\n\n이제 여러분이 여기를 채워가면 됩니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "패키지 개발"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/unittest.html",
    "href": "src/ecosystem_of_julia/unittest.html",
    "title": "유닛테스트 : Test.jl",
    "section": "",
    "text": "유닛테스트(Unit test) 혹은 단위테스트는 작성한 함수의 실행 결과가 기대했던 것과 일치하는지 여부를 확인하는 것을 말합니다. 이를 위해 Test.jl 을 설치합니다.\n여기서는 유닛테스트의 기초적인 내용을 다룹니다. 자세한 내용은 Julia 공식 매뉴얼의 Unit Testing 을 참고하시기 바랍니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "유닛테스트 : Test.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/unittest.html#test-매크로를-사용한-유닛테스트",
    "href": "src/ecosystem_of_julia/unittest.html#test-매크로를-사용한-유닛테스트",
    "title": "유닛테스트 : Test.jl",
    "section": "1 @test 매크로를 사용한 유닛테스트",
    "text": "1 @test 매크로를 사용한 유닛테스트\n가장 간단한 단위테스트 입니다. 어떤 표현식 ex 에 대해 아래와 같은 네가지 방법으로 사용할 수 있습니다.\n@test ex\n@test f(args...) key=val ...\n@test ex broken=true\n@test ex skip=true\n\n\n1.1 @test\n@test 다음에 true 혹은 false 를 반환하는 표현식이 올 경우 true 이면 테스트를 통과한 것으로, false 이면 실패한 것으로 간주합니다.\nIn [1]: using Test\n\nIn [2]: @test 2+3 == 5\nOut[2]: Test Passed\n\nIn [3]: @test 3 == 5\nTest Failed at REPL[3]:1\n  Expression: 3 == 5\n   Evaluated: 3 == 5\n\nERROR: There was an error during testing\n\n\n\n1.2 @test f(args...) key=val ...\nisapprox(a, b; atol=1.0e-10) 함수는 norm(b-a) 가 atol 키워드 인자로 주어진 값보다 작으면 true 를 아니면 false 를 반환합니다. (isapprox 함수는 수 뿐만 아니라 배열에 대해서도 사용할 수 있으며 atol 이외의 키워드 인자도 입력 할 수 있습니다. Julia 에 포함된 공식 문서를 참고하시기 바랍니다.) 이 함수에 대해 다음과 같이 테스트 할 수 있습니다.\nIn [2]: @test isapprox(1.0e-7, 0.0, atol=1.0e-5)\nOut[2]: Test Passed\n\nIn [3]: @test isapprox(1.0e-7, 0.0) atol=1.0e-5\nOut[3]: Test Passed\n@test 다음에 함수가 올 때는 키워드 인자를 함수의 ( ) 안에 넣어도 되고 밖에 넣어도 됩니다.\n\n\n\n1.3 broken=true 혹은 broken=false 조건\n단위테스트에서는 어떤 표현식이 틀리거나 예외를 발생시키 것으로 함수의 기능을 확인해야 할 때가 있는데 이런 경우에 사용합니다. broken 인자는 true 이거나 false 이어야 합니다. broken=true 조건에서는 ex 표현식이 false 이거나 예외를 발생시킬 때 테스트를 통과한 것으로 간주합니다. broken=true 조건이라면 일반적인 @test ex 와 같습니다.\nIn [1]: @test [2, 3] + \"a\"  broken=true\nOut[1]: Test Broken\n  Expression: [2, 3] + \"a\"\n\nIn [2]: @test 3==4 broken=true\nOut[2]: Test Broken\n  Expression: 3 == 4\n\nIn [3]: @test 2+3==5 broken=false\nOut[3]: Test Passed\n\nIn [4]: @test 2+3==5 broken=true\nError During Test at REPL[15]:1\n Unexpected Pass\n Expression: 2 + 3 == 5\n Got correct result, please change to @test if no longer broken.\nIn [1] 의 경우 [2, 3] + \"a\" 는 예외를 발생시켜야 하는데 broken=true 조건으로 인해 테스트를 통과하게 됩니다. 일반적인 통과가 아니므로 출력 메시지가 Test Broken 이 됩니다. In [2] 의 경우 3==4 는 false 이므로 역시 broken test 를 통과합니다.\nIn [3] 에서 broken=false 를 주면 @test 와 동일하다는 것을 확인할 수 있습니다.\nIn [4] 에서는 표현식이 true 이며 broken=true 옵션이 주어지면 에러가 발생한다는 것을 보여줍니다.\n\n\n\n1.4 skip=true 혹은 skip=false 조건\n이 옵션은 주로 아직 구현되지 않은 함수에 대해 미리 테스트 구문을 만들어 놓을 때 사용합니다. skip=true 이면 무조건 Test Broken 을 리턴합니다. skip=false 이면 skip 옵션을 지정하지 않은것과 같습니다.\nIn [27]: @test 2==3 skip=true\nOut[27]: Test Broken\n  Skipped: 2 == 3\n\nIn [28]: @test 2==3 skip=true\nOut[28]: Test Broken\n  Skipped: 2 == 3",
    "crumbs": [
      "Julia 언어 생태계",
      "유닛테스트 : Test.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/unittest.html#test_throws",
    "href": "src/ecosystem_of_julia/unittest.html#test_throws",
    "title": "유닛테스트 : Test.jl",
    "section": "2 @test_throws",
    "text": "2 @test_throws\n@thest_throws exception expr 구문은 표현식 expr 이 실제로 예외 exception 을 발생시키는지를 확인합니다.\nIn [1]: f(x) = [x x+1 x+2]\nOut[1]: f (generic function with 1 method)\n\nIn [2]: @test_throws BoundsError f(3)[4]\nOut[2]: Test Passed\n      Thrown: BoundsError\n함수 f(x) 는 [x x+1 x+2] 라는 길이가 3인 배열을 반환하므로 f(3)[4] 는 BoundsError 를 발생시킵니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "유닛테스트 : Test.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/unittest.html#testset",
    "href": "src/ecosystem_of_julia/unittest.html#testset",
    "title": "유닛테스트 : Test.jl",
    "section": "3 @testset",
    "text": "3 @testset\n\n3.1 @testset\n아주 간단한 함수를 테스트하는 것이 아니라 어느 정도 규모가 있는 모듈이나 패키지를 테스트한다면 테스트 구문이 여러개 필요합니다. 일단 begin ... end 블록으로 처리 할 수 있을 것 같습니다. 아래의 예를 봅시다.\nIn [11]: begin\n         @test 2^2==4\n         @test 3+3==6\n         end\nOut[14]: Test Passed\n테스트가 통과했다는 메시지가 나옵니다. 만약 첫번째 테스트 구문을 통과하지 못한다면 어떻게 될지 확인해 봅시다.\nIn [12]: begin\n        @test 1+1==3\n        @test 3+3==6\n        end\nTest Failed at REPL[6]:2\n  Expression: 1 + 1 == 3\n   Evaluated: 2 == 3\nbegin, end 블록 안에 여러개의 @test 혹은 @test_throws 구문을 넣었을 때 중간에 테스트가 실패한다면 거기서 즉시 멈추고 이후의 테스트를 수행하지 않습니다. 위에서는 @test 1+1==3 에서 테스트가 실패했기 때문에 그 다음의 @test 3+3==6 을 수행하지 않았습니다.\n여러개의 테스트를 수행하며, 중간에 테스트를 실패하더라도 계속 수행하고, 최종적으로 성공한 테스트와 실패한 테스트에 대해 보고해주는 매크로가 @testset 매크로 입니다. 기본적으로 @testset 은 함수 내에 사용 되거나 @testset 이후의 begin ... end , for ... end, let ... end 블럭으로 사용됩니다.\n\n\n\n3.2 @testset 이름과 옵션\n@testset 매크로는 별도의 이름을 부여할 수 있습니다. 또한 옵션도 줄 수 있습니다.\nIn [19]: @testset \"Simple Test Set\" showtiming=true begin\n         @test 2^2==4\n         @test 3+3==6\n         end;\nTest Summary:   | Pass  Total  Time\nSimple Test Set |    2      2  0.0s\n@testset [테스트셋 이름] [옵션] begin ... end 형식으로 begin 과 end 사이에 @test, @test_throws 혹은 다른 @testset 구문이 들어 갈 수 있습니다. 즉 @testset 은 중첩 될 수 있습니다. [테스트셋 이름] 은 문자열 이며 생략 될 수 있습니다. [옵션] 은 아래의 세가지가 있으며 역시 생략 될 수 있습니다.\n\n\n\n표 1: @testset 옵션\n\n\n\n\n\n\n\n\n\n옵션\n설명\n\n\n\n\nverbose\ntrue 이면 중첩된 @testset 구문의 결과도 모두 보여줍니다. 기본값은 false 이며 이 경우 중첩된 @testset 이 모두 Pass 이면 결과를 보여주지 않습니다.\n\n\nshowtiming\ntrue 이면 테스트 수행 시간을 보여줍니다. 기본값은 true 입니다.\n\n\nfailfast\ntrue 이면 중간에 테스트가 실패할 경우 이후 테스트를 수행하지 않고 그때까지의 결과값을 반환합니다. 환경변수 JULIA_TEST_FAILFAST 를 통해 기본값을 설정 할 수 있으며 이 변수값이 설정되지 않았을 경우에는 기본값은 false 입니다.\n\n\n\n\n\n\n\n\n\n3.3 @testset for ... end\n@testset 에 for ... end 블럭을 결합한 것입니다. 아래와 같이 사용합니다.\nIn [24]: @testset for k ∈ 1:4\n         @test sin(-k*π) ≈ - sin(k*π)\n         @test cos(-k*π) ≈ cos(k*π)\n         end;\nTest Summary: | Pass  Total  Time\nk = 1         |    2      2  0.0s\nTest Summary: | Pass  Total  Time\nk = 2         |    2      2  0.0s\nTest Summary: | Pass  Total  Time\nk = 3         |    2      2  0.0s\nTest Summary: | Pass  Total  Time\nk = 4         |    2      2  0.0s\n여기서 ≈ 는 주어진 부동소수의 오차 내에서 일치하는지에 대한 연산자로 내부적으로 isapprox 함수를 사용합니다.\n\n\n\n3.4 @testset let ... end\n임시로 함수나 변수를 정하여 사용할 수 있습니다.\nIn [25]: @testset let logi = log(im)\n         @test imag(logi) == π/2\n         @test !iszero(real(logi))\n         end;\nTest Failed at REPL[25]:3\n  Expression: !(iszero(real(logi)))\n     Context: logi = 0.0 + 1.5707963267948966im\n\nERROR: There was an error during testing",
    "crumbs": [
      "Julia 언어 생태계",
      "유닛테스트 : Test.jl"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html",
    "href": "src/introduction_to_julia/01_julia_language.html",
    "title": "설치와 환경 구성",
    "section": "",
    "text": "다운로드 페이지 에서 다운받을 수도 있고, 맥 OSX 의 경우에는 homebrew, Ubuntu Linux 의 경우에는 apt 같은 운영체제별 패키지 관리자를 이용하여 설치할 수도 있습니다만 Julia 는 공식적으로는 다운로드 페이지에서 다운로드 받아서 설치하거나 juliaup 이라는 패키지를 이용할 것을 권합니다. 설치가 완료된 후 터미널에서 julia 명령을 수행하면 다음과 같은 화면을 볼 수 있을 것입니다.\n\n\n\n\n\n\n그림 1: Julia REPL screenshot\n\n\n\n위의 화면이 보인다면 julia 가 정상적으로 설치 된 것입니다. Julia 언어를 사용하는 방법은 크게 두가지가 있습니다. 하나는 REPL 이라고 불리는 상호작용을 통해 코드의 전체 혹은 일부를 수행하고 결과를 보는 방법이고 다른 하나는 전체 julia 코드를 한번에 수행하는 방법입니다.\n\n\n위의 스크린샷과 같이 julia&gt; 옆에 무언가를 치면 그대로 입력됩니다. 예를 들어 3+3 을 계산하고 싶으면 3+3 을 치고 엔터키를 누르면 그 결과가 출력됩니다.\njulia&gt; 3+3\n6\n이렇게 입력을 기다리다가 입력이 되면 읽어서(Read), 그 값을 평가하고(Evaluation), 그 결과를 출력하는(Printing) 것을 계속 반복하게(Loop) 하게 됩니다. 이것을 영어 단어의 첫글자만 따서 REPL 이라고 합니다. Julia 언어의 기본적인 상호작용은 터미널에서 REPL 을 수행하는 것입니다. 별도의 다른 프로그램이 필요하지 않고, 간단한 계산을 할 때 가장 빠르다는 장점이 있지만 긴 코드를 짤 때 불편하며, 그래프를 출력하는데 많은 제한이 있습니다. 그래서 보통은 다른 환경에서 julia 를 수행합니다. 대표적으로 Jupyter notebook/lab이나 Visual Studio Code 가 있습니다.\n\n\n\n\n기본적으로 julia REPL 의 프롬프트는 julia&gt; 이지만 개인적으로\nIn [1]: 5 + 3\nOut[1]: 8\n와 같은 방식을 선호하기 때문에 위와 같은 방식을 사용합니다. Julia 공식 메뉴얼의 Numbered Prompt 대로 고치면 이렇게 사용 할 수 있습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "설치와 환경 구성"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#julia-설치",
    "href": "src/introduction_to_julia/01_julia_language.html#julia-설치",
    "title": "설치와 환경 구성",
    "section": "",
    "text": "다운로드 페이지 에서 다운받을 수도 있고, 맥 OSX 의 경우에는 homebrew, Ubuntu Linux 의 경우에는 apt 같은 운영체제별 패키지 관리자를 이용하여 설치할 수도 있습니다만 Julia 는 공식적으로는 다운로드 페이지에서 다운로드 받아서 설치하거나 juliaup 이라는 패키지를 이용할 것을 권합니다. 설치가 완료된 후 터미널에서 julia 명령을 수행하면 다음과 같은 화면을 볼 수 있을 것입니다.\n\n\n\n\n\n\n그림 1: Julia REPL screenshot\n\n\n\n위의 화면이 보인다면 julia 가 정상적으로 설치 된 것입니다. Julia 언어를 사용하는 방법은 크게 두가지가 있습니다. 하나는 REPL 이라고 불리는 상호작용을 통해 코드의 전체 혹은 일부를 수행하고 결과를 보는 방법이고 다른 하나는 전체 julia 코드를 한번에 수행하는 방법입니다.\n\n\n위의 스크린샷과 같이 julia&gt; 옆에 무언가를 치면 그대로 입력됩니다. 예를 들어 3+3 을 계산하고 싶으면 3+3 을 치고 엔터키를 누르면 그 결과가 출력됩니다.\njulia&gt; 3+3\n6\n이렇게 입력을 기다리다가 입력이 되면 읽어서(Read), 그 값을 평가하고(Evaluation), 그 결과를 출력하는(Printing) 것을 계속 반복하게(Loop) 하게 됩니다. 이것을 영어 단어의 첫글자만 따서 REPL 이라고 합니다. Julia 언어의 기본적인 상호작용은 터미널에서 REPL 을 수행하는 것입니다. 별도의 다른 프로그램이 필요하지 않고, 간단한 계산을 할 때 가장 빠르다는 장점이 있지만 긴 코드를 짤 때 불편하며, 그래프를 출력하는데 많은 제한이 있습니다. 그래서 보통은 다른 환경에서 julia 를 수행합니다. 대표적으로 Jupyter notebook/lab이나 Visual Studio Code 가 있습니다.\n\n\n\n\n기본적으로 julia REPL 의 프롬프트는 julia&gt; 이지만 개인적으로\nIn [1]: 5 + 3\nOut[1]: 8\n와 같은 방식을 선호하기 때문에 위와 같은 방식을 사용합니다. Julia 공식 메뉴얼의 Numbered Prompt 대로 고치면 이렇게 사용 할 수 있습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "설치와 환경 구성"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#개발환경-설정에-관해",
    "href": "src/introduction_to_julia/01_julia_language.html#개발환경-설정에-관해",
    "title": "설치와 환경 구성",
    "section": "2 개발환경 설정에 관해",
    "text": "2 개발환경 설정에 관해\nJulia 의 개발 환경은 많은 선택지가 있습니다. Python 에서 많이 사용하는 jupyter notebook 을 사용할 수도 있으며, emacs, vim, atom, vscode 와 같은 다양한 편집기를 사용할 수도 있습니다. 개인적으로 Microsoft 사에서 제공하는 텍스트 편집기 겸 통합개발환경인 Visual Studio code (vscode) 를 사용하는 개발환경을 추천합니다. vscode 에서의 julia 지원 페이지 대로 따라 하면 julia 개발 환경을 구성 할 수 있습니다.\n저는 짧은 코드를 계속 입력하면서 결과를 확인하는 작업을 많이 할때는 vscode 의 jupyter 환경을 주로 사용하며, 긴 코드를 사용할 때는 vscode 와 Julia 언어 지원을 사용합니다. Jupyter 에 익숙하지 않다면 단순히 julia 지원만을 사용하는 것도 좋은 방법입니다. 여기에서도 줄단위, 블럭단위, 파일단위로 실행시켜 볼 수 있습니다. 그 이외에도 저는 사용해 본 적이 없지만 Pluto.jl 도 있습니다. 검색창에서 julia 개발 환경 을 검색하면 많은 내용이 나옵니다. 그 중에 여러분의 입맞에 맡는 것을 선택하면 됩니다. 여기에서는 짧은 코드는 Julia REPL 을 바탕으로 설명하겠지만 다른 개발 환경에서도 거의 그대로 결과가 나올 것입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "설치와 환경 구성"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#기본-제공-문서",
    "href": "src/introduction_to_julia/01_julia_language.html#기본-제공-문서",
    "title": "설치와 환경 구성",
    "section": "3 기본 제공 문서",
    "text": "3 기본 제공 문서\n영어로 되어 있는 Julia 에 포함된 기본 도움말은 매우 훌륭합니다\\(^\\ast\\). Julia REPL 에서는 julia&gt; 프롬프트에 ? 를 치면 help&gt;로 변경되는 것을 볼 수 있을 것입니다. 여기에 함수 이름이라든가, 타입 이름 같은 것을 치면 그에 대한 도움말을 제공합니다. Jupyter 에서는 입력 셀에 ?sin 과 같이 ? 를 맨 앞에 두고 입력한후 실행하면 문서를 찾아 제공합니다. vscode 에서는 자동적으로 팝업 윈도우로 제공합니다만 2023년 12월 현재로서는 완전하지 않습니다. 이렇게 제공되는 문서는 당신이 사용하는 Julia 와 페키지에 대한 공식 문서이므로, 가장 믿을만하고 우선적으로 참고해야하는 문서가 되겠습니다.\\(^\\ast\\) 이 도움말은 별도로 제공되는 것이 아니라 소스코드에 주석으로 포함되어 있습니다.\nJulia 언어에 기본적으로 포함되어있는 함수, 모듈들 이외에 많은 모듈을 설치하게 될텐데 그 모듈들도 대부분 똑같은 형식의 도움말을 제공합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "설치와 환경 구성"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#sec-unicode_support",
    "href": "src/introduction_to_julia/01_julia_language.html#sec-unicode_support",
    "title": "설치와 환경 구성",
    "section": "4 유니코드 및 수학 기호 지원",
    "text": "4 유니코드 및 수학 기호 지원\nJulia 에서는 REPL 에서도 수학 기호를 포함한 다양한 문자를 입력하고 사용 할 수 있습니다. \\ 로 시작되는 구문을 입력한 후에 공백 없이 탭 키를 누르면 자동적으로 기호로 변환된됩니다. 예를 들어 Julia REPL(Julia 에서 지원하는 interactive command line 환경), jupyter notebook, vscode 에서 \\alpha 를 치고 곧바로 탭(tab) 키를 누르면 α 로 변환됩니다. 정확히 말하면 \\alp 정도 까지만 입력한 후 탭키를 눌러도 자동완성 기능으로 인해 \\alpha 가 다 입력된 후 α 로 변환된 것입니다. 이렇게 입력된 α 는 일반 알파벳과 같이 변수명으로도 사용 될 수 있습니다. 이 때 입력되는 구문은 LaTeX 와 같거나 유사한 경우가 많습니다. 주의할 것은 π(\\pi+[tab]) 와 ℯ(\\euler + [tab]) 는 특정 값이 지정되어 있는 대표적인 수학 기호입니다. pi 역시 원주율 입니다.\njulia&gt; π\nπ = 3.1415926535897...\n\njulia&gt; ℯ\nℯ = 2.7182818284590...\n\njulia&gt; pi\nπ = 3.1415926535897...\nJulia 에서 사용할 수 있는 유니코드 기호와 \\로 시작하여 탭 키를 눌러 완성되는 문자들은 julia 공식 문서의 Unicode Input 을 참고하시기 바랍니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "설치와 환경 구성"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#완벽한-초보를-위한-설치-가이드",
    "href": "src/introduction_to_julia/01_julia_language.html#완벽한-초보를-위한-설치-가이드",
    "title": "설치와 환경 구성",
    "section": "5 완벽한 초보를 위한 설치 가이드",
    "text": "5 완벽한 초보를 위한 설치 가이드\n만약 당신이 완벽한 초보자라면 아래의 방법을 따라 해 보시기 바랍니다.\n\nJulia 설치\nJulia 다운로드 페이지 에서 다운로드 받고 설치합니다. 윂페이지를 아래로 내리다 보면 크게 Official Binaries for Manual Download 라고 써 있고 거기에 최신 버젼(Current stable release) 을 다운로드 받을 수 있도록 해 놨습니다. 윈도우즈 계열의 OS 라면 시작 버튼을 눌렀을 때 나오는 프로그램 목록에서 Julia 를 실행 시킬 수 있으며 이 때 Julia REPL 그림 1 과 같이 실행됩니다.\n\n\n\nVisual Studio Code 설치\nVisual Studio Code (이하 vscode) 는 현재 전 세계에서 가장 많이 사용하는 텍스트 편집기로 Microsoft 사에서 제작하여 무료로 배포합니다.\nVS code 홈페이지 로 가면 운영체제에 따른 다운로드 버튼이 있습니다. 다운로드 후 실행하면 VS 코드가 설치됩니다. 이후 vscode 를 실행시키면 다음과 같은 화면이 뜨게 됩니다.\n\n\n\n\n\n\n\n그림 2: VS code 처음 시작 화면\n\n\n\n\n\nVS code 한글 설정\n시작화면의 맨 오른쪽의 바로가기 아이콘들중에 윗부분은 아래와 같은 기능을 합니다.\n\n\n\n\n\n\n그림 3: VS code 바로가기\n\n\n\n여기서 확장은 vs code 위에서 vs code 의 기능을 추가해주는 작은 프로그램과 자료들이라고 보면 됩니다. 우선 vscode 의 메뉴와 명령을 한글화해주는 한글팩을 설치합시다. 영어가 익숙하거나 편한 분들은 그대로 사용해도 됩니다. 확장 아이콘을 누르면 많이 사용하는 확장 프로그램의 긴 목록 위에 텍스트를 입력 할 수 있는 칸이 나옵니다. 여기에 korea 혹은 한국 을 입력하면 지구본 모양의 아이콘과 함께 Korean Language pack 이 리스트의 맨 위로 올 것이고 그 옆에 파란 바탕의 하얀 글씨로 Install 이라고 보일 것입니다. 여기서 Install 버튼을 누르면 설치가 시작됩니다. 설치가 종료되면 vscode 오른쪽 아래에 Change Language and Restart 버튼이 보일 것입니다. 이것을 누르면 VS code 가 종료 후 다시 실행되면서 메뉴와 설명의 많은 부분이 한글로 바뀝니다.\n\n\n\nJulia 확장 설치\n한글 설정 때와 같이 vscode 바로가기 에서 확장 아이콘을 누르고 julia 를 검색합니다. 맨 위에 Julia 라는 이름과 로고를 가진 확장 프로그램이 보일 것입니다. 한글 팩을 설치했다면 Install 이 아닌 설치 버튼이 보일 것입니다. 이것을 설치해 줍니다. 이것을 설치하면 바로가기 아이콘에 Julia 아이콘이 추가됩니다.\n\n\n\n최초의 Julia 파일 작성\n바로가기의 탐색기 버튼을 누릅니다. 그러면 바로가개 버튼의 바로 오른쪽에 새로운 칸이 열리면서 폴더 열기 버튼이 보일 것입니다. 폴더 열기 버튼을 누르면 운영 체제에 따라 새로운 폴더를 만드는 창이 생깁니다. 여기에 코드를 작성할 폴더를 만들어 줍니다. 저의 경우는 홈 디렉토리 밑에 developement 폴더를 만들고 그 폴더 아래에 test001 폴더를 만들 것입니다. 이미 존재하는 폴더를 선택하면 그 폴더의 파일들이 보일 것입니다. 왠만하면 폴더와 파일 이름은 한글이나 다른 언어를 사용하지 않고 영어 알파벳, 숫자, _ 문자만 사용하시길 추천합니다.\n폴더를 선택하면 운영체제나 계정에 따라 이 폴더의 작성자를 신뢰하느냐는 메시지가 뜰 것입니다. 자신의 계정의 폴더라면 신뢰한다는 버튼을 누르십시요. 타인의 폴더라면 계정의 주인과 상의하시기 바랍니다.\n탐색기 창에 지정한 폴더의 이름과 이 폴더에 포함된 파일들의 이름이 보일 것입니다. 그리고 폴더 이름 옆에 네개의 아이콘이 보입니다. 각각의 아이콘 위에 커서를 가져다만 대고 누르지 않으면 새 파일…, 새 폴더…, 탐색기 새로고침, 탐색기에서 폴더 축소 라는 설명을 볼 수 있습니다. 설명대로 각각 새로운 파일을 만들거나, 지정한 폴더 아래에 새로운 폴더를 만들거나, 탐색기의 파일 목록을 다시 읽습니다. 탐색기에서 폴더 축소는 현재 폴더 아래에 파일과 폴더가 많은 경우 특히 하위폴더의 파일 이름이 보일 경우 이것을 접어서 더 간략하게 보도록 해 줍니다.\n이제 새 파일 버튼을 누르면 폴더창 아래에 입력칸이 생길 것입니다. 여기에 파일 이름을 입력합니다. 앞서 말했듯이 영어 알파벳과 숫자만을 사용하여 test01.jl 이라고 입력합니다.\n여기에 다음과 같이 입력합니다.\n2+3\n\nexp(1)\n\ncos(0)\n첫번째 줄의 2+3 줄에 커서를 옮기고 Control+Enter (혹은 Ctrl+Enter) 를 누릅니다. 그렇게 되면 커서가 위치한 줄, 혹은 블럭을 실행하여 그 결과를 julia REPL 로 출력합니다. 아마 vscode 의 하단에 터미널이 열리면서\nOut[1]: 5\n과 같이 보일 것입니다. vscode 는 자체에 터미널이 내장되어 있어 다른 터미널을 사용하지 않고 여기서 많은 일을 할 수 있습니다.\nWindows/Linux 에서 Alt+Enter, Mac 에서 Option+Enter 키를 누르면 파일의 코드 전체를 REPL 에서 실행합니다.\n\n\n\nNotebook\n같은 폴더에 test01.ipynb 라는 이름을 가진 파일을 새로 만들어 줍니다. 그렇다면 아래와 같은 모양이 될 것입니다.\n\n\n\n\n\n\n그림 4: vscode notebook 시작화면\n\n\n\n\n오른쪽 상단에 커널 선택이 아니라 Julia 1.10.3 과 같은 방금전 설치한 julia 버젼이 나타난다면 그냥 두고 아니라면 커널 선택을 눌러 선택해 줍니다. 그리고 1이라고 써 있는 칸(이것을 입력셀 이라고 합니다)의 오른쪽 하단이 보기처럼 Python 이나 julia 가 아닌 다른 것이라면 그 부분을 눌러 julia 를 선택해 줍니다. 아래와 같이 julia 버젼과 입력셀에 julia 가 보이면 성공입니다.\n\n\n\n\n\n\n그림 5: vscode notebook julia\n\n\n\n\n입력셀에 아래의 코드를 복사&붙여넣기를 해 봅니다.\ntsum = 0\nfor i in 1:10\n    tsum+=i\nend\nprintln(tsum)\n그리고 Shift+Enter 를 누릅니다. 다음과 같이 입력창 아래에 55 라는 결과가 나오면 성공입니다.\n\n\n\n\n\n\n그림 6: vscode notebook 입력창 실행\n\n\n\nShift+Enter 는 입력창을 실행시키고, 가장 마지막 명령어의 실행 결과를 출력하며, 다음 입력창으로 갑니다. 다음 입력창이 존재하지 않으면 새로운 입력창을 만듭니다.\n\nVisual Studio Code 의 노트북은 Jupyter notebook 혹은 그 개선 버젼인 Jupyter-lab 과 유사한 실행 환경입니다. 정확히는 이미 존재하던 jupyter",
    "crumbs": [
      "Julia 언어의 기초",
      "설치와 환경 구성"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/03_functions_and_operators.html",
    "href": "src/introduction_to_julia/03_functions_and_operators.html",
    "title": "연산자와 함수",
    "section": "",
    "text": "연산자는 add(a, b) 와 같은 함수 이름, 괄호, 인자 의 형식을 따르지 않는 함수를 말합니다.\n\n\n많은 다른 프로그래밍 언어에서와 같이 x = y 는 y 의 값을 x 에 할당한다는 표현식이며 == 와 === 는 이 기호의 왼편과 오른편의 변수나 값이 같은지 아닌지를 판단하여 같으면 true 다르면 false 를 반환하는 연산자입니다. === 는 == 보다 더 엄격하게 판단합니다. 예를 들어,\nIn [1]: 2==2.0\nOut[1]: true\n\nIn [2]: 2===2.0\nOut[2]: false\n를 보면 2==2.0 은 true 이지만 2===2.0 은 false 입니다. === 는 타입의 종류까지 같아야 true 를 반환합니다. 그런데 == 는 좀 혼란스럽습니다. 다음 경우를 봅시다.\nIn [3]: 1.0 == 1.0f0\nOut[3]: true\n\nIn [4]: 2.0 == 2.0f0\nOut[4]: true\n\nIn [5]: 1.2 == 1.2f0\nOut[5]: false\n\nIn [6]: Float32(1.2) == 1.2f0\nOut[6]: true\n1.0 등 왼쪽의 값들은 모두 Float64 타입이며 오른쪽의 값들은 Float32 의 값입니다. 1.0 == 1.0f0 는 true 인데 1.2 == 1.2f0 는 false 입니다. 이런 행동을 내부적인 코드 수준에서 이해하는 것은 힘든 일입니다. 다만 다른 타입의 값을 비교할 때, 특히 같은지 여부를 판단할 때는 매우 조심해야 한다는 것을 알아야 합니다.\n\n\n\n\n기본적인 값에 대한 연산에는 다음과 같은 것들이 있습니다.\n\n\n\n표현\n정의\n\n\n\n\n+x\n항등 연산\n\n\n-x\n덧셈에 대한 역원. 혹은 x 에 -1 을 곱한 수\n\n\nx + y\n덧셈\n\n\nx - y\n뺄셈\n\n\nx * y\n곱셈\n\n\nx / y\n나눗셈\n\n\nx ÷ y\n나눗셈의 정수 몫, div(x, y) 와 같다.\n\n\nx \\ y\n역 나눗셈. y / x 와 같다.\n\n\nx ^ y\n거듭제곱. x 의 y 승\n\n\nx % y\n나머지. rem(x, y) 와 같다.\n\n\nx//y\nx, y 가 정수일 때 유리수 타입의 \\(x/y\\)\n\n\n\n\n÷ 는 \\div+ [tab] 키 로 입력 할 수 있습니다.\nx / y 에서 x 와 y 가 모두 정수일 때는 실수로 타입이 변환됩니다. 즉 5/2 는 2.5 이며 6/3 은 2.0 입니다.\nx//y 는 x, y 가 정수일 때 Julia 의 Rational 타입의 값을 반환합니다. 앞서 말했듯이 Julia 에서 유리수는 Int64 나 Float64 와 같은 고유한 타입입니다.\nx ÷ y 는 x 와 y 가 모두 정수 타입이라면 정수몫을 리턴하지만 x 나 y 가 정수가 아닌 부동수일 경우에는 정수몫을 부동소수로 반환합니다. 아래의 예를 참고하세요.\n\nIn [7]: 173 ÷ 2\nOut[7]: 86\n\nIn [8]: 173 ÷ 2.0\nOut[8]: 86.0\n\nIn [9]: 173.0 ÷ 2\nOut[9]: 86.0\n\nIn [10]: -173 ÷ 2\nOut[10]: -86\n\n\n\n실수 \\(a\\) 를 실수 \\(d\\) 로 나눌 때 \\(a=k\\cdot d + r\\) 을 만족하는 정수 \\(k\\)를 몫이라고 하고 \\(r\\) 을 나머지라고 합니다. \\(a,\\,d\\) 가 양수라면 \\(0\\le r &lt; d\\) 를 만족하는 \\(r\\) 을 찾으면 됩니다. 그런데 \\(a,\\,d\\) 둘 가운데 하나라도 음수 일 경우를 생각해 봅시다. 예를 들어 \\(13.0\\) 을 \\(-3.0\\) 으로 나누는 경우,\n\\[\n\\begin{aligned}\n13.0 &= (-4.0) \\times (-3.0) -1.0, \\\\\n13.0 &= (-5.0) \\times (-3.0) + 2.0,\n\\end{aligned}\n\\]\n과 같이 몫 나머지를 각각 (-4.0, -1.0) 이나 (-5.0, 2.0) 으로 생각 할 수 있습니다. \\(a=kd + r\\) 로 표현할 때 나머지 \\(r\\) 의 부호를 \\(a\\) 를 따르도록 하는 경우와 \\(d\\) 의 부호를 따르도록 하는 경우가 있는데 julia 의 나머지 a % r 은 a 의 부호를 따릅니다. 모든 경우에 대해 \\(0 \\le |r| &lt; |d|\\) 입니다.\nIn [11]: -13.0 % 3.0\nOut[11]: -1.0\n\nIn [12]: 13.0 % -3.0\nOut[12]: 1.0\n\nIn [13]: -13.0 % -3.0\nOut[13]: -1.0\n\n\n\n\n\n\n부동소수 나머지 연산에서의 Round-off 에러\n\n\n\n원칙적으로는 a == (a ÷ d) * d + (a % d) 이어야 하지만, a 나 d 가 부동소수일 경우 round-off 에러로 인해 차이가 있을 수 있습니다.\nIn [14]: (-13.3 ÷ 3.0) * 3.0 + (-13.3 % 3.0)\nOut[14]: -13.3\n\nIn [15]: (17.24 ÷ 3.42) * 3.42 + (17.24 % 3.42)\nOut[15]: 17.240000000000002\n\n\n\n\n\n\n\n불(Bool) 타입에 대한 연산은 다음과 같은 것이 있습니다.\n\n\n\n표현\n설명\n\n\n\n\n!x\n부정(negation)\n\n\nx && y\nshort-circuiting and\n\n\nx || y\nshort-circuiting or\n\n\n\n\n!(true) 는 false 이고 !(false) 는 true 입니다.\n아래에 나오는 비트별 연산자 & 와 | 도 불 연산에 and 연산과 or 연산으로 사용될 수 있습니다.\n\n\n\n\n\n논리연산자 x && y 는 x 를 먼저 평가하여 true 이면 y 를 평가하며 y 도 true 이면 연산의 결과는 true 가 됩니다. x 가 false 이면 y 는 평가할 필요가 없이 결과는 false 가 됩니다. 그런데 y 가 불 값이 아닌 어떤 기능을 하는 함수라면 어떻게 될까요? x && y 는 x 가 true 일 경우에만 y 를 실행시키는 조건부 실행문이 됩니다. x || y 일 때는 반대로 x 가 true 이면 true 를 리턴하고 x 가 거짓이면 y 를 실행시킵니다. 불 연산을 사용하여 조건에 따라 실행시키는 것을 short-circuiting 연산이라고 하며, julia 에서 상당히 많이 사용되는 테크닉 입니다.\nIn [19]: x=3\nOut[19]: 3\n\nIn [20]: x&gt;0 && println(\"true and short-circuiting and\")\ntrue and short-circuiting and\n\nIn [21]: x&lt;0 && println(\"false and short-circuiting and\")\nOut[21]: false\n\nIn [22]: x&gt;0 || println(\"true and short-circuiting or\")\nOut[22]: true\n\nIn [23]: x&lt;0 || println(\"false and short-circuiting or\")\nfalse and short-circuiting or\n\n\n\n\n비트는 true 혹은 false 값을 갖는 정보 단위입니다. 아래의 표는 비트에 대한 연산자를 설명합니다.\n\n\n\n표현\nName\n\n\n\n\n~x\nbitwise not\n\n\nx & y\nbitwise and\n\n\nx | y\nbitwise or\n\n\nx ⊻ y\nbitwise xor (exclusive or)\n\n\nx ⊼ y\nbitwise nand (not and)\n\n\nx ⊽ y\nbitwise nor (not or)\n\n\nx &gt;&gt;&gt; y\nlogical shift right\n\n\nx &gt;&gt; y\narithmetic shift right\n\n\nx &lt;&lt; y\nlogical/arithmetic shift left\n\n\n\n\n⊻ 는 \\xor + 탭키, ⊼ 는 \\nand + 탭키, ⊽ 는 \\nor + 탭키 로 입력합니다. &gt;&gt;&gt; 나 &lt;&lt; 는 단순한 키보드 입력입니다.\n한국어 위키백과-비트연산 과 영어 위키백과-비트연산 을 참고하시기 바랍니다\nx&gt;&gt;y 의 경우는 정수 x 를 \\(2^y\\) 로 나눈 몫을 계산하는데 자주 사용됩니다. 예를 들어\n\nIn [24]: 15&gt;&gt;1 # 15 나누기 2^1=2 의 몫\nOut[24]: 7\n\nIn [25]: 427&gt;&gt;2 #427 나누기 2^2=4 의 몫\nOut[25]: 106\n입니다. 비트연산에 대해 편리한 함수로 입력값을 비트 문자열로 바꾸어주는 bitstring() 함수가 있습니다.\nIn [26]: bitstring(1)\nOut[26]: \"0000000000000000000000000000000000000000000000000000000000000001\"\n\nIn [27]: bitstring(3.23)\nOut[27]: \"0100000000001001110101110000101000111101011100001010001111010111\"\n\n\n\n\n비교 연산은 표현을 평가하여 true 혹은 false 를 반환합니다.\n\n\n\n표현\ntrue 인 경우\n\n\n\n\nx == y\nx 와 y 가 같을 때\n\n\nx != y, x ≠ y\nx 와 y 가 다를 때\n\n\nx &lt; y\nx 가 y 보다 작을 때\n\n\nx &lt;= y, x ≤ y\nx 가 y 보다 작거나 같을 때\n\n\nx &gt; y\nx 가 y 보다 클 때\n\n\nx &gt;= y , x ≥ y\nx 가 y 보다 크거나 같을 때\n\n\n\n\n≠ 는 \\ne+탭 키, ≤ 는 \\le+ 탭 키, ≥ 는 \\ge + 탭 키 를 통해 입력합니다.\n비교 연산을 1 &lt; 2 &lt;= 3 &lt; 5 != 10 &lt; 12 같이 이어서 쓸 수 있습니다. 모든 비교 항목이 true 일 때만 true 를 리턴합니다.\n\n특히 부동소수가 포함된 계산의 결과를 비교할때는 조심해야 합니다. Round-off 에러로 인해 오류가 발생 할 수 있습니다.\nIn [28]: 0 == 0.0\nOut[28]: true\n\nIn [29]: 4 == 4.0\nOut[29]: true\n\nIn [30]: 8.3-1.0 == 7.3\nOut[30]: false",
    "crumbs": [
      "Julia 언어의 기초",
      "연산자와 함수"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/03_functions_and_operators.html#기본-연산자",
    "href": "src/introduction_to_julia/03_functions_and_operators.html#기본-연산자",
    "title": "연산자와 함수",
    "section": "",
    "text": "연산자는 add(a, b) 와 같은 함수 이름, 괄호, 인자 의 형식을 따르지 않는 함수를 말합니다.\n\n\n많은 다른 프로그래밍 언어에서와 같이 x = y 는 y 의 값을 x 에 할당한다는 표현식이며 == 와 === 는 이 기호의 왼편과 오른편의 변수나 값이 같은지 아닌지를 판단하여 같으면 true 다르면 false 를 반환하는 연산자입니다. === 는 == 보다 더 엄격하게 판단합니다. 예를 들어,\nIn [1]: 2==2.0\nOut[1]: true\n\nIn [2]: 2===2.0\nOut[2]: false\n를 보면 2==2.0 은 true 이지만 2===2.0 은 false 입니다. === 는 타입의 종류까지 같아야 true 를 반환합니다. 그런데 == 는 좀 혼란스럽습니다. 다음 경우를 봅시다.\nIn [3]: 1.0 == 1.0f0\nOut[3]: true\n\nIn [4]: 2.0 == 2.0f0\nOut[4]: true\n\nIn [5]: 1.2 == 1.2f0\nOut[5]: false\n\nIn [6]: Float32(1.2) == 1.2f0\nOut[6]: true\n1.0 등 왼쪽의 값들은 모두 Float64 타입이며 오른쪽의 값들은 Float32 의 값입니다. 1.0 == 1.0f0 는 true 인데 1.2 == 1.2f0 는 false 입니다. 이런 행동을 내부적인 코드 수준에서 이해하는 것은 힘든 일입니다. 다만 다른 타입의 값을 비교할 때, 특히 같은지 여부를 판단할 때는 매우 조심해야 한다는 것을 알아야 합니다.\n\n\n\n\n기본적인 값에 대한 연산에는 다음과 같은 것들이 있습니다.\n\n\n\n표현\n정의\n\n\n\n\n+x\n항등 연산\n\n\n-x\n덧셈에 대한 역원. 혹은 x 에 -1 을 곱한 수\n\n\nx + y\n덧셈\n\n\nx - y\n뺄셈\n\n\nx * y\n곱셈\n\n\nx / y\n나눗셈\n\n\nx ÷ y\n나눗셈의 정수 몫, div(x, y) 와 같다.\n\n\nx \\ y\n역 나눗셈. y / x 와 같다.\n\n\nx ^ y\n거듭제곱. x 의 y 승\n\n\nx % y\n나머지. rem(x, y) 와 같다.\n\n\nx//y\nx, y 가 정수일 때 유리수 타입의 \\(x/y\\)\n\n\n\n\n÷ 는 \\div+ [tab] 키 로 입력 할 수 있습니다.\nx / y 에서 x 와 y 가 모두 정수일 때는 실수로 타입이 변환됩니다. 즉 5/2 는 2.5 이며 6/3 은 2.0 입니다.\nx//y 는 x, y 가 정수일 때 Julia 의 Rational 타입의 값을 반환합니다. 앞서 말했듯이 Julia 에서 유리수는 Int64 나 Float64 와 같은 고유한 타입입니다.\nx ÷ y 는 x 와 y 가 모두 정수 타입이라면 정수몫을 리턴하지만 x 나 y 가 정수가 아닌 부동수일 경우에는 정수몫을 부동소수로 반환합니다. 아래의 예를 참고하세요.\n\nIn [7]: 173 ÷ 2\nOut[7]: 86\n\nIn [8]: 173 ÷ 2.0\nOut[8]: 86.0\n\nIn [9]: 173.0 ÷ 2\nOut[9]: 86.0\n\nIn [10]: -173 ÷ 2\nOut[10]: -86\n\n\n\n실수 \\(a\\) 를 실수 \\(d\\) 로 나눌 때 \\(a=k\\cdot d + r\\) 을 만족하는 정수 \\(k\\)를 몫이라고 하고 \\(r\\) 을 나머지라고 합니다. \\(a,\\,d\\) 가 양수라면 \\(0\\le r &lt; d\\) 를 만족하는 \\(r\\) 을 찾으면 됩니다. 그런데 \\(a,\\,d\\) 둘 가운데 하나라도 음수 일 경우를 생각해 봅시다. 예를 들어 \\(13.0\\) 을 \\(-3.0\\) 으로 나누는 경우,\n\\[\n\\begin{aligned}\n13.0 &= (-4.0) \\times (-3.0) -1.0, \\\\\n13.0 &= (-5.0) \\times (-3.0) + 2.0,\n\\end{aligned}\n\\]\n과 같이 몫 나머지를 각각 (-4.0, -1.0) 이나 (-5.0, 2.0) 으로 생각 할 수 있습니다. \\(a=kd + r\\) 로 표현할 때 나머지 \\(r\\) 의 부호를 \\(a\\) 를 따르도록 하는 경우와 \\(d\\) 의 부호를 따르도록 하는 경우가 있는데 julia 의 나머지 a % r 은 a 의 부호를 따릅니다. 모든 경우에 대해 \\(0 \\le |r| &lt; |d|\\) 입니다.\nIn [11]: -13.0 % 3.0\nOut[11]: -1.0\n\nIn [12]: 13.0 % -3.0\nOut[12]: 1.0\n\nIn [13]: -13.0 % -3.0\nOut[13]: -1.0\n\n\n\n\n\n\n부동소수 나머지 연산에서의 Round-off 에러\n\n\n\n원칙적으로는 a == (a ÷ d) * d + (a % d) 이어야 하지만, a 나 d 가 부동소수일 경우 round-off 에러로 인해 차이가 있을 수 있습니다.\nIn [14]: (-13.3 ÷ 3.0) * 3.0 + (-13.3 % 3.0)\nOut[14]: -13.3\n\nIn [15]: (17.24 ÷ 3.42) * 3.42 + (17.24 % 3.42)\nOut[15]: 17.240000000000002\n\n\n\n\n\n\n\n불(Bool) 타입에 대한 연산은 다음과 같은 것이 있습니다.\n\n\n\n표현\n설명\n\n\n\n\n!x\n부정(negation)\n\n\nx && y\nshort-circuiting and\n\n\nx || y\nshort-circuiting or\n\n\n\n\n!(true) 는 false 이고 !(false) 는 true 입니다.\n아래에 나오는 비트별 연산자 & 와 | 도 불 연산에 and 연산과 or 연산으로 사용될 수 있습니다.\n\n\n\n\n\n논리연산자 x && y 는 x 를 먼저 평가하여 true 이면 y 를 평가하며 y 도 true 이면 연산의 결과는 true 가 됩니다. x 가 false 이면 y 는 평가할 필요가 없이 결과는 false 가 됩니다. 그런데 y 가 불 값이 아닌 어떤 기능을 하는 함수라면 어떻게 될까요? x && y 는 x 가 true 일 경우에만 y 를 실행시키는 조건부 실행문이 됩니다. x || y 일 때는 반대로 x 가 true 이면 true 를 리턴하고 x 가 거짓이면 y 를 실행시킵니다. 불 연산을 사용하여 조건에 따라 실행시키는 것을 short-circuiting 연산이라고 하며, julia 에서 상당히 많이 사용되는 테크닉 입니다.\nIn [19]: x=3\nOut[19]: 3\n\nIn [20]: x&gt;0 && println(\"true and short-circuiting and\")\ntrue and short-circuiting and\n\nIn [21]: x&lt;0 && println(\"false and short-circuiting and\")\nOut[21]: false\n\nIn [22]: x&gt;0 || println(\"true and short-circuiting or\")\nOut[22]: true\n\nIn [23]: x&lt;0 || println(\"false and short-circuiting or\")\nfalse and short-circuiting or\n\n\n\n\n비트는 true 혹은 false 값을 갖는 정보 단위입니다. 아래의 표는 비트에 대한 연산자를 설명합니다.\n\n\n\n표현\nName\n\n\n\n\n~x\nbitwise not\n\n\nx & y\nbitwise and\n\n\nx | y\nbitwise or\n\n\nx ⊻ y\nbitwise xor (exclusive or)\n\n\nx ⊼ y\nbitwise nand (not and)\n\n\nx ⊽ y\nbitwise nor (not or)\n\n\nx &gt;&gt;&gt; y\nlogical shift right\n\n\nx &gt;&gt; y\narithmetic shift right\n\n\nx &lt;&lt; y\nlogical/arithmetic shift left\n\n\n\n\n⊻ 는 \\xor + 탭키, ⊼ 는 \\nand + 탭키, ⊽ 는 \\nor + 탭키 로 입력합니다. &gt;&gt;&gt; 나 &lt;&lt; 는 단순한 키보드 입력입니다.\n한국어 위키백과-비트연산 과 영어 위키백과-비트연산 을 참고하시기 바랍니다\nx&gt;&gt;y 의 경우는 정수 x 를 \\(2^y\\) 로 나눈 몫을 계산하는데 자주 사용됩니다. 예를 들어\n\nIn [24]: 15&gt;&gt;1 # 15 나누기 2^1=2 의 몫\nOut[24]: 7\n\nIn [25]: 427&gt;&gt;2 #427 나누기 2^2=4 의 몫\nOut[25]: 106\n입니다. 비트연산에 대해 편리한 함수로 입력값을 비트 문자열로 바꾸어주는 bitstring() 함수가 있습니다.\nIn [26]: bitstring(1)\nOut[26]: \"0000000000000000000000000000000000000000000000000000000000000001\"\n\nIn [27]: bitstring(3.23)\nOut[27]: \"0100000000001001110101110000101000111101011100001010001111010111\"\n\n\n\n\n비교 연산은 표현을 평가하여 true 혹은 false 를 반환합니다.\n\n\n\n표현\ntrue 인 경우\n\n\n\n\nx == y\nx 와 y 가 같을 때\n\n\nx != y, x ≠ y\nx 와 y 가 다를 때\n\n\nx &lt; y\nx 가 y 보다 작을 때\n\n\nx &lt;= y, x ≤ y\nx 가 y 보다 작거나 같을 때\n\n\nx &gt; y\nx 가 y 보다 클 때\n\n\nx &gt;= y , x ≥ y\nx 가 y 보다 크거나 같을 때\n\n\n\n\n≠ 는 \\ne+탭 키, ≤ 는 \\le+ 탭 키, ≥ 는 \\ge + 탭 키 를 통해 입력합니다.\n비교 연산을 1 &lt; 2 &lt;= 3 &lt; 5 != 10 &lt; 12 같이 이어서 쓸 수 있습니다. 모든 비교 항목이 true 일 때만 true 를 리턴합니다.\n\n특히 부동소수가 포함된 계산의 결과를 비교할때는 조심해야 합니다. Round-off 에러로 인해 오류가 발생 할 수 있습니다.\nIn [28]: 0 == 0.0\nOut[28]: true\n\nIn [29]: 4 == 4.0\nOut[29]: true\n\nIn [30]: 8.3-1.0 == 7.3\nOut[30]: false",
    "crumbs": [
      "Julia 언어의 기초",
      "연산자와 함수"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/03_functions_and_operators.html#함수",
    "href": "src/introduction_to_julia/03_functions_and_operators.html#함수",
    "title": "연산자와 함수",
    "section": "2 함수",
    "text": "2 함수\nJulia 에서의 함수는 많은 다른 언어들과 마찬가지로 함수명 뒤의 괄호 ( ) 안에 필요한 값들을 입력하여 함수를 실행시킵니다. 변수 a 에 대한 sin 함수값을 알고싶다면 sin(a) 로 입력합니다. 이 때 sin 이 함수 이름이며 함수에 입력되는 값 a 를 인자(argument) 라고 합니다. 인자는 값일수도 있고 문자열 혹은 다른 것일 수 있으며, 하나일 수도 있고 여러개일 수도 있습니다.\n\n수학 함수\nJulia 에서 제공 하는 함수 가운데 기본적인 함수를 소개합니다. 이 함수들의 정의와 사용법에 대해서는 관련 문서 를 참고하기 바랍니다.\n\n\n\n\n\n\n\n설명\n함수\n\n\n\n\n최대공약수, 최소공배수\ngcd, lcm\n\n\n절대값과 부호\nabs, abs2, sign, signbit, copysign, flipsign\n\n\n제곱근, 지수, 로그 관련\nsqrt, cbrt , hypot, exp, expm1, ldexp, log, log2, ,log10, exponent\n\n\n반올림, 올림, 내림 관련\nround, floor, ceil, trunc\n\n\n삼각함수\nsin, cos, tan, cot, sec, csc\n\n\n역 삼각함수\nasin, acos, atan, acot, asec, acsc\n\n\n쌍곡선 함수\nsinh, cosh, tanh, coth, sech, csch\n\n\n역 쌍곡선 함수\nasinh, acosh, atanh, acoth, asech, acsch\n\n\n기타\nsinc, cosc\n\n\n\n\n\n\n사용자 정의 함수\n예를 들어 두 값 x 와 y 를 입력 받아 두 값의 합을 반환하는 함수는 다음과 같이 정의합니다.\nfunction myadd(x, y)\n    return x+y\nend\n혹은 간단하게\nmyadd2(x, y) = x+y\n와 같이 정의할 수도 있습니다. 위의 myadd 와 myadd2 는 기능상 동일합니다.\n함수 정의는 function 으로 시작하여 함수 이름이 나오고 ( ) 안에 인자를 받는 변수와 그 정보를 나열합니다. 결과를 반환해야 할 경우 return 후에 반환해야 할 값이나 변수를 써 주고, end 로 끝납니다. return 이 나오면, 그 이후는 평가하지 않고 종료합니다.\nfunction myadd3(x)\n    return x+1\n    println(x+2)\nend\n에 대해 myadd3(3) 을 실행시키면 3+1=4 를 반환하고 종료하며 return 의 다음 명령인 println(x+2) 명령은 수행하지 않습니다.\n만약 함수 정의 안에 return 이 없다면 end 바로 앞의 표현식의 결과를 리턴합니다.\nfunction aa(a)\n    a+1\nend\n에 대해 b=aa(3) 을 수행하면 end 바로 앞의 a+1 을 리턴하므로 b==4 입니다. 만약 아무 것도 리턴하고 싶지 않다면 명시적으로 return nothing 이라고 해 주는 것이 좋습니다.\n\n\n\n익명함수 (람다함수)\n인자 -&gt; 반환하는 함수의 표현식 꼴로 선언되는 이름 없는 함수를 익명함수(anonymous function) 혹은람다 함수(lambda function) 이라고 합니다. 우선은 함수를 간단하게 정의하는 데도 사용합니다.\nIn [1]: sq = (x-&gt;x^2)\nOut[1]: #11 (generic function with 1 method)\n\nIn [2]: sq(3)\nOut[2]: 9\n\nIn [3]: sq(\"ab\")\nOut[3]: \"abab\"\nsq = (x-&gt;x^2) 를 봅시다. 오른쪽의 (x-&gt;x^2) 는 입력 x 에 대해 x^2 를 반환하는 익명 함수를 의미하며 sq = (x-&gt;x^2) 는 이 함수 객체를 sq 변수에 할당했습니다. 따라서 sq 는 함수이며 sq(3) 는 3^2 인 9 를 반환하고 sq(\"ab\") 는 \"ab\"^2==\"abab\" 를 반환합니다.\n익명 함수는 여려개의 인자를 가질 수도 있습니다.\nIn [4]: madd = (x, y) -&gt; x+y\nOut[4]: #13 (generic function with 1 method)\n\nIn [5]: madd(3, -2)\nOut[5]: 1\n익명함수를 위와 같이 사용하는 것은 다음과 같은 경우에 비해 이점이 없습니다.\nIn [10]: madd2(x,y) = x+y\nOut[10]: madd2 (generic function with 1 method)\n\nIn [11]: madd2(3, -2)\nOut[11]: 1\n익명함수는 map 함수에서의 익명함수의 사용 에서 볼 수 있듯이 map, reduce, 등에서 유용하게 사용됩니다. 또한 배열 comprehension 에서도 유용하게 사용 할 수 있습니다.\n\n\n\n익명 함수 : do ... end, begin ... end\n람다 함수 이외에 익명함수를 정의하는 방법은 do ... end 블럭과 begin ... end 블럭이 있습니다. 이것은 do ... end, begin ... end 의 사용 에서 좀 더 다루도록 하겠습니다.\n\n\n\n선택적 인자\n인자의 값을 입력하지 않아도 되는 인자를 선택적 인자(optional arguments) 라고 합니다.\n\n기본값이 있는 선택적 인자\n함수의 특정 인자에 대한 기본값을 정할 수 있으며 함수를 실행 할 때 이 인자에 값을 입력하지 않으면 기본값이 사용됩니다. 영어로는 Optional argument 라고 합니다. 예를 들어,\nmyadd3(x, y=1) = x+y\n와 같이 정의하면 y 를 입력하지 않았을 경우 즉 myadd(3) 으로 함수를 실행시켰을 경우 y=1 로 수행 됩니다. 즉 myadd(3)==4 입니다.\n\n\n\n기본값이 없는 선택적 인자\n실제로 코드상에서 기본값이 없는 선택적 인자는 없습니다. 일반적으로 기본값이 없는 선택적 인자는 인자의 값이 주어졌느냐 안주어졌느냐가 중요 할 때 사용합니다. 예를 들어 위의 myadd3 에서 myadd(2, 1) 과 myadd(2) 는 구별 할 수 없습니다. 인자가 선택되지 않았을 때 어떤 기능을 하고싶다면 어떻게 할까요? 특별히 인자가 특정 타입을 받는 경우라면? 이때는 보통 nothing 을 기본 인자로 놓습니다. 이 선택적 인자에 값을 입력한다면 정수여야 한다면 타입 유니온을 사용할 수 있습니다.\nfunction optional_arg(x, y::Union{Nothing, Integer} = nothing)\n    if y === nothing\n        return x^2\n    else\n        return x+y\n    end\nend\n이 경우 optional_arg(3) 은 y=nothing 으로 입력이 되기 때문에 \\(9\\) 를 반환하지만 optional_arg(3, 4) 는 y=4 로 입력이 되므로 3+4 인 7 이 반환됩니다.\nIn [10]: function optional_arg(x, y::Union{Nothing, Integer} = nothing)\n             if y === nothing\n                 return x^2\n             else\n                 return x+y\n             end\n         end\nOut[10]: optional_arg (generic function with 2 methods)\n\nIn [11]: optional_arg(3)\nOut[11]: 9\n\nIn [12]: optional_arg(3, 4)\nOut[12]: 7\n\n\n\n\n키워드 인자\n인자에 특정한 키워드를 반드시 사용하도록 정할 수도 있습니다. 함수의 정의에서 ; 으로 구분하여 ; 앞에는 순서대로 정해진 인자가, ; 에는 키워드로 정해진 인자가 오도록 합니다.\nIn [1]: function myfunc(x, y; color=\"red\")\n            println(\"color = $color, x=$x, y=$y\")\n        end\nOut[1]: myfunc (generic function with 1 method)\n\nIn [2]: myfunc(1, color=2, 3)  # 키워드로 정해진 인자는 인자 입력의 순서를 무시한다.\ncolor = 2, x=1, y=3\n\nIn [3]: myfunc(1, 2)\ncolor = red, x=1, y=2\n함수 호출에서 키워드로 정해진 인자는 인자의 입력 순서를 무시하며, 키워드가 없는 인자끼리의 순서대로 인자가 입력된다는 것을 알 수 있습니다.\n\n\n\n인자와 반환값의 타입 지정\n함수를 정의 할 때 인자나 반환값의 타입을 :: 연산자를 통해 지정 할 수 있습니다. 예를 들어,\nfunction mfunc(x::Int64)::Int64\n    return x+1\nend\n는 인자 x 의 타입을 Int64 로 지정하였으며, x 에 Int64 타입이 아닌 인자가 할당될 경우 에러가 발생합니다. 리턴값의 타입을 지정하는 경우는 약간 다른데 julia 는 리턴 값을 지정된 타입으로 변환시키려고 하며, 변환될 경우는 변환된 값을, 변환되지 않을 경우는 에러를 출력합니다. 예를 들어,\nfunction mfunc2(x)::Int64\n    return x/2\nend\n에서 mfunc2(1) 은 1/2 가 정수로 변환되지 않으므로 에러를 출력하지만 myfunc(2.0) 은 2.0/2 가 정수로 변환되므로 변환된 Int64 타입의 값 1 을 리턴합니다.\nIn [1]: function myfunc2(x)::Int64\n        return x/2\n        end\nOut[1]: myfunc2 (generic function with 1 method)\n\nIn [2]: myfunc2(1)\nERROR: InexactError: Int64(0.5)\n...\n\nIn [3]: myfunc2(2.0)\nOut[3]: 1\n\n여러분들은 타입에 너무 엄격한 것이 아니냐고 생각 할 수 있습니다. 만약 어떠 함수의 인자로 UInt8 이든 Int64 든 상관 없이 정수만을 받고 싶을 수도 있습니다. 이에 대한 방법은 타입의 계층 구조 에서 다루도록 하겠습니다.\n\n\n\n함수의 시그너쳐와 메서드\n함수 이름과 인자의 갯수, 각 인자의 타입의 정보를 함수의 시그너쳐(signature)라고 합니다. Julia 에서는 하나의 함수 이름으로 인자의 타입과 갯수에 따라 각각 다른 기능을 하게 할 수 있는데 이를 메서드(method)라고 합니다. 자세한 것은 메서드 다중 디스패치 에서 다루도록 하겠습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "연산자와 함수"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04_containers.html",
    "href": "src/introduction_to_julia/04_containers.html",
    "title": "컨테이너",
    "section": "",
    "text": "여러 개의 데이터를 저장하고 처리하기 위한 데이터 타입을 컨테이너(container)이라고 하며, 대표적으로 배열(Array), 튜플(Tuple), 사전(Dict), StepRange, 집합(Set) 등이 있습니다. 컨테이너은 기본적으로 length 함수를 통해 포함되어 있는 아이템의 갯수를 알 수 있으며, 아이템을 하나하나 순회할 수 있습니다. 순서가 있는 컨테이너일 경우 순서대로 1, 2, … 의 인덱스를 가지며 포함하는 객체에 접근하여 값을 가져오거나 값을 변경할 때 정수 인덱스로 접근 할 수 있습니다. 순서가 중요하지 않은 컨테이너 일 경우 값마다 지정된 키(key) 인덱스를 통해 접근할 수 있습니다. 집합 타입의 컨테이너의 경우는 인덱스로도, 키로도 접근할 수 없습니다. 컨테이너에서 아이템을 더하거나 뺄 수 있는 컨테이너를 mutable 하다고 하며, 한번 생성된 컨테이너을 변경 할 수 없다면 immutable 하다고 합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "컨테이너"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04_containers.html#sec-collections",
    "href": "src/introduction_to_julia/04_containers.html#sec-collections",
    "title": "컨테이너",
    "section": "1 대표적인 컨테이너들",
    "text": "1 대표적인 컨테이너들\nJulia 에서는 많은 종류의 컨테이너를 기본적으로 제공하며, 이 가운데 가장 많이 사용되는 것들의 특징을 정리하였습니다.\n\n\n\n표 1: 대표적인 컨테이너과 그 특징\n\n\n\n\n\n이름\n정수 인덱스로 접근\n키 인덱스로 접근\nmutable\n\n\n\n\n배열 (Array)\no\nx\no\n\n\n튜플 (Tuple)\no\nx\nx\n\n\n기명 튜플 (NamedTuple)\no\no\nx\n\n\n사전 (Dictionary)\nx\no\no\n\n\nStepRange (StepRange)\no\nx\nx\n\n\n집합 (Set)\nx\nx\no\n\n\n배열 (Array)\no\nx\no\n\n\n\n\n\n\n\n\n배열 (Array)\n배열은 정수 인덱스로 접근하는 같은 타입의 성분을 갖는 다차원 컨테이너로 mutable 입니다. 수치 해석에서 기본이 되는 벡터, 행렬과 이미지 등은 대부분 배열로 처리됩니다. 배열은 Julia 에서 특히 수치 해석에서 너무나 중요하기 때문에 이후 배열 에서 자세히 다루고 여기서는 1차원 배열에 대해서만 간단히 다루도록 하겠습니다.\n\n\n\n1차원 배열 (Vector)\n1차원 배열은 Vector 라고 불리며 [ ] 안에 쉼표로 분리되어 나열된 아이템을 성분으로 갖는 컨테이너 입니다. 수를 비롯하여 모든 타입의 아이템을 포함할 수 있으며 삽입과 삭제가 자유로운 mutable 타입으로 정수 인덱스로 접근합니다. 다음과 같이 정의합니다.\nIn [1]: vec1 = [1, 2, \"a\", 3.4, \"bbc\"]\nOut[1]: 5-element Vector{Any}:\n 1\n 2\n  \"a\"\n 3.4\n  \"bbc\"\n\nIn [2]: vec2=[2,3,4,5]\nOut[2]: 4-element Vector{Int64}:\n 2\n 3\n 4\n 5\n이 때 vec1[1]=1 이며 vec1[5]=\"bbc\" 입니다. Vector 옆의 {Any} 나 {Int64} 는 벡터의 성분(벡터에 포함된 아이템을 성분(entry, element) 라고 합니다) 의 타입입니다. Any 타입은 모든 타입을 포함하는 타입입니다. 베열이 생성될 때 정해지며, 일단 정해진 벡터의 타입은 변경 될 수 없습니다. 다만 타입을 변경한 새로운 벡터를 만들 수 있습니다. 배열은 mutable 이므로 성분을 인덱스로 접근하여 변경 할 수 있습니다.\nIn [5]: vec1[2]=2.2; vec1\nOut[5]: 5-element Vector{Any}:\n 1\n 2.2\n  \"a\"\n 3.4\n  \"bbc\"\n\n\n\n\n\n\n\n명령문 끝의 ;\n\n\n\n위의 In [5] 에서와 같이 Julia REPL 에서 명령어 다음에 세미콜론 ; 을 붙이면 명령을 수행하지만 그 결과는 출력하지 않습니다. Jupyter 나 vscode 환경에서도 마찬가지 입니다.\n\n\n\n벡터에 성분을 마지막에 추가하고 싶으면 append!(vec1, item1, item2, .. ) 처럼 사용합니다. 그렇게 되면 vec1 에 item1, item2 가 차례대로 추가됩니다. 만약 item1, item2… 들이 컨테이너이라면 vec1 에 item1 를 순서대로 합칩니다.\n\n\n\n\n\n\n\n함수명 끝의 !\n\n\n\nJulia 에서는 함수명을 붙일 때 함수의 어떤 인자를 변경하는 함수라면 관례적으로 그 이름 끝에 ! 를 붙입니다. 다음부터 나올 push! 나 pop! 함수 이름에 ! 가 붙은것은 이 함수가 직접 인자를 변경하기 때문입니다. 직접 변경하지 않을 때는 ! 를 붙이지 않습니다.\n\n\n\n\n예제 1 append!(vec1, [2, 4], [\"k\", \"g\"]) 를 수행해 보세요.\n\n\n어떤 정해진 인덱스에 삽입하려면 insert!(vec1, index1, item1) 처럼 사용합니다. 그렇게 되면 vec1[index1] == item1 이 되며 원래 index1 에 위치했던 아이템과 그 뒤의 아이템들의 인덱스가 하나씩 늘어나게 됩니다. item 이 컨테이너이라도 append! 처럼 컨테이너의 아이템이 순서대로 삽입되지 않고 컨테이너 자체로 삽입됩니다. (타입이 지정된 벡터이면 에러가 발생합니다.)\nIn [6]: vec1 = [1, 2, \"a\", 3.4, \"bbc\"];\n\nIn [7]: insert!(vec1, 3, \"II\")\nOut[7]: 6-element Vector{Any}:\n 1\n 2\n  \"II\"\n  \"a\"\n 3.4\n  \"bbc\"\n특정 인덱스의 아이템을 삭제하고 싶으면 deleteat! 함수를 사용합니다. 만약 vec1[4] 인 “a” 를 삭제하고 싶으면 deleteat!(vec1, 4) 처럼 사용합니다.\nJulia 의 모든 타입은 Any 로부터 가지처럼 뻗어나가는 계층 구조를 가지고 있습니다. 여기에 대해서는 타입의 계층구조 에서 좀 더 자세히 알아 볼 것입니다. 벡터를 정의할 때 vec1 처럼 여러 타입을 가진 아이템을 포함한다면 julia 가 알아서 적절한 타입으로 변환합니다. 정수와 부동소수만으로 이루어진 배열은 자동적으로 부동소수로 변환됩니다. Any 는 모든 타입을 포함 할 수 있는 타입이므로 임의의 타입을 위한 배열의 타입으로 사용됩니다. 당분간은 배열은 특정한 타입만을 포함 할 수 있으며, 임의의 타입을 포함하고 싶을때는 Vector 다음에 {Any} 를 명시적으로 붙인다고 알고 있겠습니다.\n\n\n\n\n\n\nPromotion\n\n\n\n연산에서 같은 타입이 아닐 때 타입을 조정하는것을 promotion 이라고 합니다. 예를 들자면 2+3.0 이나 3.3 + π 을 계산하는 경우 둘의 타입이 다르기 때문에 julia 가 적절한 타입, 이 경우는 둘 다 부동소수로 타입으로 변환합니다.\n\n\nIn [1]: vec2=Vector{Any}([1,2,3]);\n\nIn [2]: ec3=Vector([1,2,3]);\nvec2 와 vec3 는 모두 세 정수로 이루어진 벡터이지만 vec2 는 Any 타입으로 지정되었습니다. 따라서 insert!(vec2, 2, \"A\") 는 동작하지만 insert!(vec3, 2, \"A\") 는 동작하지 않습니다.\npush! 와 pop! 은 벡터의 미지막에 어떤 아이템을 추가하거나, 마지막 아이템을 제거하는 명령입니다. push!(vec3, 5) 나 pop!(vec3) 처럼 사용합니다. pop! 의 경우 제거된 아이템을 반환합니다.\nIn [3]: push!(vec3, 5)\nOut[3]: 4-element Vector{Int64}:\n 1\n 2\n 3\n 5\n\nIn [4]: pop!(vec3)\nOut[4]: 5\n\nIn [5]: vec3\nOut[5]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\n연습문제 1 pushfirst!, popfirst!, empty! 함수를 알아보고 벡터를 변형시켜 봅시다.\n\n\n\n\nStepRange\n일정한 간격으로 나열되는 수를 위한 immutable 컨테이너입니다. 대표적으로 start:step:end 형식이나 start:end 형식으로 할당하며, 후자의 경우 start 와 end 의 타입으로부터 1 혹은 1.0 의 간격을 갖도록 만들어집니다.\n\nrange1 = start:step:end 형식으로 만들 경우 1 부터 시작하는 인덱스 i 에 대해 range1[i] == start + (i-1)*step 값을 가지며 당연히 end 값을 넘지 않습니다. 그리고 end 값을 포함 할 수 있습니다. 1:1:5 의 경우는 5번째 값은 5 입니다. \nend &gt; start 일 경우는 step 값이 0 보다 작아야 합니다.\n\npython 의 경우 range(1, 5) 나 numpy.arange(1, 5) 로 생성하는 배열은 5 를 포함하지 않습니다.\n연습문제 2 start &gt; end 일 때, step 값을 양수로 정의해 보거나, start &lt; end 일 때 step 값을 음수로 정의하고 인덱스를 통해 접근해 보기 바랍니다. 또한 start == end 일 때는 어떻게 되는지 확인해 보기 바랍니다.\n\nrange 함수를 통해서도 생성 할 수 있습니다. range(1, 10, step=1) 은 1:1:10 과 같습니다. 또한 range(start=0.0, stop=π, length=100) 은 0 부터 \\(\\pi\\) 까지 100 개의 길이를 가진 Range 만듭니다. 자세한 것은 julia 의 기본 문서에서 range 를 검색해 보기 바랍니다.\n많은 경우 StepRange 는 벡터처럼 동작하지만 immutable 이므로 수정 할 수 없습니다. 그리고 많은 경우 수학 함수에 적용되면 결과가 벡터로 변환됩니다.\nIn [6]: sin.(0.0:0.1:π)\nOut[6]: 32-element Vector{Float64}:\n 0.0\n 0.09983341664682815\n 0.19866933079506122\n 0.2955202066613396\n 0.3894183423086505\n 0.479425538604203\n 0.5646424733950355\n 0.6442176872376911\n ⋮\n 0.5984721441039564\n 0.5155013718214642\n 0.4273798802338298\n 0.33498815015590466\n 0.23924932921398198\n 0.1411200080598672\n 0.04158066243329049\n\nStepRange 값을 벡터로 변환할 때는 collect 함수를 사용합니다. collect 함수는 컨테이너를 인자로 받아 이것을 벡터로 바꾸어 주는 함수입니다.\nIn [6]: collect(1:2:11)\nOut[6]: 6-element Vector{Int64}:\n  1\n  3\n  5\n  7\n  9\n 11\n\n\nrange 함수\nStepRange 와 비슷한 기능을 하는 range 함수가 있습니다. REPL 에서 ?range 로 알 수 있는 range 함수의 시그너쳐는 다음과 같습니다.\n  range(start, stop, length)\n  range(start, stop; length, step)\n  range(start; length, stop, step)\n  range(;start, length, stop, step)\nrange(1, 10, 10) 은 시작과 끝, 그리고 길이를 지정하는 첫번째 시그너쳐에 따라 생성합니다. 0.0:0.1:10.0 에서는 간격이 주어지지만 range 는 간격 대신 길이를 지정 할 수 있습니다.\n\n\n\n\n튜플 (Tuple)\n튜플은 벡터처럼 인덱스를 통해 포함하는 아이템에 접근 할 수 있지만 새로운 아이템을 추가할 수도 없고, 포함하는 아이템을 삭제할 수도 없습니다. 즉 immutable 입니다. 튜플은 tuple1 = (1, 3.3, 'A', cos, (2, \"a\", sin)) 과 같이 ( ) 안에서 , 로 구분하여 선언합니다. 여기서 A 는 Char 타입, “a” 는 String 타입이며, sin, cos 는 함수입니다. (Julia 에서 함수는 Function 타입입니다.) 튜플에서는 1 부터 시작되는 인덱스를 이용하여 포함된 아이템에 접근 할 수 있습니다. 앞서의 tuple1 의 경우, tuple1[1]==1 이며, typle1[3]=='A' 입니다. tuple[5]== (2, \"a\", sin) 이므로 tuple1[5][2]==\"a\" 입니다. tuple1[5][3]==sin 인 함수이므로 다음과 같은 결과를 얻을 수 있습니다.\nIn [1]: tuple1 = (1, 3.3, 'A', cos, (2, \"a\", sin))\nOut[1]: (1, 3.3, 'A', cos, (2, \"a\", sin))\n\nIn [2]: tuple1[5][3](π/2)\nOut[2]: 1.0\ntuple 은 immutable 한 컨테이너이므로 tuple1[2]=4.4 와 같은 방식으로 아이템을 변경 할 수 없으며, 성분을 추가하거나 삭제할 수도 없습니다.\n\n\n연습문제 3 임의의 튜플을 만든 후 인덱스를 통해 아이템을 변경해 보고 그 에러를 확인해 보세요.\n\n\n튜플이 벡터와 구별되는 것 가운데 하나는 포함되는 아이템의 타입을 일치시키려 하지 않는 점 입니다. 앞서 보았듯이 vec0 = [1, 2.0] 를 수행하면 맨 처음의 1 은 벡터가 되면서 2.0 의 타입을 고려하여 Float64 타입인 1.0 으로 변경됩니다. 이것은 vec0 = Vector{Any}([1, 2.0]) 를 해도 마찬가지 입니다. 그러나 튜플은 다릅니다.\nIn [1]: tup0 = (1, 2.0)\nOut[1]: (1, 2.0)\n와 같이 타입을 일치시키려 하지 않습니다.\n\n튜플이 가장 흔하게 사용되는 곳은 함수의 return 에서 입니다. 만약 함수가 아래와 같이 여러개의 값을 , 로 구분하여 반환한다면 이것은 이 값들을 순서대로 묶은 튜플을 반환하는 것입니다. 아래의 return3() 함수는 그냥 1, 2, 3 을 반환하는 함수인데, 리턴값은 이 값을 묶은 튜플입니다. 아래의 함수는 1, 2, 3 을 반환하는 함수입니다.\nfunction return3()\n    return 1, 2, 3\nend\n이 함수를 실행시키면 튜플 (1, 2, 3) 을 반환합니다.\nIn [3]: return3()\nOut[3]: (1, 2, 3)\n\n튜플을 사용하는 기법중의 하나가 두 변수의 값을 서로 바꿀 때 입니다. 예를 들어 다음 코드를 봅시다.\nIn [4]: a=1;b=2;a, b = b, a\nOut[4]: (2, 1)\n\nIn [5]: println(\"a=$a, b= $b\")\na=2, b= 1\n우선 a, b 에 각각 1 과 2 를 할당했습니다. 그 다음의 a, b = b, a 를 봅시다. 우선 등호의 오른쪽 b, a 를 수행하여 (b, a) 인 튜플을 만듭니다. 그리고 a, b=b, a 를 통해 a=(b, a)[1] 과 b=(b, a)[2] 를 수행합니다. 즉 (b, a) 인 새로운 튜플을 만들고 그 값을 순서대로 a, b 에 할당하는 것이기 때문에 결과적으로 두 변수의 값을 서로 교환하게 된 것입니다.\n\n\n\n기명 튜플 (NamedTuple)\n기명 튜플은 튜플과 유사하나 성분 하나마다 특별한 이름이 붙으며, 성분에 접근할 때 인덱스를 이용할 수도 있고, 그 이름을 이용할 수도 있습니다. 기명튜플도 immutable 이므로 값을 변경하거나, 성분을 추가하거나 삭제 할 수 없습니다.\nIn [6]: ntup1 = (b=1, a=2)\nOut[6]: (b = 1, a = 2)\n\nIn [7]: ntup1.a\nOut[7]: 2\n\nIn [8]: ntup1[1]\nOut[8]: 1\n\n\n\n사전 (Dictionary)\n사전은 키(key)-값(value) 를 묶어서 여러 타입을 저장하는 컨테이너으로 성분의 값을 변경 할 수 있는 mutable 타입입니다. 아래와 같이 Dict 를 통해 선언하며 [ ] 를 통해 접근하거나 값을 변경 할 수 있습니다. 기명 튜플과는 달리 인덱스로는 접근 할 수 없습니다. 사전은 아래에서 보듯이 명시적으로 키와 와 값의 타입을 알려주지 않았더라도, 그 타입이 정의되며 만들어집니다. 아래의 dict1 은 키인 \"a\", 와 \"b\" 가 모두 문자열이기 때문에 키는 문자열 타입으로, 값인 1 과 2 가 모두 Int64 타입이므로 값은 Int64 타입으로 정의되었습니다. 즉 dict1 을 만들었을 때의 출력 Dict{String, Int64} 는 키가 문자열(String) 타입이며 값이 64비트 정수(Int64) 타입으로 한정된 사전이라는 것을 의미합니다. 원래 사전은 mutable 타입이므로 새로운 키-값 을 추가 할 수 있지만, 이것은 처음 정의될 때의 사전의 키-값 타입이 허용하는 범위 안에 있을 때만 가능합니다.\nIn [10]: dict1=Dict(\"a\"=&gt;1, \"b\"=&gt;2) # 사전 선언\nOut[10]: Dict{String, Int64} with 2 entries:\n  \"b\" =&gt; 2\n  \"a\" =&gt; 1\n\nIn [11]: dict1[\"a\"] # 사전의 성분 접근\nOut[11]: 1\n\nIn [12]: dict1[\"a\"]=3 # 사전의 값 변경\nOut[12]: 3\n\nIn [13]: dict1\nOut[13]: Dict{String, Int64} with 2 entries:\n  \"b\" =&gt; 2\n  \"a\" =&gt; 3\n\nIn [14]: dict1[\"c\"]=-2 # 사전에 새로운 키-값 추가\nOut[14]: -2\n\nIn [15]: dict1\nOut[15]: Dict{String, Int64} with 3 entries:\n  \"c\" =&gt; -2\n  \"b\" =&gt; 2\n  \"a\" =&gt; 3\n\nIn [16]: dict1[\"d\"]=3.3 # 사전의 값의 타입 범위를 벗어나는 키-값 추가 시도는 실패한다.\nERROR: InexactError: Int64(3.3)\n...\nkeys(), values() 함수를 통해 사전의 key 와 value 를 얻을 수 있으며, haskey() 함수를 통해 해당 key 가 사전에 존재하는지 확인 할 수 있습니다.\nIn [17]: keys(dict1)\nOut[17]: KeySet for a Dict{String, Int64} with 3 entries. Keys:\n  \"c\"\n  \"b\"\n  \"a\"\n\nIn [18]: values(dict1)\nOut[18]: ValueIterator for a Dict{String, Int64} with 3 entries. Values:\n  -2\n  2\n  3\n\nIn [19]: haskey(dict1, \"a\")\nOut[19]: true\n\nIn [20]: haskey(dict1, \"c\")\nOut[20]: true\n사전에 key, value 를 추가할때는 dict1[\"f\"]=5 와 같이 합니다. 사전의 값을 호출할때는 dict1[\"a\"] 처럼 사용합니다.\n사전을 처음 선언 할 때 타입을 정할 수 있습니다. 또한 임의의 타입의 키-값을 갖는 사전도 정할 수 있습니다. 예를 들어 아래의 In [21] 과 같이 Dict{Any, Any} 로 시작하는 정의를 사용하면 모든 타입의 키와 값 을 가질 수 있습니다. Any 는 Int64 나 Rational 과 같은 타입 이름으로 모든 타입을 포함하는 최상위 타입입니다. 타입에 대해 자세한것은 타입 계층 구조 에서 알아볼 것입니다.\nIn [21]: dict3=Dict{Any, Any}(\"a\"=&gt;1)\nOut[21]: Dict{Any, Any} with 1 entry:\n  \"a\" =&gt; 1\n\nIn [22]: dict3[4]=\"abcd\"\nOut[22]: \"abcd\"\n\nIn [24]: dict3[\"sinfunction\"]=sin\nOut[24]: sin (generic function with 14 methods)\n\nIn [25]: dict3[\"sinfunction\"](π/2)\nOut[25]: 1.0\n이 때 dict3[4] 의 4 는 인덱스가 아닌 키 입니다. 정수 뿐 아니라, 부동소수나 복소수도 키가 될 수 있습니다. In [24] 는 사전의 값으로 함수가 오는 것을 보여줍니다. In [25] 에서 볼 수 있듯이 사전과 키를 이용하여 함수처럼 사용 할 수 있습니다.\n\n\n\n문자열 (String)\n앞서 타입에서 알아본 문자열(String) 도 개별적인 문자에 인덱스로 접근 할 수 있으며 length() 함수로 그 길이를 알 수 있다는 점에서 컨테이너입니다. 개별적인 문자에 인덱스로 접근 할 수 있지만 바꿀 수 없으므로 immutable 입니다.\n\n\n\n집합 (Set)\n집합은 아이템의 추가나 삭제는 가능하지만 인덱스로도, 키로도 접근 할 수 없는 mutable collection 입니다. 수학적인 집합과 동일하게 같은 값을 두 개 이상 가질 수 없습니다. 예를 들어 tuple1 = (1, 2, 3, 1) 은 1 값을 두개 가지고 있지만 set1 = Set([1, 2, 3, 1]) 은 1 이 중복되므로 아이템의 갯수는 3개 입니다. 아이템을 추가할때는 push! 함수를 사용하여 push!(set1, 5) 와 같이 하며, 아이템을 제거할때는 pop!(set1, 3) 처럼 사용합니다. 마치 수학의 집합처럼 합집합 ∪(\\cup + [tab]) 나 교집합 ∩(\\cap + [tab]) 연산자를 통해 합집합과 교집합을 계산 할 수 있습니다. 실제로 ∪ 나 ∩ 는 다른 컨테이너 타입에도 사용 할 수 있습니다.\nIn [11]: A=Set([1,2, 3]);B= Set([-1, 0, 1]);\n\nIn [12]: A ∪ B\nOut[12]: Set{Int64} with 5 elements:\n  0\n  2\n  -1\n  3\n  1\n\nIn [13]: A ∩ B\nOut[13]: Set{Int64} with 1 element:\n  1\n\nIn [14]: intersect(A, B)\nOut[14]: Set{Int64} with 1 element:\n  1\n\nIn [15]: union(A, B)\nOut[15]: Set{Int64} with 5 elements:\n  0\n  2\n  -1\n  3\n  1\n\nIn [16]: (1,2, 3) ∩ [ 3, 4, 5]\nOut[16]: 1-element Vector{Int64}:\n 3",
    "crumbs": [
      "Julia 언어의 기초",
      "컨테이너"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04_containers.html#일반적인-컨테이너에-대한-연산",
    "href": "src/introduction_to_julia/04_containers.html#일반적인-컨테이너에-대한-연산",
    "title": "컨테이너",
    "section": "2 일반적인 컨테이너에 대한 연산",
    "text": "2 일반적인 컨테이너에 대한 연산\n\n∈, ∉\n우선 in 혹은 ∈ (\\in+[tab]) 은 어떤 아이템이 컨테이너에 속해있는지 여부를 true/false 로 반환합니다. 반대로 ∉(\\notin+[tab]) 은 아이템이 컨테이너에 포함되어 있지 않을 때 true 를 반환합니다. StepRange, 벡터, 집합에의 포함 여부는 다음과 같이 알 수 있습니다.\nIn [10]: 1 ∈ 1:10\nOut[10]: true\n\nIn [11]: \"a\" ∈ (2, \"5\", \"a\")\nOut[11]: true\n\nIn [12]: \"a\" ∉ (2, \"5\", \"a\")\nOut[12]: false\n\nJulia 는 키-값 쌍을 Pair 라는 객체로 처리합니다. 사전에 어떤 키가 포함되어있는지, 값이 포함되어 있는지는 keys, values 함수로 알 수 있습니다. 키-값 쌍이 있는지는 다음과 같이 확인 할 수 있습니다.\nIn [13]: Pair(\"a\", 1) ∈ Dict(\"a\"=&gt;1, \"b\"=&gt;2)\nOut[13]: true\n\n우리는 앞서 홑따옴표 ' ' 안에는 글자 하나만 포함 될 수 있으며 Char 타입이고 겹따옴표 \" \" 는 한줄 문자열, 세겹따옴표는 \"\"\" \"\"\" 여러줄 문자열을 포함한다는 것을 알았습니다. 따라서 ∈ 나 ∉ 연산자로 포함 여부를 확인할 때 연산자의 왼쪽에는 Char 형식의 한 글자에 대해서만 가능합니다. 즉\nIn [19]: 'a' ∈ \"abc\"\nOut[19]: true\n\nIn [20]: \"a\" ∈ \"abc\"\nERROR: use occursin(needle, haystack) for string containment\n...\n의 결과를 보입니다. \"a\" 는 하나의 성분을 갖는 컨테이너이므로 ∈ 나 ∉ 의 왼쪽에 올 수 없습니다.\n\n\n\nlength\nlength 함수는 컨테이너에 포함된 아이템의 갯수를 반환합니다.\nIn [1]: length(Dict(\"a\"=&gt;1, \"b\"=&gt;2))\nOut[1]: 2\n\nIn [2]: length([1, 2, (3, 4, 5)])\nOut[2]: 3\n\n\n\neltype\neltype 은 컨테이너에 포함된 아이템의 타입을 반환합니다.\nIn [1]: eltype([1.0, 2.0, 3.0])\nOut[1]: Float64\n\nIn [2]: eltype(['a', 'b', 'c'])\nOut[2]: Char\n\n\n\nunique\n컨테이너에 포함된 아이템 가운데 중복되는 것을 제외한 아이템들을 벡터로 반환합니다.\njulia&gt; unique((1, 2, 3, 1, 2, 4))\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n\n... 연산자\n... 연산자가 함수의 정의나 실행시에 사용되는 것에 대해서는 Interude : ‘…’ 연산자 에 대해 좀 더 자세히 다루었습니다.\n순서가 있는 컨테이너에서 앞부분의 몇개만 중요할 때 사용할 수 있습니다. 예를 들어\nIn [1]: a, b, c... = [4, 8, 15, 16, 23, 42]\nOut[1]: 6-element Vector{Int64}:\n  4\n  8\n 15\n 16\n 23\n 42\n\nIn [2]: a\nOut[2]: 4\n\nIn [3]: b\nOut[3]: 8\n\nIn [4]: c\nOut[4]: 4-element Vector{Int64}:\n 15\n 16\n 23\n 42\n입니다. 즉 1차원 배열 A 에 대해 첫번째 두개만 중요할 경우 a, b, c.. = arr1 와 같이 사용하면 a==A[1], b==A[2] 이며 c==A[3:end] 가 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "컨테이너"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04_containers.html#주로-수로-이루어진-순서가-있는-컨테이너에서-이루어지는-연산",
    "href": "src/introduction_to_julia/04_containers.html#주로-수로-이루어진-순서가-있는-컨테이너에서-이루어지는-연산",
    "title": "컨테이너",
    "section": "3 주로 수로 이루어진 순서가 있는 컨테이너에서 이루어지는 연산",
    "text": "3 주로 수로 이루어진 순서가 있는 컨테이너에서 이루어지는 연산\n여기서는 벡터나 StepRange 같은 인덱스로 접근 가능한 컨테이너에 대해 성분이 모두 수로 이루어졌을 때 사용할 수 있는 연산에 대해 다루도록 하겠습니다. 많은 경우 수가 아닌 경우에도 사용 할 수 있지만 여기서는 수로 이루어진 컨테이너에 대해서만 논의하기로 합니다.\n\n\n. 연산 (도트 연산)\n벡터나 튜플, StepRange 같은 컨테이너의 아이템 마다 함수나 연산자를 적용시킬 때 도트 연산자 . 를 사용할 수 있습니다. 함수 이름의 끝에 . 를 붙이거나, 연산자의 앞에 . 를 붙입니다. 이를 도트 연산이라고 합니다.\n\n스칼라와 컨테이너의 연산에서는 컨테이너의 각 성분과 스칼라와의 연산 결과를 반환합니다.\n순서가 있는 컨테이너과 컨에티너의 연산에서는 컨테이너의 각 순서별 성분끼리 연산합니다.\n순서가 없는 컨테이너(예를 들어 집합(Set)) 에 도트연산을 수행 할 수 있지만 그 순서가 유지되지 않으며, 어쨋든 계산이 되면 그 결과는 벡터가 됩니다.\n\n아래의 코드를 봅시다.\n# 스칼라와 컨테이너의 도트 연산\nIn [13]: 3 .* (1, 2, 3)\nOut[13]: (3, 6, 9)\n\n# 순서가 있는 컨테이너의 도트 연산\nIn [14]: [1, 2, 3] .* [-1, 0, 1]\nOut[14]: 3-element Vector{Int64}:\n -1\n  0\n  3\n\n# 함수에서의 도트 연산. 함수 이름 끝에 . 를 붙이기만 하면 됩니다.\nIn [15]: sin.([-π/2, 0.0, π/2])\nOut[15]: 3-element Vector{Float64}:\n -1.0\n  0.0\n  1.0\n\n# 순서가 없는 컨테이너에 대한 도트 연산. 순서가 유지되지 않음.\nIn [16]: 3.0 .* Set([1, 2, 3])\nOut[16]: 3-element Vector{Float64}:\n 6.0\n 9.0\n 3.0\n\n함수나 연산자마다 . 을 붙여주는 것이 코드의 가독성을 해치거나 오류의 원인이 될 수 있습니다. 이때는 표현식 앞에 @. 를 붙여주면 julia 는 모든 연산자와 함수에 필요할 때 . 가 붙은 것처럼 작동하도록 합니다. @ 로 시작하는 명령문은 매크로라고 하며 특정한 기능을 하는 함수로 julia 의 핵심적인 기능중의 하나입니다. 자세한 것은 메타프로그래밍과 매크로 에서 다루겠습니다. 일단 다음 코드를 봅시다.\nIn [1]: @. 3+[1,2,3,4]\nOut[1]: 4-element Vector{Int64}:\n 4\n 5\n 6\n 7\n\nIn [2]: @. sin(0.0:0.1:π)\nOut[2]: 32-element Vector{Float64}:\n 0.0\n 0.09983341664682815\n 0.19866933079506122\n 0.2955202066613396\n 0.3894183423086505\n 0.479425538604203\n ⋮\n 0.4273798802338298\n 0.33498815015590466\n 0.23924932921398198\n 0.1411200080598672\n 0.04158066243329049\n\nIn [3]: a = @. 3 * [1,2,3]\nOut[3]: 3-element Vector{Int64}:\n 3\n 6\n 9\n\n\n\n\n\n\n도트연산자와 소숫점의 혼동\n\n\n\n3.*[1, 2, 3] 수행하면 (3 과 .* 사이에 공백이 없는 경우 입니다) 에러가 발생합니다. Julia 에서는 정수 다음에 . 이 붙을 경우 부동소수로 간주합니다. 예를 들어 julia 는 -1. 을 -1.0 으로 해석합니다. 따라서 3.*[1, 2, 3] 는 (3.0) * [1, 2, 3] 로 해석 될 수도 있고 (3) .* [1, 2, 3] 으로 해석 될 수도 있습니다. .* 와 같이 도트를 앞에 붙여서 사용하는 연산의 경우는 . 앞에 공백을 앞에 두는 습관을 들이는 것이 좋습니다.\n\n\n1차원 컨테이너 끼리의 도트 연산을 위해서는 컨테이너의 크기가 같아야 합니다. 다차원 배열의 경우는 배열 에서 다루겠습니다.\n\n\n\nminimum, maximum, extrema\n이 함수들은 컨테이너에 포함되는 값 가운데의 최소값(minimum), 최대값(maximum), 그리고 둘 다(extrema)를 반환합니다. 단 이때는 컨테이너의 모든 아이템들이 서로 비교 가능해야 합니다. 예를 들어 정수와 부동소수는 비교가능 하지만 수와 문자열은 서로 크기를 비교 할 수 없습니다. 따라서 수와 문자열을 같이 포함하는 컨테이너에서는 위의 함수들을 사용 할 수 없습니다.\nIn [23]: extrema(1:5)\nOut[23]: (1, 5)\n\nIn [24]: maximum([1, 2, \"ab\"])\nERROR: MethodError: no method matching isless(::String, ::Int64)\n...\n이 함수들은 어떤 컨테이너의 극값 뿐만 아니라 컨테이너에 함수를 적용했을 때의 최대값 최소값을 구하는 데도 사용 할 수 있습니다. 예를 들어,\nIn [25]: extrema(cos, 0:π/1000:π)\nOut[25]: (-1.0, 1.0)\n는 0:π/1000:π 에 대한 각각의 cos 값의 최소값과 최대값을 반환합니다.\n\n\n\nargmin, argmax, findmin, findmax\nargmin, argmax 는 각각 컨테이너에서 최소값과 최대값의 인덱스를 반환하며, 그 값이 여러개일 경우 첫번째 인덱스를 반환합니다. findmin, findmax 는 각각 최대값, 최소값에 대해 값과 인덱스를 튜플로 반환합니다.\nIn [29]: argmin([2, 3, 1, 2, 3, 1, 4, 1, 6])\nOut[29]: 3\n\nIn [30]: findmax([2, 3, 1, 2, 3, 1, 4, 1, 6])\nOut[30]: (6, 9)\n함수에 대한 결과값의 최대, 최소를 구할 수도 있습니다.\nIn [35]: findmax(cos, range(0.0, π, length=30))\nOut[35]: (1.0, 1)\n\n\n\n\n\n\nargmin, argmax 의 주의사항\n\n\n\nargmin, argmax 도 함수를 입력하면 에러가 나지 않지만 우리가 기대하는 행동을 하지 않습니다. 예를 들어\nIn [37]: argmin(cos, range(0.0, π, length=30))\nOut[37]: 3.141592653589793\n의 경우 range(0.0, π, length=30) 에 cos 함수를 적용시켰을 때 최소값이 나오는 인덱스(이경우30) 이 나오길 기대할 수 있지만 cos 함수를 최소화하는 range(0.0, π, length=30) 에서의 값을 반환합니다. argmax 도 같은 방식으로 동작합니다. 혼란을 줄 수 있으므로 왠만하면 argmin, argmax 는 사용하지 말고 findmin, findmax 를 사용하시기를 권합니다.\n\n\n\n\n\nmap\n함수 f 와 컨테이너 c 에 대해 map(f, c) 는 c 의 개별적인 성분에 f 를 적용한 값을 리턴합니다.\nIn [1]: map(abs, [1, -1, 2, -2, 3, -5])\nOut[1]: 6-element Vector{Int64}:\n 1\n 1\n 2\n 2\n 3\n 5\n\n인자가 여러개인 함수에 대해서는 여러개의 컨테이너를 인자로 입력합니다.\nIn [4]: f(x, y) = x+y\nOut[4]: f (generic function with 1 method)\n\nIn [5]: map(f, [1,2, 3], [3, 4,5])\nOut[5]: 3-element Vector{Int64}:\n 4\n 6\n 8\n\n인자로 주어지는 컨테이너의 갯수가 다를 때는 길이가 최소인 컨테이너에 맞추며 나머지 컨테이너의 성분은 무시합니다.\nIn [6]: map(f, [1,2, 3], [3, 4,5, 6, 7])\nOut[6]: 3-element Vector{Int64}:\n 4\n 6\n 8\n\n함수 뿐만 아니라 연산자가 올 수 도 있습니다.\nIn [8]: map(÷, [4, 7, 9], [2, 3, 5])\nOut[8]: 3-element Vector{Int64}:\n 2\n 2\n 1\n\n\n익명 함수의 사용\nmap 뿐만 아니라 바로 뒤에 나올 reduce, mapreduce, filter 에 익명 함수 가 아주 유용하게 사용될 수 있습니다. 예를 들어\nIn [3]: map(x-&gt;cos(x)+1, range(0, π, length=4))\nOut[3]: 4-element Vector{Float64}:\n 2.0\n 1.5\n 0.5000000000000002\n 0.0\n를 봅시다. range(0, π, length=4) 는 0 부터 π 까지 같은 간격을 가진 4개의 성분을 가진 배열을 만듭니다. 이 배열의 각각의 성분에 cos 함수를 취한후 1 을 더하는 익명함수 x-&gt;cos(x)+1 을 적용시킨 결과입니다. 도트 연산자르르 사용하면 똑같은 일을 할 수 있지만 아무래도 map 함수 쪽이 훨씬 읽기 편합니다.\nIn [3]: cos.(range(0, π, length=4)) .+ 1\n\n\n\ndo ... end, begin ... end 의 사용\ndo ... end 구문이나 begin ... end 구문 역시 일종의 익명 함수를 만드는 데 사용될 수 있습니다. 당연히 컨테이너에만 사용되는 것은 아니지만 컨테이에 대한 연산, 특히 map 이나 앞으로 나올 reduce, filter 등의 함수에 유용하게 사용 할 수 있습니다. 일단 In [3] 와 같은 결과를 내는 코드는 다음과 같습니다.\\(^\\ast\\) \\(^\\ast\\) 함수의 정의에서 return 문이 없다면 end 바로전의 표현식의 결과를 반환한다는 것을 알았습니다. 아래 코드에서도 마찬가지로 return cos(x)+1 대신에 cos(x)+1 만 있어도 실행됩니다.\nIn [4]: map(range(0, π, length=4)) do x\n        return cos(x)+1\n        end\n\nIn [5]: map( x-&gt; begin\n        return cos(x) +1\n        end\n        , range(0, π, length=4))\n우선 함수 f1 을 첫번째 인자로 받는 함수 mfunc(f1, b...) 에서 f1 의 정의를 mfunc(b...) do x 로 시작합니다. 이 때 x 는 f1 의 인자입니다. 그 이후 구문은 end 가 나올 때 까지 f1 을 정의하는 구문과 같습니다. do ... end 구문이나 begin ... end 구문에서는 변수를 선언하여 활용 할 수 있습니다.\nmap(0.0:0.1:π) do x\n    y = sqrt(x)\n    z = x^2\n    cos(y+z)\nend\n이 코드는 다음과 두 코드와 각각 같습니다.\nfunction f1(x)\n    y = sqrt(x)\n    z = x^2\n    cos(y+z)\nend\n\nmap(f1, 0.0:0.1:π)\nmap(x-&gt;begin\n    y = sqrt(x)\n    z = x^2\n    cos(y+z)\n    end, \n    0.0:0.1:π)\n\n\n\n\nreduce\nmap 이 컨테이너의 각 성분에 연산을 수행한다면, 그래서 결과는 입력된 컨테이너의 길이와 같은 벡터가 된다면 reduce 는 컨테이너에 대해 각각의 성분에 대해 연산을 수행하여 하나의 값을 얻는데 사용합니다. 예를 들어\nreduce(+, [1,2, 3, 4])\n를 봅시다. reduce 는 우선 첫번째와 두번째 성분으로 주어진 연산자나 함수에 대해 계산한 후 결과값을 세번째성분과 계산하고 이것을 마지막 성분까지 계속합니다. 즉 위의 코드는 (((1+2)+3)+4) 와 같습니다. 그렇다면\nreduce(-, [1,2, 3, 4])\n는 (((1-2)-3)-4) 와 같습니다.\n\n\n\nmapreduce\nmapreduc 는 map 과 reduce 를 합친 기능을 합니다. mapreduce(f, op, iter) 는 reduce(op, map(f, iter)) 와 같은 역할을 합니다. 예를 들어 다음 두 명령어는 기능적으로 같습니다. 1 에서 10 까지의 정수를 제곱한 배열을 만든 후 그 배열의 합을 구하는 것입니다.\nmapreduce(x-&gt;x^2, +, 1:10)\nreduce(+, map(x-&gt;x^2, 1:10))\n\n\nfilter\nfilter(f, c) 에서 f 는 true 혹은 false 를 반환하는 함수나 연산자이어야 합니다. 컨테이너의 성분에 함수를 적용했을 때 참인 성분만을 골라 반환합니다. 예를 들어,\nIn [1]: filter(x-&gt;(x&gt;3), [1,2,3,4,5])\nOut[1]: 2-element Vector{Int64}:\n 4\n 5\n를 봅시다. x-&gt;(x&gt;3) 은 익명함수로 x&gt;3 의 조건을 만족하면 true, 그렇지 않다면 false 를 리턴합니다. 따라서 이 조건을 만족하는 [4, 5] 만을 반환합니다.\n참고로 3보다 큰 성분을 배열로 리턴하는 것이 아니라 3보다 크면 1, 3보다 작으면 0 을 리턴하도록 하려면 어떻게 하면 될까요? 아래를 보고 왜 이렇게 작동하는지 생각해 보시기 바랍니다.\nIn [2]: [1, 2, 3, 4, 5] .&gt; 3\nOut[2]: 5-element BitVector:\n 0\n 0\n 0\n 1\n 1",
    "crumbs": [
      "Julia 언어의 기초",
      "컨테이너"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06I_function_composition_and_piping.html",
    "href": "src/introduction_to_julia/06I_function_composition_and_piping.html",
    "title": "Interlude : 함수의 합성과 전달",
    "section": "",
    "text": "함수의 합성은 ∘ 연산자를 이용하며 \\circ + [탭키] 로 입력합니다. 예를 들어\nIn [1]: (sqrt ∘ +)(9, 16)\nOut[1]: 5.0\n를 봅시다. 두개의 인자 9 와 16 을 더한 후 제곱근을 반환하며, 이것은 보통의 수학적인 합성함수의 정의와 일치합니다. 한 함수의 반환값을 다른 함수의 입력값으로 사용 할 때 함수의 합성을 사용하며, 함수의 합성은 다수의 함수에 대해서도 가능합니다.\nIn [2]: (sin ∘ sqrt ∘ -)(π, π/4)\nOut[2]: 0.9993590241845508\n\n합성연산자는 컨테이너에 대한 도트 연산을 수행할 수 없습니다. 합성연산자와 비슷한 기능을 하며 도트 연산도 수행할 수 있는 것이 전달연산자 |&gt; 입니다.\n\n\n\n\n|&gt; 는 기본적으로 합수의 합성과 같습니다. In [1] 과 In [2] 를 |&gt; 을 사용한 표현으로 바꾸면 다음과 같습니다.\nIn [3]: +(9, 16) |&gt; sqrt\nOut[3]: 5.0\n\nIn [4]: -(π, π/4) |&gt; sqrt |&gt; sin\nOut[4]: 0.9993590241845508\n|&gt; 의 오른쪽의 연산 결과를 |&gt; 왼쪽 함수에 대한 입력으로 사용합니다. In [4] 에서와 같이 |&gt; 연산자를 이어서 사용 할 수도 있습니다.\n앞서 말한 것처럼 .|&gt; 와 같은 도트 연산도 가능합니다.\nIn [6]: 0:0.01:π .|&gt; cos |&gt; maximum\nOut[6]: 1.0\n익명 함수를 사용할 수도 있습니다.\nIn [2]: -π:0.001:π .|&gt; (x-&gt;x^2 * cos(x)) |&gt; maximum\nOut[2]: 0.5497738913075754\n여기서 가운데의 (x-&gt;x^2 * cos(x)) 에서 가장 바깥의 괄호를 표기하지 않으면 julia 는 연산자의 우선순위 상 -π:0.001:π .|&gt; x-&gt; (x^2 * cos(x)) |&gt; maximum) 로 해석을 하기 때문에 다른 결과가 나옵니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 함수의 합성과 전달"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06I_function_composition_and_piping.html#합성연산자",
    "href": "src/introduction_to_julia/06I_function_composition_and_piping.html#합성연산자",
    "title": "Interlude : 함수의 합성과 전달",
    "section": "",
    "text": "함수의 합성은 ∘ 연산자를 이용하며 \\circ + [탭키] 로 입력합니다. 예를 들어\nIn [1]: (sqrt ∘ +)(9, 16)\nOut[1]: 5.0\n를 봅시다. 두개의 인자 9 와 16 을 더한 후 제곱근을 반환하며, 이것은 보통의 수학적인 합성함수의 정의와 일치합니다. 한 함수의 반환값을 다른 함수의 입력값으로 사용 할 때 함수의 합성을 사용하며, 함수의 합성은 다수의 함수에 대해서도 가능합니다.\nIn [2]: (sin ∘ sqrt ∘ -)(π, π/4)\nOut[2]: 0.9993590241845508\n\n합성연산자는 컨테이너에 대한 도트 연산을 수행할 수 없습니다. 합성연산자와 비슷한 기능을 하며 도트 연산도 수행할 수 있는 것이 전달연산자 |&gt; 입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 함수의 합성과 전달"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06I_function_composition_and_piping.html#전달-연산자",
    "href": "src/introduction_to_julia/06I_function_composition_and_piping.html#전달-연산자",
    "title": "Interlude : 함수의 합성과 전달",
    "section": "",
    "text": "|&gt; 는 기본적으로 합수의 합성과 같습니다. In [1] 과 In [2] 를 |&gt; 을 사용한 표현으로 바꾸면 다음과 같습니다.\nIn [3]: +(9, 16) |&gt; sqrt\nOut[3]: 5.0\n\nIn [4]: -(π, π/4) |&gt; sqrt |&gt; sin\nOut[4]: 0.9993590241845508\n|&gt; 의 오른쪽의 연산 결과를 |&gt; 왼쪽 함수에 대한 입력으로 사용합니다. In [4] 에서와 같이 |&gt; 연산자를 이어서 사용 할 수도 있습니다.\n앞서 말한 것처럼 .|&gt; 와 같은 도트 연산도 가능합니다.\nIn [6]: 0:0.01:π .|&gt; cos |&gt; maximum\nOut[6]: 1.0\n익명 함수를 사용할 수도 있습니다.\nIn [2]: -π:0.001:π .|&gt; (x-&gt;x^2 * cos(x)) |&gt; maximum\nOut[2]: 0.5497738913075754\n여기서 가운데의 (x-&gt;x^2 * cos(x)) 에서 가장 바깥의 괄호를 표기하지 않으면 julia 는 연산자의 우선순위 상 -π:0.001:π .|&gt; x-&gt; (x^2 * cos(x)) |&gt; maximum) 로 해석을 하기 때문에 다른 결과가 나옵니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 함수의 합성과 전달"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07I_sort.html",
    "href": "src/introduction_to_julia/07I_sort.html",
    "title": "Interlude : 정렬",
    "section": "",
    "text": "Interlude : 정렬\n정렬(sorting)이란 데이터를 정해진 순서에 따라 나열하는 것을 말합니다. 예를 들어 \\(1, 3, 2\\) 를 오름차순으로 정렬하면 \\(1, 2, 3\\) 이 되고, 내림차순으로 정렬하면 \\(3, 2, 1\\) 이 됩니다. 일반적으로 정렬이라고 하면 오름차순 정렬을 말합니다.\n정렬은 컴퓨터로 아주 많이 수행하는 연산중의 하나이며, 정렬을 효율적으로 하기 위해 많은 알고리즘이 제안되기도 하였습니다. 여기서는 그 알고리즘을 다루지는 않으며, 기본적인 정렬 함수와 그 사용법에 대해서만 다루도록 합니다. 좀 더 자세히 알고 싶으면 julia 문서 Soring and Related Functions 를 참고하시기 바랍니다.\nsort() 가 정렬을 수행하는 기본적인 함수입니다. sort(a) 는 컨테이너 a 를 정렬한 컨테이너를 반환하며 a 자체를 바꾸지는 않습니다. 그러나 sort!(a) 는 a 를 정렬된 상태로 바꿉니다. 그리고 함수 인자에 rev = true 를 입력하면 내림차순으로 정렬합니다.\nIn [1]: a=[1, 3, 5, 2]; b = sort(a)\nOut[1]: 4-element Vector{Int64}:\n 1\n 2\n 3\n 5\n\nIn [2]: sort!(b, rev = true);\n\nIn [3]: b\nOut[3]: 4-element Vector{Int64}:\n 5\n 3\n 2\n 1\nsortperm() 함수는 컨테이너가 정렬되었을 때의 인덱스를 반환합니다. 예를 들어 v=[11, 3, 22] 일 때 v 를 정렬하면 [3, 11, 22] 될 것이며 원래 v 의 입장에서는 v[2], v[1],v[3]가 될 것입니다.sortperm()함수는 바로 그 인덱스[2, 1, 3]` 을 반환합니다.\nIn [1]: v = [11, 3, 22]\nOut[1]: 3-element Vector{Int64}:\n 11\n  3\n 22\n\nIn [2]: sortperm(v)\nOut[2]: 3-element Vector{Int64}:\n 2\n 1\n 3\n배열 a 에 대해 a[[1, 3, 2, 4]] 는 [a[1], a[3], a[2], a[4]] 와 같습니다. 즉 a[sortperm(a)] 는 sort(a) 와 같습니다. sortperm 함수는 어떤 컨테이너의 정럴 순서로 다른 컨테이너를 정렬 할 수 있게 해 줍니다. 예를 들어 우리가 다음과 같은 데이터를 얻었다고 합시다.\n\n\n\nx\ny\n\n\n\n\n5\n10\n\n\n2\n3\n\n\n1\n6\n\n\n7\n12\n\n\n\n배열 x 는 [5, 2, 1, 7] 이고 y 는 [10, 3, 6, 12] 입니다. 이것을 보기 좋게 x 의 순서대로 y 까지 정렬해 봅시다..\nIn [10]: x=[5, 2, 1, 7];y=[10, 3, 6, 12];\n\nIn [11]: v = sortperm(x); x1 = x[v]; y1 = y[v]\nOut[11]: 4-element Vector{Int64}:\n  6\n  3\n 10\n 12\n\nIn [12]: for (x, y) in zip(x1, y1)\n         @show x, y\n         end\n(x, y) = (1, 6)\n(x, y) = (2, 3)\n(x, y) = (5, 10)\n(x, y) = (7, 12)\nx1 과 y1 이 각각 x 의 순서대로 x 와 y 를 정렬한 것임을 확인 할 수 있습니다..\n\n\n함수에 의한 정렬\n함수 f 에 대해 b = sort(a, by = f) 는 함수 f 의 결과값에 따라 a 를 정렬한 배열입니다. 다음 예를 봅시다. sort(0, by=cos) 은 a[perm(cos.(0))] 와 같습니다. 물룐 rev=true 를 인자로 넣으면 역순으로 정렬합니다.\nIn [1]: θ = [0, π/2, π, 3*π/2]\nOut[1]: 4-element Vector{Float64}:\n 0.0\n 1.5707963267948966\n 3.141592653589793\n 4.71238898038469\n\nIn [2]: θ[sortperm(cos.(θ))]\nOut[2]: 4-element Vector{Float64}:\n 3.141592653589793\n 4.71238898038469\n 1.5707963267948966\n 0.0\n\nIn [3]: sort(θ, by = cos)\nOut[3]: 4-element Vector{Float64}:\n 3.141592653589793\n 4.71238898038469\n 1.5707963267948966\n 0.0\n\nIn [4]: sort(θ, by = cos, rev=true)\nOut[4]: 4-element Vector{Float64}:\n 0.0\n 1.5707963267948966\n 4.71238898038469\n 3.141592653589793",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 정렬"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/08I_documentation.html",
    "href": "src/introduction_to_julia/08I_documentation.html",
    "title": "Interlude : 문서화",
    "section": "",
    "text": "Interlude : 문서화\n함수나 연산자에 대해 알고 싶을 때 도움말은 다음과 같이 사용 할 수 있습니다.\n\nJulia REPL : ? 를 쳐 들어가는 help? 프롬프트에 함수 이름 등을 입력하고 엔터를 누른다.\nJupyter Notebook/Lab : 입력 셀에 ? 이후 함수 이름등을 입력하고 실행시킨다.\nvscode notebook : 입력 셀에 함수 이름 등을 입력하고 마우스 포인터를 위로 이동시킨다.\n\n여기서 보이는 도움말은 별도의 문서가 있는 것이 아니라 해당 함수나 뒤에 나올 복합타입 등의 위에 세겹 따옴표 \"\"\" 를 사용하여 표기합니다. 예를 들어 다음을 doctest01.jl 로 저장해 봅시다.\n\"\"\"\n    bps(a::Number) \n\n`a` 에 2를 곱한다.\n\n# Example\n\n```julia-repl\njulia&gt; bps([1 2;3 4])\n\n2×2 Matrix{Int64}:\n 2  4\n 6  8\n\n\"\"\"\nfunction bps(a::Number) \n    return a*2\nend\njulia REPL 이나 jupyter 노트북에서는\ninclude(\"doctest01.jl\")\n를 이용하여 파일을 포함하면 각각의 방법을 통해 bps 에 대한 도움말을 볼 수 있습니다. vscode 에서는 2023년 8월 현재 단순히 include 를 통해 포함시킨 julia 함수에 대한 도움말을 볼 수는 없는 것 같습니다.\n함수 혹은 객체에 대한 도움말을 작성 할 때 julia 언어에서 권고하는 몇가지 방침이 있습니다. 여기에 공식 문서 Documentations 의 지침을 요약하여 설명합니다. 영어를 기준으로 기술되었기 때문에 한국어와는 잘 안맞을 수도 있습니다.\n\nJulia 마크다운(markdown) 문법으로 작성합니다.\n\nJulia 의 마크다운은 일반적인 마크다운과 약간 다릅니다. 예를 들어 일반적인 마크다운에서 문장내 수식이 $\\sin x$ 형식으로 가능하지만 julia 마크다운에서는 문장 내 수식이 불가능하며 코드블럭을 이용하여 다음과 같이 사용합니다.\n\n\n```math\nf(a) = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} (\\alpha+R\\cos(\\theta))d\\theta\n```\n```\n\n4개의 공백으로 들여쓰기를 한후 함수의 시그너쳐를 표현합니다.\n\n기본적으로 함수 정의의 시그너쳐를 그대로 쓰지만 시그너쳐가 너무 길 경우 인자의 타입을 생략하는 등의 간략화도 가능합니다.\n기본값이 정해진 선택적 인자는 그 기본값도 표시합니다. func(x, y=1) 과 같이 표현합니다.\n기본값이 없는 선택적 인자는 [ ] 안에 표현합니다. func(x, [y]) 나 func(x[, y[, z]]) 와 같이 표현합니다. 혹은 각각의 경우에 대해 별도의 문단에서 설명 할 수 있습니다.\n키워드 인자를 받는 함수의 경우 키워드 인자의 갯수가 많으면 func(x; &lt;keyword arguments&gt;) 와 같이 쓰고 뒤에 별도로 셜명합니다.\n\n시그너쳐 아랫줄의 설명은 함수가 어떤 기능을 하는지 한 문장으로 짧게 설명하는 것으로 시작합니다. 이 한문장 설명 이후 두번째 문장부터는 필요하다면 상세히 설명합니다.\n\n첫번째 한문장으로 설명하는 문장은 명령문 혹은 지시문의 형태를 사용하며 함수를 주어로 하는 3인칭을 사용하지 않으며 마침표로 끝납니다.\n함수의 의미를 간단 명료하게 요약하기 힘들 경우, 각각의 분야에 대해 자세하며 전체적으로는 일관된 기술로 대신 할 수 있습니다.\n\n반복은 피하십시요.\n\n예를 들어 첫줄의 함수 시그너쳐 부분에 함수 이름이 있기 때문에 다음에 나오는 한문장 설명이 bps 함수는 으로 시작될 필요가 없습니다. 또한 인자 유형이 시그너쳐에 표현될 경우 굳이 그것을 다시 설명할 필요도 없습니다.\n\n꼭 필요할 경우에만 인자들의 목록을 제시합니다.\n\n간단한 함수의 경우는 인자들의 역할만 기술합니다.\n키워드 인자가 많은 경우와 같이 함수 시그너쳐가 복잡할 경우는 인자들의 목록을 제시하는 것이 오히려 나을 경우가 있습니다.\n\n관련된 함수에 대한 정보를 제공합니다.\n\nsin 함수에 대한 도움말에\n\nSee also [`sind`](@ref), [`sinpi`](@ref), [`sincos`](@ref), [`cis`](@ref), [`asin`](@ref).\n라고 쓰인 것처럼 하면 됩니다.\n# Example 절에 예를 들어 줍니다. 마크다운 문법에서 코드블럭은 ```jldoctetst 로 시작해서 ``` 로 끝납니다.\n\n\"\"\"\nSome nice documentation here.\n\n# Examples\n```jldoctest\njulia&gt; a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n```\n\"\"\"\n# Examples 섹션은 패키지가 제대로 설치되었는지 확인할 수 있는 간단한 코드를 넣습니다. 가능하면 julia REPL 에서 실행하는 코드를 넣는것이 좋습니다. 임의의 수를 생성하는 rand 함수 같은 것은 실행할 때 마다 결과가 다를 수 있기 때문에 꼭 필요한 경우가 아니라면 사용하지 않는 것이 좋습니다.\n\n물론 이 원칙이 항상 적용되는 것도 아니며, 많은 유명한 패키지들도 이런 원칙을 다 지키는 것은 아니지만 이런 것들을 따르는 것이 도움이 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 문서화"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/09I_pretty_printing.html",
    "href": "src/introduction_to_julia/09I_pretty_printing.html",
    "title": "Interlude : 객체를 보기좋게 출력하기",
    "section": "",
    "text": "Interlude : 객체를 보기좋게 출력하기\n복소수를 나타내는 Complex 타입은 복합 타입이며 복소수에 대한 출력은 다음과 같습니다.\nIn [1]: c1 = Complex(2.0, 3.0)\nOut[1]: 2.0 + 3.0im\n당신이 만약 당신만의 복소수 타입을 복합타입으로 만들었다고 합시다.\nIn [2]: struct mycomplex\n        re\n        im\n        end\n\nIn [3]: c2 = mycomplex(2.0, 3.0)\nOut[3]: mycomplex(2.0, 3.0)\n보통 복합 타입의 출력은 위와 같이 타입 이름 뒤에 괄호로 그 필드의 값을 정의된 순서대로 나열합니다. 만약 어떤 타입에 많은 필드가 있지만 실제로 사용하면서 확인해야 할 필드는 소수라면, 굳이 여러개의 필드를 보여주지 않아도 됩니다. 혹은 Complex 타입에서 순허수 \\(\\sqrt{-1}\\) 를 im 으로 표기하는 것이 당신의 미적 감각에 거슬릴 수도 있습니다. 이 때 Base.show 함수를 mycomplex 타입에 대한 메서드로 만든다면 그 출력을 바꿀 수 있습니다.\nIn [12]: Base.show(io::IO, cc::mycomplex) = print(io, cc.re , \" + i\",  cc.im)\n\nIn [13]: c2\nOut[13]: 2.0+ i 3.0\n\nIn [14]: [mycomplex(2.0, 3.0); mycomplex(3.0, 4.0)]\nOut[14]: 2-element Vector{mycomplex}:\n 2.0 + i3.0\n 3.0 + i4.0\n그런데 허수부가 음수일 경우에는 별로 보기 안좋습니다.\nIn [20]: mycomplex(2.0, -1.0)\nOut[20]: 2.0 + i-1.0\n이것은 표준적인 복소수 표기법에 어긋나죠. 우리가 원하는 것은 2.0 - i1.0 입니다.\nIn [23]: function Base.show(io::IO, cc::mycomplex)\n         if cc.im &gt;= 0.0\n             print(io, cc.re, \" + i\", cc.im)\n         else\n             print(io, cc.re, \" - i\", abs(cc.im))\n         end\n         end\n\nIn [24]: mycomplex(2.0, -1.0)\nOut[24]: 2.0 - i1.0\n이젠 좀 괜찮아 진 것 같습니다. 물론 mycomplex 타입은 기본적인 사칙연산도 정의가 안되어 있기 때문에 쓸모 없긴 합니다. repr 함수는 Base.show 함수로 출력하는 문자열을 리턴합니다. 예를 들어\nIn [25]: c=mycomplex(1.0, -1.0)\nOut[25]: 1.0 - i1.0\n\nIn [26]: c\nOut[26]: 1.0 - i1.0\n\nIn [27]: repr(c)\nOut[27]: \"1.0 - i1.0\"\n입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 객체를 보기좋게 출력하기"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10I_exception.html",
    "href": "src/introduction_to_julia/10I_exception.html",
    "title": "Interlude : 예외 처리",
    "section": "",
    "text": "예를 들어 길이가 3인 일차원 벡터의 네번째 성분에 접근할 경우, julia 인터프리터는 BoundsError 를 발생시키고 실행을 종료합니다.\nIn [1]: aa=[1,2,3];println(aa[4]);println(\"End\")\nERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]\nStacktrace:\n이렇게 줄리아 코드가 실행중일 때 실행을 지속시키지 못하거나 후속 처리가 필요한 중대한 조건을 예외(Exception) 라고 합니다. 위의 경우처럼 julia 인터프리터가 예외를 발생시킬 수도 있으며, 프로그래머가 의도적으로 예외를 발생시킬 수도 있습니다. 발생한 예외에 대해서는 프로그램 실행을 중단시킬 수도 있고, 예외에 따라 적합한 처리를 수행할 수도 있습니다. 이를 예외 처리(Exception handling) 라고 합니다.\nJulia 에서 기본적으로 제공하는 예외는 기본 매뉴얼의 Built-in Exceptions 에 나와 있습니다. Julia 에서 제공하는 에러 가운데 자주 사용되는 것들을 표 1 에 정리하였습니다.\n\n\n\n표 1: Julia 의 주요 에러\n\n\n\n\n\n\n\n\n\n\n에러\n설명\n예\n\n\n\n\nArgumentError\n함수에 유효하지 않은 인자가 입력된경우\nparse(Int, \"abc\")\n\n\nBoundsError\n인덱스로 접근하는 컨테이너에 범위를 벗어나는 인덱스로 접근했을 때\na=[1, 2];b=a[3]\n\n\nDimensionMismatch\n호출된 객체가 차원에 대한 불일치가 발생할 때\n[1 2;3 4]+[1 2]\n\n\nDivideError\ndiv 함수를 사용하며 정수를 0 으로 나눌 때\ndiv(5, 0)\n\n\nDomainError\n함수의 정의역 집합을 벗어나는 인자를 제시했을 때\nsqrt(-1)\n\n\nErrorException\n일반적인 에러에 대한 예외\n\n\n\nKeyError\n사전형 컨테이너에서 존재하지 않는 키로 접근했을 때\nd1=Dict(\"a\"=&gt;1);d1[\"b\"]\n\n\nMethodError\n주어진 인자에 대한 메서드가 존재하지 않을 때\ncos(\"a\")\n\n\nTypeError\ntypeassert 함수를 이용한 타입 주장이 실패하거나 isa 와 같은 julia 고유 함수에 잘못된 타입의 인자가 제시될 때\nisa(3, 4)\n\n\n\n\n\n\n\n\n\n\nthrow 함수를 통해 에러를 발생시킬 수 있습니다. 만약 당신이 물리 시뮬레이션에서 물체의 속력 \\(v\\) 에 대한 어떤 계산을 수행하고 있는데 \\(v\\) 가 빛의 속력 \\(c\\) 보다 커서는 안된다고 해 봅시다. 그렇다면\nmsg = \"speed must not larger than speed of light\"\nv = (v&gt;c) ? throw(DomainError(v, msg)) : next_calc(v)\n와 같이 DomainError 를 에러 메시지(여기서는 msg) 와 함께 발생시킬 수 있습니다.\n표 1 를 포함한 Julia 의 예외는 ( ) 없이 이름만 사용될 경우는 예외 타입의 이름일 뿐이며 실제 예외를 발생시키기 위해서는 DomainError(v, msg) 와 같이 호출되어야 합니다. 인자로는 메시지 뿐만 아니라 에러에 대한 정확한 정보를 제공하기 위해 변수나 함수 이름이 포함되어야 합니다.\n예외적으로 ErrorException 은 error(msg) 함수로 발생시킬 수 있습니다. ErrorExeption 은 일반적인 오류에 대한 예외이며 가장 간편하게 예외를 발생시켜 프로그램 실행을 중단 시킬 수 있는, 그래서 가장 흔히 사용하는 예외 발생 방법입니다. error(msg) 는 ErrorExeption 을 발생시키며 문자열 msg 를 출력합니다.\nIn [11]: error(\"AttributeError :  aabb\")\nERROR: AttributeError :  aabb\n...\nIn [13]: throw(ErrorException(\"AttributeError : aabb\"))\nERROR: AttributeError : aabb\n...\n\n\n\n\n예외가 발생하면 실행이 중단되는데, 실행을 중단시키지 않고 어떤 처리를 통해 처리를 계속 진행 시킬 수 있습니다. 이 경우는 try ... catch ... end 구문을 통해 처리 할 수 있습니다. 예를 들어 sqrt() 함수에 인자를 음수로 넣으면 DomainError 가 발생합니다. 아래의 코드를 봅시다.\ntry\n    v = sqrt(x)\ncatch e\n    v= 0\nend\n우선 try 블럭을 봅시다. 여기서는 v=sqrt(x) 를 평가합니다. 만약 x 가 음수라면 DomainError 가 발생하지만 try 문은 일단 프로그램 정지를 막고 예외가 발생할 경우 catch e 와 end 사이의 코드를 수행하게 됩니다. 즉 v=0 이 됩니다. catch e 에서 e 는 예외 객체입니다. 어쨌든 예외가 발생하면 v=0 을 수행하게 됩니다. 어떤 예외라도 상관 없다면 e 없이 catch 만 사용해도 됩니다. 위의 코드는 아래와 동일한 기능을 합니다.\ntry v=sqrt(x) catch; v=0 end\nJulia 1.8 부터는 예외가 발생 하지 않았을 경우를 처리하는 else 구문이 추가되었으며 예외가 발생 하든 안하든 어떤 일을 수행하는 finally 구문이 존재합니다. 즉\ntry\n    # 예외가 발생할 수도 있는 처리\ncatch e\n    # 예외가 발생했을 경우의 처리\nelse \n    # 예외가 발생하지 않았을 경우의 처리\nfinally\n    # 어쨌든 처리\nend\n형식이 됩니다.\n\n\n\n\n예를 들어 시뮬레이션에서 입자의 속도가 광속을 넘는 경우를 방지하기 위한 예외가 필요하다고 해 봅시다. 이를 OverSpeedOfLightException 라고 합시다. 예외는 추상 타입인 Exception 의 하위타입이어야 하며, 속도와 메시지를 표현해주기 위한 필드를 가져야 하기 때문에 다음과 같이 표현 할 수 있습니다.\nstruct OverSpeedOfLightException &lt;: Exception\n    speed::Number\n    msg::String\nend\n다음과 같이 오류를 발생 시킬 수 있습니다.\nIn [2]: throw(OverSpeedOfLightException(10000000, \"speed must be smaller than c\"))\nERROR: OverSpeedOfLightException(10000000, \"speed must be smaller than c\")",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 예외 처리"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10I_exception.html#julia-에서의-에러",
    "href": "src/introduction_to_julia/10I_exception.html#julia-에서의-에러",
    "title": "Interlude : 예외 처리",
    "section": "",
    "text": "예를 들어 길이가 3인 일차원 벡터의 네번째 성분에 접근할 경우, julia 인터프리터는 BoundsError 를 발생시키고 실행을 종료합니다.\nIn [1]: aa=[1,2,3];println(aa[4]);println(\"End\")\nERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]\nStacktrace:\n이렇게 줄리아 코드가 실행중일 때 실행을 지속시키지 못하거나 후속 처리가 필요한 중대한 조건을 예외(Exception) 라고 합니다. 위의 경우처럼 julia 인터프리터가 예외를 발생시킬 수도 있으며, 프로그래머가 의도적으로 예외를 발생시킬 수도 있습니다. 발생한 예외에 대해서는 프로그램 실행을 중단시킬 수도 있고, 예외에 따라 적합한 처리를 수행할 수도 있습니다. 이를 예외 처리(Exception handling) 라고 합니다.\nJulia 에서 기본적으로 제공하는 예외는 기본 매뉴얼의 Built-in Exceptions 에 나와 있습니다. Julia 에서 제공하는 에러 가운데 자주 사용되는 것들을 표 1 에 정리하였습니다.\n\n\n\n표 1: Julia 의 주요 에러\n\n\n\n\n\n\n\n\n\n\n에러\n설명\n예\n\n\n\n\nArgumentError\n함수에 유효하지 않은 인자가 입력된경우\nparse(Int, \"abc\")\n\n\nBoundsError\n인덱스로 접근하는 컨테이너에 범위를 벗어나는 인덱스로 접근했을 때\na=[1, 2];b=a[3]\n\n\nDimensionMismatch\n호출된 객체가 차원에 대한 불일치가 발생할 때\n[1 2;3 4]+[1 2]\n\n\nDivideError\ndiv 함수를 사용하며 정수를 0 으로 나눌 때\ndiv(5, 0)\n\n\nDomainError\n함수의 정의역 집합을 벗어나는 인자를 제시했을 때\nsqrt(-1)\n\n\nErrorException\n일반적인 에러에 대한 예외\n\n\n\nKeyError\n사전형 컨테이너에서 존재하지 않는 키로 접근했을 때\nd1=Dict(\"a\"=&gt;1);d1[\"b\"]\n\n\nMethodError\n주어진 인자에 대한 메서드가 존재하지 않을 때\ncos(\"a\")\n\n\nTypeError\ntypeassert 함수를 이용한 타입 주장이 실패하거나 isa 와 같은 julia 고유 함수에 잘못된 타입의 인자가 제시될 때\nisa(3, 4)",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 예외 처리"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10I_exception.html#throw-를-통한-예외-발생",
    "href": "src/introduction_to_julia/10I_exception.html#throw-를-통한-예외-발생",
    "title": "Interlude : 예외 처리",
    "section": "",
    "text": "throw 함수를 통해 에러를 발생시킬 수 있습니다. 만약 당신이 물리 시뮬레이션에서 물체의 속력 \\(v\\) 에 대한 어떤 계산을 수행하고 있는데 \\(v\\) 가 빛의 속력 \\(c\\) 보다 커서는 안된다고 해 봅시다. 그렇다면\nmsg = \"speed must not larger than speed of light\"\nv = (v&gt;c) ? throw(DomainError(v, msg)) : next_calc(v)\n와 같이 DomainError 를 에러 메시지(여기서는 msg) 와 함께 발생시킬 수 있습니다.\n표 1 를 포함한 Julia 의 예외는 ( ) 없이 이름만 사용될 경우는 예외 타입의 이름일 뿐이며 실제 예외를 발생시키기 위해서는 DomainError(v, msg) 와 같이 호출되어야 합니다. 인자로는 메시지 뿐만 아니라 에러에 대한 정확한 정보를 제공하기 위해 변수나 함수 이름이 포함되어야 합니다.\n예외적으로 ErrorException 은 error(msg) 함수로 발생시킬 수 있습니다. ErrorExeption 은 일반적인 오류에 대한 예외이며 가장 간편하게 예외를 발생시켜 프로그램 실행을 중단 시킬 수 있는, 그래서 가장 흔히 사용하는 예외 발생 방법입니다. error(msg) 는 ErrorExeption 을 발생시키며 문자열 msg 를 출력합니다.\nIn [11]: error(\"AttributeError :  aabb\")\nERROR: AttributeError :  aabb\n...\nIn [13]: throw(ErrorException(\"AttributeError : aabb\"))\nERROR: AttributeError : aabb\n...",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 예외 처리"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10I_exception.html#try-...-catch-...-end-를-통한-예외-처리",
    "href": "src/introduction_to_julia/10I_exception.html#try-...-catch-...-end-를-통한-예외-처리",
    "title": "Interlude : 예외 처리",
    "section": "",
    "text": "예외가 발생하면 실행이 중단되는데, 실행을 중단시키지 않고 어떤 처리를 통해 처리를 계속 진행 시킬 수 있습니다. 이 경우는 try ... catch ... end 구문을 통해 처리 할 수 있습니다. 예를 들어 sqrt() 함수에 인자를 음수로 넣으면 DomainError 가 발생합니다. 아래의 코드를 봅시다.\ntry\n    v = sqrt(x)\ncatch e\n    v= 0\nend\n우선 try 블럭을 봅시다. 여기서는 v=sqrt(x) 를 평가합니다. 만약 x 가 음수라면 DomainError 가 발생하지만 try 문은 일단 프로그램 정지를 막고 예외가 발생할 경우 catch e 와 end 사이의 코드를 수행하게 됩니다. 즉 v=0 이 됩니다. catch e 에서 e 는 예외 객체입니다. 어쨌든 예외가 발생하면 v=0 을 수행하게 됩니다. 어떤 예외라도 상관 없다면 e 없이 catch 만 사용해도 됩니다. 위의 코드는 아래와 동일한 기능을 합니다.\ntry v=sqrt(x) catch; v=0 end\nJulia 1.8 부터는 예외가 발생 하지 않았을 경우를 처리하는 else 구문이 추가되었으며 예외가 발생 하든 안하든 어떤 일을 수행하는 finally 구문이 존재합니다. 즉\ntry\n    # 예외가 발생할 수도 있는 처리\ncatch e\n    # 예외가 발생했을 경우의 처리\nelse \n    # 예외가 발생하지 않았을 경우의 처리\nfinally\n    # 어쨌든 처리\nend\n형식이 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 예외 처리"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10I_exception.html#사용자-정의-오류",
    "href": "src/introduction_to_julia/10I_exception.html#사용자-정의-오류",
    "title": "Interlude : 예외 처리",
    "section": "",
    "text": "예를 들어 시뮬레이션에서 입자의 속도가 광속을 넘는 경우를 방지하기 위한 예외가 필요하다고 해 봅시다. 이를 OverSpeedOfLightException 라고 합시다. 예외는 추상 타입인 Exception 의 하위타입이어야 하며, 속도와 메시지를 표현해주기 위한 필드를 가져야 하기 때문에 다음과 같이 표현 할 수 있습니다.\nstruct OverSpeedOfLightException &lt;: Exception\n    speed::Number\n    msg::String\nend\n다음과 같이 오류를 발생 시킬 수 있습니다.\nIn [2]: throw(OverSpeedOfLightException(10000000, \"speed must be smaller than c\"))\nERROR: OverSpeedOfLightException(10000000, \"speed must be smaller than c\")",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 예외 처리"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/11_interfaces.html",
    "href": "src/introduction_to_julia/11_interfaces.html",
    "title": "인터페이스",
    "section": "",
    "text": "반복자(Iterator) 는 컨테이너 타입으로 포함하는 성분을 처음부터 끝까지 하나 하나 접근 할 수 있는 자료구조를 말하며, Julia 에서 제공하는 컨테이너 타입은 대부분 iterator 입니다. 배열이나 튜플과 같이 순서가 정해져 있을 수도 있고 사전과 같이 순서가 임의적일 수는 있지만 어쨌든 하나하나 접근 할 수 있어야 합니다. 다음과 같은 자료형은 정의상 4개의 값을 저장할 수 있는 컨테이너이지만 반복자는 아닙니다.\nJulia 에서 어떤 타입이 반복자라는 것은 그 타입에 대해 아래의 메서드가 정의되어 있다는 것을 말합니다. 아래에서 state 는 컨테이너의 아이템과 1대1 대응되는 어떤 값이며 배열의 경우는 인덱스입니다.\n반복자에 대해 추가로 정의 할 수 있는 메서드에는 다음과 같은 것이 있습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "인터페이스"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/11_interfaces.html#인덱스로-접근가능한-반복자",
    "href": "src/introduction_to_julia/11_interfaces.html#인덱스로-접근가능한-반복자",
    "title": "인터페이스",
    "section": "1 인덱스로 접근가능한 반복자",
    "text": "1 인덱스로 접근가능한 반복자\n이제 유용한 반복자를 하나 만들어 봅시다. 신호처리에서 많이 사용하는 베열가운데 로그스케일로 변화하는 배열이 있습니다. matlab 에서의 logspace 함수, python 에서의 numpy.logspace 함수로 logspace(a, b, n, base=10) 는 base 의 a 승부터 base 의 b 승까지 로그스케일로 변하는 배열입니다. Julia 에서는 base .^ range(a,b,n) 과 그 결과가 같습니다.(정확히 말하면 끝값을 포함 하느냐 하지 않느냐에 따라 다릅니다. Matlab 과 julia 는 포함하며 python 은 포함하지 않습니다.)\n이 반복자를 LogSpacingRange 라고 합시다. 우리의 목표는 logspace 함수로 LogSpacingRange 객체 생성시켜 배열처럼 사용 할 수 있게 하는 것입니다. 배열이나 튜플처럼 인덱스로 접근 가능한 객체를 만들기 위해서는 위해서는 다음의 네가지 메서드를 정의해 줘야 합니다.\n\n\n\n메서드\n설명\n\n\n\n\ngetindex(X, i)\nX[i], 인덱스를 이용한 접근\n\n\nsetindex!(X, v, i)\nX[i] = v, 인덱스를 이용한 할당\n\n\nfirstindex(X)\nX[begin] 로 접근 가능한 첫번째 성분\n\n\nlastindex(X)\nX[end] 로 접근 가능한 마지막 성분\n\n\n\nLogSpacingRange 객체는 immutable 인 것이 좋을 것 같습니다. 이 경우 LogSpacingRange 타입에 대한 setindex 메서드를 작성하지 않으면 됩니다. 나머지 함수에 대해서는 적절하게 만들어 줍니다. 전체 코드는 다음과 같습니다.\nstruct LogSpacingRange{T}\n    start::T\n    stop::T\n    base::T\n    size::Int64\n\n    function LogSpacingRange(start::Real, stop::Real, size::Int64, base::Real)\n        @assert base &gt; 1\n        @assert size ≥ 1\n        ftype = promote_type(typeof(start), typeof(stop))\n        if ~(ftype &lt;: AbstractFloat)\n            ftype = Float64\n        end\n\n        return new{ftype}(start, stop, base, size)\n    end\nend\n\nBase.size(p::LogSpacingRange) = (p.size, )\nBase.length(p::LogSpacingRange) = p.size\nBase.iterate(p::LogSpacingRange, state=1) = state &gt; p.size ? nothing : (p[state], state+1)\nBase.eltype(p::LogSpacingRange{T}) where {T} = T\nBase.IteratorSize(::LogSpacingRange{T}) where {T} = Base.HasLength()\nBase.IteratorEltype(::LogSpacingRange{T}) where {T} = Base.HasEltype()\n\nfunction Base.getindex(p::LogSpacingRange, i::Int64) \n    @assert 0 &lt; i ≤ p.size\n    if p.size == 1\n        return p.start\n    else \n        r = p.start + (p.stop-p.start)/(p.size-1)*(i-1)\n        return (p.base)^r\n    end\nend\n\nfunction logspace(a, b, n::Integer=10, base::Real=10)\n    return LogSpacingRange(a, b, n, base)\nend\n\nlogspace(a, b, n=10, base=10) 함수를 통해 LogSpacingRange 타입의 반복자를 생성 할 수 있습니다.\nfor v in logspace(1, 5, 3, 10)\n    @show v\nend \n를 통해 다음과 같은 결과를 얻습니다.\nv = 10.0\nv = 1000.0\nv = 100000.0\n또한 getindex 함수를 정의하여 배열처럼 사용 할 수 있습니다.\nIn [6]: a=logspace(1, 10, 10)\nOut[6]: NAJ.LogSpacingRange{Float64}(1.0, 10.0, 10.0, 10)\n\nIn [7]: a[3]\nOut[7]: 1000.0\n물론 10.0.^range(1, 5, length=3) 이 같은 기능을 하는 배열을 만들어 줍니다. LogSpacingRange 의 장점은 숫자 세개만으로 큰 크기의 배열의 기능을 수행 할 수 있다는 것입니다. 물론 collect() 함수를 통해 배열로 변경하는 경우 그 장점은 사라지지만 말입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "인터페이스"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/11_interfaces.html#배열처럼-동작하는-반복자",
    "href": "src/introduction_to_julia/11_interfaces.html#배열처럼-동작하는-반복자",
    "title": "인터페이스",
    "section": "2 배열처럼 동작하는 반복자",
    "text": "2 배열처럼 동작하는 반복자\n앞서의 LogSpacingRange 는 1차원 배열, 혹은 튜플처럼 동작했습니다. 그렇다면 배열, 특히 다차원 배열과 같이 동작하기 위해서는 다음의 메서드가 정의되어야 합니다.\n\n\n\n메서드\n설명\n\n\n\n\nsize(A)\nA 의 차원 튜플\n\n\ngetindex(A, i::Int)\n선형 인덱스로의 접근\n\n\ngetindex(A, I::Vararg{Int, N})\n데카르트 인덱스로의 접근\n\n\n\n\n다차원 배열처럼 동작하는 반복자를 만들어 봅시다. Julia 에서 많이 사용되는 패키지 가운데 OffsetArrays.jl 이 있습니다. OffsetArrays 는 인덱스가 1 이 아닌 임의의 정수부터 시작하는 배열을 만들 수 있습니다. 그것은 Base.getindex 나 Base.setindex! 등을 다시 정의하여 동작하게 합니다. OffsetArrays 는 상당히 진지한, 그러니까 심각한 작업에도 사용할 수 있도록 세심하게 만들어진 타입이지만 우리는 여기어 이와 비슷하게 작동하는, 그리고 교육 목적의 타입을 만들어 봅시다. 이름은 ShiftedIndexedArray 로 합니다.\nstruct ShiftedIndexedArray{T, N, AA &lt;: AbstractArray{T, N}} \n    A::AA\n    offsets::NTuple{N, Int}\n    \n    function ShiftedIndexedArray{T, N, AA}(arr::AA, offsets::NTuple{N, Int}) where {T, N, AA&lt;:AbstractArray{T, N}}\n        return new{T, N, AA}(arr, offsets)\n    end\nend\n\nfunction ShiftedIndexedArray(arr::AA, offsets::NTuple{N, Int}) where {N, AA&lt;:AbstractArray}\n    return ShiftedIndexedArray{eltype(arr), ndims(arr), typeof(arr)}(arr, offsets)\nend\n\nconst ShiftedIndexedVector{T, AA&lt;: AbstractVector{T}} = ShiftedIndexedArray{T, 1, AA}\nconst ShiftedIndexedMarix{T, AA&lt;:AbstractMatrix{T}} = ShiftedIndexedArray{T, 2, AA}\n\nfunction Base.getindex(S::ShiftedIndexedArray{T, N, AA}, I...) where {T, N, AA}\n    oind = _original_cartesian_index(S, I)\n    if checkbounds(Bool, S.A, oind...) \n        return getindex(S.A, oind...)\n    else\n        throw(BoundsError(S, I...))\n    end\nend\n\nfunction Base.getindex(S::ShiftedIndexedArray{T, N, AA}, i::Int64) where {T, N, AA}\n    oind = _original_linear_index(S, i)\n    if checkbounds(Bool, S.A, oind)\n        return getindex(S.A, oind)\n    else \n        throw(BoundsError(S, i))\n    end\nend\n\nfunction Base.setindex!(S::ShiftedIndexedArray{T, N, AA}, v, I... ) where {T, N, AA}\n    oind = _original_cartesian_index(S, I)\n    if checkbounds(Bool, S.A, oind...) == false\n        throw(BoundsError(S, I...))\n    else\n        return setindex!(S.A, v, oind...)\n    end\nend\n\nfunction Base.setindex!(S::ShiftedIndexedArray{T, N, AA}, v, i::Int ) where {T, N, AA}\n    oind = _original_liear_index(S, i)\n    if checkbounds(Bool, S.A, oind) == false\n        throw(BoundsError(S, i))\n    else\n        return setindex!(S.A, v, oind)\n    end\nend\n\n\nBase.similar(S::ShiftedIndexedArray) = ShiftedIndexedArray(Base.similar(S.A), S.offsets)\nBase.sizeof(S::ShiftedIndexedArray) = sizeof(S.A)\n\nBase.iterate(S::ShiftedIndexedArray, state=1) = iterate(S.A, state)\nBase.IndexStyle(S::ShiftedIndexedArray) = IndexStyle(S.A)\nShiftedIndexedArray 는 두개의 필드를 갖습니다. 하나는 배열을 저장하는 .A 필드이고, 하나는 각 축에 대한 시작 인덱스를 지정하는 .offsets 입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "인터페이스"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/index.html",
    "href": "src/introduction_to_julia/index.html",
    "title": "Introduction to Julia",
    "section": "",
    "text": "Introduction to Julia\nJulia 는 이제 나온지 10년이 조금 넘어가는 신생 언어입니다. 2024년 2월 현재 최신 버젼이 1.10 입니다. 많이 비교되는 파이썬은 30년이 조금 넘었으며 현재 최신 버젼이 3.10 입니다. 제가 파이썬을 처음 접한게 25년쯤 전이었는데 25년동안의 파이썬의 위상은 엄청나게 바뀌었습니다. 25년전의 파이썬은 배우기 쉽고 써먹기 좋은 언어로만 인식되었습니다. 그때는 numpy 도 없었으며(혹시나 해서 numpy 공식 사이트에서 확인해보니 2005년에 등장했군요), 과학/공학 분야에서도 코딩이 빠른 언어였지 진지한 계산에 사용할 만한 언어라는 인식은 별로 없었습니다. 파이썬으로 한시간 코딩해서 한시간동안 돌려서 결과를 볼것이냐, C/C++ 로 하루 코딩해서 1분만에 결과를 볼것이냐 하는 문제였죠. 현재는 다양한 파이썬 생태계로 인해 과학/공학 분야에서 널리 쓰이고 있으며 특히 인공지능 분야에서는 그 위치가 엄청나죠.\nJulia 에 대해 설명할 때 파이썬 만큼 쉽고 C 만큼 빠르다 라고 합니다. 어떤 면에서는 맞는 말입니다. 그런데 20년전의 파이썬과 비교해 봤을때 파이썬도 많이 어려워졌거든요. 파이썬도 잘 쓰려면 배워야 할 것이 많습니다. 그런 의미에서 Julia 가 파이썬 만큼 쉬우냐 하는 질문에는 제 경험상 큰 차이는 나지 않는다고 말하겠습니다. 또 C/C++/Fortran 으로 작성하여 컴파일한것을 파이썬에서 읽어서 실행시키는 부분은 C/C++/Fortran 직접 실행시켰을 때와 거의 차이가 나지 않습니다. 즉 어떤 부분에서는 (비록 내부적으로는 최적화된 C/C++/Fortran 으로 작성된 실행 코드를 돌릴지라도) 파이썬의 속도가 느리지 않습니다. 그리고 30년 동안 이루어진 파이썬의 생태계도 엄청나게 거대하죠. Julia 언어는 numpy 와 비교해서도 많은 부분에서 상당히 빠릅니다. 특히 이미 존재하는 함수를 그냥 가져다 쓰는 것이 아닌 경우, julia 로 for 루프를 돌리는 것이 아주 빠른 경우가 많습니다. 파이썬으로 대규모의 루프를 돌리는 것은 별로 권장할 만하지 않죠. 그렇다고 julia 가 C/C++/Fortran 만큼 빠르냐고 하면 꼭 그렇지는 않습니다. 하지만 연산 속도를 증가시키는 여러 테크닉(주로 매크로)을 사용할 때 비슷한 속도가 나오는 경우도 많습니다.\n저에게 있어 julia 언어의 장점중의 하나는 멀티스레딩입니다. 파이썬은 (적어도 공식적인 CPython 의 경우) 멀티쓰레딩이 가능하지만 수치해석적인 면에서 의미가 없습니다. Julia 는 멀티쓰레딩을 아주 편하게 사용 할 수 있으며, 강력합니다.\n반면 Julia 언어의 최대의 단점은 아직은 부족한 생태계입니다. 파이썬이나 매트랩에서 이미 구현되어 널리 사용되고 있는 어떤 기능이 Julia 에 없어서 당신이 필요한 계산을 하기 위해 바닥부터 코드를 작성해야 할 수 도 있습니다. 하지만 특히 과학/공학 분야에서 점점 사용자가 많아지고 있기 때문에 이 단점은 점점 감소될 것이라고 예상합니다. 또 연산이 매우 빠른 스크립트 언어라는 장점은 과학/공학 분야 뿐만 아니라 다른 분야에서도 아주 유용하기 때문에 Julia 의 사용이 점점 확산 될 것이라고 생각합니다."
  }
]