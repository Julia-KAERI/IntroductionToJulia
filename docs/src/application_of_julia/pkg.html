<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Pkg.jl – Introduction To Julia</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../src/application_of_julia/string_literal.html" rel="next">
<link href="../../src/application_of_julia/more_on_types.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Introduction To Julia</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/introduction_to_julia/01_julia_language.html"> 
<span class="menu-text">Julia 언어의 기초</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../src/application_of_julia/00_part2.html" aria-current="page"> 
<span class="menu-text">Julia 언어의 활용</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/ecosystem_of_julia/00_part3.html"> 
<span class="menu-text">Julia 언어 생태계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="mailto:julia.kaeri@gmail.com" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-envelope"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/application_of_julia/pkg.html">Pkg.jl</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/application_of_julia/00_part2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Julia 언어의 활용</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/application_of_julia/more_on_types.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">타입에 대해 더 알아보기</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/application_of_julia/pkg.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Pkg.jl</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/application_of_julia/string_literal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">문자열 리터럴</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/application_of_julia/performance_tips.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Julia 성능 팁</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/application_of_julia/multithreads.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">다중스레딩</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/application_of_julia/asynchronous.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">비동기 프로그래밍</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#sec-introduction" id="toc-sec-introduction" class="nav-link active" data-scroll-target="#sec-introduction"><span class="header-section-number">1</span> 들어가며</a>
  <ul class="collapse">
  <li><a href="#sec-background_and_design" id="toc-sec-background_and_design" class="nav-link" data-scroll-target="#sec-background_and_design"><span class="header-section-number">1.1</span> 배경과 설계</a></li>
  </ul></li>
  <li><a href="#sec-getting_started" id="toc-sec-getting_started" class="nav-link" data-scroll-target="#sec-getting_started"><span class="header-section-number">2</span> 시작하기</a>
  <ul class="collapse">
  <li><a href="#sec-basic_usage" id="toc-sec-basic_usage" class="nav-link" data-scroll-target="#sec-basic_usage"><span class="header-section-number">2.1</span> 기본 사용법</a></li>
  <li><a href="#sec-getting_started_with_environments" id="toc-sec-getting_started_with_environments" class="nav-link" data-scroll-target="#sec-getting_started_with_environments"><span class="header-section-number">2.2</span> 환경(Environments)과 함께 시작하기</a></li>
  <li><a href="#도움-요청" id="toc-도움-요청" class="nav-link" data-scroll-target="#도움-요청"><span class="header-section-number">2.3</span> 도움 요청</a></li>
  <li><a href="#의존성-변경" id="toc-의존성-변경" class="nav-link" data-scroll-target="#의존성-변경"><span class="header-section-number">2.4</span> 의존성 변경</a></li>
  </ul></li>
  <li><a href="#sec-managing_packages" id="toc-sec-managing_packages" class="nav-link" data-scroll-target="#sec-managing_packages"><span class="header-section-number">3</span> 패키지 관리</a>
  <ul class="collapse">
  <li><a href="#sec-adding_packages" id="toc-sec-adding_packages" class="nav-link" data-scroll-target="#sec-adding_packages"><span class="header-section-number">3.1</span> 패키지 추가</a></li>
  <li><a href="#sec-removing_packages" id="toc-sec-removing_packages" class="nav-link" data-scroll-target="#sec-removing_packages"><span class="header-section-number">3.2</span> 패키지 제거</a></li>
  <li><a href="#sec-updating_packages" id="toc-sec-updating_packages" class="nav-link" data-scroll-target="#sec-updating_packages"><span class="header-section-number">3.3</span> 패키지 업데이트</a></li>
  <li><a href="#sec-pinning_a_package" id="toc-sec-pinning_a_package" class="nav-link" data-scroll-target="#sec-pinning_a_package"><span class="header-section-number">3.4</span> 패키지 고정</a></li>
  <li><a href="#sec-testing_package" id="toc-sec-testing_package" class="nav-link" data-scroll-target="#sec-testing_package"><span class="header-section-number">3.5</span> 패키지 테스트</a></li>
  <li><a href="#sec-building_package" id="toc-sec-building_package" class="nav-link" data-scroll-target="#sec-building_package"><span class="header-section-number">3.6</span> 패키지 빌드</a></li>
  <li><a href="#sec-interpreting_and_resolving_version_conficts" id="toc-sec-interpreting_and_resolving_version_conficts" class="nav-link" data-scroll-target="#sec-interpreting_and_resolving_version_conficts"><span class="header-section-number">3.7</span> 버젼 충돌의 해석과 해소</a></li>
  <li><a href="#sec-garbage_collecting_old_unused_packages" id="toc-sec-garbage_collecting_old_unused_packages" class="nav-link" data-scroll-target="#sec-garbage_collecting_old_unused_packages"><span class="header-section-number">3.8</span> 오래되고 사용되지 않는 패키지를 가비지 컬렉팅 하기</a></li>
  <li><a href="#sec-offline_mode" id="toc-sec-offline_mode" class="nav-link" data-scroll-target="#sec-offline_mode"><span class="header-section-number">3.9</span> 오프라인 모드</a></li>
  <li><a href="#sec-pkg_client_server" id="toc-sec-pkg_client_server" class="nav-link" data-scroll-target="#sec-pkg_client_server"><span class="header-section-number">3.10</span> Pkg 클라이언트/서버</a></li>
  </ul></li>
  <li><a href="#sec-working_with_environment" id="toc-sec-working_with_environment" class="nav-link" data-scroll-target="#sec-working_with_environment"><span class="header-section-number">4</span> 환경을 이용한 작업</a>
  <ul class="collapse">
  <li><a href="#sec-creating_your_own_project" id="toc-sec-creating_your_own_project" class="nav-link" data-scroll-target="#sec-creating_your_own_project"><span class="header-section-number">4.1</span> 당신의 프로젝트를 생성하기</a></li>
  <li><a href="#프로젝트-사전-컴파일precompile" id="toc-프로젝트-사전-컴파일precompile" class="nav-link" data-scroll-target="#프로젝트-사전-컴파일precompile"><span class="header-section-number">4.2</span> 프로젝트 사전 컴파일(Precompile)</a></li>
  <li><a href="#다른-사람의-프로젝트를-사용하기" id="toc-다른-사람의-프로젝트를-사용하기" class="nav-link" data-scroll-target="#다른-사람의-프로젝트를-사용하기"><span class="header-section-number">4.3</span> 다른 사람의 프로젝트를 사용하기</a></li>
  </ul></li>
  <li><a href="#패키지-작성" id="toc-패키지-작성" class="nav-link" data-scroll-target="#패키지-작성"><span class="header-section-number">5</span> 5. 패키지 작성</a>
  <ul class="collapse">
  <li><a href="#패키지용-파일-생성" id="toc-패키지용-파일-생성" class="nav-link" data-scroll-target="#패키지용-파일-생성"><span class="header-section-number">5.1</span> 패키지용 파일 생성</a></li>
  <li><a href="#프로젝트에-의존성-추가" id="toc-프로젝트에-의존성-추가" class="nav-link" data-scroll-target="#프로젝트에-의존성-추가"><span class="header-section-number">5.2</span> 프로젝트에 의존성 추가</a></li>
  <li><a href="#패키지에-빌드-단계를-추가하기" id="toc-패키지에-빌드-단계를-추가하기" class="nav-link" data-scroll-target="#패키지에-빌드-단계를-추가하기"><span class="header-section-number">5.3</span> 패키지에 빌드 단계를 추가하기</a></li>
  <li><a href="#패키지에-테스트-추가하기" id="toc-패키지에-테스트-추가하기" class="nav-link" data-scroll-target="#패키지에-테스트-추가하기"><span class="header-section-number">5.4</span> 패키지에 테스트 추가하기</a></li>
  <li><a href="#패키지-작명-가이드" id="toc-패키지-작명-가이드" class="nav-link" data-scroll-target="#패키지-작명-가이드"><span class="header-section-number">5.5</span> 패키지 작명 가이드</a></li>
  <li><a href="#패키지-등록" id="toc-패키지-등록" class="nav-link" data-scroll-target="#패키지-등록"><span class="header-section-number">5.6</span> 패키지 등록</a></li>
  <li><a href="#best-practices" id="toc-best-practices" class="nav-link" data-scroll-target="#best-practices"><span class="header-section-number">5.7</span> Best Practices</a></li>
  </ul></li>
  <li><a href="#호환성-compatiblity" id="toc-호환성-compatiblity" class="nav-link" data-scroll-target="#호환성-compatiblity"><span class="header-section-number">6</span> 6. 호환성 (Compatiblity)</a>
  <ul class="collapse">
  <li><a href="#버젼-지정-형식" id="toc-버젼-지정-형식" class="nav-link" data-scroll-target="#버젼-지정-형식"><span class="header-section-number">6.1</span> 버젼 지정 형식</a></li>
  <li><a href="#충돌-수정" id="toc-충돌-수정" class="nav-link" data-scroll-target="#충돌-수정"><span class="header-section-number">6.2</span> 충돌 수정</a></li>
  </ul></li>
  <li><a href="#레지스트리" id="toc-레지스트리" class="nav-link" data-scroll-target="#레지스트리"><span class="header-section-number">7</span> 7. 레지스트리</a>
  <ul class="collapse">
  <li><a href="#레지스트리-관리" id="toc-레지스트리-관리" class="nav-link" data-scroll-target="#레지스트리-관리"><span class="header-section-number">7.1</span> 레지스트리 관리</a></li>
  </ul></li>
  <li><a href="#아티팩트artifacts" id="toc-아티팩트artifacts" class="nav-link" data-scroll-target="#아티팩트artifacts"><span class="header-section-number">8</span> 8. 아티팩트(Artifacts)</a>
  <ul class="collapse">
  <li><a href="#기본적인-사용법" id="toc-기본적인-사용법" class="nav-link" data-scroll-target="#기본적인-사용법"><span class="header-section-number">8.1</span> 기본적인 사용법</a></li>
  <li><a href="#artifacts.toml-파일" id="toc-artifacts.toml-파일" class="nav-link" data-scroll-target="#artifacts.toml-파일"><span class="header-section-number">8.2</span> <code>Artifacts.toml</code> 파일</a></li>
  <li><a href="#아티팩트-타입과-프로퍼티" id="toc-아티팩트-타입과-프로퍼티" class="nav-link" data-scroll-target="#아티팩트-타입과-프로퍼티"><span class="header-section-number">8.3</span> 아티팩트 타입과 프로퍼티</a></li>
  <li><a href="#아티팩트-사용" id="toc-아티팩트-사용" class="nav-link" data-scroll-target="#아티팩트-사용"><span class="header-section-number">8.4</span> 아티팩트 사용</a></li>
  <li><a href="#pkg.artifacts-api" id="toc-pkg.artifacts-api" class="nav-link" data-scroll-target="#pkg.artifacts-api"><span class="header-section-number">8.5</span> <code>Pkg.Artifacts</code> API</a></li>
  <li><a href="#아티팩트-위치-오버라이딩" id="toc-아티팩트-위치-오버라이딩" class="nav-link" data-scroll-target="#아티팩트-위치-오버라이딩"><span class="header-section-number">8.6</span> 아티팩트 위치 오버라이딩</a></li>
  <li><a href="#플랫폼-선택-확장" id="toc-플랫폼-선택-확장" class="nav-link" data-scroll-target="#플랫폼-선택-확장"><span class="header-section-number">8.7</span> 플랫폼 선택 확장</a></li>
  </ul></li>
  <li><a href="#용어-glossary" id="toc-용어-glossary" class="nav-link" data-scroll-target="#용어-glossary"><span class="header-section-number">9</span> 9. 용어 (Glossary)</a></li>
  <li><a href="#project.toml-과-manifest.toml" id="toc-project.toml-과-manifest.toml" class="nav-link" data-scroll-target="#project.toml-과-manifest.toml"><span class="header-section-number">10</span> 10. <code>Project.toml</code> 과 <code>Manifest.toml</code></a>
  <ul class="collapse">
  <li><a href="#project.toml" id="toc-project.toml" class="nav-link" data-scroll-target="#project.toml"><span class="header-section-number">10.1</span> <code>Project.toml</code></a></li>
  <li><a href="#manifest.toml" id="toc-manifest.toml" class="nav-link" data-scroll-target="#manifest.toml"><span class="header-section-number">10.2</span> <code>Manifest.toml</code></a></li>
  </ul></li>
  <li><a href="#repl-모드-레퍼런스" id="toc-repl-모드-레퍼런스" class="nav-link" data-scroll-target="#repl-모드-레퍼런스"><span class="header-section-number">11</span> 11. REPL 모드 레퍼런스</a></li>
  <li><a href="#api-레퍼런스" id="toc-api-레퍼런스" class="nav-link" data-scroll-target="#api-레퍼런스"><span class="header-section-number">12</span> 12. API 레퍼런스</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Pkg.jl</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-simple callout-important no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<ul>
<li><p><a href="https://pkgdocs.julialang.org/v1/"><code>Pkg.jl</code> 문서</a> 에 대한 개인적인 번역</p></li>
<li><p>ver : 2024.11.17</p></li>
</ul>
</div>
</div>
</div>
<section id="sec-introduction" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="sec-introduction"><span class="header-section-number">1</span> 들어가며</h2>
<p>Julia의 패키지 관리자인 Pkg의 문서에 오신 것을 환영합니다. 이 문서는 예를 들어 패키지 설치 관리, 패키지 개발, 패키지 레지스트리 작업 등과 같은 많은 내용을 다룹니다.</p>
<p>설명서 전체에서 Pkg에 대한 REPL 인터페이스인 Pkg REPL 모드가 예제에서 사용됩니다. 대화식으로 작업하지 않을 때 선호되는 함수적 API도 있습니다. 이 API는 <a href="https://pkgdocs.julialang.org/v1/api/#API-Reference">API Reference</a> 섹션에 설명되어 있습니다.</p>
<p><br></p>
<section id="sec-background_and_design" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="sec-background_and_design"><span class="header-section-number">1.1</span> 배경과 설계</h3>
<p>기존 패키지 관리자와 달리 Pkg는 독립적인 패키지 세트로서 개별 프로젝트에 한정 될 수 있는 “환경(environment)”를 중심으로 설계되었습니다. 환경은 개별 프로젝트에 국한되될 수도 있고 이름으로 공유되거나 선택될 수 있는 독립적인 패키지 집합입니다. 환경의 정확한 패키지 및 버전 목록은 manifest 파일(<code>manifest.toml</code>) 에 기록되며, 이 파일은 프로젝트 저장소에 체크인하고 버전 관리 시스템에서 추적할 수 있습니다. 이를 통해 프로젝트의 재현성이 크게 향상됩니다. 한동안 사용하지 않았던 코드를 실행하려고 시도했지만, 프로젝트에서 사용하던 패키지 중 일부를 업데이트하거나 제거한 후 작동하지 않는 상황을 경험해 보셨다면, 이런 접근 방식의 필요성을 이해할 수 있을 것입니다. Pkg에서는 각 프로젝트가 독립적인 패키지 버전 집합을 유지하기 때문에 이런 문제는 더 이상 발생하지 않습니다. 게다가 새로운 시스템에서 프로젝트를 체크아웃한 경우, manifest 파일에 설명된 환경을 단순히 구현(materialize) 하면, 안정성이 검증된 의존성 세트를 즉시 사용할 수 있습니다.</p>
<p>환경이 서로 독립적으로 관리되고 업데이트되기 때문에 Pkg에서는 소위 “의존성 지옥(dependency hell)”이 크게 완화됩니다. 새 프로젝트에서 일부 패키지의 가장 최신 버전을 사용하고 싶지만 다른 프로젝트에서 이전 버전에 갇혀 있는 경우 문제가 되지 않습니다. 별도의 환경이 있기 때문에 서로 다른 버전을 사용할 수 있습니다. 시스템의 다른 위치에 동시에 설치됩니다. 각 패키지 버전의 위치는 표준적이므로 환경에서 동일한 버전의 패키지를 사용하는 경우 설치를 공유하여 불필요한 패키지 복제를 방지할 수 있습니다. 어떤 환경에서도 더 이상 사용되지 않는 이전 패키지 버전은 패키지 관리자에 의해 주기적으로 “가비지 수집(garbage collected)”됩니다.</p>
<p>로컬 환경에 대한 Pkg의 접근 방식은 Python의 <code>virtualenv</code> 또는 Ruby의 <code>bundler</code>를 사용해 본 사람들에게 친숙한 방식입니다. Julia에서는 환경(environment) 을 지원하기 위해 언어의 코드 로딩 메커니즘을 해킹하는 대신 Julia가 기본적으로 이를 이해한다는 이점이 있습니다. 또한 Julia 환경은 “적층 가능(stackable)”합니다. 하나의 환경을 다른 환경에 덮을(overlay) 수 있으므로 기본 환경 외부의 추가 패키지에 액세스할 수 있습니다. 이를 통해 기본 환경(environment)을 제공하는 프로젝트에서 쉽게 작업할 수 있으며 환경에 프로파일러, 디버거 등과 같은 모든 일반적인 개발 도구들을 로드 경로(load path) 에 추가하여, REPL에서 이 개발도구들에 계속 액세스할 수 있습니다.</p>
<p>마지막으로, Pkg는 <strong>분산 패키지 레지스트리(federated package registries)</strong>를 지원하도록 설계되었습니다. 즉, 여러 주체가 관리하는 레지스트리를 원활하게 상호작용할 수 있습니다. 특히, 기업 방화벽 뒤에 존재할 수 있는 <strong>비공개 레지스트리(private registries)</strong>가 포함됩니다. 이를 통해 공식 Julia 패키지를 설치하고 관리할 때 사용하는 동일한 도구와 워크플로를 활용하여 비공개 레지스트리에서 패키지를 설치 및 업데이트할 수 있습니다. 예를 들어, 회사의 제품에 중요한 공용 패키지에 긴급 패치(hotfix)가 필요하다면, 해당 패키지의 비공식 버전을 회사의 내부 레지스트리에 태그하여 신속하게 개발자 및 운영 팀에 제공할 수 있습니다. 이렇게 하면 상위 패치가 승인되고 배포되기를 기다릴 필요 없이 빠르게 문제를 해결할 수 있습니다. 이후 공식 수정 버전이 배포되면, 의존성을 업그레이드하여 다시 공식 릴리스로 돌아갈 수 있습니다.</p>
<p><br></p>
</section>
</section>
<section id="sec-getting_started" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="sec-getting_started"><span class="header-section-number">2</span> 시작하기</h2>
<p>다음은 Julia의 패키지 관리자인 Pkg에 대한 개요입니다. 새로운 사용자가 기본 Pkg 기능에 익숙해지는 데 도움이 됩니다.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
노트
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>이 섹션에서는 기본 가이드에 집중하기 위해 일부 Pkg 출력 내용이 생략되었습니다. 이는 적절한 속도를 유지하고 세부사항에 치우치지 않도록 돕기 위함입니다. 더 많은 세부정보가 필요하다면, Pkg 매뉴얼의 후속 섹션을 참고하시기 바랍니다.</p></li>
<li><p>이 가이드는 Pkg 명령어를 실행하기 위해 Pkg REPL을 사용합니다. 비대화형(non-interactive) 용도로는 Pkg API를 사용하는 것을 권장합니다. Pkg API는 Pkg 문서의 <a href="https://pkgdocs.julialang.org/v1/api/#API-Reference">API Reference</a> 섹션에 완전히 문서화되어 있습니다.</p></li>
</ul>
</div>
</div>
<p><br></p>
<section id="sec-basic_usage" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="sec-basic_usage"><span class="header-section-number">2.1</span> 기본 사용법</h3>
<p>Pkg 는 REPL과 함께 제공됩니다. Julia REPL에서 <code>]</code> 를 눌러 Pkg REPL 에 진입합니다. Julia REPL로 돌아가려면 백스페이스 또는 <code>^C</code> 를 누릅니다.</p>
<p><br></p>
<p>Pkg REPL 에 진입하면 유사한 프롬프트가 표시됩니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(@v1.9) pkg&gt;</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>패키지를 설치하려면 <code>add</code> 를 사용합니다 :</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(@v1.9) pkg&gt; add Example</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>   Resolving package versions...</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>   Installed Example ─ v0.5.3</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.9/Project.toml`</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  [7876af07] + Example v0.5.3</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.9/Manifest.toml`</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  [7876af07] + Example v0.5.3</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>패키지를 설치한 후 Julia 세션에서 로드 할 수 있습니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="im">import</span> <span class="bu">Example</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> Example.<span class="fu">hello</span>(<span class="st">"friend"</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="st">"Hello, friend"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>다수의 패키지를 한번에 지정 할 수 있습니다.</p>
<pre class="none"><code>(@v1.9) pkg&gt; add JSON StaticArrays</code></pre>
<p><code>status</code> 명령어(혹은 줄여서 <code>st</code> 명령어) 를 통해 설치된 패키지를 확인 할 수 있습니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(@v1.9) pkg&gt; st</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>Status `~/.julia/environments/v1.6/Project.toml`</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  [7876af07] Example v0.5.3</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  [682c06a0] JSON v0.21.3</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  [90137ffa] StaticArrays v1.5.9</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
노트
</div>
</div>
<div class="callout-body-container callout-body">
<p><code>status</code> 에 대한 <code>st</code> 이외에도 일부 Pkg REPL 명령어에 대한 이런 약식 명령어가 있습니다.</p>
</div>
</div>
<p>패키지를 제거하기 위해서는 <code>rm</code> 을 사용합니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(@v1.9) pkg&gt; rm JSON StaticArrays</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>up</code> 혹은 <code>update</code> 명령어를 사용하여 설치된 패키지를 업데이트 합니다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(@v1.9) pkg&gt; up</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 가이드를 따라 진행했다면, 설치된 패키지들이 이미 최신 버전일 가능성이 높고, 그렇다면 up 명령은 아무 작업도 수행하지 않을 것입니다. 아래에서는 Example 패키지의 이전 버전을 의도적으로 설치한 후 이를 업그레이드하는 경우의 상태 출력 예시를 보여줍니다:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>(@v1.9) pkg&gt; st</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>Status `~/.julia/environments/v1.9/Project.toml`</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>⌃ [7876af07] Example v0.5.1</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>Info Packages marked with ⌃ have new versions available and may be upgradable.</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>(@v1.9) pkg&gt; up</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.9/Project.toml`</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  [7876af07] ↑ Example v0.5.1 ⇒ v0.5.3</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>상태 출력에서 새 버전이 사용 가능함을 알 수 있으며, <code>up</code> 명령이 해당 패키지를 업그레이드한다는 것을 확인할 수 있습니다.</p>
<p>패키지 관리에 대한 자세한 내용은 문서의 [Managing Packages] 섹션을 참고하세요.</p>
<p><br></p>
</section>
<section id="sec-getting_started_with_environments" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="sec-getting_started_with_environments"><span class="header-section-number">2.2</span> 환경(Environments)과 함께 시작하기</h3>
<p>지금까지는 기본적인 패키지 관리 즉 추가, 업데이트 및 제거 에 대해 다루었습니다.</p>
<p>REPL 프롬프트에서 <code>(@v1.9)</code> 을 발견했을 수 있습니다. 이를 통해 v1.9이 현재 활성화된 환경이라는 것을 알 수 있습니다. 활성 환경은 <code>add</code>, <code>rm</code> 및 <code>update</code>와 같은 Pkg 명령에 의해 수정될 환경입니다.</p>
<p>새로운 환경을 설정해 봅시다. 활성 환경을 설정하려면 <code>activate</code> 명령을 사용합니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(@v1.9) pkg&gt; activate tutorial</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>[ Info: activating new environment at `~/tutorial/Project.toml`.</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Pkg는 새로운 환경을 생성 중임을 알려주며, 이 환경이 <code>~/tutorial</code> 디렉터리에 저장된다고 안내합니다. 새로운 환경의 경로는 REPL의 현재 작업 디렉터리를 기준으로 상대 경로로 생성됩니다.</p>
<p>또한, Pkg는 새로 활성화된 환경을 반영하기 위해 REPL 프롬프트도 업데이트했습니다:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(tutorial) pkg&gt;</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>status</code> 를 사용하여 활성화된 환경에 대한 정보를 요청할 수 있습니다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(tutorial) pkg&gt; status</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    Status `~/tutorial/Project.toml`</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>   (empty environment)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>~/tutorial/Project.toml</code> 은 활성 환경의 프로젝트 파일의 위치입니다. 프로젝트 파일은 <a href="https://toml.io/en/"><code>TOML</code></a> 파일로 Pkg는 명시적으로 설치된 패키지를 이 프로젝트 파일에 저장합니다. 이 새 환경은 비어 있습니다. 패키지를 추가하고 관찰해 보겠습니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>(tutorial) pkg&gt; add Example JSON</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>(tutorial) pkg&gt; status</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    Status `~/tutorial/Project.toml`</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  [7876af07] Example v0.5.3</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  [682c06a0] JSON v0.21.3</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이제 <code>tutorial</code> 이 <code>Example</code> 과 <code>JSON</code> 을 의존성으로 포함하는 것을 볼 수 있습니다.</p>
<p><br></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
노트
</div>
</div>
<div class="callout-body-container callout-body">
<p>동일한 패키지(버전까지 같은)가 여러 환경에 설치되어 있는 경우, 해당 패키지는 하드 드라이브에 한 번만 다운로드 되고 저장됩니다. 이러한 특성으로 인해 환경은 매우 가볍고 사실상 무료로 생성할 수 있습니다.</p>
<p>Julia에서 초보자가 흔히 저지르는 실수 중 하나는, 많은 수의 패키지를 <strong>기본 환경(default environment)</strong>에만 설치하는 것입니다. 환경을 효과적으로 사용하는 방법을 배우면 Julia 패키지를 활용하는 경험이 크게 향상될 것입니다.</p>
</div>
</div>
<p><br></p>
<p>환경에 대해 좀 더 알아보고 싶다면 <a href="">Working with Eivironment</a> 절을 참고하세요.</p>
</section>
<section id="도움-요청" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="도움-요청"><span class="header-section-number">2.3</span> 도움 요청</h3>
<p>언제든지 문제가 생기면, Pkg에 도움을 요청할 수 있습니다:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>(@v1.9) pkg&gt; ?</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>사용 가능한 명령어와 이에 대한 간략한 설명을 볼 수 있습니다. 특정 명령어에 대해 더 자세한 도움을 원하면, 해당 명령어를 지정하여 도움을 요청할 수 있습니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>(@v1.9) pkg&gt; ?develop</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 가이드는 <code>Pkg</code>를 시작하는 데 도움을 줄 것입니다. Pkg는 강력한 패키지 관리 기능을 많이 제공하므로, 더 많은 정보를 원하시면 전체 매뉴얼을 읽어보세요!</p>
</section>
<section id="의존성-변경" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="의존성-변경"><span class="header-section-number">2.4</span> 의존성 변경</h3>
<p><code>Example</code> 에서 작업 중이고 새로운 기능이 필요하다고 느낀다고 가정해 보겠습니다. 소스 코드를 어떻게 수정할 수 있습니까? 우리는 <code>Example</code> 패키지의 git 클론을 설정하기 위해 <code>develop</code> 명령을 사용할 수 있습니다.</p>
<pre class="none"><code>(tutorial) pkg&gt; develop --local Example
...

(tutorial) pkg&gt; status
    Status `/tmp/tutorial/Project.toml`
  [7876af07] Example v0.5.1+ [`dev/Example`]</code></pre>
<p>피드백이 변경된것을 확인 할 수 있습니다. <code>dev/Example</code> 은 새로 생성된 클론의 위치를 나타냅니다. <code>/tmp/tutorial</code> 디렉토리를 보면 다음 파일이 있음을 알 수 있습니다.</p>
<pre class="none"><code>tutorial
├── dev
│   └── Example
├── Manifest.toml
└── Project.toml</code></pre>
<p>등록된 버전의 <code>Example</code> 을 로드하는 대신 Julia는 <code>tutorial/dev/Example</code> 에 포함된 소스 코드를 로드합니다.</p>
<p>자 이제 한번 해봅시다. 먼저 <code>tutorial/dev/Example/src/Example.jl</code> 에서 파일을 수정하고 간단한 함수를 추가합니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plusone</span>(x<span class="op">::</span><span class="dt">Int</span>) <span class="op">=</span> x <span class="op">+</span> <span class="fl">1</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이제 Julia REPL로 돌아가서 패키지를 로드할 수 있습니다.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="im">import</span> <span class="bu">Example</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<blockquote class="blockquote">
<p><strong>경고</strong><br>
패키지는 Julia 세션당 한 번만 로드할 수 있습니다. 현재 Julia 세션에서 <code>import Example</code> 을 실행한 경우 Julia를 다시 시작하고 Pkg REPL에서 <code>activate tutorial</code> 을 다시 실행해야 합니다. <a href="https://github.com/timholy/Revise.jl/">Revise.jl</a>은 이 이 과정을 훨씬 쾌적하게 만들 수 있지만 그것을 설정하는 것은 이 가이드의 범위를 벗어납니다.</p>
</blockquote>
<p><br></p>
<p>Julia는 새 코드를 로드해야 합니다. 테스트해 봅시다:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> Example.<span class="fu">plusone</span>(<span class="fl">1</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fl">2</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>우리가 생각이 바뀌어서 세상이 그런 우아한 코드를 받아들일 준비가 되어 있지 않다고 결정했다고 가정해 봅시다. Pkg에게 로컬 복제본 사용을 중지하고 대신 등록된 버전을 사용하도록 지시할 수 있습니다. <code>free</code> 를 사용합니다.</p>
<pre class="none"><code>(tutorial) pkg&gt; free Example</code></pre>
<p><code>tutorial</code> 실험을 마치면 인수 없이 <code>activate</code> 를 실행하여 <strong>기본 환경</strong>으로 돌아갈 수 있습니다.</p>
<pre class="none"><code>(tutorial) pkg&gt; activate

(v1.1) pkg&gt;</code></pre>
<p><br></p>
</section>
</section>
<section id="sec-managing_packages" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="sec-managing_packages"><span class="header-section-number">3</span> 패키지 관리</h2>
<p><br></p>
<section id="sec-adding_packages" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="sec-adding_packages"><span class="header-section-number">3.1</span> 패키지 추가</h3>
<p><code>add</code> 명령 또는 <code>dev</code> 명령으로 패키지를 추가 할 수 있습니다. 더 많이 사용되는 <code>add</code> 를 먼저 설명합니다.</p>
<p><br></p>
<section id="sec-adding_registered_packages" class="level4">
<h4 class="anchored" data-anchor-id="sec-adding_registered_packages">등록된 패키지 추가</h4>
<p>Pkg REPL에서 <code>add</code> 명령 다음에 패키지 이름을 사용하여 패키지를 추가할 수 있습니다. 예를 들면 다음과 같습니다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; add JSON</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  Installing known registries into `~/`</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>   Resolving package versions...</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>   Installed Parsers ─ v2.4.0</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>   Installed JSON ──── v0.21.3</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.8/Project.toml`</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  [682c06a0] + JSON v0.21.3</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    Updating `~/environments/v1.9/Manifest.toml`</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  [682c06a0] + JSON v0.21.3</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  [69de0a69] + Parsers v2.4.0</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  [ade2ca70] + Dates</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  [a63ad114] + Mmap</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>  [de0858da] + Printf</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  [4ec0a83e] + Unicode</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>Precompiling environment...</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>  2 dependencies successfully precompiled in 2 seconds</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>현재 프로젝트에 <code>JSON</code> 패키지를 추가했습니다. 여기서는 새로 설치된 Julia 를 사용하고 있으며 Pkg를 사용하여 패키지를 추가하는 것은 이번이 처음입니다. 기본적으로 Pkg는 Julia의 General 레지스트리를 설치하고 이 레지스트리를 사용하여 현재 환경에 추가할 패키지를 찾습니다. 상태 업데이트에서는 왼쪽에 짧은 형식의 패키지의 UUID(일종의 고유식별자 입니다), 패키지 이름 및 버전을 표시합니다. 마지막으로 새로 설치된 패키지는 “사전 컴파일(precompiled)”됩니다.</p>
<p>다수의 패키지를 한번에 설치할 때는 다음과 같이 합니다. <code>pkg&gt; add A B C</code>.</p>
<p>상태 출려은 당신이 추가한 패키지에 대해 출력합니다. 이경우 <code>JSON</code> 입니다.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>(@v1.11) pkg&gt; st</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    Status `~/.julia/environments/v1.8/Project.toml`</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  [682c06a0] JSON v0.21.3</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>manifest 상태는 재귀적 의존성을 포함하여 환경의 모든 패키지를 보여줍니다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>(@v1.11) pkg&gt; st -m</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>Status `~/environments/v1.9/Manifest.toml`</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  [682c06a0] JSON v0.21.3</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  [69de0a69] Parsers v2.4.0</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  [ade2ca70] Dates</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  [a63ad114] Mmap</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  [de0858da] Printf</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  [4ec0a83e] Unicode</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>Dates</code> 와 같은 표준 라이브러리는 Julia 와 같이 제공되므로 버젼이 없습니다.</p>
<p>특정 버전(또는 버전 집합)의 패키지를 사용하려면 <code>compat</code> 명령을 사용합니다. 예를 들어 JSON 패키지의 <code>v0.21</code> 시리즈에서 <code>v0.21.4</code> 이후의 모든 패치 릴리스를 요구하려면 다음과 같이 <code>compat</code> 명령을 호출합니다:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>(@1.11) pkg&gt; compat JSON 0.21.4</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>      Compat entry set:</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  JSON = "0.21.4"</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>     Resolve checking for compliance with the new compat rules...</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>       Error empty intersection between JSON@0.21.3 and project compatibility 0.21.4 - 0.21</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  Suggestion Call `update` to attempt to meet the compatibility requirements.</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>(@1.11) pkg&gt; update</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    Updating registry at `~/.julia/registries/General.toml`</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/1.11/Project.toml`</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>  [682c06a0] ↑ JSON v0.21.3 ⇒ v0.21.4</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/1.11/Manifest.toml`</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>  [682c06a0] ↑ JSON v0.21.3 ⇒ v0.21.4</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>compat</code> 을 사용하는 것에 대해 더 알고싶다면 <a href="">Compatibility</a> 을 참고하세요.</p>
<p>패키지가 프로젝트에 추가되면 Julia에서 로드할 수 있습니다.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>julia&gt; using JSON</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>julia&gt; JSON.json(Dict("foo" =&gt; [1, "bar"])) |&gt; print</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>{"foo":[1,"bar"]}</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
노트
</div>
</div>
<div class="callout-body-container callout-body">
<p><code>add</code> 명령어로 추가된 패키지만 로딩할 수 있습니다. 이 패키지는 Pkg REPL에서 <code>st</code> 명령을 사용할 때 표시되는 패키지들입니다. 반면, 의존성으로만 추가된 패키지(예: 위 예시의 Parsers 패키지)는 로딩할 수 없습니다.</p>
</div>
</div>
<p><code>@</code> 기호 뒤에 버전을 추가하여, 즉 패키지 이름 뒤에 <code>@v0.4</code> 와 같이 써서 특정 버전을 설치할 수 있습니다.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; add JSON@0.21.1</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>   Resolving package versions...</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.8/Project.toml`</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>⌃ [682c06a0] + JSON v0.21.1</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    Updating `~/environments/v1.9/Manifest.toml`</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>⌃ [682c06a0] + JSON v0.21.1</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>⌅ [69de0a69] + Parsers v1.1.2</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  [ade2ca70] + Dates</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>  [a63ad114] + Mmap</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>  [de0858da] + Printf</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>  [4ec0a83e] + Unicode</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>        Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ ar</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>위에서 볼 수 있듯이, Pkg는 패키지가 최신 버전으로 설치되지 않은 경우 일부 정보를 제공합니다.</p>
<p>버전 번호가 세 자리가 아닌 경우, 예를 들어 0.21만 주어진다면, 0.21.x의 최신 등록된 버전이 설치됩니다.</p>
<p><code>Example</code> 패키지의 브랜치(또는 특정 커밋)에 핫픽스가 포함되어 있지만, 아직 등록된 버전에는 포함되지 않은 경우, 해당 브랜치(또는 커밋)를 명시적으로 추적할 수 있습니다. 이를 위해 패키지 이름 뒤에 <code>#branchname</code> (또는 <code>#commitSHA1</code>)을 추가합니다:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; add Example#master</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>     Cloning git-repo `https://github.com/JuliaLang/Example.jl.git`</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>   Resolving package versions...</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.8/Project.toml`</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    Updating `~/environments/v1.9/Manifest.toml`</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이제 상태 출력에 <code>Example</code>의 <code>master</code> branch 를 추적하고 있음이 표시됩니다. 패키지를 업데이트할 때 해당 분기에서 업데이트를 가져옵니다.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
노트
</div>
</div>
<div class="callout-body-container callout-body">
<p>만약 브랜치 이름 대신 커밋 ID를 지정하면, 예를 들어 <code>add Example#025cf7e</code> 와 같이 입력하면, 해당 커밋에 <strong>“고정(pinned)”</strong>된 패키지를 사용하게 됩니다. 이는 커밋 ID가 항상 동일한 내용을 가리키기 때문입니다. 반면, 브랜치는 업데이트될 수 있기 때문에 특정 시점의 커밋을 고정하려면 커밋 ID를 사용하는 것이 좋습니다.</p>
</div>
</div>
<p><br></p>
<p><code>Example</code> 의 레지스트리 버전 추적으로 돌아가려면 <code>free</code> 명령을 사용합니다.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; free Example</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>   Resolving package versions...</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>   Installed Example ─ v0.5.3</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.8/Project.toml`</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    Updating `~/environments/v1.9/Manifest.toml`</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="adding_unregistred_packages" class="level4">
<h4 class="anchored" data-anchor-id="adding_unregistred_packages">등록되지 않은 패키지 추가</h4>
<p>패키지가 레지스트리에 없는 경우 Git 저장소에 대한 URL을 지정하여 패키지를 추가할 수 있습니다.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; add https://github.com/fredrikekre/ImportMacros.jl</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>     Cloning git-repo `https://github.com/fredrikekre/ImportMacros.jl`</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>   Resolving package versions...</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.8/Project.toml`</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  [92a963f6] + ImportMacros v1.0.0 `https://github.com/fredrikekre/ImportMacros.jl#master`</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    Updating `~/environments/v1.9/Manifest.toml`</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>  [92a963f6] + ImportMacros v1.0.0 `https://github.com/fredrikekre/ImportMacros.jl#master`</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>등록되지 않은 패키지가 의존하는 패키지(여기서는 <code>MacroTools</code>)가 설치되었습니다. 등록되지 않은 패키지의 경우 등록된 패키지와 마찬가지로 <code>#</code>을 사용하여 추적하기 위해 브랜치 이름(또는 커밋 <code>SHA1</code>)을 제시할 수 있습니다.</p>
<p>SSH 기반 <code>git</code> 프로토콜을 사용하여 패키지를 추가하려면 URL에 <code>@</code> 가 포함되어 있으므로 따옴표를 사용해야 합니다. 예를 들어,</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; add "git@github.com:fredrikekre/ImportMacros.jl.git"</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    Cloning git-repo `git@github.com:fredrikekre/ImportMacros.jl.git`</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>   Updating registry at `~/.julia/registries/General`</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  Resolving package versions...</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>Updating `~/.julia/environments/v1/Project.toml`</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>Updating `~/.julia/environments/v1/Manifest.toml`</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="sec-adding_a_package_in_a_subdirectory_of_a_repository" class="level4">
<h4 class="anchored" data-anchor-id="sec-adding_a_package_in_a_subdirectory_of_a_repository">저장소의 서브디렉토리에 있는 패키지 추가하기</h4>
<p>만약 URL 로 설치하기를 원하는 패키지가 저장소의 루트 디렉토리가 아닌 서브디렉토리에 위치한다면 <code>:</code> 를 사용합니다. 예를 들어 <a href="https://github.com/timholy/SnoopCompile.jl"><code>SnoopComple</code></a> 저장소의 <code>SnoopcompileCore</code> 패키지 를 설치하고자 한다면 다음과 같이 합니다.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>pkg&gt; add https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    Cloning git-repo `https://github.com/timholy/SnoopCompile.jl.git`</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>   Resolving package versions...</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.8/Project.toml`</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  [e2b509da] + SnoopCompileCore v2.9.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.8/Manifest.toml`</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  [e2b509da] + SnoopCompileCore v2.9.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>  [9e88b42a] + Serialization</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="sec-adding_a_local_package" class="level4">
<h4 class="anchored" data-anchor-id="sec-adding_a_local_package">로칼 패키지 추가</h4>
<p>Git 저장소의 URL을 제공하는 대신, 로컬 경로를 지정하여 Git 저장소를 추가할 수도 있습니다. 이는 URL을 추가하는 것과 유사하게 작동합니다. 로컬 저장소가 지정되면, 해당 저장소의 특정 브랜치를 추적하게 되며, 패키지를 업데이트할 때 그 로컬 저장소에서 업데이트를 가져옵니다</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
경고
</div>
</div>
<div class="callout-body-container callout-body">
<p>다음 섹션에서 설명하겠지만 <code>add</code> 명령어로 패키지를 추적하는 것과 <code>develop</code> 명령어를 사용하는 것은 다릅니다. 로컬 Git 저장소에서 <code>add</code> 를 사용하여 패키지를 추가하면 로컬 패키지 저장소에서 파일을 수정해도 그 변경 사항이 즉시 로드되는 패키지에 반영되지 않습니다. 변경 사항은 커밋되고, 패키지를 업데이트해야만 반영됩니다.</p>
<p>대부분의 경우, 로컬 경로에서 작업할 때는 <code>add</code> 보다는 <code>develop</code> 을 사용하는 것이 적합합니다. <code>develop</code> 은 로컬 패키지의 변경 사항을 실시간으로 추적하고 반영할 수 있도록 해줍니다.</p>
</div>
</div>
<p><br></p>
</section>
<section id="sec-developing_package" class="level4">
<h4 class="anchored" data-anchor-id="sec-developing_package">패키지 개발</h4>
<p><code>add</code> 만 사용하면 환경은 항상 <em>재현 가능한 상태</em> 를 유지합니다. 즉, 사용된 레지스트리와 저장소가 여전히 접근 가능하다면, 환경 내 모든 의존성의 정확한 상태를 다시 가져올 수 있습니다. 이 방식의 장점은 <code>Project.toml</code> 과 <code>Manifest.toml</code> 파일을 다른 사람에게 보내면, 그 사람이 해당 환경을 <code>Pkg.instantiate</code> 명령을 통해 동일한 상태로 재현할 수 있다는 점입니다. 하지만 패키지를 개발할 때는 패키지를 현재 상태에서 로드하는 것이 더 편리합니다. 이를 위해 <code>dev</code> 명령어가 존재합니다. <code>dev</code> 는 로컬 경로에 있는 패키지를 개발 중인 상태로 추적하고, 즉시 반영할 수 있게 해줍니다.</p>
<p>등록된 패키지를 <code>dev</code> 해 봅시다:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; dev Example</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>   Resolving package versions...</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.8/Project.toml`</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  [7876af07] + Example v0.5.4 `~/.julia/dev/Example`</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.8/Manifest.toml`</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>  [7876af07] + Example v0.5.4 `~/.julia/dev/Example`</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>dev</code> 명령은 패키지의 전체 복사본을 <code>~/.julia/dev/</code> 로 가져옵니다(경로는 <code>JULIA_PKG_DEVDIR</code> 환경 변수를 설정하여 변경할 수 있으며 기본값은 <code>joinpath(DEPOT_PATH[1],"dev")</code> 입니다). <code>Example</code> 을 가져올 때 julia는 이제 <code>~/.julia/dev/Example</code> 에서 가져오고 해당 경로의 파일에 대한 모든 로컬 변경 사항이 결과적으로 로드된 코드에 반영됩니다. <code>add</code> 를 사용할 때 우리는 패키지 저장소를 추적한다고 말했지만 여기에서는 경로 자체를 추적한다고 말합니다. 패키지 관리자는 추적된 경로에 있는 파일을 건드리지 않는다는 것에 주의하십시요. 따라서 업데이트 가져오기, 브랜치 변경 등은 사용자에게 달려 있습니다. <code>~/.julia/dev/</code> 패키지 매니저 에 이미 존재하는 어떤 브랜치의 패키지를 <code>dev</code> 하면, 단순히 기존 경로를 사용합니다. 로컬 경로에서 <code>dev</code> 를 사용하면, 그 경로가 기록되고 패키지를 로드할 때 사용됩니다. 이 경로는 프로젝트 파일을 기준으로 상대 경로로 기록되며, 절대 경로로 제공된 경우에는 절대 경로로 기록됩니다.</p>
<p><code>~/.julia/dev/Example/src/Example.jl</code> 파일을 수정하여 간단한 함수를 추가해보겠습니다.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plusone</span>(x<span class="op">::</span><span class="dt">Int</span>) <span class="op">=</span> x <span class="op">+</span> <span class="fl">1</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이제 Julia REPL 로 돌아가 패키지를 로드하고 새로운 함수를 실행시켜 봅시다.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>julia&gt; import Example</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>julia&gt; Example.plusone(1)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>2</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
경고
</div>
</div>
<div class="callout-body-container callout-body">
<p>한 Julia 세션에서 패키지는 한 번만 로드될 수 있습니다. 따라서 현재 세션에서 <code>import Example</code> 을 실행한 경우, <code>Example</code> 패키지의 변경 사항을 확인하려면 Julia 세션을 재시작해야 합니다.</p>
<p>이 과정은 <a href="https://github.com/timholy/Revise.jl/"><code>Revise.jl</code></a> 을 사용하면 훨씬 더 편리하게 처리할 수 있습니다. <code>Revise.jl</code> 은 패키지의 소스 코드가 변경될 때마다 자동으로 새로 고침하여 세션을 재시작하지 않고도 변경 사항을 즉시 반영할 수 있게 해줍니다. 하지만 <code>Revise.jl</code> 의 설정은 이 가이드의 범위를 벗어나므로, 더 자세한 설정 방법은 <code>Revise.jl</code> 문서를 참고하는 것이 좋습니다.</p>
</div>
</div>
<p>경로를 추적하는 것을 멈추고 다시 등록된 버젼을 사용하고 싶다면 <code>free</code> 명령어를 사용합니다.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; free Example</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>   Resolving package versions...</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.8/Project.toml`</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  [7876af07] ~ Example v0.5.4 `~/.julia/dev/Example` ⇒ v0.5.3</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    Updating `~/.julia/environments/v1.8/Manifest.toml`</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  [7876af07] ~ Example v0.5.4 `~/.julia/dev/Example` ⇒ v0.5.3</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>dev</code> 명령어를 사용하면 프로젝트가 본질적으로 상태 저장(stateful) 방식이 됩니다. 즉, 프로젝트의 상태는 해당 경로에 있는 파일들의 현재 내용에 의존하게 됩니다. 이 경우, Manifest는 프로젝트의 정확한 상태를 “인스턴스화”하는 데 사용할 수 없습니다. 다른 사람이 동일한 상태로 프로젝트를 실행하려면 해당 패스에서 추적하는 모든 패키지의 정확한 내용을 알아야 합니다.</p>
<p>또한, 로컬 경로를 추적하는 패키지에 의존성을 추가하면 Manifest(전체 의존성 그래프를 포함하는)가 실제 의존성 그래프와 일치하지 않게 됩니다. 즉, Manifest에 해당 의존성이 기록되지 않기 때문에 패키지는 그 의존성을 로드할 수 없습니다. 이를 해결하려면, <code>resolve</code> 명령어를 사용하여 Manifest를 동기화해야 합니다.</p>
<p>또한, <code>add</code> 와 <code>dev</code> 명령은 상대 경로(relative paths)도 지원합니다. 이 경우, 활성 프로젝트에서 패키지까지의 상대 경로가 저장됩니다. 이는 패키지의 절대 경로보다 상대적인 위치가 더 중요한 경우에 유용합니다. 예를 들어, 추적하는 의존성들이 활성 프로젝트 디렉토리 내에 있을 때, 해당 디렉토리 전체를 이동시켜도 Pkg는 의존성의 상대 경로를 통해 여전히 의존성을 찾을 수 있습니다. 이는 절대 경로가 변경되었더라도, 상대 경로가 유지되기 때문입니다.</p>
<p><br></p>
</section>
</section>
<section id="sec-removing_packages" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="sec-removing_packages"><span class="header-section-number">3.2</span> 패키지 제거</h3>
<p><code>pkg&gt; rm Package</code> 를 사용하여 현재 프로젝트에서 패키지를 제거할 수 있습니다. 이렇게 하면 프로젝트에 있는 패키지만 제거됩니다. 의존성으로만 존재하는 패키지를 제거하려면 <code>pkg&gt; rm --manifest DepPackage</code> 를 사용하십시오. 이렇게 하면 <code>DepPackage</code>에 의존하는 모든 패키지가 제거됩니다.</p>
<p><br></p>
</section>
<section id="sec-updating_packages" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="sec-updating_packages"><span class="header-section-number">3.3</span> 패키지 업데이트</h3>
<p>프로젝트에서 사용 중인 패키지의 새 버전이 릴리스되면 업데이트하는 것이 좋습니다. <code>up</code> 을 호출하기만 하면 프로젝트의 <em>모든</em> 의존성을 최신 호환 버전으로 업데이트하려고 시도합니다. 가끔은 이것을 원하지 않을 수도 있습니다. <code>up</code> 에 인수로 제공하여 업그레이드할 의존성의 하위 집합을 지정할 수 있습니다:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; up Example</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>위의 명령은 오직 <code>Example</code> 만 업그레이드 하도록 합니다. <code>--preserve=direct</code> 플래그를 사용하면, Example 패키지의 의존성 중 직접 의존하는 패키지들만 업그레이드할 수 있게 됩니다. 즉, 프로젝트에 명시적으로 추가된 패키지들은 업그레이드되지 않지만, 간접적으로 의존하는 패키지들은 업데이트될 수 있습니다.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; up --preserve=direct Example</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>만약 Example 패키지의 의존성뿐만 아니라 프로젝트에 명시적으로 추가된 의존성도 업그레이드하고 싶다면, <code>--preserve=none</code> 플래그를 사용할 수 있습니다. 이 플래그를 사용하면 직접 의존성과 간접 의존성 모두 업그레이드가 허용됩니다.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; up --preserve=none Example</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="sec-pinning_a_package" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="sec-pinning_a_package"><span class="header-section-number">3.4</span> 패키지 고정</h3>
<p>고정된 패키지는 절대 업데이트되지 않습니다. <code>pin</code> 을 사용하여 패키지를 고정할 수 있습니다. 예를 들면 다음과 같습니다.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; pin Example</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a> Resolving package versions...</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  Updating `~/.julia/environments/v1.8/Project.toml`</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  [7876af07] ~ Example v0.5.3 ⇒ v0.5.3 ⚲</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  Updating `~/.julia/environments/v1.8/Manifest.toml`</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  [7876af07] ~ Example v0.5.3 ⇒ v0.5.3 ⚲</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>패키지가 고정되었음을 나타내는 핀 기호 <code>⚲</code>에 유의하십시오. 핀 제거는 <code>free</code> 를 사용합니다.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; free Example</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  Updating `~/.julia/environments/v1.8/Project.toml`</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  [7876af07] ~ Example v0.5.3 ⚲ ⇒ v0.5.3</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>  Updating `~/.julia/environments/v1.8/Manifest.toml`</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  [7876af07] ~ Example v0.5.3 ⚲ ⇒ v0.5.3</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="sec-testing_package" class="level3" data-number="3.5">
<h3 data-number="3.5" class="anchored" data-anchor-id="sec-testing_package"><span class="header-section-number">3.5</span> 패키지 테스트</h3>
<p>패키지에 대한 테스트는 <code>test</code> 명령을 사용하여 실행할 수 있습니다.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; test Example</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>   Testing Example</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>   Testing Example tests passed</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="sec-building_package" class="level3" data-number="3.6">
<h3 data-number="3.6" class="anchored" data-anchor-id="sec-building_package"><span class="header-section-number">3.6</span> 패키지 빌드</h3>
<p>패키지의 빌드 단계는 패키지가 처음 설치될 때 자동으로 실행됩니다. 빌드 프로세스의 출력은 파일로 보내집니다. 패키지의 빌드 단계를 명시적으로 실행하려면 <code>build</code> 명령을 사용합니다.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; build IJulia</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    Building Conda ─→ `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/6e47d11ea2776bc5627421d59cdcc1296c058071/build.log`</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    Building IJulia → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/98ab633acb0fe071b671f6c1785c46cd70bb86bd/build.log`</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>julia&gt; print(read(joinpath(homedir(), ".julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/98ab633acb0fe071b671f6c1785c46cd70bb86bd/build.log"), String))</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>[ Info: Installing Julia kernelspec in /home/kc/.local/share/jupyter/kernels/julia-1.8</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="sec-interpreting_and_resolving_version_conficts" class="level3" data-number="3.7">
<h3 data-number="3.7" class="anchored" data-anchor-id="sec-interpreting_and_resolving_version_conficts"><span class="header-section-number">3.7</span> 버젼 충돌의 해석과 해소</h3>
<p>환경은 상호 호환 가능한 패키지 세트로 구성됩니다. 때로는 동시에 사용하려는 두 패키지의 요구 사항이 호환되지 않는 상황에 처할 수 있습니다. 이러한 경우 “충족할 수 없는 요구 사항(Unsatisfiable requirements)” 오류가 발생합니다.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>pkg&gt; add A</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>Unsatisfiable requirements detected for package D [756980fe]:</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a> D [756980fe] log:</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a> ├─possible versions are: 0.1.0 - 0.2.1 or uninstalled</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a> ├─restricted by compatibility requirements with B [f4259836] to versions: 0.1.0</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a> │ └─B [f4259836] log:</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a> │   ├─possible versions are: 1.0.0 or uninstalled</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a> │   └─restricted to versions * by an explicit requirement, leaving only versions: 1.0.0</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a> └─restricted by compatibility requirements with C [c99a7cb2] to versions: 0.2.0 — no versions left</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>   └─C [c99a7cb2] log:</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>     ├─possible versions are: 0.1.0 - 0.2.0 or uninstalled</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>     └─restricted by compatibility requirements with A [29c70717] to versions: 0.2.0</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>       └─A [29c70717] log:</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>         ├─possible versions are: 1.0.0 or uninstalled</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>         └─restricted to versions * by an explicit requirement, leaving only versions: 1.0.0</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 메시지는 <code>D</code> 라는 패키지에 버전 충돌이 있음을 의미합니다. <code>D</code> 를 직접 추가한 적이 없더라도 사용하려는 다른 패키지에서 <code>D</code> 가 필요한 경우 이러한 종류의 오류가 발생할 수 있습니다.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
노트
</div>
</div>
<div class="callout-body-container callout-body">
<p>이러한 충돌을 해결할 때는 우선 프로젝트가 커질수록 이런 일이 발생할 가능성이 더 높다는 점을 고려하십시오. 어떤 주어진 과업에는 해당하는 프로젝트를 사용하는 것이 좋습니다. 사용하지 않는 의존성을 제거하는 것은 이러한 문제가 발생할 때 좋은 첫 번째 단계입니다. 예를 들어 일반적인 함정은 기본(예: (<code>@1.8</code>)) 환경에 몇 개 이상의 패키지가 있고 이를 julia를 사용하는 모든 작업의 환경으로 사용하는 것입니다. 작업 중인 작업을 위한 전용 프로젝트를 만들고 거기에 의존성을 최소화하는 것이 좋습니다. 자세한 내용은 <a href="#4-환경을-이용한-작업">환경을 이용한 작업</a>을 참조하십시오.</p>
</div>
</div>
<p><br></p>
<p>오류 메시지에는 중요한 정보가 많이 있습니다. 낱낱이 해석하는 것이 가장 쉬울 수 있습니다.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>Unsatisfiable requirements detected for package D [756980fe]:</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a> D [756980fe] log:</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a> ├─possible versions are: [0.1.0, 0.2.0-0.2.1] or uninstalled</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>위의 메시지는 <code>D</code> 에 <code>v0.1.0</code>, <code>v0.2.0</code> 및 <code>v0.2.1</code> 의 세 가지 릴리스 버전이 있음을 의미합니다. 전혀 설치하지 않는 옵션도 있습니다. 이러한 각 옵션은 설치할 수 있는 다른 패키지 집합에 대해 서로 다른 의미를 가질 수 있습니다.</p>
<p>결정적으로 획문자(수직 및 수평선)와 들여쓰기를 확인하십시오. 이들은 메시지와 특정 패키지를 연결하는데 같이 사용됩니다. 예를 들어 <code>├─</code> 의 오른쪽 획은 오른쪽에 있는 메시지(<code>possible versions...</code>)가 수직 획(<code>D</code>)이 가리키는 패키지에 연결되어 있음을 나타냅니다. 다음 줄에도 동일한 원칙이 적용됩니다.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a> ├─restricted by compatibility requirements with B [f4259836] to versions: 0.1.0</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>여기서 세로 획도 <code>D</code> 아래에 정렬되어 있으므로 이 메시지는 <code>D</code> 를 참조합니다. 특히 <code>D</code> 의 버전 <code>v0.1.0</code> 에 의존하는 다른 패키지 B가 있습니다. 이것은 <code>D</code> 의 최신 버전이 아닙니다.</p>
<p>다음은 <code>B</code>에 대한 정보입니다.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a> │ └─B [f4259836] log:</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a> │   ├─possible versions are: 1.0.0 or uninstalled</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a> │   └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>첫 번째 줄 아래의 두 줄에는 <code>B</code> 와 정렬되는 세로 획이 있으므로 <code>B</code> 에 대한 정보를 제공합니다. <code>B</code> 에 <code>v1.0.0</code> 릴리스가 하나만 있음을 알려줍니다. <code>B</code> 의 특정 버전을 지정하지 않았지만(<code>restricted to versions *</code>은 모든 버전이 가능함을 의미합니다) 명시적 요구 사항은 <code>B</code> 가 환경의 일부가 되도록 요청했음을 의미합니다(예: <code>pkg&gt; add B</code>). 이전에 <code>B</code>를 요청했을 수 있으며 요구 사항이 여전히 유효합니다.</p>
<p>선으로 인해 충돌이 분명해집니다.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>└─restricted by compatibility requirements with C [c99a7cb2] to versions: 0.2.0 — no versions left</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>여기서 다시 세로 획은 <code>D</code> 와 정렬됩니다. 이것은 <code>D</code> 가 다른 패키지 <code>C</code> 에도 필요함을 의미합니다. <code>C</code> 에는 <code>D</code> 의 <code>v0.2.0</code> 이 필요하며 이는 <code>D</code> 의 <code>v0.1.0</code> 에 대한 <code>B</code>의 요구와 충돌합니다. 이것이 충돌을 설명합니다.</p>
<p>하지만 잠깐, <code>C</code> 가 무엇이고 왜 <code>C</code> 가 필요한지 물을 수 있습니다. 다음 몇 줄은 문제를 소개합니다.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>   └─C [c99a7cb2] log:</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>     ├─possible versions are: [0.1.0-0.1.1, 0.2.0] or uninstalled</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>     └─restricted by compatibility requirements with A [29c70717] to versions: 0.2.0</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이는 <code>C</code> 에 대한 자세한 정보를 제공하며 <code>v0.1.0</code>, <code>v0.1.1</code> 및 <code>v0.2.0</code> 의 3개 릴리스 버전이 있음을 나타냅니다. 또한 <code>C</code> 는 다른 패키지 <code>A</code> 에 필요합니다. 실제로 <code>A</code> 의 요구 사항은 <code>C</code> 의 <code>v0.2.0</code> 이 필요하다는 것입니다. <code>A</code> 의 출처는 다음 줄에 표시됩니다.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>       └─A [29c70717] log:</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>         ├─possible versions are: 1.0.0 or uninstalled</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>         └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>따라서 <code>A</code> 가 명시적으로 필요하다는 것을 알 수 있습니다. 이 경우에는 <code>A</code> 를 환경에 추가하려고 했기 때문입니다.</p>
<p>요약하면 우리는 명시적으로 <code>A</code> 와 <code>B</code> 를 사용하도록 요청했지만 이로 인해 <code>D</code> 와 충돌이 발생했습니다. 그 이유는 <code>B</code> 와 <code>C</code> 가 충돌하는 버전의 <code>D</code> 를 필요로 하기 때문입니다. <code>C</code> 는 우리가 명시적으로 요청한 것이 아니지만 <code>A</code> 가 필요로 했습니다.</p>
<p>이러한 오류를 수정하려면 다음과 같은 여러 가지 옵션이 있습니다.</p>
<ul>
<li><p><a href="#패키지-업데이트">패키지 업데이트</a>를 시도하십시오. 패키지의 개발자가 최근 상호 호환되는 새 버전을 출시했을 가능성이 있습니다.</p></li>
<li><p>환경에서 <code>A</code> 또는 <code>B</code> 를 제거하십시오. 아마도 <code>B</code> 는 이전에 작업하던 작업에서 남겨져 더 이상 필요하지 않을 수 있습니다. <code>A</code> 와 <code>B</code> 가 동시에 필요하지 않은 경우 문제를 해결하는 가장 쉬운 방법입니다.</p></li>
<li><p>충돌을 보고합니다. 이 경우 <code>B</code> 에는 오래된 버전의 <code>D</code> 가 필요하다고 추론할 수 있었습니다. 따라서 <code>B.jl</code> 의 개발 저장소에서 업데이트된 버전을 요청하는 이슈를 보고할 수 있습니다.</p></li>
<li><p>문제를 직접 해결해 보십시오. <code>Project.toml</code> 파일과 파일이 호환성 요구 사항을 선언하는 방법을 이해하면 이 작업이 더 쉬워집니다. <a href="#충돌-수정">충돌 해결</a>에서 이 예제로 돌아갑니다.</p></li>
</ul>
<p><br></p>
</section>
<section id="sec-garbage_collecting_old_unused_packages" class="level3" data-number="3.8">
<h3 data-number="3.8" class="anchored" data-anchor-id="sec-garbage_collecting_old_unused_packages"><span class="header-section-number">3.8</span> 오래되고 사용되지 않는 패키지를 가비지 컬렉팅 하기</h3>
<p>패키지가 업데이트되고 프로젝트가 삭제되면 설치된 패키지 버전과 아티팩트는 필연적으로 오래되어 기존 프로젝트에서 사용되지 않습니다. <code>Pkg</code> 는 사용된 모든 프로젝트의 로그를 유지하므로 로그를 통해 어떤 프로젝트가 여전히 존재하고 해당 프로젝트에서 어떤 패키지/아티팩트가 사용되었는지 정확히 확인할 수 있습니다. 패키지 또는 아티팩트가 프로젝트에서 사용된 것으로 표시되지 않은 경우 고아 패키지(orphaned package) 목록에 추가됩니다. 다시 사용하지 않고 30일 동안 고아 목록에 있는 패키지 및 아티팩트는 다음 가비지 수집 시 시스템에서 삭제됩니다. 이 시점은 <code>Pkg.gc()</code>에 대한 <code>collect_delay</code> 키워드 인수를 통해 설정할 수 있습니다. 값이 0이면 사용하지 않는 항목이 고아목록을 건너뛰고 즉시 삭제됩니다. 디스크 공간이 부족하고 사용하지 않는 패키지와 아티팩트를 가능한 한 많이 정리하려는 경우 이 방법을 시도해 볼 수 있지만 이러한 버전이 다시 필요한 경우 다시 다운로드해야 합니다. 기본 인수를 사용하여 일반적인 가비지 수집을 실행하려면 <code>pkg&gt;</code> REPL에서 <code>gc</code> 명령을 사용하면 됩니다.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>(@v1.8) pkg&gt; gc</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    Active manifests at:</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>        `~/BinaryProvider/Manifest.toml`</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>        ...</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>        `~/Compat.jl/Manifest.toml`</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    Active artifacts:</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>        `~/src/MyProject/Artifacts.toml`</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    Deleted ~/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>    Deleted ~/.julia/packages/Cassette/BXVB: 795.557 KiB</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>   Deleted `~/.julia/artifacts/e44cdf2579a92ad5cbacd1cddb7414c8b9d2e24e` (152.253 KiB)</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>   Deleted `~/.julia/artifacts/f2df5266567842bbb8a06acca56bcabf813cd73f` (21.536 MiB)</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>   Deleted 36 package installations (113.205 MiB)</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>   Deleted 15 artifact installations (20.759 GiB)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>~/.julia/packages</code> 에 포함된 패키지만 삭제되는 것을 확인 할 수 있습니다.</p>
<p><br></p>
</section>
<section id="sec-offline_mode" class="level3" data-number="3.9">
<h3 data-number="3.9" class="anchored" data-anchor-id="sec-offline_mode"><span class="header-section-number">3.9</span> 오프라인 모드</h3>
<p>오프라인 모드에서 Pkg는 인터넷에 연결하지 않고 가능한 한 많은 일을 하려고 합니다. 예를 들어 패키지를 추가할 때 Pkg는 버전 확인에서 이미 다운로드된 버전만 고려합니다.</p>
<p>오프라인 모드에서 작업하려면 <code>import Pkg</code> 를 사용하십시오. <code>Pkg.offline(true)</code> 또는 환경 변수 <code>JULIA_PKG_OFFLINE</code> 을 “<code>true</code>” 로 설정합니다.</p>
<p><br></p>
</section>
<section id="sec-pkg_client_server" class="level3" data-number="3.10">
<h3 data-number="3.10" class="anchored" data-anchor-id="sec-pkg_client_server"><span class="header-section-number">3.10</span> Pkg 클라이언트/서버</h3>
<p>등록된 패키지를 새로 추가하면 일반적으로 다음 세 가지가 발생합니다.</p>
<ol type="1">
<li><p>레지스트리 업데이트,</p></li>
<li><p>패키지의 소스 코드 다운로드,</p></li>
<li><p>사용할 수 없는 경우 패키지에 필요한 <a href="#8-아티팩트artifacts">아티팩트</a>를 다운로드.</p></li>
</ol>
<p><a href="https://github.com/JuliaRegistries/General">General</a> 레지스트리와 그 안에 있는 대부분의 패키지는 Github 에서 개발되며 아티팩트 데이터는 다양한 플랫폼에서 호스팅됩니다. Github 및 AWS S3에 대한 네트워크 연결이 안정적이지 않은 경우 일반적으로 패키지를 설치하거나 업데이트하는 것은 좋은 경험이 아닙니다. 다행스럽게도 pkg 클라이언트/서버 기능은 다음과 같은 측면에서 경험을 향상시킵니다.</p>
<ol type="1">
<li><p>설정된 경우 pkg 클라이언트는 먼저 pkg 서버에서 데이터 다운로드를 시도합니다.</p></li>
<li><p>실패하면 원래 소스(예: Github)에서 다시 다운로드합니다.</p></li>
</ol>
<p>기본적으로, Pkg 클라이언트는 서버에 최대 8개의 동시 요청을 보냅니다. 이 동시 요청의 수는 <code>JULIA_PKG_CONCURRENT_DOWNLOADS</code> 환경 변수를 설정하여 조정할 수 있습니다.</p>
<p>Julia 1.5부터 JuliaLang 이 제공하는 기본 패키지 서버는 https://pkg.julialang.org 입니다. 대다수의 경우 이는 투명하게 작동하므로 사용자가 별도로 설정할 필요가 없습니다. 그러나 필요할 경우 사용자들은 환경 변수 <code>JULIA_PKG_SERVER</code>를 통해 직접 패키지 서버를 설정하거나 해제할 수 있습니다.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co"># manually set it to some pkg server</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="cn">ENV</span>[<span class="st">"JULIA_PKG_SERVER"</span>] <span class="op">=</span> <span class="st">"pkg.julialang.org"</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="st">"pkg.julialang.org"</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="co"># unset to always download data from original sources</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="cn">ENV</span>[<span class="st">"JULIA_PKG_SERVER"</span>] <span class="op">=</span> <span class="st">""</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="st">""</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>명확하게 하자면, 일부 소스는 Pkg 서버에서 제공하지 않습니다.</p>
<ul>
<li><p>git을 통해 가져온 패키지/레지스트리</p>
<ul>
<li><p><code>]add https://github.com/JuliaLang/Example.jl.git</code></p></li>
<li><p><code>]add Example#v0.5.3</code> (이것은 <code>]add Example@0.5.3</code>과 다릅니다)</p></li>
<li><p><code>]registry add https://github.com/JuliaRegistries/General.git</code>, 1.4 이전에 Julia가 설치한 레지스트리 포함됨</p></li>
</ul></li>
<li><p>다운로드 정보가 없는 아티팩트</p>
<ul>
<li><a href="https://github.com/JuliaImages/TestImages.jl/blob/eaa94348df619c65956e8cfb0032ecddb7a29d3a/Artifacts.toml#L1-L2">TestImages</a></li>
</ul></li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
노트
</div>
</div>
<div class="callout-body-container callout-body">
<p>pkg 서버를 통해 새 레지스트리를 설치한 경우 이전 Julia 버전이 레지스트리를 업데이트하는 것은 불가능합니다. 1.4 이전의 Julia는 새 데이터를 가져오는 방법을 모르기 때문입니다. 따라서 여러 julia 버전 간에 자주 전환하는 사용자의 경우 git 제어 레지스트리를 계속 사용하는 것이 좋습니다.</p>
</div>
</div>
<p><br></p>
<p>pkg 서버 배포에 대해서는 <a href="https://github.com/JuliaPackaging/PkgServer.jl">PkgServer.jl</a>을 참조하십시오.</p>
<p><br></p>
</section>
</section>
<section id="sec-working_with_environment" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="sec-working_with_environment"><span class="header-section-number">4</span> 환경을 이용한 작업</h2>
<p>다음은 Pkg와 환경의 상호 작용에 대해 설명합니다. 코드를 로드할 수 있는 환경의 “스택”을 포함하여 코드를 로딩할 때의 환경의 역할에 대한 자세한 내용은 <a href="https://docs.julialang.org/en/v1/manual/code-loading/#Environments-1">Julia 설명서의 이 섹션</a>을 참조하세요.</p>
<p><br></p>
<section id="sec-creating_your_own_project" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="sec-creating_your_own_project"><span class="header-section-number">4.1</span> 당신의 프로젝트를 생성하기</h3>
<p>지금까지 <code>~/.julia/environments/v1.9</code> 의 기본 프로젝트에 패키지를 추가했습니다. 그러나 다른 독립적인 프로젝트를 만드는 것은 쉽습니다. 이 접근 방식은 <code>Project.toml</code> 및 원하는 경우 <code>Manifest.toml</code> 을 코드와 함께 버전 제어(예: git)에 체크인할 수 있는 이점이 있습니다. 두 프로젝트가 동일한 버전의 동일한 패키지를 사용하는 경우 이 패키지의 내용이 중복되지 않는다는 점에 유의해야 합니다. 새 프로젝트를 만들려면 디렉터리를 만든 다음 해당 디렉터리를 활성화하여 패키지 작업이 처리하는 “활성 프로젝트(active project)”로 만듭니다.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>julia&gt; mkdir("MyProject")</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>julia&gt; cd("MyProject")</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>/Users/kristoffer/MyProject</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a># we can now use "." instead of a longer relative or full path:</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>(v1.0) pkg&gt; activate .</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>(MyProject) pkg&gt; st</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    Status `Project.toml`</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>새 프로젝트가 활성화되면 REPL 프롬프트가 변경되었습니다. 이것은 새로 생성된 프로젝트이므로 상태 명령은 패키지가 포함되어 있지 않으며 실제로 패키지를 추가할 때까지 프로젝트 또는 메니패스트 파일이 없음을 보여줍니다.</p>
<pre class="none"><code>julia&gt; readdir()
0-element Array{String,1}

(MyProject) pkg&gt; add Example
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
 Resolving package versions...
  Updating `Project.toml`
  [7876af07] + Example v0.5.1
  Updating `Manifest.toml`
  [7876af07] + Example v0.5.1
  [8dfed614] + Test
Precompiling project...
  1 dependency successfully precompiled in 2 seconds

julia&gt; readdir()
2-element Array{String,1}:
 "Manifest.toml"
 "Project.toml"

julia&gt; print(read("Project.toml", String))
[deps]
Example = "7876af07-990d-54b4-ab0e-23690620f79a"

julia&gt; print(read("Manifest.toml", String))
[[Example]]
deps = ["Test"]
git-tree-sha1 = "8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8"
uuid = "7876af07-990d-54b4-ab0e-23690620f79a"
version = "0.5.1"

[[Test]]
uuid = "8dfed614-e22c-5e08-85e1-65c5234f0b40"</code></pre>
<p>이 새로운 환경은 이전에 사용했던 환경과 완전히 별개입니다.</p>
<p><br></p>
</section>
<section id="프로젝트-사전-컴파일precompile" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="프로젝트-사전-컴파일precompile"><span class="header-section-number">4.2</span> 프로젝트 사전 컴파일(Precompile)</h3>
<p>패키지를 임포트 하기 전에 Julia는 소스 코드를 디스크상에서의 더 효율적인 중간 캐시로 “사전 컴파일(precompile)”합니다. 임포트 되지 않은 패키지가 새 패키지이거나 마지막 캐시 이후 변경된 패키지일 경우 코드 로드를 통해 사전 컴파일이 개시될 수 있습니다.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="im">using</span> <span class="bu">Example</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>[ Info<span class="op">:</span> Precompiling Example [<span class="fl">7876</span>af07<span class="op">-</span><span class="fl">990</span>d<span class="op">-</span><span class="fl">54</span>b4<span class="op">-</span>ab0e<span class="op">-</span><span class="fl">23690620f79</span>a]</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>또는 전체 프로젝트나 지정된 의존성을 사전 컴파일할 수 있는 Pkg의 사전 컴파일 옵션을 사용하여 병렬로 수행할 수 있는데, 이 방법이 위의 코드 로드 경로보다 훨씬 빠를 수 있습니다.</p>
<pre class="none"><code>(@v1.6) pkg&gt; precompile
Precompiling project...
  23 dependencies successfully precompiled in 36 seconds</code></pre>
<p>그러나 Pkg의 자동 사전 컴파일로 인해 이들 중 어느 것도 일상적으로 필요하지 않습니다.</p>
<p><br></p>
<section id="자동-사전-컴파일-automatic-precompilation" class="level4">
<h4 class="anchored" data-anchor-id="자동-사전-컴파일-automatic-precompilation">자동 사전 컴파일 (Automatic Precompilation)</h4>
<p>기본적으로 프로젝트에 추가되거나 Pkg 작업에서 업데이트되는 모든 패키지는 해당 의존성과 함께 자동으로 미리 컴파일됩니다.</p>
<pre class="none"><code>(@v1.6) pkg&gt; add Images
   Resolving package versions...
    Updating `~/.julia/environments/v1.9/Project.toml`
  [916415d5] + Images v0.25.2
    Updating `~/.julia/environments/v1.9/Manifest.toml`
    ...
Precompiling project...
  Progress [===================&gt;                     ]  45/97
  ✓ NaNMath
  ✓ IntervalSets
  ◐ CoordinateTransformations
  ◑ ArnoldiMethod
  ◑ IntegralArrays
  ◒ RegionTrees
  ◐ ChangesOfVariables
  ◓ PaddedViews</code></pre>
<p><code>develop</code> 명령은 예외인데 패키지를 빌드하거나 미리 컴파일하지 않습니다. 언제 할지는 사용자가 결정할 수 있습니다.</p>
<p>자동 사전 컴파일 중에 지정된 패키지 버전 오류가 발생하면 Pkg는 자동으로 시도하는 이후의 시간동안 기억하고 간단한 경고와 함께 해당 패키지를 건너뜁니다. <code>pkg&gt; precompile</code> 은 항상 모든 패키지를 재시도하므로 수동 사전 컴파일을 사용하여 이러한 패키지를 강제로 재시도할 수 있습니다.</p>
<p>자동 사전 컴파일을 비활성화하려면 <code>ENV["JULIA_PKG_PRECOMPILE_AUTO"]=0</code>을 설정합니다.</p>
<p><br></p>
</section>
<section id="로드된-패키지의-새-버젼을-사전-컴파일하기" class="level4">
<h4 class="anchored" data-anchor-id="로드된-패키지의-새-버젼을-사전-컴파일하기">로드된 패키지의 새 버젼을 사전 컴파일하기</h4>
<p>업데이트된 패키지가 이미 세션에 로드된 경우 사전 컴파일 프로세스가 계속 진행되어 새 버전과 이에 의존하는 모든 패키지를 사전 컴파일하지만 세션을 다시 시작할 때까지 패키지를 사용할 수 없다는 점에 유의하십시오.</p>
<p><br></p>
</section>
</section>
<section id="다른-사람의-프로젝트를-사용하기" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="다른-사람의-프로젝트를-사용하기"><span class="header-section-number">4.3</span> 다른 사람의 프로젝트를 사용하기</h3>
<p><code>git clone</code> 과 같은 명령어를 이용하여 프로젝트를 복제하기만 하면 됩니다. <code>cd</code> 로 프로젝트 디렉토리로 이동하고 다음을 호출합니다.</p>
<pre class="none"><code>(v1.0) pkg&gt; activate .

(SomeProject) pkg&gt; instantiate</code></pre>
<p>프로젝트에 manifest가 포함된 경우 해당 manifest에서 제공하는 것과 동일한 상태로 패키지를 설치합니다. 그렇지 않으면 프로젝트와 호환되는 최신 버전의 의존성으로 결정합니다.</p>
<p><code>activate</code> 자체는 누락된 의존성을 설치하지 않습니다. <code>Project.toml</code>만 있는 경우 환경을 “분석(resolving)”하여 <code>Manifest.toml</code> 을 생성한 다음 누락된 패키지를 모두 설치하고 미리 컴파일해야 합니다. <code>instantiate</code> 는 이 모든 작업을 수행합니다.</p>
<p>해결된 <code>Manifest.toml</code> 이 이미 있는 경우에도 패키지가 올바른 버전으로 설치되어 있는지 확인해야 합니다. 다시 <code>instantiate</code> 를 실행하면 이 작업이 수행됩니다.</p>
<p>즉, <code>instantiate</code> 는 환경을 사용할 준비가 되었는지 확인하는 당신의 친구입니다. 할 일이 없으면 <code>instantiate</code> 는 아무 작업도 수행하지 않습니다.</p>
<blockquote class="blockquote">
<p><strong>시작시의 프로젝트 지정</strong><br>
Julia 내에서 <code>activate</code> 를 사용하는 대신 <code>--project=&lt;path&gt;</code> 플래그를 사용하여 시작할 때 프로젝트를 지정할 수 있습니다. 예를 들어 현재 디렉토리의 환경을 사용하여 명령줄에서 스크립트를 실행하려면 다음을 실행할 수 있습니다.</p>
<pre class="none"><code>$ julia --project=. myscript.jl</code></pre>
</blockquote>
<p><br></p>
</section>
</section>
<section id="패키지-작성" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="패키지-작성"><span class="header-section-number">5</span> 5. 패키지 작성</h2>
<p>패키지는 <code>Project.toml</code> 파일의 <code>name</code>, <code>uuid</code> 및 <code>version</code> 항목과 <code>PackageName</code> 모듈을 정의하는 <code>src/PackageName.jl</code> 파일이 있는 프로젝트입니다. 이 파일은 패키지가 로드될 때 실행됩니다.</p>
<p><br></p>
<section id="패키지용-파일-생성" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="패키지용-파일-생성"><span class="header-section-number">5.1</span> 패키지용 파일 생성</h3>
<blockquote class="blockquote">
<p><strong>주의</strong><br>
<a href="https://github.com/invenia/PkgTemplates.jl">PkgTemplates</a> 패키지는 새 패키지용 파일을 생성하는 매우 쉽고 반복 가능하며 사용자 맞춤식의 방법을 제공합니다. 아래에 설명된 최소한의 <code>pkg&gt; generate</code> 기능을 사용하는 대신 <code>PkgTemplates</code> 를 사용하여 새 패키지를 만드는 것이 좋습니다.</p>
</blockquote>
<p><br></p>
<p>새 패키지에 대한 파일을 생성하려면 <code>pkg&gt; generate</code> 를 실행하십시오.</p>
<pre class="none"><code>(v1.0) pkg&gt; generate HelloWorld</code></pre>
<p>이렇게 하면 다음 파일이 포함된 새 프로젝트 <code>HelloWorld</code>가 생성됩니다(외부 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a> 명령으로 시각화됩니다).</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="fu">cd</span>(<span class="st">"HelloWorld"</span>)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>shell<span class="op">&gt;</span> tree .</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>.</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>├── Project.toml</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>└── src</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>    └── HelloWorld.jl</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a><span class="fl">1</span> directory, <span class="fl">2</span> files</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>Project.toml</code> 파일에는 패키지 이름, 고유한 UUID, 버전, 작성자 및 잠재적 의존성이 포함됩니다.</p>
<pre class="none"><code>name = "HelloWorld"
uuid = "b4cd1eb8-1e24-11e8-3319-93036a3eb9f3"
version = "0.1.0"
authors = ["Some One &lt;someone@email.com&gt;"]

[deps]</code></pre>
<p><code>src/HelloWorld.jl</code> 의 내용은 다음과 같습니다</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> HelloWorld</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="fu">greet</span>() <span class="op">=</span> <span class="fu">print</span>(<span class="st">"Hello World!"</span>)</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span> <span class="co"># module</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이제 프로젝트를 활성화하고 패키지를 로드할 수 있습니다.</p>
<pre class="none"><code>pkg&gt; activate .

julia&gt; import HelloWorld

julia&gt; HelloWorld.greet()
Hello World!</code></pre>
<p><br></p>
</section>
<section id="프로젝트에-의존성-추가" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="프로젝트에-의존성-추가"><span class="header-section-number">5.2</span> 프로젝트에 의존성 추가</h3>
<p>프로젝트에서 표준 라이브러리 패키지인 <code>Random</code> 과 등록된 패키지 <code>JSON</code> 을 사용하고 싶다고 가정해 보겠습니다. 이 패키지를 <code>add</code> 하기만 하면 됩니다(새로 생성된 프로젝트를 <code>actvate</code> 한 이후에는 프롬프트에 이제 프로젝트 이름이 표시됩니다).</p>
<pre class="none"><code>(HelloWorld) pkg&gt; add Random JSON
 Resolving package versions...
  Updating "~/Documents/HelloWorld/Project.toml"
 [682c06a0] + JSON v0.17.1
 [9a3f8284] + Random
  Updating "~/Documents/HelloWorld/Manifest.toml"
 [34da2185] + Compat v0.57.0
 [682c06a0] + JSON v0.17.1
 [4d1e1d77] + Nullables v0.0.4
 ...</code></pre>
<p><code>Random</code> 과 <code>JSON</code> 이 모두 프로젝트의 <code>Project.toml</code> 파일에 추가되었고 결과 의존성이 <code>Manifest.toml</code> 파일에 추가되었습니다. 리졸버(resolver)는 가능한 가장 높은 버전의 각 패키지를 설치했지만 각 패키지가 해당 의존성에 적용하는 호환성을 여전히 존중합니다.</p>
<p>이제 프로젝트에서 <code>Random</code> 과 <code>JSON</code> 을 모두 사용할 수 있습니다. <code>src/HelloWorld.jl</code> 을 아래와 같이 변경하고</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> HelloWorld</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="bu">Random</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="bu">JSON</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="fu">greet</span>() <span class="op">=</span> <span class="fu">print</span>(<span class="st">"Hello World!"</span>)</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="fu">greet_alien</span>() <span class="op">=</span> <span class="fu">print</span>(<span class="st">"Hello "</span>, <span class="bu">Random</span>.<span class="fu">randstring</span>(<span class="fl">8</span>))</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span> <span class="co"># module</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>다시 패키지를 로딩하면 <code>Random</code> 을 사용하는 새로운 <code>greet_alien</code> 함수를 호출 할 수 있습니다.</p>
<pre class="none"><code>julia&gt; HelloWorld.greet_alien()
Hello aT157rHV</code></pre>
<p><br></p>
</section>
<section id="패키지에-빌드-단계를-추가하기" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="패키지에-빌드-단계를-추가하기"><span class="header-section-number">5.3</span> 패키지에 빌드 단계를 추가하기</h3>
<p>빌드 단계는 패키지가 처음 설치되거나 <code>build</code> 를 통해 명시적으로 호출될 때 실행됩니다. 패키지는 <code>deps/build.jl</code> 파일을 실행하여 빌드됩니다.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="fu">print</span>(<span class="fu">read</span>(<span class="st">"deps/build.jl"</span>, <span class="dt">String</span>))</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="fu">println</span>(<span class="st">"I am being built..."</span>)</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>(HelloWorld) pkg<span class="op">&gt;</span> build</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>  Building HelloWorld <span class="op">→</span> <span class="ss">`deps/build.log`</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a> Resolving package versions<span class="op">...</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="fu">print</span>(<span class="fu">read</span>(<span class="st">"deps/build.log"</span>, <span class="dt">String</span>))</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>I am being built<span class="op">...</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>빌드 단계가 실패하면 빌드 단계의 출력이 콘솔에 인쇄됩니다.</p>
<pre class="none"><code>julia&gt; print(read("deps/build.jl", String))
error("Ooops")

(HelloWorld) pkg&gt; build
  Building HelloWorld → `deps/build.log`
 Resolving package versions...
┌ Error: Error building `HelloWorld`:
│ ERROR: LoadError: Ooops
│ Stacktrace:
│  [1] error(::String) at ./error.jl:33
│  [2] top-level scope at none:0
│  [3] include at ./boot.jl:317 [inlined]
│  [4] include_relative(::Module, ::String) at ./loading.jl:1071
│  [5] include(::Module, ::String) at ./sysimg.jl:29
│  [6] include(::String) at ./client.jl:393
│  [7] top-level scope at none:0
│ in expression starting at /Users/kristoffer/.julia/dev/Pkg/HelloWorld/deps/build.jl:1
└ @ Pkg.Operations Operations.jl:938</code></pre>
<p><br></p>
</section>
<section id="패키지에-테스트-추가하기" class="level3" data-number="5.4">
<h3 data-number="5.4" class="anchored" data-anchor-id="패키지에-테스트-추가하기"><span class="header-section-number">5.4</span> 패키지에 테스트 추가하기</h3>
<p>패키지가 테스트되면 <code>test/runtests.jl</code> 파일이 실행됩니다.</p>
<pre class="none"><code>julia&gt; print(read("test/runtests.jl", String))
println("Testing...")

(HelloWorld) pkg&gt; test
   Testing HelloWorld
 Resolving package versions...
Testing...
   Testing HelloWorld tests passed</code></pre>
<p>테스트는 패키지 자체와 테스트 관련 의존성을 사용할 수 있는 새로운 Julia 프로세스에서 실행됩니다(아래 참조).</p>
<p><br></p>
<section id="julia-1.2-이후에서의-테스트용-의존성" class="level4">
<h4 class="anchored" data-anchor-id="julia-1.2-이후에서의-테스트용-의존성">Julia 1.2 이후에서의 테스트용 의존성</h4>
<blockquote class="blockquote">
<p><strong>Julia1.2</strong><br>
이 섹션은 Julia 1.2 이상에만 적용됩니다. 이전 Julia 버전에 대한 테스트용 의존성을 지정하려면 <a href="https://pkgdocs.julialang.org/v1/creating-packages/#Test-specific-dependencies-in-Julia-1.0-and-1.1">Julia 1.0 및 1.1의 테스트용 의존성</a>을 참조하십시오. (본 문서에서는 생략함)</p>
</blockquote>
<p><br></p>
<blockquote class="blockquote">
<p><strong>주의</strong><br>
<code>Project.toml</code>, <code>test/Project.toml</code> 및 해당 <code>Manifest.toml</code> 간의 정확한 상호 작용은 완전히 결정되지 않았으며 향후 버전에서 변경될 수 있습니다. 따라서 다음 섹션에서 설명하는 테스트용 의존성을 추가하는 예전 방법은 모든 Julia 1.X 릴리스에서 지원됩니다.</p>
</blockquote>
<p><br></p>
<p>Julia 1.2 이상에서 테스트 환경은 <code>test/Project.toml</code> 에 의해 제공됩니다. 따라서 테스트를 실행할 때 이것이 활성 프로젝트가 되며 <code>test/Project.toml</code> 프로젝트에 대한 의존성만 사용할 수 있습니다. Pkg는 테스트된 패키지 자체를 암시적으로 추가합니다.</p>
<blockquote class="blockquote">
<p><strong>주의</strong><br>
<code>test/Project.toml</code>이 없으면 Pkg는 <a href="https://pkgdocs.julialang.org/v1/creating-packages/#Test-specific-dependencies-in-Julia-1.0-and-1.1">Julia 1.0 및 1.1의 테스트용 의존성</a>에 설명된 대로 이전 스타일의 테스트 설정을 사용합니다.</p>
</blockquote>
<p><br></p>
<p>테스트용 의존성, 즉 테스트할 때만 사용할 수 있는 의존성을 추가하려면 이 의존성을 <code>test/Project.toml</code> 프로젝트에 추가하는 것으로 충분합니다. 이 작업은 이 환경을 활성화하여 Pkg REPL에서 수행할 수 있으며 평소처럼 <code>add</code> 를 사용할 수 있습니다. <code>Test</code> 표준 라이브러리를 테스트 의존성으로 추가해 보겠습니다.</p>
<pre class="none"><code>(HelloWorld) pkg&gt; activate ./test
[ Info: activating environment at `~/HelloWorld/test/Project.toml`.

(test) pkg&gt; add Test
 Resolving package versions...
  Updating `~/HelloWorld/test/Project.toml`
  [8dfed614] + Test
  Updating `~/HelloWorld/test/Manifest.toml`
  [...]</code></pre>
<p>이제 테스트 스크립트에서 <code>Test</code> 를 사용할 수 있으며 테스트할 때 설치되는 것을 볼 수 있습니다.</p>
<pre class="none"><code>julia&gt; print(read("test/runtests.jl", String))
using Test
@test 1 == 1

(HelloWorld) pkg&gt; test
   Testing HelloWorld
 Resolving package versions...
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
  [8dfed614] + Test
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
   Testing HelloWorld tests passed```</code></pre>
<p><br></p>
</section>
</section>
<section id="패키지-작명-가이드" class="level3" data-number="5.5">
<h3 data-number="5.5" class="anchored" data-anchor-id="패키지-작명-가이드"><span class="header-section-number">5.5</span> 패키지 작명 가이드</h3>
<p>패키지 이름은 도메인 전문가가 아니더라도 대부분의 Julia 사용자가 이해할 수 있어야 합니다. 다음 지침은 <code>General</code> 레지스트리에 적용되지만 다른 패키지 레지스트리에도 유용할 수 있습니다.</p>
<p><code>General</code> 레지스트리는 전체 커뮤니티에 속하므로 패키지 이름을 게시할 때 사람들이 패키지 이름에 대해 의견을 가질 수 있습니다. 특히 패키지 이름이 모호하거나 다른 이름과 혼동될 수 있는 경우 더욱 그렇습니다. 일반적으로 패키지에 더 잘 맞는 새 이름에 대한 제안을 받게 됩니다.</p>
<ol type="1">
<li>전문 용어를 사용하지 마십시오. 특히 혼동의 가능성이 최소화되지 않는 한 두문자어를 사용하지 마십시오.
<ul>
<li>미국에 대해 이야기할 때는 <code>USA</code> 라고 말하는 것이 좋습니다.</li>
<li>정적인 정신 자세에 대해 이야기하더라도 <code>PMA</code>(Positive Mental Attitude) 라고 말하는 것은 옳지 않습니다.</li>
</ul></li>
<li>패키지 이름에 Julia를 사용하거나 접두사로 Ju를 사용하지 마십시오.
<ul>
<li>패키지가 Julia 패키지라는 것은 일반적으로 컨텍스트와 사용자에게 명확합니다.</li>
<li>패키지 이름에는 이미 <code>.jl</code> 확장자가 있어 <code>Package.jl</code> 이 Julia 패키지임을 사용자에게 알립니다.</li>
<li>이름에 Julia가 있으면 패키지가 Julia 언어 자체에 대한 기여자와 연관되어 있거나 기여자가 승인했음을 의미할 수 있습니다.</li>
</ul></li>
<li>새로운 유형과 관련하여 대부분의 기능을 제공하는 패키지에는 복수형 이름이 있어야 합니다.
<ul>
<li><code>DataFrames</code> 는 <code>DataFrame</code> 유형을 제공합니다.</li>
<li><code>BloomFilters</code> 는 <code>BloomFilter</code> 유형을 제공합니다.</li>
<li>반대로 <code>JuliaParser</code> 는 새로운 유형을 제공하지 않지만 대신 <code>JuliaParser.parse()</code> 함수에서 새로운 기능을 제공합니다.</li>
</ul></li>
<li>명확성이 당신에게 오래 걸리는 것처럼 보이더라도 명확성의 측면에 오류가 있습니다.
<ul>
<li><code>RandomMatrices</code>는 <code>RndMat</code> 또는 <code>RMT</code> 가 더 짧지만 덜 모호한 이름입니다.</li>
<li>덜 체계적인 이름은 해당 도메인에 대한 여러 가능한 접근 방식 중 하나를 구현하는 패키지에 적합할 수 있습니다.</li>
<li>Julia는 포괄적인 단일 플로팅 패키지가 없습니다. 대신 <code>Gadfly</code>, <code>PyPlot</code>, <code>Winston</code> 및 기타 패키지는 각각 특정 디자인 철학을 기반으로 고유한 접근 방식을 구현합니다.</li>
<li>대조적으로, <code>SortingAlgorithms</code> 는 많은 잘 정립된 정렬 알고리즘을 사용하기 위한 일관된 인터페이스를 제공합니다.</li>
</ul></li>
<li>외부 라이브러리나 프로그램을 래핑하는 패키지는 해당 라이브러리나 프로그램의 이름을 따서 명명해야 합니다.
<ul>
<li><code>CPLEX.jl</code>은 웹 검색에서 쉽게 식별할 수 있는 <code>CPLEX</code> 라이브러리를 래핑합니다.</li>
<li><code>MATLAB.jl</code>은 Julia 내에서 MATLAB 엔진을 호출하는 인터페이스를 제공합니다.</li>
</ul></li>
<li>패키지 이름을 기존 패키지에 유사하게 지정하지 마십시오.
<ul>
<li><code>Websocket</code>은 <code>WebSockets</code> 과 너무 유사하고 사용자에게 혼란을 줄 수 있습니다. 대신 <code>SimpleWebsockets</code> 과 같은 새 이름을 사용하십시오.</li>
</ul></li>
</ol>
<p><br></p>
</section>
<section id="패키지-등록" class="level3" data-number="5.6">
<h3 data-number="5.6" class="anchored" data-anchor-id="패키지-등록"><span class="header-section-number">5.6</span> 패키지 등록</h3>
<p>패키지가 준비되면 <a href="https://github.com/JuliaRegistries/General#registering-a-package-in-general">일반 레지스트리(General Registray)</a>에 등록할 수 있습니다(<a href="https://github.com/JuliaRegistries/General#faq">FAQ</a> 참조). 현재 패키지는 <a href="https://juliaregistrator.github.io/"><code>Registrator</code></a>를 통해 제출됩니다. 등록자 외에도 <a href="https://github.com/marketplace/actions/julia-tagbot"><code>TagBot</code></a>은 릴리스 태그 지정 프로세스를 관리하는 데 도움이 됩니다.</p>
<p><br></p>
</section>
<section id="best-practices" class="level3" data-number="5.7">
<h3 data-number="5.7" class="anchored" data-anchor-id="best-practices"><span class="header-section-number">5.7</span> Best Practices</h3>
<p>패키지는 자체 상태 변경(패키지 디렉토리 내의 파일에 쓰기)을 피해야 합니다. 일반적으로 패키지는 쓰기 가능한 위치(예: 시스템 전체 저장소의 일부로 설치된 경우) 또는 안정적인 위치(예: <a href="https://github.com/JuliaLang/PackageCompiler.jl"><code>PackageCompiler.jl</code></a>에 의해 시스템 이미지에 번들된 경우)에 있다고 가정하지 않아야 합니다. Julia 패키지 생태계의 다양한 사용 사례를 지원하기 위해 Pkg 개발자는 패키지 작성자가 독립적이고 변경 불가능하며 재배치 가능한 패키지를 만드는 데 도움이 되는 여러 보조 패키지 및 기술을 만들었습니다.</p>
<ul>
<li><p><a href="https://pkgdocs.julialang.org/v1/artifacts/"><code>아티팩트(Artifacts)</code></a> 를 사용하여 패키지와 함께 데이터 더미를 뭉치고 요청에 의해 다운로드할 수 있습니다. 재배치가 불가능하므로 <code>joinpath(@__DIR__, "data", "my_dataset.csv")</code> 와 같은 경로를 통해 파일을 열려고 시도하는 것보다 아티팩트를 선호하십시오. 패키지가 사전 컴파일되면 <code>@__DIR__</code> 의 결과가 미리 컴파일된 패키지 데이터에 구워지며 이 패키지를 배포하려고 하면 잘못된 위치에서 파일을 로드하려고 시도합니다. 아티팩트를 뭉치고 <code>artifact"name"</code> 문자열 매크로를 사용하여 쉽게 액세스할 수 있습니다. 아티팩트는 Julia 1.3부터 사용할 수 있습니다.</p></li>
<li><p><a href="https://github.com/JuliaPackaging/Scratch.jl"><code>Scratch.jl</code></a> 은 패키지에 대한 변경 가능한 데이터 컨테이너인 “스크래치 공간”이라는 개념을 제공합니다. 스크래치 공간은 패키지에 의해 완전히 관리되는 데이터 캐시를 위해 설계되었으며 패키지 자체가 제거될 때 제거되어야 합니다. 중요한 사용자 생성 데이터의 경우 패키지는 Julia 또는 Pkg에서 관리하지 않는 사용자 지정 경로에 계속 작성해야 합니다. Scratch는 Julia 1.5부터 사용할 수 있습니다.</p></li>
<li><p><a href="https://github.com/JuliaPackaging/Preferences.jl"><code>Preferences.jl</code></a>을 사용하면 패키지가 최상위 <code>Project.toml</code>에 대한 기본 설정을 읽고 쓸 수 있습니다. 이러한 기본 설정은 패키지 동작의 다양한 측면을 활성화 또는 비활성화하기 위해 런타임 또는 컴파일 타임에 읽을 수 있습니다. 이전에는 패키지가 사용자 또는 환경에서 설정한 옵션을 기록하기 위해 자체 패키지 디렉토리에 파일을 작성했지만 이제는 <code>Preferences</code> 를 사용할 수 있으므로 권장하지 않습니다. Preferences 는 Julia 1.6부터 사용할 수 있습니다.</p></li>
</ul>
<p><br></p>
</section>
</section>
<section id="호환성-compatiblity" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="호환성-compatiblity"><span class="header-section-number">6</span> 6. 호환성 (Compatiblity)</h2>
<p>호환성은 프로젝트가 호환되는 의존성의 버전을 제한하는 기능을 말합니다. 의존성에 대한 호환성이 지정되지 않은 경우 프로젝트는 해당 의존성의 모든 버전과 호환되는 것으로 간주됩니다.</p>
<p>의존성에 대한 호환성은 <code>Project.toml</code> 파일에 다음과 같이 입력됩니다.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="dt">julia</span> <span class="op">=</span> <span class="st">"1.0"</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Example</span> <span class="op">=</span> <span class="st">"0.4.3"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>프로젝트 파일에 호환성 항목을 입력한 후 <code>up</code> 을 사용하여 적용할 수 있습니다.</p>
<p>버전 지정자의 형식은 아래에 자세히 설명되어 있습니다.</p>
<blockquote class="blockquote">
<p><strong>Info</strong><br>
<code>compat</code> 명령을 사용하여 Pkg REPL의 compat 항목을 편집하거나 프로젝트 파일을 수동으로 편집합니다.</p>
</blockquote>
<p><br></p>
<section id="버젼-지정-형식" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="버젼-지정-형식"><span class="header-section-number">6.1</span> 버젼 지정 형식</h3>
<p>다른 패키지 관리자와 마찬가지로 Julia 패키지 관리자는 <a href="https://semver.org/">semantic versioning(semver)</a>을 따릅니다. 예를 들어 <code>1.2.3</code> 과 같이 주어진 버젼 지정자는 버전 <code>[1.2.3 - 2.0.0)</code> 과 호환되는 것으로 가정합니다. 여기서 <code>)</code> 는 비포함 상한입니다. 보다 구체적으로 지정하기 위해 버전 지정자는 <code>^1.2.3</code> 와 같은 <strong>캐럿 지정자</strong> 나, <code>~1.2.3</code> 와 같은 <strong>물결표 지정자</strong> 가 될 수 있습니다. 캐럿 지정자가 기본값이므로 <code>1.2.3 == ^1.2.3</code>입니다. 캐럿과 물결표의 차이점은 다음 섹션에서 설명합니다. 여러 버전 지정자의 합집합은 개별 버전 지정자를 쉼표로 구분하여 형성할 수 있습니다. 예를 들어,</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Example</span> <span class="op">=</span> <span class="st">"1.2, 2"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>의 결과는 <code>[1.2.0, 3.0.0)</code> 입니다. 가장 앞에 <code>0</code> 이 나오면 다르게 취급됩니다. <code>Example = "0.2, 1"</code>은 <code>[0.2.0 - 0.3.0)</code> <span class="math inline">\(\cup\)</span> <code>[1.0.0 - 2.0.0)</code>만 됩니다. 가장 앞에 <code>0</code> 이 있는 버전에 대한 자세한 내용은 다음 섹션을 참조하세요.</p>
<p><br></p>
<section id="으로-시작하는-버젼의-행동-0.0.x-와-0.x.y" class="level4">
<h4 class="anchored" data-anchor-id="으로-시작하는-버젼의-행동-0.0.x-와-0.x.y"><code>0</code> 으로 시작하는 버젼의 행동 (0.0.x 와 0.x.y)</h4>
<p>semver 사양에는 주 버전이 0인 모든 버전(1.0.0 이전 버전)이 서로 호환되지 않는다고 나와 있지만 주 버전과 부 버전이 모두 0인 경우에만 적용하기로 했습니다. 즉, 0.0.1과 0.0.2는 호환되지 않는 것으로 간주됩니다. 0이 아닌 부 버전(<code>0.a.b</code> 에서 <code>a != 0</code>인 경우 )이 있는 1.0 이전 버전은 동일한 부 버전 및 더 작거나 동일한 패치 버전(<code>0.a.c</code> 에서 <code>c &lt;= b</code> 인 경우)이 있는 버전과 호환되는 것으로 간주됩니다. 즉, 버전 0.2.2 및 0.2.3은 0.2.1 및 0.2.0과 호환됩니다. 주 버전이 0이고 다른 부 버전이 있는 버전은 호환되는 것으로 간주되지 않으므로 버전 0.3.0은 0.2.0에서 주요 변경 사항이 있을 수 있습니다. 이를 위한 <code>[compat]</code>항목은 다음과 같습니다.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Example</span> <span class="op">=</span> <span class="st">"0.0.1"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>여기서는 <code>[0.0.1, 0.0.2)</code>(버전 0.0.1에만 해당)로 <code>Example</code> 에 대한 버전 바인딩이 발생하는 반면 <code>[compat]</code> 이</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Example</span> <span class="op">=</span> <span class="st">"0.2.1"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>라면,<code>[0.2.1, 0.3.0)</code> 으로 버전 바인딩이 발생합니다.</p>
<p>특히 패키지는 0.2.0과 역호환성을 유지하는 한 0.2.3과 비교하여 기능 추가가 있을 때 버전 = “0.2.4”를 설정할 수 있습니다. <a href="#version-필드"><code>version</code> 필드</a> 도 참조하십시오.</p>
<p><br></p>
</section>
<section id="캐럿-지정자" class="level4">
<h4 class="anchored" data-anchor-id="캐럿-지정자">캐럿 지정자</h4>
<p>캐럿(<code>^</code>) 지정자는 semver에 따라 호환되는 업그레이드를 허용합니다. 지정자가 사용되지 않는 경우 이것이 기본 동작입니다. 업데이트된 의존성은 새 버전이 버전 지정자에서 가장 왼쪽의 0이 아닌 숫자를 수정하지 않는 경우 호환되는 것으로 간주됩니다.</p>
<p>몇 가지 예가 아래에 나와 있습니다.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"^1.2.3"</span> <span class="co"># [1.2.3, 2.0.0)</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgB</span> <span class="op">=</span> <span class="st">"^1.2"</span>   <span class="co"># [1.2.0, 2.0.0)</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgC</span> <span class="op">=</span> <span class="st">"^1"</span>     <span class="co"># [1.0.0, 2.0.0)</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgD</span> <span class="op">=</span> <span class="st">"^0.2.3"</span> <span class="co"># [0.2.3, 0.3.0)</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgE</span> <span class="op">=</span> <span class="st">"^0.0.3"</span> <span class="co"># [0.0.3, 0.0.4)</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgF</span> <span class="op">=</span> <span class="st">"^0.0"</span>   <span class="co"># [0.0.0, 0.1.0)</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgG</span> <span class="op">=</span> <span class="st">"^0"</span>     <span class="co"># [0.0.0, 1.0.0)</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="물결표-지정자" class="level4">
<h4 class="anchored" data-anchor-id="물결표-지정자">물결표 지정자</h4>
<p>물결표 지정자는 보다 제한된 업그레이드 가능성을 제공합니다. 주 버전, 부 버전, 패치 버전을 지정하거나 주 버전과 부 버전을 지정할 때 패치 버전만 변경할 수 있습니다. 주 버전만 지정하면 부 버전과 패치 버전을 모두 업그레이드할 수 있습니다(따라서 <code>~1</code>은 <code>^1</code>과 같습니다). 예를 들어:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"~1.2.3"</span> <span class="co"># [1.2.3, 1.3.0)</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgB</span> <span class="op">=</span> <span class="st">"~1.2"</span>   <span class="co"># [1.2.0, 1.3.0)</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgC</span> <span class="op">=</span> <span class="st">"~1"</span>     <span class="co"># [1.0.0, 2.0.0)</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgD</span> <span class="op">=</span> <span class="st">"~0.2.3"</span> <span class="co"># [0.2.3, 0.3.0)</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgE</span> <span class="op">=</span> <span class="st">"~0.0.3"</span> <span class="co"># [0.0.3, 0.0.4)</span></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgF</span> <span class="op">=</span> <span class="st">"~0.0"</span>   <span class="co"># [0.0.0, 0.1.0)</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgG</span> <span class="op">=</span> <span class="st">"~0"</span>     <span class="co"># [0.0.0, 1.0.0)</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>주 버전이 0인 모든 버전에서 물결표 및 캐럿 지정자는 동일합니다.</p>
<p><br></p>
</section>
<section id="부등식-지정자" class="level4">
<h4 class="anchored" data-anchor-id="부등식-지정자">부등식 지정자</h4>
<p>부등식을 사용하여 버전 범위를 지정할 수도 있습니다.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgB</span> <span class="op">=</span> <span class="st">"&gt;= 1.2.3"</span> <span class="co"># [1.2.3,  ∞)</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgC</span> <span class="op">=</span> <span class="st">"≥ 1.2.3"</span>  <span class="co"># [1.2.3,  ∞)</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgD</span> <span class="op">=</span> <span class="st">"&lt; 1.2.3"</span>  <span class="co"># [0.0.0, 1.2.3) = [0.0.0, 1.2.2]</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="하이픈-지정자" class="level4">
<h4 class="anchored" data-anchor-id="하이픈-지정자">하이픈 지정자</h4>
<p>하이픈 구문을 사용하여 버전 범위를 지정할 수도 있습니다. 하이픈 양쪽에 공백이 있는지 확인하십시오.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"1.2.3 - 4.5.6"</span> <span class="co"># [1.2.3, 4.5.6]</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"0.2.3 - 4.5.6"</span> <span class="co"># [0.2.3, 4.5.6]</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>두 번째 끝점의 지정되지 않은 후행 숫자는 와일드카드로 간주됩니다.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"1.2.3 - 4.5"</span>   <span class="co"># 1.2.3 - 4.5.* = [1.2.3, 4.6.0)</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"1.2.3 - 4"</span>     <span class="co"># 1.2.3 - 4.*.* = [1.2.3, 5.0.0)</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"1.2 - 4.5"</span>     <span class="co"># 1.2.0 - 4.5.* = [1.2.0, 4.6.0)</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"1.2 - 4"</span>       <span class="co"># 1.2.0 - 4.*.* = [1.2.0, 5.0.0)</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"1 - 4.5"</span>       <span class="co"># 1.0.0 - 4.5.* = [1.0.0, 4.6.0)</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"1 - 4"</span>         <span class="co"># 1.0.0 - 4.*.* = [1.0.0, 5.0.0)</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"0.2.3 - 4.5"</span>   <span class="co"># 0.2.3 - 4.5.* = [0.2.3, 4.6.0)</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"0.2.3 - 4"</span>     <span class="co"># 0.2.3 - 4.*.* = [0.2.3, 5.0.0)</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"0.2 - 4.5"</span>     <span class="co"># 0.2.0 - 4.5.* = [0.2.0, 4.6.0)</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"0.2 - 4"</span>       <span class="co"># 0.2.0 - 4.*.* = [0.2.0, 5.0.0)</span></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"0.2 - 0.5"</span>     <span class="co"># 0.2.0 - 0.5.* = [0.2.0, 0.6.0)</span></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a><span class="dt">PkgA</span> <span class="op">=</span> <span class="st">"0.2 - 0"</span>       <span class="co"># 0.2.0 - 0.*.* = [0.2.0, 1.0.0)</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<blockquote class="blockquote">
<p><strong>Julia 1.4</strong><br>
하이픈 지정자는 최소한 Julia 1.4가 필요하므로 사용할 때 프로젝트 파일에 <code>add</code> 하는 것이 좋습니다</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="dt">julia</span> <span class="op">=</span> <span class="st">"1.4"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</blockquote>
<p><br></p>
</section>
</section>
<section id="충돌-수정" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="충돌-수정"><span class="header-section-number">6.2</span> 충돌 수정</h3>
<p>버전 충돌은 다른 두 패키지인 <code>B</code> 와 <code>C</code> 에서 사용하는 패키지 <code>D</code> 에서 발생하는 충돌의 예와 함께 이전에 소개되었습니다. 오류 메시지를 분석한 결과 <code>B</code>가 오래된 버전의 <code>D</code>를 사용하고 있음이 밝혀졌습니다. 이를 해결하기 위해 가장 먼저 시도하는 것은 <code>B</code> 와 해당 호환성 요구 사항을 수정할 수 있도록 <code>pkg&gt; dev B</code> 를 수행하는 것입니다. 편집기에서 <code>Project.toml</code>파일을 열면 다음과 같은 내용을 알 수 있습니다.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="dt">D</span> <span class="op">=</span> <span class="st">"0.1"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>일반적으로 첫 번째 단계는 이것을 다음과 같이 수정하는 것입니다.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="dt">D</span> <span class="op">=</span> <span class="st">"0.1, 0.2"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이는 <code>B</code>가 버전 0.1 및 버전 0.2 모두와 호환됨을 나타냅니다. <code>pkg&gt; up</code> 하면 패키지 오류가 수정됩니다. 그러나 먼저 해결해야 할 한 가지 중요한 문제가 있습니다. 아마도 <code>D</code> 의 <code>v0.2</code> 에 <code>B</code> 를 손상시키는 호환되지 않는 변경이 있었을 수 있습니다. 더 진행하기 전에 모든 패키지를 업데이트한 다음 <code>B</code> 의 테스트를 실행하여 <code>pkg&gt; test B</code> 의 출력을 스캔해서 <code>D</code> 의 <code>v0.2</code>가 실제로 사용되고 있는지 확인해야 합니다. (<code>D</code> 의 추가 의존성으로 인해 <code>v0.1</code> 에 고정될 수 있으며 최신 버전에서 <code>B</code> 를 테스트했다고 잘못 생각하고 싶지 않을 것입니다.) 새 버전이 사용되었고 테스트가 여전히 통과된 경우, <code>D</code> 의 <code>v0.2</code> 를 수용하기 위해 <code>B</code> 가 추가 업데이트가 필요하지 않다고 가정할 수 있습니다. 새 릴리스가 만들어지도록 이 변경 사항을 풀 요청으로 <code>B</code> 에 안전하게 제출할 수 있습니다. 대신 오류가 발생하면 <code>B</code> 가 <code>D</code> 의 최신 버전과 호환되기 위해 더 광범위한 업데이트가 필요함을 나타냅니다. 이러한 업데이트는 <code>A</code> 와 <code>B</code> 를 동시에 사용할 수 있게 되기 전에 완료되어야 합니다. 그러나 서로 독립적으로 계속 사용할 수 있습니다.</p>
<p><br></p>
</section>
</section>
<section id="레지스트리" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="레지스트리"><span class="header-section-number">7</span> 7. 레지스트리</h2>
<p>레지스트리에는 사용 가능한 릴리스, 의존성, 다운로드할 수 있는 위치와 같은 패키지에 대한 정보가 포함되어 있습니다. <code>General</code> 레지스트리(<a href="https://github.com/JuliaRegistries/General">https://github.com/JuliaRegistries/General</a>) 는 기본 레지스트리이며 다른 레지스트리가 설치되어 있지 않으면 자동으로 설치됩니다.</p>
<p><br></p>
<section id="레지스트리-관리" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="레지스트리-관리"><span class="header-section-number">7.1</span> 레지스트리 관리</h3>
<blockquote class="blockquote">
<p><strong>Julia 1.1</strong><br>
Pkg의 레지스트리 처리에는 최소한 Julia 1.1이 필요합니다.</p>
</blockquote>
<p><br></p>
<p>레지스트리는 Pkg REPL에서, 또는 함수적 API(functional API)를 사용하여 추가하거나 제거할수 있고, 업데이트할 수 있습니다. 이 섹션에서는 REPL 인터페이스에 대해 설명합니다. 레지스트리 API는 <a href="[#12-api-레퍼런스](https://pkgdocs.julialang.org/v1/api/#Registry-API-Reference)">Registry API Reference</a>에 설명되어 있습니다.</p>
<p><br></p>
<section id="레지스트리-추가" class="level4">
<h4 class="anchored" data-anchor-id="레지스트리-추가">레지스트리 추가</h4>
<p>Pkg REPL에서 <code>registry add</code> 명령을 사용하여 사용자 지정 레지스트리를 추가할 수 있습니다. 일반적으로 이것은 레지스트리에 대한 URL로 수행됩니다.</p>
<p>사용자 지정 레지스트리를 추가하면 <code>General</code> 레지스트리가 자동으로 추가되지 않을 수 있습니다. 이 경우 <code>General</code> 레지스트리를 수동으로 추가하기만 하면 됩니다.</p>
<pre class="none"><code>pkg&gt; registry add https://github.com/JuliaRegistries/General
   Cloning registry from "https://github.com/JuliaRegistries/General"
     Added registry `General` to `~/.julia/registries/General`</code></pre>
<p>이제 <code>General</code> 에 등록된 모든 패키지를 추가하는 등에 사용할 수 있습니다. 현재 설치된 레지스트리를 확인하려면 <code>registry status</code>(또는 <code>registry st</code>) 명령을 사용할 수 있습니다.</p>
<pre class="none"><code>pkg&gt; registry st
Registry Status
 [23338594] General (https://github.com/JuliaRegistries/General.git)</code></pre>
<p>레지스트리는 항상 <code>DEPOT_PATH</code>의 첫 번째 항목인 사용자 저장소에 추가됩니다(<a href="#9-용어-glossary">용어</a> 섹션 참조).</p>
<p><br></p>
</section>
<section id="레지스트리-제거" class="level4">
<h4 class="anchored" data-anchor-id="레지스트리-제거">레지스트리 제거</h4>
<p>레지스트리는 <code>registry remove</code>(또는 <code>registry rm</code>) 명령으로 제거할 수 있습니다. 여기에서 <code>General</code> 레지스트리를 제거합니다.</p>
<pre class="none"><code>pkg&gt; registry rm General
  Removing registry `General` from ~/.julia/registries/General

pkg&gt; registry st
Registry Status
  (no registries found)</code></pre>
<p><code>General</code> 이라는 이름의 레지스트리가 여러 개 설치되어 있는 경우 패키지를 조작할 때와 마찬가지로 <code>uuid</code> 로 구분해야 합니다.</p>
<pre class="none"><code>pkg&gt; registry rm General=23338594-aafe-5451-b93e-139f81909106
  Removing registry `General` from ~/.julia/registries/General</code></pre>
<p><br></p>
</section>
<section id="레지스트리-업데이트" class="level4">
<h4 class="anchored" data-anchor-id="레지스트리-업데이트">레지스트리 업데이트</h4>
<p><code>registry update</code>(또는 <code>registry up</code>) 명령을 사용하여 레지스트리를 업데이트할 수 있습니다. 여기에서 <code>General</code> 레지스트리를 업데이트합니다.</p>
<pre class="none"><code>pkg&gt; registry up General
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General`</code></pre>
<p>설치된 모든 레지스트리를 업데이트하려면 다음을 수행하십시오.</p>
<pre class="none"><code>pkg&gt; registry up
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General`</code></pre>
<p><br></p>
</section>
<section id="레지스트리-개설과-유지" class="level4">
<h4 class="anchored" data-anchor-id="레지스트리-개설과-유지">레지스트리 개설과 유지</h4>
<p>Pkg는 레지스트리를 생성하거나 유지 관리하는 기능이 아니라 레지스트리에 대한 클라이언트 기능만 제공합니다. 그러나 <a href="https://github.com/JuliaRegistries/Registrator.jl">Registrator.jl</a> 및 <a href="https://github.com/GunnarFarneback/LocalRegistry.jl">LocalRegistry.jl</a> 은 레지스트리를 만들고 업데이트하는 방법을 제공하고 <a href="https://github.com/JuliaRegistries/RegistryCI.jl">RegistryCI.jl</a> 은 레지스트리 유지 관리를 위한 자동화된 테스트 및 병합 기능을 제공합니다.</p>
<p><br></p>
</section>
</section>
</section>
<section id="아티팩트artifacts" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="아티팩트artifacts"><span class="header-section-number">8</span> 8. 아티팩트(Artifacts)</h2>
<blockquote class="blockquote">
<p><strong>Julia 1.3</strong><br>
Pkg의 아티팩트 기능에는 최소한 Julia 1.3이 필요합니다.</p>
</blockquote>
<p><br></p>
<p><code>Pkg</code>는 Julia 패키지가 아닌 데이터 컨테이너를 설치하고 관리할 수 있습니다. 이러한 컨테이너는 플랫폼 마다의 바이너리, 데이터 세트, 텍스트 또는 다른 종류의 데이터(변경 불가능한 수명 주기 데이터 저장소(immutable, life-cycled datastore) 내에 배치하기에 편리한)를 포함할 수 있습니다. (“아티팩트(artifacts)” 라고 불리는) 이러한 컨테이너는 로컬에서 생성되고 어디에서나 호스팅되며 Julia 패키지 설치 시 자동으로 다운로드 및 압축 해제될 수 있습니다. 이 메커니즘은 <a href="https://github.com/JuliaPackaging/BinaryBuilder.jl"><code>BinaryBuilder.jl</code></a>로 빌드된 패키지에 대한 바이너리 의존성을 제공하는 데에도 사용됩니다.</p>
<p><br></p>
<section id="기본적인-사용법" class="level3" data-number="8.1">
<h3 data-number="8.1" class="anchored" data-anchor-id="기본적인-사용법"><span class="header-section-number">8.1</span> 기본적인 사용법</h3>
<p><code>Pkg</code> 아티팩트는 <code>Artifacts.toml</code> 파일에서 선언되며 현재 디렉터리나 패키지의 루트에 배치할 수 있습니다. 현재 <code>Pkg</code>는 URL로부터 압축 가능한 tar 파일 다운로드를 지원합니다. 다음은 <code>github.com</code> 에서 <code>socrates.tar.gz</code> 파일을 다운로드할 수 있는 최소한의 <code>Artifacts.toml</code> 파일입니다. 이 예에서는 <code>socrates</code> 라는 이름이 지정된 단일 아티팩트가 정의됩니다.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co"># a simple Artifacts.toml file</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[socrates]</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="dt">git-tree-sha1</span> <span class="op">=</span> <span class="st">"43563e7631a7eafae1f9f8d9d332e3de44ad7239"</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[[socrates.download]]</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">url</span> <span class="op">=</span> <span class="st">"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz"</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">sha256</span> <span class="op">=</span> <span class="st">"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 <code>Artifacts.toml</code> 파일이 현재 디렉토리에 있는 경우 <code>socrates.tar.gz</code> 를 다운로드하고 압축을 풀고 <code>artifact"socrates"</code>와 함께 사용할 수 있습니다. 이 tarball에는 <code>bin</code> 폴더와 해당 폴더 내에 <code>socrates</code> 라는 텍스트 파일이 포함되어 있으므로 다음과 같이 해당 파일의 내용에 액세스할 수 있습니다.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Pkg.Artifacts</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>rootpath <span class="op">=</span> artifact<span class="st">"socrates"</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="fu">open</span>(<span class="fu">joinpath</span>(rootpath, <span class="st">"bin"</span>, <span class="st">"socrates"</span>)) <span class="cf">do</span> file</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">println</span>(<span class="fu">read</span>(file, <span class="dt">String</span>))</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>URL을 통해 액세스할 수 있는 기존 tarball이 있는 경우 이 방식으로도 액세스할 수 있습니다. <code>Artifacts.toml</code> 을 만들려면 다운로드 파일의 <code>sha256</code> 해시와 압축을 푼 콘텐츠의 <code>git-tree-sha1</code> 이라는 두 가지 해시를 계산해야 합니다. 다음과 같이 계산할 수 있습니다.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Tar</span>, <span class="bu">Inflate</span>, <span class="bu">SHA</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>filename <span class="op">=</span> <span class="st">"socrates.tar.gz"</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="fu">println</span>(<span class="st">"sha256: "</span>, <span class="fu">bytes2hex</span>(<span class="fu">open</span>(sha256, filename)))</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a><span class="fu">println</span>(<span class="st">"git-tree-sha1: "</span>, Tar.<span class="fu">tree_hash</span>(<span class="fu">IOBuffer</span>(<span class="fu">inflate_gzip</span>(filename))))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="artifacts.toml-파일" class="level3" data-number="8.2">
<h3 data-number="8.2" class="anchored" data-anchor-id="artifacts.toml-파일"><span class="header-section-number">8.2</span> <code>Artifacts.toml</code> 파일</h3>
<p><code>Pkg</code> 는 패키지에서 아티팩트 사용을 기록하고 패키지 설치 시 아티팩트 다운로드를 자동화하기 위해 <code>TOML</code> 파일 형식뿐만 아니라 아티팩트 작업을 위한 API를 제공합니다. 아티팩트는 항상 콘텐츠 해시에 의해 참조될 수 있지만 일반적으로 프로젝트의 소스 트리에 있는 <code>Artifacts.toml</code> 파일의 콘텐츠 해시에 바인딩된 이름으로 액세스됩니다.</p>
<blockquote class="blockquote">
<p><strong>주의</strong><br>
<code>Project.toml</code> 와 <code>Manifest.toml</code> 대신 <code>JuliaProject.toml</code> 와 <code>JuliaManifest.toml</code>을 사용할 수 있는 것과 비슷하게 <code>JuliaArtifacts.toml</code> 을 사용할 수 있습니다.</p>
</blockquote>
<p><br></p>
<p><code>Artifacts.toml</code> 파일의 예는 다음과 같습니다.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Artifacts.toml file</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="kw">[socrates]</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="dt">git-tree-sha1</span> <span class="op">=</span> <span class="st">"43563e7631a7eafae1f9f8d9d332e3de44ad7239"</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="dt">lazy</span> <span class="op">=</span> <span class="cn">true</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[[socrates.download]]</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">url</span> <span class="op">=</span> <span class="st">"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz"</span></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">sha256</span> <span class="op">=</span> <span class="st">"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58"</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[[socrates.download]]</span></span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">url</span> <span class="op">=</span> <span class="st">"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.bz2"</span></span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">sha256</span> <span class="op">=</span> <span class="st">"13fc17b97be41763b02cbb80e9d048302cec3bd3d446c2ed6e8210bddcd3ac76"</span></span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a><span class="kw">[[c_simple]]</span></span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true" tabindex="-1"></a><span class="dt">arch</span> <span class="op">=</span> <span class="st">"x86_64"</span></span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true" tabindex="-1"></a><span class="dt">git-tree-sha1</span> <span class="op">=</span> <span class="st">"4bdf4556050cb55b67b211d4e78009aaec378cbc"</span></span>
<span id="cb94-17"><a href="#cb94-17" aria-hidden="true" tabindex="-1"></a><span class="dt">libc</span> <span class="op">=</span> <span class="st">"musl"</span></span>
<span id="cb94-18"><a href="#cb94-18" aria-hidden="true" tabindex="-1"></a><span class="dt">os</span> <span class="op">=</span> <span class="st">"linux"</span></span>
<span id="cb94-19"><a href="#cb94-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-20"><a href="#cb94-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[[c_simple.download]]</span></span>
<span id="cb94-21"><a href="#cb94-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">sha256</span> <span class="op">=</span> <span class="st">"411d6befd49942826ea1e59041bddf7dbb72fb871bb03165bf4e164b13ab5130"</span></span>
<span id="cb94-22"><a href="#cb94-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">url</span> <span class="op">=</span> <span class="st">"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-linux-musl.tar.gz"</span></span>
<span id="cb94-23"><a href="#cb94-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-24"><a href="#cb94-24" aria-hidden="true" tabindex="-1"></a><span class="kw">[[c_simple]]</span></span>
<span id="cb94-25"><a href="#cb94-25" aria-hidden="true" tabindex="-1"></a><span class="dt">arch</span> <span class="op">=</span> <span class="st">"x86_64"</span></span>
<span id="cb94-26"><a href="#cb94-26" aria-hidden="true" tabindex="-1"></a><span class="dt">git-tree-sha1</span> <span class="op">=</span> <span class="st">"51264dbc770cd38aeb15f93536c29dc38c727e4c"</span></span>
<span id="cb94-27"><a href="#cb94-27" aria-hidden="true" tabindex="-1"></a><span class="dt">os</span> <span class="op">=</span> <span class="st">"macos"</span></span>
<span id="cb94-28"><a href="#cb94-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-29"><a href="#cb94-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[[c_simple.download]]</span></span>
<span id="cb94-30"><a href="#cb94-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">sha256</span> <span class="op">=</span> <span class="st">"6c17d9e1dc95ba86ec7462637824afe7a25b8509cc51453f0eb86eda03ed4dc3"</span></span>
<span id="cb94-31"><a href="#cb94-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">url</span> <span class="op">=</span> <span class="st">"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-apple-darwin14.tar.gz"</span></span>
<span id="cb94-32"><a href="#cb94-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-33"><a href="#cb94-33" aria-hidden="true" tabindex="-1"></a><span class="kw">[processed_output]</span></span>
<span id="cb94-34"><a href="#cb94-34" aria-hidden="true" tabindex="-1"></a><span class="dt">git-tree-sha1</span> <span class="op">=</span> <span class="st">"1c223e66f1a8e0fae1f9fcb9d3f2e3ce48a82200"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 <code>Artifacts.toml</code>은 세 가지 아티팩트를 바인딩합니다. 하나는 <code>socrates</code>, 하나는 <code>c_simple</code>, 다른 하나는 <code>processed_output</code> 입니다. 아티팩트에 필요한 단일 정보는 <code>git-tree-sha1</code> 입니다. 아티팩트는 콘텐츠 해시로만 처리되기 때문에 <code>Artifacts.toml</code> 파일의 목적은 사람이 읽을 수 있는 이름을 콘텐츠 해시에 바인딩하고, 아티팩트를 다운로드할 수 있는 위치에 대한 정보를 제공하는 것과 같은 아티팩트에 대한 메타데이터를 제공하는 것입니다. 또는 단일 이름을 운영 체제 또는 libgfortran 버전과 같은 플랫폼별 제약 조건에 의해 키가 지정되는 여러 해시에 바인딩할 수도 있습니다.</p>
<p><br></p>
</section>
<section id="아티팩트-타입과-프로퍼티" class="level3" data-number="8.3">
<h3 data-number="8.3" class="anchored" data-anchor-id="아티팩트-타입과-프로퍼티"><span class="header-section-number">8.3</span> 아티팩트 타입과 프로퍼티</h3>
<p>위의 예에서 <code>socrates</code> 아티팩트는 여러 다운로드 위치가 있는 플랫폼 독립적 아티팩트를 보여줍니다. <code>socrates</code> 아티팩트를 다운로드하고 설치할 때 URL은 성공할 때까지 순서대로 시도됩니다. <code>socrates</code> 아티팩트는 <code>lazy</code> 로 표시됩니다. 즉, 포함 패키지가 설치될 때 자동으로 다운로드되지 않고 패키지가 처음 사용하려고 할 때 주문형으로 다운로드됩니다.</p>
<p><code>c_simple</code> 아티팩트는 플랫폼 의존적인 아티팩트를 보여줍니다. 여기서 <code>c_simple</code> 배열의 각 항목에는 호출 패키지가 호스트 시스템의 특정 사항을 기반으로 적절한 다운로드를 선택하는 데 도움이 되는 키가 포함되어 있습니다. 각 아티팩트에는 각 다운로드 항목에 대한 <code>git-tree-sha1</code> 및 <code>sha256</code> 이 모두 포함되어 있습니다. 이것은 압축을 풀기 전에 다운로드한 타르볼이 안전한지 확인하고 모든 타르볼이 동일한 전체 트리 해시로 확장되도록 하기 위한 것입니다.</p>
<p><code>processed_output</code> 아티팩트에는 <code>download</code> 구문이 포함되어 있지 않으므로 설치할 수 없습니다. 이런 아티팩트는 이전에 실행되어 새 아티팩트를 생성하고 결과 해시를 이 프로젝트 내의 이름에 바인딩하는 코드의 결과물이 될 것입니다.</p>
<p><br></p>
</section>
<section id="아티팩트-사용" class="level3" data-number="8.4">
<h3 data-number="8.4" class="anchored" data-anchor-id="아티팩트-사용"><span class="header-section-number">8.4</span> 아티팩트 사용</h3>
<p><code>Pkg.Artifacts</code> 네임스페이스에서 노출되는 편리한 API를 사용하여 아티팩트를 조작할 수 있습니다. 동기를 부여하는 예로 <a href="https://archive.ics.uci.edu/ml/datasets/iris">Iris 기계 학습 데이터 세트</a>를 로드해야 하는 패키지를 작성한다고 가정해 보겠습니다. 빌드 단계에서 패키지 디렉토리로 데이터 세트를 다운로드할 수 있고 현재 많은 패키지가 이를 정확하게 수행하지만 몇 가지 중요한 단점이 있습니다.</p>
<ul>
<li><p>첫째, 이는 패키지 디렉토리를 수정하여, 패키지 설치를 stateful 로 만드는데 이는 우리가 피하고 싶은 것입니다. 앞으로는 패키지가 설치 후 자체적으로 수정되는 대신 완전히 읽기 전용으로 설치될 수 있는 지점에 도달하고자 합니다.</p></li>
<li><p>둘째, 다운로드된 데이터는 패키지의 다른 버전 간에 공유되지 않습니다. 다양한 프로젝트에서 사용하기 위해 설치된 세 가지 다른 버전의 패키지가 있는 경우 해당 버전 간에 변경되지 않았더라도 데이터의 세 가지 다른 복사본이 필요합니다. 또한 패키지를 업그레이드하거나 다운그레이드할 때마다 영리한(아마도 안전하지 않은) 작업을 수행하지 않는 한 데이터를 다시 다운로드해야 합니다.</p></li>
</ul>
<p>아티팩트를 사용하면 <code>iris</code> 아티팩트가 디스크에 이미 존재하는지 확인하고 그렇지 않은 경우에만 다운로드하여 설치한 다음 결과를 <code>Artifacts.toml</code> 파일에 바인딩할 수 있습니다.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Pkg.Artifacts</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="co"># This is the path to the Artifacts.toml we will manipulate</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>artifact_toml <span class="op">=</span> <span class="fu">joinpath</span>(<span class="pp">@__DIR__</span>, <span class="st">"Artifacts.toml"</span>)</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Query the `Artifacts.toml` file for the hash bound to the name "iris"</span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a><span class="co"># (returns `nothing` if no such binding exists)</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>iris_hash <span class="op">=</span> <span class="fu">artifact_hash</span>(<span class="st">"iris"</span>, artifact_toml)</span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a><span class="co"># If the name was not bound, or the hash it was bound to does not exist, create it!</span></span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> iris_hash <span class="op">==</span> <span class="cn">nothing</span> <span class="op">||</span> !<span class="fu">artifact_exists</span>(iris_hash)</span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create_artifact() returns the content-hash of the artifact directory once we're finished creating it</span></span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>    iris_hash <span class="op">=</span> <span class="fu">create_artifact</span>() <span class="cf">do</span> artifact_dir</span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># We create the artifact by simply downloading a few files into the new artifact directory</span></span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>        iris_url_base <span class="op">=</span> <span class="st">"https://archive.ics.uci.edu/ml/machine-learning-databases/iris"</span></span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a>        <span class="fu">download</span>(<span class="st">"</span><span class="sc">$</span>(iris_url_base)<span class="st">/iris.data"</span>, <span class="fu">joinpath</span>(artifact_dir, <span class="st">"iris.csv"</span>))</span>
<span id="cb95-17"><a href="#cb95-17" aria-hidden="true" tabindex="-1"></a>        <span class="fu">download</span>(<span class="st">"</span><span class="sc">$</span>(iris_url_base)<span class="st">/bezdekIris.data"</span>, <span class="fu">joinpath</span>(artifact_dir, <span class="st">"bezdekIris.csv"</span>))</span>
<span id="cb95-18"><a href="#cb95-18" aria-hidden="true" tabindex="-1"></a>        <span class="fu">download</span>(<span class="st">"</span><span class="sc">$</span>(iris_url_base)<span class="st">/iris.names"</span>, <span class="fu">joinpath</span>(artifact_dir, <span class="st">"iris.names"</span>))</span>
<span id="cb95-19"><a href="#cb95-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb95-20"><a href="#cb95-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-21"><a href="#cb95-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now bind that hash within our `Artifacts.toml`.  `force = true` means that if it already exists,</span></span>
<span id="cb95-22"><a href="#cb95-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># just overwrite with the new content-hash.  Unless the source files change, we do not expect</span></span>
<span id="cb95-23"><a href="#cb95-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># the content hash to change, so this should not cause unnecessary version control churn.</span></span>
<span id="cb95-24"><a href="#cb95-24" aria-hidden="true" tabindex="-1"></a>    <span class="fu">bind_artifact!</span>(artifact_toml, <span class="st">"iris"</span>, iris_hash)</span>
<span id="cb95-25"><a href="#cb95-25" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb95-26"><a href="#cb95-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-27"><a href="#cb95-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the path of the iris dataset, either newly created or previously generated.</span></span>
<span id="cb95-28"><a href="#cb95-28" aria-hidden="true" tabindex="-1"></a><span class="co"># this should be something like `~/.julia/artifacts/dbd04e28be047a54fbe9bf67e934be5b5e0d357a`</span></span>
<span id="cb95-29"><a href="#cb95-29" aria-hidden="true" tabindex="-1"></a>iris_dataset_path <span class="op">=</span> <span class="fu">artifact_path</span>(iris_hash)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이전에 바인딩된 아티팩트를 사용하는 특별한 사례의 경우 현재 패키지에 포함된 <code>Artifacts.toml</code> 파일을 자동으로 검색하고 지정된 아티팩트를 이름으로 조회하고 설치하는 약식 표기인 <code>artifact"name"</code> 이 있습니다. 아직 설치되지 않은 경우 해당 아티팩트의 경로를 반환합니다. 이 약식 표기법의 예는 다음과 같습니다.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Pkg.Artifacts</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="co"># For this to work, an `Artifacts.toml` file must be in the current working directory</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span class="co"># (or in the root of the current package) and must define a mapping for the "iris"</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a><span class="co"># artifact.  If it does not exist on-disk, it will be downloaded.</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>iris_dataset_path <span class="op">=</span> artifact<span class="st">"iris"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="pkg.artifacts-api" class="level3" data-number="8.5">
<h3 data-number="8.5" class="anchored" data-anchor-id="pkg.artifacts-api"><span class="header-section-number">8.5</span> <code>Pkg.Artifacts</code> API</h3>
<p><code>Artifacts</code> API는 해시 인식 기능, 이름 인식 기능 및 유틸리티 기능의 세 가지 수준으로 나뉩니다.</p>
<ul>
<li><p>해시 인식 기능은 콘텐츠 해시를 처리하며 본질적으로 다른 것은 처리하지 않습니다. 이러한 메서드를 사용하면 아티팩트가 있는지 여부, 경로가 무엇인지 쿼리하고 아티팩트가 디스크의 콘텐츠 해시를 충족하는지 확인하는 등의 작업을 수행할 수 있습니다. 해시 인식 기능에는 다음이 포함됩니다 : <code>artifact_exists()</code>, <code>artifact_path()</code>, <code>remove_artifact()</code>, <code>verify_artifact()</code> 및 <code>archive_artifact()</code>. 일반적으로 <code>remove_artifact()</code> 를 사용하지 말고 대신 <code>Pkg.gc()</code> 를 사용하여 아티팩트 설치를 정리해야 합니다.</p></li>
<li><p>이름 인식 기능은 <code>Artifacts.toml</code> 파일 내에서 바인딩된 이름을 처리하므로 일반적으로 <code>Artifacts.toml</code> 파일에 대한 경로와 아티팩트 이름이 모두 필요합니다. 이름 인식 기능에는 다음이 포함됩니다 : <code>artifact_meta()</code>, <code>artifact_hash()</code>, <code>bind_artifact!()</code>, <code>unbind_artifact!()</code>, <code>download_artifact()</code> and <code>ensure_artifact_installed()</code>.</p></li>
<li><p>유틸리티 함수는 <code>create_artifact()</code>, <code>ensure_all_artifacts_installed()</code>, 심지어 <code>@artifact_str</code> 문자열 매크로와 같은 아티팩트 수명의 여러가지 측면을 처리합니다.</p></li>
</ul>
<p>docstring 및 메서드의 전체 목록은 <a href="#12-api-레퍼런스">Artifacts API 레퍼런스</a> 섹션을 참조하세요.</p>
<p><br></p>
</section>
<section id="아티팩트-위치-오버라이딩" class="level3" data-number="8.6">
<h3 data-number="8.6" class="anchored" data-anchor-id="아티팩트-위치-오버라이딩"><span class="header-section-number">8.6</span> 아티팩트 위치 오버라이딩</h3>
<p>경우에 따라 아티팩트의 위치와 콘텐츠를 재정의할 수 있어야 합니다. 일반적인 사용 사례는 패키지가 게시된 이 의존성의 버전에 관계없이 특정 버전의 이진 의존성을 사용해야 하는 컴퓨팅 환경입니다. 일반적인 Julia 구성이 일반 라이브러리를 다운로드하고 압축을 풀고 연결하는 동안 시스템 관리자는 이를 비활성화하고 대신 로컬 시스템에 이미 설치된 라이브러리를 사용할 수 있습니다. 이를 활성화하기 위해 <code>Pkg</code> 는 아티팩트 저장소 디렉터리(예: 기본 사용자 저장소의 경우 <code>~/.julia/artifacts/Overrides.toml</code>)에 있는 저장소별 <code>Overrides.toml</code> 파일을 지원합니다. 해시 또는 패키지 UUID 및 바인딩된 아티팩트 이름으로. 또한 대상 위치는 절대 경로이거나 대체 아티팩트 콘텐츠 해시일 수 있습니다. 이를 통해 시스템 관리자는 새 아티팩트를 사용하도록 다른 패키지를 재정의하여 사용할 수 있는 자체 아티팩트를 생성할 수 있습니다.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Override single hash to absolute path</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="dt">78f35e74ff113f02274ce60dab6e92b4546ef806</span> <span class="op">=</span> <span class="st">"/path/to/replacement"</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Override single hash to new artifact content-hash</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a><span class="dt">683942669b4639019be7631caa28c38f3e1924fe</span> <span class="op">=</span> <span class="st">"d826e316b6c0d29d9ad0875af6ca63bf67ed38c3"</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Override package bindings by specifying the package UUID and bound artifact name</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a><span class="co"># For demonstration purposes we assume this package is called `Foo`</span></span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a><span class="kw">[d57dbccd-ca19-4d82-b9b8-9d660942965b]</span></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a><span class="dt">libfoo</span> <span class="op">=</span> <span class="st">"/path/to/libfoo"</span></span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a><span class="dt">libbar</span> <span class="op">=</span> <span class="st">"683942669b4639019be7631caa28c38f3e1924fe"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Pkg 저장소의 계층적 특성으로 인해 여러 <code>Overrides.toml</code> 파일이 한 번에 적용될 수 있습니다. 이렇게 하면 “내부” <code>Overrides.toml</code> 파일이 “외부” <code>Overrides.toml</code> 파일 내에 배치된 재정의를 재정의할 수 있습니다. 재정의를 제거하고 아티팩트에 대한 기본 위치 논리를 다시 활성화하려면 빈 문자열에 대한 항목 매핑을 삽입합니다.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="dt">78f35e74ff113f02274ce60dab6e92b4546ef806</span> <span class="op">=</span> <span class="st">"/path/to/new/replacement"</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="dt">683942669b4639019be7631caa28c38f3e1924fe</span> <span class="op">=</span> <span class="st">""</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a><span class="kw">[d57dbccd-ca19-4d82-b9b8-9d660942965b]</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a><span class="dt">libfoo</span> <span class="op">=</span> <span class="st">""</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>위에 주어진 두 개의 <code>Overrides.toml</code> 스니펫이 서로 위에 겹쳐 있는 경우 최종 결과는 콘텐츠 해시 <code>78f35e74ff113f02274ce60dab6e92b4546ef806</code> 을 <code>"/path/to/new/replacement"</code> 에 매핑하고 <code>Foo.libbar</code> 를 콘텐츠 해시 <code>683942669b4639019be7631caa28c38f3e1924fe</code> 에 의해 식별된 아티팩트에 매핑합니다. 해당 해시는 이전에 재정의되었지만 더 이상 재정의되지 않으므로 <code>Foo.libbar</code> 는 <code>~/.julia/artifacts/683942669b4639019be7631caa28c38f3e1924fe</code> 와 같은 위치를 직접 확인합니다.</p>
<p>재정의의 영향을 받는 대부분의 메서드는 <code>honor_overrides=false</code> 를 키워드 인수로 설정하여 재정의를 무시할 수 있습니다. UUID/이름 기반의 오버라이드가 작동하려면 <code>Artifacts.toml</code> 파일을 로드하는 패키지의 UUID 를 알고 로드해야 합니다. 이것은 <code>artifacts""</code> 문자열 매크로에 의해 자동으로 추론되지만 어떤 이유로 패키지 내에서 <code>Pkg.Artifacts</code> API를 수동으로 사용하고 재정의를 적용하려는 경우에는 <code>artifact_meta()</code> 및 <code>pkg_uuid</code> 키워드 인자를 통한 <code>ensure_artifact_installed()</code> 와 같은 API 호출에 패키지 UUID 가 필요합니다.</p>
<p><br></p>
</section>
<section id="플랫폼-선택-확장" class="level3" data-number="8.7">
<h3 data-number="8.7" class="anchored" data-anchor-id="플랫폼-선택-확장"><span class="header-section-number">8.7</span> 플랫폼 선택 확장</h3>
<blockquote class="blockquote">
<p><strong>Julia 1.7</strong><br>
Pkg의 확장된 플랫폼 선택에는 최소한 Julia 1.7이 필요하며 실험적인 것으로 간주됩니다.</p>
</blockquote>
<p><br></p>
<p>Julia 1.6의 새로운 기능인 <code>Platform</code> 개체는 확장된 특성을 적용할 수 있으므로 아티팩트에 CUDA 드라이버 버전 호환성, 마이크로아키텍처 호환성, Julia 버전 호환성 등과 같은 태그를 지정할 수 있습니다! 이 기능은 실험적인 것으로 간주되며 향후 변경될 수 있습니다. 패키지 개발자로서 이 기능이 필요한 경우 전체 생태계의 이익을 위해 발전할 수 있도록 우리에게 문의하십시오. <code>Pkg.add()</code> 시간에 아티팩트 선택을 지원하기 위해 <code>Pkg</code> 는 특별하게 이름지어진 파일 <code>&lt;project_root&gt;/.pkg/select_artifacts.jl</code> 을 실행하여 현재 플랫폼 트리플릿을 첫 번째 인수로 전달합니다. 이 아티팩트 선택 스크립트는 지정된 플랫폼에 따라 이 패키지에 필요한 아티팩트를 나타내는 <code>TOML</code> 직렬화된 사전을 출력하고 지정된 플랫폼에서 플랫폼 트리플릿을 명시적으로 제공하지 않는 경우 플랫폼 기능을 자동 감지하는 데 필요한 시스템 검사를 수행해야 합니다. 사전의 형식은 <code>Artifacts.select_downloadable_artifacts()</code> 에서 반환된 형식과 일치해야 하며 실제로 대부분의 패키지는 확장된 <code>Platform</code> 객체로 해당 함수를 호출해야 합니다. 아티팩트 선택 후크 정의의 예는 다음과 같을 수 있으며 두 파일로 분할됩니다.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="co"># .pkg/platform_augmentation.jl</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Libdl</span>, <span class="bu">Base.BinaryPlatforms</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">augment_platform!</span>(p<span class="op">::</span><span class="dt">Platform</span>)</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If this platform object already has a `cuda` tag set, don't augment</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="fu">haskey</span>(p, <span class="st">"cuda"</span>)</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p</span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Open libcuda explicitly, so it gets `dlclose()`'ed after we're done</span></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">dlopen</span>(<span class="st">"libcuda"</span>) <span class="cf">do</span> lib</span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># find symbol to ask for driver version; if we can't find it, just silently continue</span></span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>        cuDriverGetVersion <span class="op">=</span> <span class="fu">dlsym</span>(lib, <span class="st">"cuDriverGetVersion"</span>; throw_error<span class="op">=</span><span class="cn">false</span>)</span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cuDriverGetVersion <span class="op">!==</span> <span class="cn">nothing</span></span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Interrogate CUDA driver for driver version:</span></span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a>            driverVersion <span class="op">=</span> <span class="fu">Ref</span><span class="dt">{Cint}</span>()</span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a>            <span class="fu">ccall</span>(cuDriverGetVersion, <span class="dt">UInt32</span>, (<span class="dt">Ptr</span>{<span class="dt">Cint</span>},), driverVersion)</span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Store only the major version</span></span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true" tabindex="-1"></a>            p[<span class="st">"cuda"</span>] <span class="op">=</span> <span class="fu">div</span>(driverVersion, <span class="fl">1000</span>)</span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb99-21"><a href="#cb99-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb99-22"><a href="#cb99-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-23"><a href="#cb99-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return possibly-altered `Platform` object</span></span>
<span id="cb99-24"><a href="#cb99-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p</span>
<span id="cb99-25"><a href="#cb99-25" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb100"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">TOML</span>, <span class="bu">Artifacts</span>, <span class="bu">Base.BinaryPlatforms</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="fu">include</span>(<span class="st">"./platform_augmentation.jl"</span>)</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>artifacts_toml <span class="op">=</span> <span class="fu">joinpath</span>(<span class="fu">dirname</span>(<span class="pp">@__DIR__</span>), <span class="st">"Artifacts.toml"</span>)</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Get "target triplet" from ARGS, if given (defaulting to the host triplet otherwise)</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>target_triplet <span class="op">=</span> <span class="fu">get</span>(<span class="cn">ARGS</span>, <span class="fl">1</span>, <span class="bu">Base</span>.BinaryPlatforms.<span class="fu">host_triplet</span>())</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Augment this platform object with any special tags we require</span></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a>platform <span class="op">=</span> <span class="fu">augment_platform!</span>(<span class="fu">HostPlatform</span>(<span class="fu">parse</span>(Platform, target_triplet)))</span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Select all downloadable artifacts that match that platform</span></span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a>artifacts <span class="op">=</span> <span class="fu">select_downloadable_artifacts</span>(artifacts_toml; platform)</span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Output the result to `stdout` as a TOML dictionary</span></span>
<span id="cb100-15"><a href="#cb100-15" aria-hidden="true" tabindex="-1"></a><span class="bu">TOML</span>.<span class="fu">print</span>(<span class="cn">stdout</span>, artifacts)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 후크 정의에서 우리의 플랫폼 보강 루틴은 시스템 라이브러리(<code>libcuda</code>)를 열고 CUDA 드라이버 버전을 제공하는 기호를 검색한 다음 해당 버전 번호의 주 버전을 우리가 보강하는 <code>Platform</code> 개체의 <code>cuda</code> 속성에 포함합니다. 이 코드가 실제로 로드된 라이브러리를 닫으려고 시도하는 것은 중요하지 않지만(패키지 작업이 완료된 직후 CUDA 패키지에 의해 다시 열릴 가능성이 높으므로) 후크를 가능한 한 가볍고 투명하게 만드는 것이 가장 좋은데 이는 향후 다른 Pkg 유틸리티에서 사용할 수 있기 때문입니다. 자체 패키지에서 다음과 같이 <code>@artifact_str</code> 매크로를 사용할 때 확장된 플랫폼 개체도 사용해야 합니다.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="fu">include</span>(<span class="st">"../.pkg/platform_augmentation.jl"</span>)</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">__init__</span>()</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fu">augment_platform!</span>(<span class="fu">HostPlatform</span>())</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> my_artifact_dir <span class="op">=</span> <span class="pp">@artifact_str</span>(<span class="st">"MyArtifact"</span>, p)</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이렇게 하면 Pkg가 설치를 시도할 때 동일한 아티팩트가 코드에서 사용됩니다.</p>
</section>
</section>
<section id="용어-glossary" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="용어-glossary"><span class="header-section-number">9</span> 9. 용어 (Glossary)</h2>
<p>프로젝트(Project): 표준 레이아웃이 있는 소스 트리로 다음을 포함합니다 : 1) Julia 코드의 본문을 위한 <code>src</code> 디렉토리, 2) 프로젝트 테스트를 위한 <code>test</code> 디렉토리, 3) 문서 파일을 위한 <code>docs</code> 디렉토리, 4) 선택적으로 빌드 스크립트 및 해당 출력을 위한 <code>deps</code> 디렉토리. 프로젝트에는 일반적으로 project 파일도 있으며 선택적으로 manifest 파일이 있을 수 있습니다.</p>
<ul>
<li><p>Project 파일: <code>Project.toml</code>(또는 <code>JuliaProject.toml</code>)이라는 이름의 프로젝트 루트 디렉터리에 있는 파일로 프로젝트 이름, UUID(패키지용), 작성자, 라이선스, 의존하는 패키지와 라이브러리의 이름 및 UUID를 포함하여 프로젝트에 대한 메타데이터를 설명합니다.</p></li>
<li><p>Manifest 파일: 프로젝트의 루트 디렉터리에 있는 <code>Manifest.toml</code>(또는 <code>JuliaManifest.toml</code>)이라는 이름의 파일로, 전체 의존성 그래프와 프로젝트에서 사용하는 각 패키지 및 라이브러리의 정확한 버전을 설명합니다.</p></li>
</ul>
<p>패키지(Package): <code>import X</code> 또는 <code>using X</code>를 사용하여 다른 Julia 프로젝트에서 사용할 수 있는 재사용 가능한 기능을 제공하는 프로젝트입니다. 패키지에는 패키지 UUID를 제공하는 <code>uuid</code> 항목이 있는 프로젝트 파일이 있어야 합니다. 이 UUID는 의존하는 프로젝트에서 패키지를 식별하는 데 사용됩니다.</p>
<p><br></p>
<blockquote class="blockquote">
<p><strong>주의</strong><br>
하위호환성을 위해 REPL 또는 스크립트의 최상위 수준에서 프로젝트 파일이나 UUID 없이 패키지를 로드할 수 있습니다. 그러나 프로젝트 파일이나 UUID가 없는 패키지는 프로젝트에서 로드할 수 없습니다. 프로젝트 파일에서 로드하면 프로젝트 파일과 UUID가 모두 필요합니다.</p>
</blockquote>
<p><br></p>
<p>응용프로그램(Application): 다른 Julia 프로젝트에서 재사용할 의도가 없는 독립 실행 기능을 제공하는 프로젝트입니다. 예를 들어 웹 애플리케이션이나 커맨드라인 유틸리티 또는 과학 논문과 함께 제공되는 시뮬레이션/분석 코드가 있습니다. 응용프로그램에 UUID가 있을 수 있지만 필요하지는 않습니다. 응용 프로그램은 의존하는 패키지에 대한 전역 구성 옵션을 제공할 수도 있습니다. 반면에 패키지는 기본 응용 프로그램의 구성과 충돌할 수 있으므로 전역 구성을 제공하지 않을 수 있습니다.</p>
<p><br></p>
<blockquote class="blockquote">
<p><strong>주의</strong><br>
프로젝트 vs.&nbsp;패키지 vs.&nbsp;응용프로그램</p>
<ol type="1">
<li>프로젝트는 포괄적인 용어입니다 : 패키지와 응용프로그램은 일종의 프로젝트입니다.</li>
<li>패키지에는 UUID가 있어야 하며 응용프로그램에는 UUID가 있을 수 있지만 필요하지는 않습니다.</li>
<li>응용프로그램은 글로벌 구성을 제공할 수 있지만 패키지는 제공할 수 없습니다.</li>
</ol>
</blockquote>
<p><br></p>
<p>환경(Environment): 다음 세가지의 조합입니다 - 1) 프로젝트 파일에서 제공하는 최상위 이름 맵 2) 의존성 그래프 3) 매니페스트 파일에서 제공하는 패키지에서 진입점까지의 맵. 자세한 내용은 코드 로딩에 대한 설명서 섹션을 참조하십시오.</p>
<ul>
<li><p>명시적 환경 (Explicit environment): 명시적인 프로젝트 파일 형식으로 된 환경(environment)과 선택사항인 해당 매니페스트 파일이 디렉터리에 함께 있습니다. 매니페스트 파일이 없으면 묵시적 의존성 그래프와 위치 맵이 비어 있습니다.</p></li>
<li><p>암시적 환경 (Implicit environment): <code>X.jl</code>, <code>X.jl/src/X.jl</code> 또는 <code>X/src/X.jl</code> 형식의 진입지점이 있는 패키지를 포함하는 디렉토리(프로젝트 파일 또는 매니페스트 파일 없음)로 제공되는 환경입니다. 최상위 이름 맵은 이러한 진입점에 의해 암시됩니다. 의존성 그래프는 패키지 디렉토리 내부에 <code>X.jl/Project.toml</code> 또는 <code>X/Project.toml</code> 와 같은 프로젝트 파일의 존재로부터 암시됩니다. . <code>X</code> 패키지의 의존성은 해당 프로젝트 파일(있는 경우)의 의존성입니다. 위치 맵은 진입점 자체에 의해 암시됩니다.</p></li>
</ul>
<p><br></p>
<p>레지스트리(Registry): 표준 레이아웃이 존재하는 메타데이터를 기록하는 소스트리 입니다. 이 메타데이터의 내용은 1) 등록된 패키지 집합, 2) 패키지들이 사용 가능한지, 어떤 버젼에서 서로 호환되거나 되지 않는지에 대한 태그된 버젼 입니다. 레지스트리는 패키지 이름과 UUID로 인덱싱되며 아래의 메타데이터를 제공하는 등록된 각 패키지에 대한 디렉토리가 있습니다.</p>
<ul>
<li><p>name - 예를 들면 <code>DataFrames</code></p></li>
<li><p>UUID - 예를 들면 <code>a93c6f00-e57d-5684-b7b6-d8193f3e46c0</code></p></li>
<li><p>repository - 예를 들면 <code>https://github.com/JuliaData/DataFrames.jl.git</code></p></li>
<li><p>versions - 모든 등록된 버젼 태그들의 목록</p></li>
</ul>
<p>각각의 등록된 패키지 버젼들에 대해 아래의 정보가 제공된다</p>
<ul>
<li><p>semantic version name - 예를 들면 <code>v1.2.3</code></p></li>
<li><p>git tree SHA-1 hash - 예를 들면 <code>7ffb18ea3245ef98e368b02b81e8a86543a11103</code></p></li>
<li><p>이름부터 의존성의 UUID 에 대한 맵</p></li>
<li><p>호환가능하거나 호환 불가능한 다른 패키지의 버젼들</p></li>
</ul>
<p>의존성과 호환성은 압축되었지만 사람이 읽을 수 있는 패키지 버젼의 범위를 사용하는 형식으로 저장됩니다.</p>
<p><br></p>
<p>저장소 (Depot) : 다양한 패키지 관련 리소스들이 위치하는 시스템상의 디렉토리로 다음을 포함합니다.</p>
<ul>
<li><p><code>environment</code> : 공유되는 이름이 붙여진 환경 (예를 들면 <code>v1.0</code> <code>devtools</code>)</p></li>
<li><p><code>clones</code> : 패키지 저장소에 있는 그대로의 복제본</p></li>
<li><p><code>compiled</code> : 컴파일되어 캐쉬된 패키지 이미지 (<code>.jl</code> 파일들)</p></li>
<li><p><code>config</code> : 전역적인 설정 파일들 (예를 들면 <code>startup.jl</code>)</p></li>
<li><p><code>dev</code> : 패키지 개발의 기본 디렉토리</p></li>
<li><p><code>logs</code> : 로그 파일들 (예를 들면 <code>manifest_usage.toml</code>, <code>repl_history.jl</code>)</p></li>
<li><p><code>packages</code> : 설치된 패키지 버젼</p></li>
<li><p><code>registries</code> : 레지스트리의 복제본 (예를 들면 <code>General</code>)</p></li>
</ul>
<p>로드 경로 (Load path): 패키지 ID 와 의존성 및 진입점이 검색되는 환경의 스택입니다. 로드 경로는 <code>JULIA_LOAD_PATH</code> 환경 변수의 값을 기반으로 시작할 때 채워지는 <code>LOAD_PATH</code> 전역 변수에 의해 Julia에서 제어됩니다. 첫 번째 항목은 주로 현재 프로젝트인 기본 환경이며, 이후 항목은 REPL 또는 최상위 스크립트에서 사용할 수 있는 추가 패키지를 제공합니다.</p>
<p>저장소 경로 (Depot path): 패키지 관리자와 Julia의 코드 로딩 메커니즘이 레지스트리, 설치된 패키지, 명명된 환경, repo 클론, 캐시된 컴파일된 패키지 이미지 및 구성 파일을 찾는 저장소 위치의 스택입니다. 저장소 경로는 <code>JULIA_DEPOT_PATH</code> 환경 변수의 값을 기반으로 시작 시 채워지는 Julia <code>DEPOT_PATH</code> 전역 변수에 의해 제어됩니다. 첫 번째 항목은 “사용자 저장소”이며 현재 사용자가 쓰기 가능하고 소유해야 합니다. 사용자 저장소는 레지스트리 복제, 새 패키지 버전 설치, 명명된 환경 생성 및 업데이트, 패키지 저장소 복제, 새로 컴파일된 패키지 이미지 파일 저장, 로그 파일 작성, 기본적으로 개발 패키지 체크아웃 및 전역 구성 데이터가 저장됩니다. 저장소 경로의 이후 항목은 읽기 전용으로 처리되며 시스템 관리자가 설치하고 관리하는 레지스트리, 패키지 등에 적합합니다.</p>
</section>
<section id="project.toml-과-manifest.toml" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="project.toml-과-manifest.toml"><span class="header-section-number">10</span> 10. <code>Project.toml</code> 과 <code>Manifest.toml</code></h2>
<p>Pkg의 핵심인 두 파일은 <code>Project.toml</code> 과 <code>Manifest.toml</code> 입니다. <code>Project.toml</code> 및 <code>Manifest.toml</code> 은 <a href="https://github.com/toml-lang/toml">TOML</a>(따라서 <code>.toml</code> 확장자)로 작성되며 의존성, 버전, 패키지 이름, UUID 등에 대한 정보를 포함합니다.</p>
<blockquote class="blockquote">
<p><strong>주의</strong><br>
<code>Project.toml</code> 및 <code>Manifest.toml</code> 파일은 패키지 관리자만 사용하는 것이 아닙니다. 그들은 또한 Julia의 코드 로딩에 의해 사용되며 예를 들자면 <code>using Example</code> 이 무슨 일을 해야하는지를 결정합니다. 자세한 내용은 Julia 설명서의 <a href="https://docs.julialang.org/en/v1/manual/code-loading/">Code Loading</a> 섹션을 참조하십시오.</p>
</blockquote>
<p><br></p>
<section id="project.toml" class="level3" data-number="10.1">
<h3 data-number="10.1" class="anchored" data-anchor-id="project.toml"><span class="header-section-number">10.1</span> <code>Project.toml</code></h3>
<p>프로젝트 파일은 상위 수준에서 프로젝트를 설명합니다. 예를 들어 패키지/프로젝트 의존성 및 호환성 제약 조건이 프로젝트 파일에 나열됩니다. 파일 항목은 아래에 설명되어 있습니다.</p>
<p><br></p>
<section id="authors-필드" class="level4">
<h4 class="anchored" data-anchor-id="authors-필드"><code>authors</code> 필드</h4>
<p>패키지의 경우 선택적인 <code>authors</code> 필드는 <code>NAME &lt;EMAIL&gt;</code> 형식으로 패키지 작성자를 설명하는 문자열 목록입니다. 예를 들어:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="dt">authors</span> <span class="op">=</span> <span class="op">[</span><span class="st">"Some One &lt;someone@email.com&gt;"</span><span class="op">,</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>           <span class="st">"Foo Bar &lt;foo@bar.com&gt;"</span><span class="op">]</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="name-필드" class="level4">
<h4 class="anchored" data-anchor-id="name-필드"><code>name</code> 필드</h4>
<p>패키지/프로젝트의 이름은 <code>name</code> 필드에 의해 결정됩니다:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="dt">name</span> <span class="op">=</span> <span class="st">"Example"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이름은 유효한 <a href="https://docs.julialang.org/en/v1/base/base/#Base.isidentifier">식별자(identifier)</a> (숫자로 시작하지 않고 <code>true</code>도 <code>false</code> 도 아닌 일련의 유니코드 문자)여야 합니다. 패키지의 경우 <a href="#패키지-작명-가이드">패키지 작명 가이드</a>를 따르는 것이 좋습니다. <code>name</code> 필드는 패키지의 필수 항목입니다.</p>
<p><br></p>
</section>
<section id="uuid-필드" class="level4">
<h4 class="anchored" data-anchor-id="uuid-필드"><code>uuid</code> 필드</h4>
<p><code>uuid</code> 는 패키지/프로젝트에 대한 <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">범용 고유 식별자</a> 입니다. 예를 들어,</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="dt">uuid</span> <span class="op">=</span> <span class="st">"7876af07-990d-54b4-ab0e-23690620f79a"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>uuid</code> 필드는 패키지의 대해 필수 항목입니다.</p>
<blockquote class="blockquote">
<p><strong>주의</strong><br>
임의의 UUIDs 를 생성하는데 <code>UUIDs.uuid4()</code> 를 사용하는 것을 추천합니다.</p>
</blockquote>
<p><br></p>
</section>
<section id="version-필드" class="level4">
<h4 class="anchored" data-anchor-id="version-필드"><code>version</code> 필드</h4>
<p><code>version</code> 은 패키지/프로젝트의 버전 번호가 포함된 문자열입니다. 주 버전, 부 버전 및 패치 번호의 3개 숫자로 구성되어야 하며 <code>.</code> 로 구분됩니다. 예를 들면 다음과 같습니다.</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="dt">version</span> <span class="op">=</span> <span class="st">"1.2.5"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Julia는 <a href="https://semver.org/">Semantic Versioning</a>(SemVer)를 사용하며 <code>version</code> 필드는 SemVer를 따라야 합니다. 기본 규칙은 다음과 같습니다.</p>
<ul>
<li><p>1.0.0 이전에는 모든 것이 가능하지만 주요 변경 사항을 만들면 부 버전이 증가해야 합니다.</p></li>
<li><p>1.0.0 이후에는 주 버전을 올릴 때만 주요 변경 사항을 만듭니다.</p></li>
<li><p>1.0.0 이후에는 마이너 버전을 올리지 않고 새로운 공개 API를 추가할 수 없습니다. 여기에는 특히 Base 또는 기타 패키지의 새로운 유형, 함수, 메서드 및 메서드 오버로드가 포함됩니다.</p></li>
</ul>
<p><a href="#6-호환성-compatiblity">호환성</a> 세션을 참고하세요.</p>
<p>Pkg.jl은 1.0.0 이전 버전의 경우 SemVer 사양과 다릅니다. 자세한 내용은 <a href="https://pkgdocs.julialang.org/v1/compatibility/#compat-pre-1.0">1.0 이전 동작</a> 섹션을 참조하십시오.</p>
<p><br></p>
</section>
<section id="deps-섹션" class="level4">
<h4 class="anchored" data-anchor-id="deps-섹션"><code>[deps]</code> 섹션</h4>
<p>패키지/프로젝트의 모든 의존성은 <code>[deps]</code> 섹션에 열거됩니다. 각각의 의존성들은 name-uuid 쌍으로 열거됩니다. 예를 듦면 :</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[deps]</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Example</span> <span class="op">=</span> <span class="st">"7876af07-990d-54b4-ab0e-23690620f79a"</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Test</span> <span class="op">=</span> <span class="st">"8dfed614-e22c-5e08-85e1-65c5234f0b40"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>보통은 <code>[deps]</code> 섹션에 수동으로 추가할 필요가 없습니다; 대신에 <code>add</code> 같은 Pkg 연산으로 다루어집니다.</p>
<p><br></p>
</section>
<section id="compat-섹션" class="level4">
<h4 class="anchored" data-anchor-id="compat-섹션"><code>[compat]</code> 섹션</h4>
<p><code>[deps]</code> 에 열거된 의존성에 대한 호환성의 제약들은 <code>[compat]</code> 섹션에 열거됩니다. 예를 들면</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[deps]</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Example</span> <span class="op">=</span> <span class="st">"7876af07-990d-54b4-ab0e-23690620f79a"</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Example</span> <span class="op">=</span> <span class="st">"1.2"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="#6-호환성-compatiblity">호환성</a> 섹션에 서로 다른 다양한 호환성 제약들이 자세히 설명하였습니다. 비록 <code>julia</code> 는 <code>[deps]</code> 섹션에 의존성이 열거되지 않더라도, <code>julia</code> 자체에 대한 제약들을 열거할수도 있습니다. :</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[compat]</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="dt">julia</span> <span class="op">=</span> <span class="st">"1.1"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
</section>
<section id="manifest.toml" class="level3" data-number="10.2">
<h3 data-number="10.2" class="anchored" data-anchor-id="manifest.toml"><span class="header-section-number">10.2</span> <code>Manifest.toml</code></h3>
<p>Manifest 파일은 환경 내의 패키지 상태에 대한 절대적인 기록입니다. 여기에는 프로젝트의 (직접 및 간접) 의존성에 대한 정확한 정보가 포함됩니다. <code>Project.toml</code> + <code>Manifest.toml</code> 쌍이 주어지면 정확히 동일한 패키지 환경을 인스턴스화할 수 있으며 이는 재현성에 매우 유용합니다. 자세한 내용은 <a href="https://pkgdocs.julialang.org/v1/api/#Pkg.instantiate"><code>Pkg.instantiate</code></a>를 참조하세요.</p>
<blockquote class="blockquote">
<p><strong>주의</strong><br>
<code>Manifest.toml</code> 파일은 Pkg에서 생성되고 및 유지되며, 일반적으로 이 파일은 수동으로 수정하면 안 됩니다.</p>
</blockquote>
<p><br></p>
<section id="manifest.toml-항목들" class="level4">
<h4 class="anchored" data-anchor-id="manifest.toml-항목들"><code>Manifest.toml</code> 항목들</h4>
<p>각각의 의존성은 manifest 파일에 자체 섹션이 있으며 해당 내용은 의존성이 환경에 추가된 방식에 따라 다릅니다. 모든 의존성 섹션에는 다음 항목의 조합이 포함됩니다.</p>
<ul>
<li><p><code>uuid</code> : the UUID for the dependency, for example <code>uuid = "7876af07-990d-54b4-ab0e-23690620f79a"</code>.</p></li>
<li><p><code>deps</code>: a vector listing the dependencies of the dependency, for example <code>deps = ["Example", "JSON"]</code>.</p></li>
<li><p><code>version</code>: a version number, for example <code>version = "1.2.6"</code>.</p></li>
<li><p><code>path</code>: a file path to the source code, for example <code>path = /home/user/Example</code>.</p></li>
<li><p><code>repo-url</code>: a URL to the repository where the source code was found, for example <code>repo-url = "https://github.com/JuliaLang/Example.jl.git"</code>.</p></li>
<li><p><code>repo-rev</code>: a git revision, for example a branch <code>repo-rev = "master"</code> or a commit <code>repo-rev = "66607a62a83cb07ab18c0b35c038fcd62987c9b1"</code>.</p></li>
<li><p><code>git-tree-sha1</code> : a content hash of the source tree, for example <code>git-tree-sha1 = "ca3820cc4e66f473467d912c4b2b3ae5dc968444"</code> .</p></li>
</ul>
<p><br></p>
</section>
<section id="추가된-패키지" class="level4">
<h4 class="anchored" data-anchor-id="추가된-패키지">추가된 패키지</h4>
<p>예를 들어 <code>pkg&gt; add Example</code> 와 같이 페키지 레지스트리로부터 패키지가 추가되거나 <code>plg&gt; add Example@1.2</code> 와 같이 특정 버젼이 추가될 때, <code>Manifest.toml</code> 은 다음과 비슷합니다 :</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[[Example]]</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="dt">deps</span> <span class="op">=</span> <span class="op">[</span><span class="st">"DependencyA"</span><span class="op">,</span> <span class="st">"DependencyB"</span><span class="op">]</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="dt">git-tree-sha1</span> <span class="op">=</span> <span class="st">"8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8"</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="dt">uuid</span> <span class="op">=</span> <span class="st">"7876af07-990d-54b4-ab0e-23690620f79a"</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="dt">version</span> <span class="op">=</span> <span class="st">"1.2.3"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>특히 이 패키지가 발견된 레지스트리에 해당 정보가 포함되어 있으므로 <code>repo-url</code> 이 존재하지 않는다는 점에 유의하십시오.</p>
<p><br></p>
</section>
<section id="브랜치로-추가된-패키지" class="level4">
<h4 class="anchored" data-anchor-id="브랜치로-추가된-패키지">브랜치로 추가된 패키지</h4>
<p>예를 들어 <code>pkg&gt; Example#master</code> 나 <code>pkg&gt; add https://github.com/JuliaLang/Example.jl.git</code> 와 같이 패키지의 특정 브랜치를 지정하여 를 추가할 때 의존성 섹션은 다음과 같습니다.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[[Example]]</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="dt">deps</span> <span class="op">=</span> <span class="op">[</span><span class="st">"DependencyA"</span><span class="op">,</span> <span class="st">"DependencyB"</span><span class="op">]</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="dt">git-tree-sha1</span> <span class="op">=</span> <span class="st">"54c7a512469a38312a058ec9f429e1db1f074474"</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a><span class="dt">repo-rev</span> <span class="op">=</span> <span class="st">"master"</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a><span class="dt">repo-url</span> <span class="op">=</span> <span class="st">"https://github.com/JuliaLang/Example.jl.git"</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a><span class="dt">uuid</span> <span class="op">=</span> <span class="st">"7876af07-990d-54b4-ab0e-23690620f79a"</span></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a><span class="dt">version</span> <span class="op">=</span> <span class="st">"1.2.4"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>우리가 추적하는 브랜치 (<code>master</code>) 와 원격 저장소 ulr (<code>"https://github.com/JuliaLang/Example.jl.git"</code>) 모두 manifest 에 저장되는것을 알 수 있습니다.</p>
<p><br></p>
</section>
<section id="커밋commit-을-통해-추가된-패키지" class="level4">
<h4 class="anchored" data-anchor-id="커밋commit-을-통해-추가된-패키지">커밋(commit) 을 통해 추가된 패키지</h4>
<p><code>pkg&gt; add Example#cf6ba6cc0be0bb5f56840188563579d67048be34</code> 와 같이 커밋에 의해 지정되어 패키지를 추적할 때의 의존성 섹션은 다음과 같습니다.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[[Example]]</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="dt">deps</span> <span class="op">=</span> <span class="op">[</span><span class="st">"DependencyA"</span><span class="op">,</span> <span class="st">"DependencyB"</span><span class="op">]</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="dt">git-tree-sha1</span> <span class="op">=</span> <span class="st">"54c7a512469a38312a058ec9f429e1db1f074474"</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="dt">repo-rev</span> <span class="op">=</span> <span class="st">"cf6ba6cc0be0bb5f56840188563579d67048be34"</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a><span class="dt">repo-url</span> <span class="op">=</span> <span class="st">"https://github.com/JuliaLang/Example.jl.git"</span></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a><span class="dt">uuid</span> <span class="op">=</span> <span class="st">"7876af07-990d-54b4-ab0e-23690620f79a"</span></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a><span class="dt">version</span> <span class="op">=</span> <span class="st">"1.2.4"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>브랜치를 추적할 때와의 유일한한 차이점은 <code>repo-rev</code> 내용입니다.</p>
<p><br></p>
</section>
<section id="개발된-패키지" class="level4">
<h4 class="anchored" data-anchor-id="개발된-패키지">개발된 패키지</h4>
<p><code>pkg&gt; develop Example</code> 이나 <code>pkg&gt; develop /path/to/local/folder/Example</code> 처럼 <code>develop</code> 를 통해 패키지를 추가하면 의존성 섹션은 다음과 같습니다.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[[Example]]</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="dt">deps</span> <span class="op">=</span> <span class="op">[</span><span class="st">"DependencyA"</span><span class="op">,</span> <span class="st">"DependencyB"</span><span class="op">]</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="dt">path</span> <span class="op">=</span> <span class="st">"/home/user/.julia/dev/Example/"</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="dt">uuid</span> <span class="op">=</span> <span class="st">"7876af07-990d-54b4-ab0e-23690620f79a"</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a><span class="dt">version</span> <span class="op">=</span> <span class="st">"1.2.4"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>소스코드 경로가 포함되며 소스 트리에의 변화가 직접적으로 반영되는것에 주의하십시요.</p>
<p><br></p>
</section>
<section id="고정된-패키지" class="level4">
<h4 class="anchored" data-anchor-id="고정된-패키지">고정된 패키지</h4>
<p>고정된 패키지(pinned packages) 역시 manifest 파일에 기록됩니다; <code>pkg&gt; add Example; pin Example</code> 에 의한 의존성 섹션은 다음과 같습니다.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[[Example]]</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="dt">deps</span> <span class="op">=</span> <span class="op">[</span><span class="st">"DependencyA"</span><span class="op">,</span> <span class="st">"DependencyB"</span><span class="op">]</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="dt">git-tree-sha1</span> <span class="op">=</span> <span class="st">"54c7a512469a38312a058ec9f429e1db1f074474"</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="dt">pinned</span> <span class="op">=</span> <span class="cn">true</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="dt">uuid</span> <span class="op">=</span> <span class="st">"7876af07-990d-54b4-ab0e-23690620f79a"</span></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a><span class="dt">version</span> <span class="op">=</span> <span class="st">"1.2.4"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>유일한 차이는 <code>pinned = true</code> 항목이 추가된 것입니다.</p>
<p><br></p>
</section>
<section id="같은-이름을-가진-복수의-패키지" class="level4">
<h4 class="anchored" data-anchor-id="같은-이름을-가진-복수의-패키지">같은 이름을 가진 복수의 패키지</h4>
<p>Julia는 UUID를 기반으로 패키지를 구분하므로 이름만으로는 패키지를 식별하기에 충분하지 않습니다. 동일한 환경에 이름은 같지만 UUID가 다른 여러 패키지가 있을 수 있습니다. 이러한 상황에서 <code>Manifest.toml</code> 파일은 약간 다르게 보입니다. 예를 들어 환경에 <code>A</code>와 <code>B</code>를 추가하고 <code>Project.toml</code> 파일이 다음과 같이 표시되는 상황을 고려하십시오.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[deps]</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="dt">A</span> <span class="op">=</span> <span class="st">"ead4f63c-334e-11e9-00e6-e7f0a5f21b60"</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="dt">B</span> <span class="op">=</span> <span class="st">"edca9bc6-334e-11e9-3554-9595dbb4349c"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>A</code>가 이제 <code>B = "f41f7b98-334e-11e9-1257-49272045fb24"</code>에 의존하는 경우, 즉 <code>B</code> 라는 이름을 가진 또 다른 패키지가 있을 경우, <code>Manifest.toml</code> 파일에 두 개의 다른 <code>B</code> 패키지가 있습니다. 이 경우 명확성을 위해 <code>git-tree-sha1</code> 및 <code>version</code> 필드가 제거된 전체 <code>Manifest.toml</code> 파일은 다음과 같습니다.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[[A]]</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="dt">uuid</span> <span class="op">=</span> <span class="st">"ead4f63c-334e-11e9-00e6-e7f0a5f21b60"</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[A.deps]</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">B</span> <span class="op">=</span> <span class="st">"f41f7b98-334e-11e9-1257-49272045fb24"</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="kw">[[B]]</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a><span class="dt">uuid</span> <span class="op">=</span> <span class="st">"f41f7b98-334e-11e9-1257-49272045fb24"</span></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a><span class="kw">[[B]]</span></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a><span class="dt">uuid</span> <span class="op">=</span> <span class="st">"edca9bc6-334e-11e9-3554-9595dbb4349c"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이제 두 개의 <code>B</code> 패키지 배열이 있으며 <code>A</code>의 <code>[deps]</code> 섹션은 <code>A</code>가 의존하는 <code>B</code> 패키지에 대해 명시적으로 확장되었습니다.</p>
<p><br></p>
</section>
</section>
</section>
<section id="repl-모드-레퍼런스" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="repl-모드-레퍼런스"><span class="header-section-number">11</span> 11. REPL 모드 레퍼런스</h2>
<p><a href="https://pkgdocs.julialang.org/v1/repl/">영문 원문</a> 참고</p>
<p><br></p>
</section>
<section id="api-레퍼런스" class="level2" data-number="12">
<h2 data-number="12" class="anchored" data-anchor-id="api-레퍼런스"><span class="header-section-number">12</span> 12. API 레퍼런스</h2>
<p><a href="https://pkgdocs.julialang.org/v1/api/">영문 원문</a> 참고</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/julia-kaeri\.github\.io\/IntroductionToJulia\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../src/application_of_julia/more_on_types.html" class="pagination-link" aria-label="타입에 대해 더 알아보기">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">타입에 대해 더 알아보기</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../src/application_of_julia/string_literal.html" class="pagination-link" aria-label="문자열 리터럴">
        <span class="nav-page-text">문자열 리터럴</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>