[
  {
    "objectID": "src/introduction_to_julia/08_type_hierarchy.html",
    "href": "src/introduction_to_julia/08_type_hierarchy.html",
    "title": "타입의 계층구조와 메서드 디스패치",
    "section": "",
    "text": "Julia 에서 다루는 모든 값은 특정 타입(Type) 의 값입니다. 타입은 julia 언어에서 제공하는 Int64 나 Complex{Float64} 일 수도 있고 필요에 의해 만든 것일 수도 있습니다. Julia 에서 변수에 값을 할당할 때 타입을 명시적으로 지정할 수 있으며, 명시적으로 지정되어 있지 않을 경우 julia 에 의해 지정되기도 합니다. 다음의 코드와 설명을 보고 이해하시기 바랍니다.\nIn [1]: a=3;typeof(a)\nOut[1]: Int64\n\nIn [2]: b=3.42;typeof(b)\nOut[2]: Float64\n\nIn [3]: c=Float32(6.44);typeof(c)\nOut[3]: Float32\n\nIn [4]: d::Float32=3.3;typeof(d)\nOut[4]: Float32\n\nIn [5]: e::UInt8=3;typeof(e)\nOut[5]: UInt8\n특별히 형을 지정하지 않았을 경우 정수는 Int64, 실수는 Float64 타입으로 암시적으로 지정됩니다. c 의 경우는 6.44 라는 Float64 의 값을 Float32 로 변환시켜 할당하였으며, d 의 경우는 변수를 Float32 타입으로 지정한 후 대입하여 자동적으로 변환되었습니다. e 의 경우도 UInt8 타입으로 지정한 후 3 을 할당하여 지정된 타입으로 자동적으로 변환되었습니다.\n\n\n\nJulia 의 타입은 추상적 타입(abstract type) 과 구체적 타입(concrete type) 으로 분류 할 수 있습니다. 구체적 타입은 변수가 지정되어 값을 할당 할 수 있지만 추상적 타입에는 변수를 지정 할 수 없으며, 값도 할당 할 수 없습니다. 억지로 할당할 경우 적당한 구체적 타입으로 변환됩니다. 우리가 지금까지 사용한 UInt8, Int64, Float64 등은 구체적 타입이며 아래의 예에서 AbstractFloat 는 부동소수에 대한 추상적인 타입입니다.\nIn [6]: aa=AbstractFloat(0.0);typeof(aa)\nOut[6]: Float64\n어떤 타입이 구체적인 타입인지 추상적인 타입인지는 isabstracttype() 함수나 isconcretetype() 함수로 확인 할 수 있습니다. Julia 에서 모든 타입은 Any 타입에서 뻗어나온 가지와 같은 계층구조를 가지고 있습니다. 예를 들어 julia 에서 제공하는 수 타입은 그림 1 와 같은 계층구조를 가집니다.\nJulia 에서 추상적 타입은 abstract 키워드를 사용하여 다음과 같이 정의합니다.\nabstract type Number end\nabstract type Real     &lt;: Number end\nabstract type AbstractFloat &lt;: Real end\nabstract type Integer  &lt;: Real end\nabstract type Signed   &lt;: Integer end\nabstract type Unsigned &lt;: Integer end\n위의 코드는 저자가 임의로 작성한 코드가 아니라 julia 에서 실제 추상 타입을 구현한 코드를 복사한 것입니다. abstract type Real &lt;: Number end 에서 Real &lt;: Number 는 Real 타입이 미리 정의된 Number 타입의 하위 타입 이란 의미입니다. Any 타입의 직접적인 하위타입은 &lt;: Any 없이 추상 타입을 정의 할 수 있습니다. 이렇게 정의된 것이 Number 타입입니다. Number 라는 수 전체를 아우르는 상위 타입이 있으며, 실수를 나타내는 Real 타입, 부동소수를 나타내는 AbstractFloat 타입, 정수를 나타내는 Integer 타입, 부호 있는 정수를 나타내는 Signed 타입, 부호 없는 정수, 즉 0 을 포함한 자연수를 나타내는 Unsigned 타입과 같은 추상 타입이 있습니다.\nJulia 의 모든 타입은 어떤 타입의 하위 타입(subtype) 이며 단 하나의 상위 타입(supertype) 을 계승합니다. 타입의 하위타입에는 갯수 제한이 없습니다. 타입 계층의 최상단에는 Any 타입이 있으며, 모든 타입은 Any 의 하위타입 이던가 Any 의 하위타입의 하위타입 이던가…. Any 의 몇대 자손중의 하나입니다. 심지어 Any 의 상위타입은 Any 입니다. 어떤 타입의 상위 타입을 알기 위해서는 supertype() 함수를 사용 하며 하위 타입들을 알기 위해서는 subtypes() 함수를 사용합니다.\nIn [7]: supertype(UInt8)\nOut[7]: Unsigned\n\nIn [8]: subtypes(Integer)\nOut[8]: 3-element Vector{Any}:\n Bool\n Signed\n Unsigned\n어떤 타입의 상위 타입은 추상적 타입만이 가능하며, 구체적 타입은 어떤 타입의 상위 타입이 될 수 없습니다. 당연히 Any 는 추상적 타입입니다. 그림 그림 1 은 Julia 에서 자체적으로 제공하는 수(number) 에 대한 타입의 계층 구조입니다. 추상적 타입은 좌우 변이 두겹인 사각형, 구체적 타입은 좌우가 둥근 도형으로 표현하였습니다. Irrational 은 \\(\\pi\\) 나 \\(e\\) 같은 특별한 무리수를 위한 타입으로 계산 될 때 적당한 타입의 값으로 변환됩니다.\n\n\n\n\n\n\nflowchart TB\n    Any[[Any]] --- Number[[Number]]\n    Number ---- Real[[Real]]\n    Number --- Complex[[Complex]]\n    Real ------- Integer[[Integer]] \n    Real --- Rational([Rational])\n    Real --- AbstractIrrational[[AbstractIrrational]]\n    Real ----- AbstractFloat[[AbstractFloat]]\n    Integer --- Unsigned[[Unsigned]] & Bool([Bool])\n    Integer ----- Signed[[Signed]]\n    AbstractIrrational --- Irrational[Irrational]\n    AbstractFloat --- Float16([Float16]) & Float32([Float32]) & Float64([Float64])  &  BigFloat([BigFloat])\n    Unsigned --- UInt8([UInt8]) & UInt16([UInt16]) & UInt32([UInt32]) & UInt64([UInt64]) & UInt128([UInt128])\n    Signed --- Int8([Int8]) & Int16([Int16]) & Int32([Int32]) & Int64([Int64])  & Int128([Int128]) & BigInt([BigInt])\n\n\n\n\n그림 1: Type hierarchy of number\n\n\n\n\n\n\n이것을 정리하면 다음과 같습니다.\n\n\n\n\n추상적 타입\n구체적 타입\n\n\n\n\n하위타입 지정\no\nx\n\n\n변수 할당\nx\no\n\n\n\n여기서 Complex 만 추상적 타입으로 구체적인 하위타입이 존재하지 않습니다. 실제로 Julia 에서 복소수는 복합 타입(composite type) 으로 정의됩니다. 여기에 대해서는 복합 타입에서 다루겠습니다.\n\n\n\n\nInt64 나 Float32 와 같이 값이 저장되는데 사용되는 바이트 수가 결정된 구체적 타입을 원시 타입(Primitive type) 이라고 합니다. isprimitivetype() 함수를 통해 특정 타입이 원시 타입인지를 확인할 수 있습니다. Julia 의 모든 기본 타입은 julia 자체 내에서 다음과 같이 정의되었습니다. 저의 경우는 Julia 설치 디렉토리의 /share/julia/base/boot.jl 파일에 정의되었습니다.\nprimitive type Float16 &lt;: AbstractFloat 16 end\nprimitive type Float32 &lt;: AbstractFloat 32 end\nprimitive type Float64 &lt;: AbstractFloat 64 end\n\nprimitive type Bool &lt;: Integer 8 end\nprimitive type Char &lt;: AbstractChar 32 end\n\nprimitive type Int8    &lt;: Signed   8 end\nprimitive type UInt8   &lt;: Unsigned 8 end\nprimitive type Int16   &lt;: Signed   16 end\nprimitive type UInt16  &lt;: Unsigned 16 end\nprimitive type Int32   &lt;: Signed   32 end\nprimitive type UInt32  &lt;: Unsigned 32 end\nprimitive type Int64   &lt;: Signed   64 end\nprimitive type UInt64  &lt;: Unsigned 64 end\nprimitive type Int128  &lt;: Signed   128 end\nprimitive type UInt128 &lt;: Unsigned 128 end\n첫번째 primitive type Float16 &lt;: AbstractFloat 16 end 는 Float16 타입은 AbstractFloat 타입의 하위타입으로 16비트, 즉 2바이트를 차지하는 타입이라는 의미입니다. 앞서 말했듯이 구체적 타입은 상위 타입이 될 수 없으므로 원시 타입은 어떤 추상 타입의 하위타입이 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "타입의 계층구조와 메서드 디스패치"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/08_type_hierarchy.html#sec-type_hierarchy",
    "href": "src/introduction_to_julia/08_type_hierarchy.html#sec-type_hierarchy",
    "title": "타입의 계층구조와 메서드 디스패치",
    "section": "",
    "text": "Julia 에서 다루는 모든 값은 특정 타입(Type) 의 값입니다. 타입은 julia 언어에서 제공하는 Int64 나 Complex{Float64} 일 수도 있고 필요에 의해 만든 것일 수도 있습니다. Julia 에서 변수에 값을 할당할 때 타입을 명시적으로 지정할 수 있으며, 명시적으로 지정되어 있지 않을 경우 julia 에 의해 지정되기도 합니다. 다음의 코드와 설명을 보고 이해하시기 바랍니다.\nIn [1]: a=3;typeof(a)\nOut[1]: Int64\n\nIn [2]: b=3.42;typeof(b)\nOut[2]: Float64\n\nIn [3]: c=Float32(6.44);typeof(c)\nOut[3]: Float32\n\nIn [4]: d::Float32=3.3;typeof(d)\nOut[4]: Float32\n\nIn [5]: e::UInt8=3;typeof(e)\nOut[5]: UInt8\n특별히 형을 지정하지 않았을 경우 정수는 Int64, 실수는 Float64 타입으로 암시적으로 지정됩니다. c 의 경우는 6.44 라는 Float64 의 값을 Float32 로 변환시켜 할당하였으며, d 의 경우는 변수를 Float32 타입으로 지정한 후 대입하여 자동적으로 변환되었습니다. e 의 경우도 UInt8 타입으로 지정한 후 3 을 할당하여 지정된 타입으로 자동적으로 변환되었습니다.\n\n\n\nJulia 의 타입은 추상적 타입(abstract type) 과 구체적 타입(concrete type) 으로 분류 할 수 있습니다. 구체적 타입은 변수가 지정되어 값을 할당 할 수 있지만 추상적 타입에는 변수를 지정 할 수 없으며, 값도 할당 할 수 없습니다. 억지로 할당할 경우 적당한 구체적 타입으로 변환됩니다. 우리가 지금까지 사용한 UInt8, Int64, Float64 등은 구체적 타입이며 아래의 예에서 AbstractFloat 는 부동소수에 대한 추상적인 타입입니다.\nIn [6]: aa=AbstractFloat(0.0);typeof(aa)\nOut[6]: Float64\n어떤 타입이 구체적인 타입인지 추상적인 타입인지는 isabstracttype() 함수나 isconcretetype() 함수로 확인 할 수 있습니다. Julia 에서 모든 타입은 Any 타입에서 뻗어나온 가지와 같은 계층구조를 가지고 있습니다. 예를 들어 julia 에서 제공하는 수 타입은 그림 1 와 같은 계층구조를 가집니다.\nJulia 에서 추상적 타입은 abstract 키워드를 사용하여 다음과 같이 정의합니다.\nabstract type Number end\nabstract type Real     &lt;: Number end\nabstract type AbstractFloat &lt;: Real end\nabstract type Integer  &lt;: Real end\nabstract type Signed   &lt;: Integer end\nabstract type Unsigned &lt;: Integer end\n위의 코드는 저자가 임의로 작성한 코드가 아니라 julia 에서 실제 추상 타입을 구현한 코드를 복사한 것입니다. abstract type Real &lt;: Number end 에서 Real &lt;: Number 는 Real 타입이 미리 정의된 Number 타입의 하위 타입 이란 의미입니다. Any 타입의 직접적인 하위타입은 &lt;: Any 없이 추상 타입을 정의 할 수 있습니다. 이렇게 정의된 것이 Number 타입입니다. Number 라는 수 전체를 아우르는 상위 타입이 있으며, 실수를 나타내는 Real 타입, 부동소수를 나타내는 AbstractFloat 타입, 정수를 나타내는 Integer 타입, 부호 있는 정수를 나타내는 Signed 타입, 부호 없는 정수, 즉 0 을 포함한 자연수를 나타내는 Unsigned 타입과 같은 추상 타입이 있습니다.\nJulia 의 모든 타입은 어떤 타입의 하위 타입(subtype) 이며 단 하나의 상위 타입(supertype) 을 계승합니다. 타입의 하위타입에는 갯수 제한이 없습니다. 타입 계층의 최상단에는 Any 타입이 있으며, 모든 타입은 Any 의 하위타입 이던가 Any 의 하위타입의 하위타입 이던가…. Any 의 몇대 자손중의 하나입니다. 심지어 Any 의 상위타입은 Any 입니다. 어떤 타입의 상위 타입을 알기 위해서는 supertype() 함수를 사용 하며 하위 타입들을 알기 위해서는 subtypes() 함수를 사용합니다.\nIn [7]: supertype(UInt8)\nOut[7]: Unsigned\n\nIn [8]: subtypes(Integer)\nOut[8]: 3-element Vector{Any}:\n Bool\n Signed\n Unsigned\n어떤 타입의 상위 타입은 추상적 타입만이 가능하며, 구체적 타입은 어떤 타입의 상위 타입이 될 수 없습니다. 당연히 Any 는 추상적 타입입니다. 그림 그림 1 은 Julia 에서 자체적으로 제공하는 수(number) 에 대한 타입의 계층 구조입니다. 추상적 타입은 좌우 변이 두겹인 사각형, 구체적 타입은 좌우가 둥근 도형으로 표현하였습니다. Irrational 은 \\(\\pi\\) 나 \\(e\\) 같은 특별한 무리수를 위한 타입으로 계산 될 때 적당한 타입의 값으로 변환됩니다.\n\n\n\n\n\n\nflowchart TB\n    Any[[Any]] --- Number[[Number]]\n    Number ---- Real[[Real]]\n    Number --- Complex[[Complex]]\n    Real ------- Integer[[Integer]] \n    Real --- Rational([Rational])\n    Real --- AbstractIrrational[[AbstractIrrational]]\n    Real ----- AbstractFloat[[AbstractFloat]]\n    Integer --- Unsigned[[Unsigned]] & Bool([Bool])\n    Integer ----- Signed[[Signed]]\n    AbstractIrrational --- Irrational[Irrational]\n    AbstractFloat --- Float16([Float16]) & Float32([Float32]) & Float64([Float64])  &  BigFloat([BigFloat])\n    Unsigned --- UInt8([UInt8]) & UInt16([UInt16]) & UInt32([UInt32]) & UInt64([UInt64]) & UInt128([UInt128])\n    Signed --- Int8([Int8]) & Int16([Int16]) & Int32([Int32]) & Int64([Int64])  & Int128([Int128]) & BigInt([BigInt])\n\n\n\n\n그림 1: Type hierarchy of number\n\n\n\n\n\n\n이것을 정리하면 다음과 같습니다.\n\n\n\n\n추상적 타입\n구체적 타입\n\n\n\n\n하위타입 지정\no\nx\n\n\n변수 할당\nx\no\n\n\n\n여기서 Complex 만 추상적 타입으로 구체적인 하위타입이 존재하지 않습니다. 실제로 Julia 에서 복소수는 복합 타입(composite type) 으로 정의됩니다. 여기에 대해서는 복합 타입에서 다루겠습니다.\n\n\n\n\nInt64 나 Float32 와 같이 값이 저장되는데 사용되는 바이트 수가 결정된 구체적 타입을 원시 타입(Primitive type) 이라고 합니다. isprimitivetype() 함수를 통해 특정 타입이 원시 타입인지를 확인할 수 있습니다. Julia 의 모든 기본 타입은 julia 자체 내에서 다음과 같이 정의되었습니다. 저의 경우는 Julia 설치 디렉토리의 /share/julia/base/boot.jl 파일에 정의되었습니다.\nprimitive type Float16 &lt;: AbstractFloat 16 end\nprimitive type Float32 &lt;: AbstractFloat 32 end\nprimitive type Float64 &lt;: AbstractFloat 64 end\n\nprimitive type Bool &lt;: Integer 8 end\nprimitive type Char &lt;: AbstractChar 32 end\n\nprimitive type Int8    &lt;: Signed   8 end\nprimitive type UInt8   &lt;: Unsigned 8 end\nprimitive type Int16   &lt;: Signed   16 end\nprimitive type UInt16  &lt;: Unsigned 16 end\nprimitive type Int32   &lt;: Signed   32 end\nprimitive type UInt32  &lt;: Unsigned 32 end\nprimitive type Int64   &lt;: Signed   64 end\nprimitive type UInt64  &lt;: Unsigned 64 end\nprimitive type Int128  &lt;: Signed   128 end\nprimitive type UInt128 &lt;: Unsigned 128 end\n첫번째 primitive type Float16 &lt;: AbstractFloat 16 end 는 Float16 타입은 AbstractFloat 타입의 하위타입으로 16비트, 즉 2바이트를 차지하는 타입이라는 의미입니다. 앞서 말했듯이 구체적 타입은 상위 타입이 될 수 없으므로 원시 타입은 어떤 추상 타입의 하위타입이 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "타입의 계층구조와 메서드 디스패치"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/08_type_hierarchy.html#sec-method_multiple_dispatch",
    "href": "src/introduction_to_julia/08_type_hierarchy.html#sec-method_multiple_dispatch",
    "title": "타입의 계층구조와 메서드 디스패치",
    "section": "2 메서드 다중 디스패치(Multiple dispatch)",
    "text": "2 메서드 다중 디스패치(Multiple dispatch)\n\n함수와 메서드\n각각의 컴퓨터 프로그래밍 언어나 프로그래밍 패러다임마다 함수와 메서드의 의미와 관계가 조금씩 다릅니다. 보통 프로그래밍에서 함수란 어떤 일련의 동작들을 모아 하나의 기능으로 만든 것을 말합니다. Julia 기본 문서의 Methods 를 보면 Julia 에서 보는 함수와 메서드는 이와는 약간 다릅니다. Julia 에서의 함수는 일종의 기능의 추상화입니다. 예를 들어 두 수를 더하는 함수를 생각해 봅시다. 먼저 원시 타입에 대한 더하기를 생각해보면, 원시 타입이란 특정한 비트의 배열이기 때문에 각 원시 타입마다 내부적으로 더하기를 다르게 구현해야 합니다. 하지만 모두 + 라는 연산자에 대해 정의됩니다. 이렇게 추상적으로 정의된 함수에 대해 각 타입마다 구체적으로 구현된 코드를 julia 에서는 메서드라고 부릅니다. 함수와 메서드의 의미와 관계는 언어마다 다르기 때문에 julia 에서 사용되는 용어가 다른 용어에서는 다른 의미 일 수 있습니다.\n다음의 함수 정의를 봅시다.\nIn [1]: function myfunc1(a, b)\n            return a*b\n        end\nOut[1]: myfunc1 (generic function with 1 method)\n함수를 정의할 때 특별히 인자에 제한조건을 두지 않았습니다. 이제 인자의 타입을 바꿔 가며 함수를 실행시켜봅시다.\nIn [2]: myfunc1(1, 3)\nOut[2]: 3\n\nIn [3]: myfunc1(2.2, 3.3)\nOut[3]: 7.26\n\nIn [4]: myfunc1(\"a\", \"bc\")\nOut[4]: \"abc\"\nJulia 는 함수의 정의를 기억했다가 처음 실행할 때 주어진 인자의 타입에 맞추어 컴파일하며 한 번 컴파일된 함수는 그 인자 타입으로 다음번 실행 할 때는 컴파일 없이 빠르게 실행 할 수 있습니다다. 이렇게 어떤 소스코드를 실행 전에 컴파일 하는 것이 아니라 실행하는 가운데 컴파일 하는것을 JIT(just-in-time) 컴파일 이라고 합니다\nmyfunc1 함수를 선언 할 때 인자의 타입에 대해 제한을 가하지 않았다는 것은 a, b 모두 Any 타입으로 지정되었다는 것입니다. 만약 a, b 모두 정수일 때, 즉 Integer 의 하위타입일 때는 곱하기가 아니라 더하기를 수행하기를 원한다고 해 봅시다.\nIn [5]: function myfunc1(a::Integer, b::Integer)\n        return a+b\n        end\nOut[5]: myfunc1 (generic function with 2 methods)\n\nIn [6]: myfunc1(1, 2)\nOut[6]: 3\n\nIn [7]: myfunc1(1.0, 2.0)\nOut[7]: 2.0\n\nIn [8]: myfunc1(1.0, 2)\nOut[8]: 2.0\n인자가 둘 다 정수일 때는 더하기가, 둘 중 하나라도 정수가 아니라면 곱하기가 수행됩니다. 만약 a 가 문자열이고 b 가 정수라면 a 를 b 의 절대값만큼 반복하도록 합시다.\nIn [9]: function myfunc1(a::String, b::Integer) \n        return a^abs(b)\n        end\nOut[9]: myfunc1 (generic function with 3 methods)\n\nIn [10]: myfunc1(\"aa\", -3)\nOut[10]: \"aaaaaa\"\n이렇게 우리는 인자 타입에 대해 myfunc1 이라는 함수 이름으로 3개의 메서드를 생성하였습니다.\n\n\n시그너쳐와 methods 함수\n메서드의 시그너쳐(signature) 는 함수이름과 인자, 그리고 인자의 타입을 포함합니다. 하나의 함수의 다양한 메서드는 시그너쳐로 구분되며, 한 함수의 시그너쳐는 method 함수로 확인 할 수 있습니다. methods(myfunc1) 는 함수 myfunc1 에 대한 모든 메서드의 시그너쳐를 반환합니다.\nIn [12]: methods(myfunc1)\nOut[12]: # 3 methods for generic function \"myfunc1\" from Main:\n [1] myfunc1(a::Integer, b::Integer)\n     @ REPL[5]:1\n [2] myfunc1(a::String, b::Integer)\n     @ REPL[9]:1\n [3] myfunc1(a, b)\n     @ REPL[1]:1\n여기서 볼 수 있듯이 myfunc1 함수에는 세가지의 메서드가 구현되었으며, 특정 타입에 대해 어떤 메서드가 실행될 지 파악 할 수 있습니다.\n\n함수 뿐만 아니라 연산자도 여러개의 메서드를 가질 수 있습니다. methods(+) 를 통해 + 연산자가 아주 많이 정의되었다는 것을 확인해 보시기 바랍니다. 이렇게 같은 함수나 연산자의 이름으로 인자의 타입에 따라 기능을 정하는 것을 메서드 디스패치, 혹은 다중 디스패치라고 합니다. 여러분은 앞으로 새로운 타입을 만드는 방법을 알게 될텐데 이미 존재하는 +, - 등의 연산자나 println, length 등의 함수를 다중 디스패치를 통해 타입에 맞게 사용 할 수 있습니다.\n\n\n\n\n모호한 메써드\n\\(a^b\\) 를 리턴하는 mypow 함수를 다음과 같이 구현했다고 해 봅시다.\nIn [1]: function mypow(a, b)\n        return a^b\n        end\nOut[1]: mypow (generic function with 1 method)\n\nIn [2]: function mypow(a::Number, b)\n        return a^b\n        end\nOut[2]: mypow (generic function with 2 methods)\n\nIn [3]: function mypow(a, b::Number)\n        return a^b\n        end\nOut[3]: mypow (generic function with 3 methods)\n\nIn [4]: methods(mypow)\nOut[4]: # 3 methods for generic function \"mypow\" from Main:\n [1] mypow(a::Number, b)\n     @ REPL[2]:1\n [2] mypow(a, b::Number)\n     @ REPL[3]:1\n [3] mypow(a, b)\n     @ REPL[1]:1\n3가지의 메서드가 구현되었습니다. 여기에 mypow(2, 3) 는 어떤 값을 리턴할까요? 컴파일러 입장에서는 두번째와 세번째 메써드가 동등한 권리를 갖고 있기 때문에 불확실 성이 존재하며 컴파일러는 에러를 발생시킵니다.\nIn [5]: mypow(2, 3)\nERROR: MethodError: mypow(::Int64, ::Int64) is ambiguous.\n\n\n\n타입 매개변수를 갖는 메서드\n메서드를 정의할 때 구체적, 추상적인 타입을 직접 표현하는 것이 아니라 타입 매개변수를 이용하여 정의 할 수도 있습니다. Julia 공식 문서의 예를 가져와 보겠습니다. 함수 인자 두개에 대해 그 타입이 같으면 true, 다르면 false 를 반환하는 함수를 작성해 봅시다. typeof 함수를 이용 할 수도 있겠지만 메서드를 이용하여 깔끔하게 정의 할 수도 있습니다. 일단 두개의 타입이 같으면 true 를 반환하는 함수를 작성합니다.\nIn [1]: same_type(x::T, y::T) where {T} = true\nOut[1]: same_type (generic function with 1 method)\n여기서 T 는 타입 매개변수 입니다. 함수의 인자 표현에서 x::T, y::T 는 x 와 y 가 그것이 무엇이든 같은 타입이어야 한다는 의미입니다. 타입이 다르면 적용할 메서드가 없다는 에러가 발생합니다.\nIn [2]: same_type(1, 2.0)\nERROR: MethodError: no method matching same_type(::Int64, ::Float64)\n타입이 다를 때는 false 를 반환하게 하려면\nIn [3]: same_type(x,y) = false\nOut[3]: same_type (generic function with 2 methods)\n와 같이만 하면 됩니다.\nIn [4]: same_type(1, 2.0)\nOut[4]: false\n이것이 작동하는 원리는 쉽습니다. 함수를 호출하면 메서드의 시그너쳐를 확인하여 실제 실행될 메서드를 찾는데 두 인자가 같은 타입일 경우 same_type(x::T, y::T) where {T} = true 메서드가 호출되며, 다른 타입일 경우 same_type(x,y) = false 메서드가 호출됩니다.\n\n타입 매개변수에 재한을 걸 수 있습니다. 예를 들어 다음을 봅시다.\nIn [10]: same_integer_type(x::T, y::T) where {T&lt;:Integer} = true\nOut[10]: same_integer_type (generic function with 1 method)\n\nIn [11]: same_integer_type(x, y) = false\nOut[11]: same_integer_type (generic function with 2 methods)\n\nIn [12]: same_integer_type(3, 4)\nOut[12]: true\n\nIn [13]: same_integer_type(UInt8(3), 4)\nOut[13]: false\n\nIn [14]: same_integer_type(3, 4.0)\nOut[14]: false\n두 변수 x, y 가 같은 종류의 정수 타입이 아니면 false 를 리턴합니다. 즉 다른 종류의 정수타입에도 false 를 반환합니다.\n\n\n함수 안에서의 타입매개변수\n함수에 타입 매개변수를 쓰는 또하나의 중요한 경우는 타입매개변수를 함수 안에서 사용하는 것입니다. 우리는 기본타입의 경우 타입 이름이 함수로 사용 될 수 있다는 것을 앞에서 보았습니다. 예를 들어 Float64(3) 에서 Float64 는 Int64 타입의 3 을 Float64 타입으로 변환시키는 함수로 사용되었습니다. 다음 함수를 봅시다.\nIn [1]: function myconvert(a::T, b) where {T}\n        return T(b)\n        end\nOut[1]: myconvert (generic function with 1 method)\n\nIn [2]: myconvert(2.0, 4)\nOut[2]: 4.0\n이 myconvert 함수는 두개의 인자를 받아 두번째 인자를 첫번째 인자의 타입으로 변환시켜 반환하는 함수입니다. 이 때 함수 시그니쳐의 타입 매개변수 T 가 함수의 몸체에서 사용되었습니다.\n\n\n\n아무것도 아닌 함수\n여러 메서드를 가지는 함수를 작성할 때 일단은 이름을 갖고 코드가 에러를 발생시키지는 않지만 실행은 안되는 함수가 필요할 때가 있습니다. 실용적으로 필요한 것이 아니라 문서화 작업 혹은 앞으로 작성할 함수라고 흔적을 남기기 위해 사용되기도 합니다.\nfunction great_function_with_many_methods end\ngreat_function_with_many_methods 은 함수로서 이름공간 포함되지만 아무 일도 할 수 없습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "타입의 계층구조와 메서드 디스패치"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/11_interfaces.html",
    "href": "src/introduction_to_julia/11_interfaces.html",
    "title": "반복자 인터페이스",
    "section": "",
    "text": "반복자(Iterator) 는 컨테이너 타입으로 포함하는 성분을 처음부터 끝까지 하나 하나 접근 할 수 있는 자료구조를 말하며, Julia 에서 제공하는 컨테이너 타입은 대부분 iterator 입니다. 배열이나 튜플과 같이 순서가 정해져 있을 수도 있고 사전과 같이 순서가 임의적일 수는 있지만 어쨌든 하나하나 접근 할 수 있어야 합니다. 다음과 같은 자료형은 정의상 4개의 값을 저장할 수 있는 컨테이너이지만 반복자는 아닙니다.\nJulia 에서 어떤 타입이 반복자라는 것은 그 타입에 대해 아래의 메서드가 정의되어 있다는 것을 말합니다. 아래에서 state 는 컨테이너의 아이템과 1대1 대응되는 어떤 값이며 배열의 경우는 인덱스입니다.\n반복자에 대해 추가로 정의 할 수 있는 메서드에는 다음과 같은 것이 있습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "반복자 인터페이스"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/11_interfaces.html#인덱스로-접근가능한-반복자",
    "href": "src/introduction_to_julia/11_interfaces.html#인덱스로-접근가능한-반복자",
    "title": "반복자 인터페이스",
    "section": "1 인덱스로 접근가능한 반복자",
    "text": "1 인덱스로 접근가능한 반복자\n이제 유용한 반복자를 하나 만들어 봅시다. 신호처리에서 많이 사용하는 베열가운데 로그스케일로 변화하는 배열이 있습니다. matlab 에서의 logspace 함수, python 에서의 numpy.logspace 함수로 logspace(a, b, n, base=10) 는 base 의 a 승부터 base 의 b 승까지 로그스케일로 변하는 배열입니다. Julia 에서는 base .^ range(a,b,n) 과 그 결과가 같습니다.(정확히 말하면 끝값을 포함 하느냐 하지 않느냐에 따라 다릅니다. Matlab 과 julia 는 포함하며 python 은 포함하지 않습니다.)\n이 반복자를 LogSpacingRange 라고 합시다. 우리의 목표는 logspace 함수로 LogSpacingRange 객체 생성시켜 배열처럼 사용 할 수 있게 하는 것입니다. 배열이나 튜플처럼 인덱스로 접근 가능한 객체를 만들기 위해서는 위해서는 다음의 네가지 메서드를 정의해 줘야 합니다.\n\n\n\n메서드\n설명\n\n\n\n\ngetindex(X, i)\nX[i], 인덱스를 이용한 접근\n\n\nsetindex!(X, v, i)\nX[i] = v, 인덱스를 이용한 할당\n\n\nfirstindex(X)\nX[begin] 로 접근 가능한 첫번째 성분\n\n\nlastindex(X)\nX[end] 로 접근 가능한 마지막 성분\n\n\n\nLogSpacingRange 객체는 immutable 인 것이 좋을 것 같습니다. 이 경우 LogSpacingRange 타입에 대한 setindex 메서드를 작성하지 않으면 됩니다. 나머지 함수에 대해서는 적절하게 만들어 줍니다. 전체 코드는 다음과 같습니다.\nstruct LogSpacingRange{T}\n    start::T\n    stop::T\n    base::T\n    size::Int64\n\n    function LogSpacingRange(start::Real, stop::Real, size::Int64, base::Real)\n        @assert base &gt; 1\n        @assert size ≥ 1\n        ftype = promote_type(typeof(start), typeof(stop))\n        if ~(ftype &lt;: AbstractFloat)\n            ftype = Float64\n        end\n\n        return new{ftype}(start, stop, base, size)\n    end\nend\n\nBase.size(p::LogSpacingRange) = (p.size, )\nBase.length(p::LogSpacingRange) = p.size\nBase.iterate(p::LogSpacingRange, state=1) = state &gt; p.size ? nothing : (p[state], state+1)\nBase.eltype(p::LogSpacingRange{T}) where {T} = T\nBase.IteratorSize(::LogSpacingRange{T}) where {T} = Base.HasLength()\nBase.IteratorEltype(::LogSpacingRange{T}) where {T} = Base.HasEltype()\n\nfunction Base.getindex(p::LogSpacingRange, i::Int64) \n    @assert 0 &lt; i ≤ p.size\n    if p.size == 1\n        return p.start\n    else \n        r = p.start + (p.stop-p.start)/(p.size-1)*(i-1)\n        return (p.base)^r\n    end\nend\n\nfunction logspace(a, b, n::Integer=10, base::Real=10)\n    return LogSpacingRange(a, b, n, base)\nend\n\nlogspace(a, b, n=10, base=10) 함수를 통해 LogSpacingRange 타입의 반복자를 생성 할 수 있습니다.\nfor v in logspace(1, 5, 3, 10)\n    @show v\nend \n를 통해 다음과 같은 결과를 얻습니다.\nv = 10.0\nv = 1000.0\nv = 100000.0\n또한 getindex 함수를 정의하여 배열처럼 사용 할 수 있습니다.\nIn [6]: a=logspace(1, 10, 10)\nOut[6]: NAJ.LogSpacingRange{Float64}(1.0, 10.0, 10.0, 10)\n\nIn [7]: a[3]\nOut[7]: 1000.0\n물론 10.0.^range(1, 5, length=3) 이 같은 기능을 하는 배열을 만들어 줍니다. LogSpacingRange 의 장점은 숫자 세개만으로 큰 크기의 배열의 기능을 수행 할 수 있다는 것입니다. 물론 collect() 함수를 통해 배열로 변경하는 경우 그 장점은 사라지지만 말입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "반복자 인터페이스"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/11_interfaces.html#배열처럼-동작하는-반복자",
    "href": "src/introduction_to_julia/11_interfaces.html#배열처럼-동작하는-반복자",
    "title": "반복자 인터페이스",
    "section": "2 배열처럼 동작하는 반복자",
    "text": "2 배열처럼 동작하는 반복자\n앞서의 LogSpacingRange 는 1차원 배열, 혹은 튜플처럼 동작했습니다. 그렇다면 배열, 특히 다차원 배열과 같이 동작하기 위해서는 다음의 메서드가 정의되어야 합니다.\n\n\n\n메서드\n설명\n\n\n\n\nsize(A)\nA 의 차원 튜플\n\n\ngetindex(A, i::Int)\n선형 인덱스로의 접근\n\n\ngetindex(A, I::Vararg{Int, N})\n데카르트 인덱스로의 접근\n\n\n\n\n다차원 배열처럼 동작하는 반복자를 만들어 봅시다. Julia 에서 많이 사용되는 패키지 가운데 OffsetArrays.jl 이 있습니다. OffsetArrays 는 인덱스가 1 이 아닌 임의의 정수부터 시작하는 배열을 만들 수 있습니다. 그것은 Base.getindex 나 Base.setindex! 등을 다시 정의하여 동작하게 합니다. OffsetArrays 는 상당히 진지한, 그러니까 심각한 작업에도 사용할 수 있도록 세심하게 만들어진 타입이지만 우리는 여기어 이와 비슷하게 작동하는, 그리고 교육 목적의 타입을 만들어 봅시다. 이름은 ShiftedIndexedArray 로 합니다.\nstruct ShiftedIndexedArray{T, N, AA &lt;: AbstractArray{T, N}} \n    A::AA\n    offsets::NTuple{N, Int}\n    \n    function ShiftedIndexedArray{T, N, AA}(arr::AA, offsets::NTuple{N, Int}) where {T, N, AA&lt;:AbstractArray{T, N}}\n        return new{T, N, AA}(arr, offsets)\n    end\nend\n\nfunction ShiftedIndexedArray(arr::AA, offsets::NTuple{N, Int}) where {N, AA&lt;:AbstractArray}\n    return ShiftedIndexedArray{eltype(arr), ndims(arr), typeof(arr)}(arr, offsets)\nend\n\nconst ShiftedIndexedVector{T, AA&lt;: AbstractVector{T}} = ShiftedIndexedArray{T, 1, AA}\nconst ShiftedIndexedMarix{T, AA&lt;:AbstractMatrix{T}} = ShiftedIndexedArray{T, 2, AA}\n\nfunction Base.getindex(S::ShiftedIndexedArray{T, N, AA}, I...) where {T, N, AA}\n    oind = _original_cartesian_index(S, I)\n    if checkbounds(Bool, S.A, oind...) \n        return getindex(S.A, oind...)\n    else\n        throw(BoundsError(S, I...))\n    end\nend\n\nfunction Base.getindex(S::ShiftedIndexedArray{T, N, AA}, i::Int64) where {T, N, AA}\n    oind = _original_linear_index(S, i)\n    if checkbounds(Bool, S.A, oind)\n        return getindex(S.A, oind)\n    else \n        throw(BoundsError(S, i))\n    end\nend\n\nfunction Base.setindex!(S::ShiftedIndexedArray{T, N, AA}, v, I... ) where {T, N, AA}\n    oind = _original_cartesian_index(S, I)\n    if checkbounds(Bool, S.A, oind...) == false\n        throw(BoundsError(S, I...))\n    else\n        return setindex!(S.A, v, oind...)\n    end\nend\n\nfunction Base.setindex!(S::ShiftedIndexedArray{T, N, AA}, v, i::Int ) where {T, N, AA}\n    oind = _original_liear_index(S, i)\n    if checkbounds(Bool, S.A, oind) == false\n        throw(BoundsError(S, i))\n    else\n        return setindex!(S.A, v, oind)\n    end\nend\n\n\nBase.similar(S::ShiftedIndexedArray) = ShiftedIndexedArray(Base.similar(S.A), S.offsets)\nBase.sizeof(S::ShiftedIndexedArray) = sizeof(S.A)\n\nBase.iterate(S::ShiftedIndexedArray, state=1) = iterate(S.A, state)\nBase.IndexStyle(S::ShiftedIndexedArray) = IndexStyle(S.A)\nShiftedIndexedArray 는 두개의 필드를 갖습니다. 하나는 배열을 저장하는 .A 필드이고, 하나는 각 축에 대한 시작 인덱스를 지정하는 .offsets 입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "반복자 인터페이스"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html",
    "href": "src/introduction_to_julia/09_composite_types.html",
    "title": "복합 타입",
    "section": "",
    "text": "복합 타입(composite type) 은 필드(field)라고 불리는 하위 변수를 갖는 타입이며, 필드는 정수나 실수 타입 뿐만 아니라 함수 타입이나 다른 복합 타입이 될 수 있습니다. 아주 간단한 복합 타입으로 2차원 평면 상의 점에 대한 복합타입을 다음과 같이 정의 할 수 있습니다.\nstruct Point\n    x\n    y\nend\n복합타입의 정의는 struct 로부터 시작하여 end 로 끝납니다. 위에서 Point 는 구체적 타입의 이름이 되며, x, y 라는 두개의 필드를 가질 수 있습니다.\nIn [2]: isconcretetype(Point)\nOut[2]: true\nPoint 타입의 변수는 p1 = Point(1, 2) 와 같이 생성할 수 있으며 각 필드는 p1.x, p1.y 와 같이 접근합니다.\nIn [3]: p1 = Point(1, 2)\nOut[3]: Point(1, 2)\n\nIn [4]: println(\"Point p1.x=$(p1.x), p1.y=$(p1.y)\")\nPoint p1.x=1, p1.y=2\n\nIn [5]: typeof(p1) # `Point` is a name of type\nOut[5]: Point\n복합 타입 인스턴스는 특별히 따로 정하지 않았다면 타입이름을 함수처럼 사용하여 생성합니다. 인자는 타입 정의에서 나열된 필드순으로 입력하면 됩니다. 즉 p1=Point(1, 2) 는 x 필드는 1, y 필드는 2 의 값을 갖는 Point 객체 인스턴스를 생성하라는 뜻입니다. 이렇게 타입 인스턴스를 만드는 함수를 생성자(constructor) 라고 합니다. 생성자는 별도로 정의할수도 있지만 위에서처럼 타입 이름을 함수로 사용하여 인자로 필드 값을 나열하는 생성자를 기본 생성자(default constructor) 라고 합니다.\n\n\n\n\n복합타입을 정의 할 때 아래와 같이 타입 매개 변수를 사용하여 정의 할 수 있습니다.\nstruct OneValue{T}\n    val::T\nend\nIn [8]: x=OneValue(3)\nOut[8]: OneValue{Int64}(3)\n\nIn [9]: y=OneValue{Float64}(4)\nOut[9]: OneValue{Float64}(4.0)\n\nIn [10]: typeof(x) == typeof(y)\nOut[10]: false\n\nIn [11]: typeof(x) == typeof(OneValue{Int64}(5))\nOut[11]: true\nstruct OneValue{T} 에서 OneValue 는 타입 이름이며 {T} 에서 {T} 가 타입에 대한 매개변수입니다. 타입에 대한 매개변수는 타입 이름일 수도 있으며 정수, 실수, Symbol 이나 Bool 과 같은 bit 타입의 값이 올 수 있습니다. 일단 매개변수로 받으면 필드의 정의나 생성자의 정의에서 사용 할 수 있습니다. 이 때 x 와 y 의 타입 즉 OneValue{Int64} 와 OneValue{Float64} 는 다른 타입입니다.\nIn [8] 을 봅시다. 매개변수 T 는 필드 val 의 타입으로 정의되었습니다. x=OneValue(3) 처럼 매개변수를 사용하지 않고 인스턴스를 만들면 val 의 타입이 자연스럽게 T 가 됩니다. In [9] 의 경우처럼 y=OneValue{Float64}(4) 와 같이 매개변수를 명시적으로 지정했을 경우에는 필드 val 의 타입이 T==Float64 로 강제로 변환됩니다.\n이렇게 타입 매개변수로 타입을 만들면 그 매개변수를 이후에도 사용 할 수 있습니다. 아래의 isIntType(o::OneValue{T}) 함수는 OneValue{T} 의 T 가 Integer 의 하위타입인지를 확인하는 함수입니다. 물론 o.val 의 타입을 확인할 수도 있지만 아래의 것이 훨씬 깔끔합니다.\nfunction isIntType(o::OneValue{T}) where T\n    if T&lt;:Integer\n        return true\n    else\n        return false\n    end\nend\nOut[13]: isIntType (generic function with 1 method)\n\nIn [14]: isIntType(x)\nOut[14]: true\n\nIn [15]: isIntType(y)\nOut[15]: false\n\n\n\n\n이제 우선 우리에게 아마도 익숙할 복소수 타입을 봅시다. Julia 는 복소수를 다루기 위한 Complex{T} 타입을 내장하고 있습니다. Complex{T} 는 필드로 실수부와 허수부를 가지며 다음과 같이 정의됩니다.\nstruct Complex{T&lt;:Real} &lt;: Number\n    re::T\n    im::T\nend\n\nComplex(x::Real, y::Real) = Complex(promote(x,y)...)\nComplex(x::Real) = Complex(x, zero(x))\n\n&lt;:Number 를 통해 Complex 객체는 Number 의 하위타입으로 정의됩니다.\nComplex{T&lt;:Real} 은 매개변수 T 를 통해 re 와 im 필드의 타입을 제한합니다. T&lt;:Real 이며 re::T, im::T 이므로 두 필드 는 Real 의 동일한 하위타입이어야 합니다. 두 개 이상의 타입이 필요할 경우는 {T1&lt;:Real, T2&lt;:Integer} 와 같이 { } 안에 , 로 분리하여 나열하면 됩니다.\n생성자가 타입 정의 외부에 존재합니다. 이를 외부생성자라고 합니다.\n첫번째 생성자는 x 와 y 가 Real 타입의 하위 타입일 때 타입을 일치시키기 위한 생성자입니다. promote(x, y) 는 x 와 y 변수의 타입을 두 변수를 공통적으로 표현할 수 있는 타입으로 변환시켜 튜플로 반환합니다. 이렇게 다른 타입의 둘 이상의 값을 같은 타입이 되도록 변환하는 것을 julia 에서는 promotion 이라고 합니다. promote(2, 3.0) == (2.0, 3.0) 입니다. 그런데 Complex(promote(2, 3.0)) 은 Complex(2.0, 3.0) 이 아니라 Complex((2.0, 3.0)) 으로 튜플 인자 하나만 주어지며, 따라서 에러가 발생합니다. Complex(promote(2, 3.0)...) 는 promote(2, 3.0) 의 결과로 주어지는 튜플을 풀어서 함수의 인자로 넣도록 합니다. 즉, Complex(promote(2, 3.0)...) 은 결과적으로 Complex(2.0, 3.0) 입니다. 함수를 실행시킬때 인자에서의 사용법 을 참고하시기 바랍니다.\n두번째 생성자는 인자가 하나만 주어졌을 때 im 필드를 인자 re 필드와 같은 타입의 0 으로 간주하여 생성하도록 하는 생성자입니다.\n\nComplex{T&lt;:Real} 은 다음과 같이 사용 할 수 있습니다.\nIn [1]: com1 = Complex{Float32}(3.3, 2.3) #Float32 타입의 필드를 갖는 복소수\nOut[1]: 3.3f0 + 2.3f0im\n\nIn [2]: com2 = Complex(3.3, 2.3) # 3.3, 2.3 이 Float64 이므로 타입의 필드를 갖는 복소수\nOut[2]: 3.3 + 2.3im\n\nIn [3]: com3 = 3.3 + 2.3im # 복소수를 선언하는 두번째 방법\nOut[3]: 3.3 + 2.3im\n\nIn [4]: com2 == com3 # 둘은 같다\nOut[4]: true\ntrue\n\n복합타입 변수의 필드에 접근하기 위해서는 . 를 사용합니다.\nIn [6]: c1 = Complex{Float64}(2.0, 3.0)\nOut[6]: 2.0 + 3.0im\n\nIn [7]: c1.re\nOut[7]: 2.0\n\nIn [8]: c1.im\nOut[8]: 3.0\n\nIn [9]: c1.im = 4.0\nERROR: setfield!: immutable struct of type Complex cannot be changed\n\n복합타입의 경우는 기본적으로 immutable 입니다. 즉 필드의 값을 직접적으로 바꿀 수 없으며 In [9] 에서와 같이 직접적으로 변경하고자 하면 에러가 발생합니다. 복합타입의 필드의 값을 바꿀 수 있는 복합타입은 mutable 이라고 하며 뒤에 변경할 수 있는 복합 타입 에서 다루겠습니다.\n\n\n\n\n복합 타입 선언 내부에서 정의된 생성자를 내부생성자 (inner constructor) 라고 하며 반대로 앞서의 Complex{T&lt;:Real} 처럼 생성자가 복합 타입 선언 밖에서 정의된 생성자를 외부 생성자 (outer constructor) 라고 합니다. 내부생성자에는 new 함수를 사용 할 수 있는데 new 함수는 생성자를 찾지 않고 즉각적으로 멤버에 접근하여 복합 타입을 만들게 해 줍니다. new 함수는 외부생성자에서는 사용 할 수 없습니다.\n코드 유지보수의 관점에서는 아무래도 외부생성자가 편리합니다. 그러나 내부생성자만이 할 수 있는 일은 기본생성자를 변경하는 것입니다. 다음의 예를 봅시다.\nstruct A\n    m::Int64\n    function A(x, y)\n        return new(Int64(x+y))\n    end\nend\n\nstruct B\n    m::Int64\nend\n\nfunction B(x, y)\n    return B(Int64(x+y))\nend\nA 와 B 는 모두 m 이라는 필드 하나만 가지고 있습니다. 이 때 B(3) 은 기본생성자가 호출되어 B.m==3 인 객체가 만들어지지만 A(3) 은 기본생성자가 교체되었으므로 에러가 발생합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "복합 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html#복합-타입",
    "href": "src/introduction_to_julia/09_composite_types.html#복합-타입",
    "title": "복합 타입",
    "section": "",
    "text": "복합 타입(composite type) 은 필드(field)라고 불리는 하위 변수를 갖는 타입이며, 필드는 정수나 실수 타입 뿐만 아니라 함수 타입이나 다른 복합 타입이 될 수 있습니다. 아주 간단한 복합 타입으로 2차원 평면 상의 점에 대한 복합타입을 다음과 같이 정의 할 수 있습니다.\nstruct Point\n    x\n    y\nend\n복합타입의 정의는 struct 로부터 시작하여 end 로 끝납니다. 위에서 Point 는 구체적 타입의 이름이 되며, x, y 라는 두개의 필드를 가질 수 있습니다.\nIn [2]: isconcretetype(Point)\nOut[2]: true\nPoint 타입의 변수는 p1 = Point(1, 2) 와 같이 생성할 수 있으며 각 필드는 p1.x, p1.y 와 같이 접근합니다.\nIn [3]: p1 = Point(1, 2)\nOut[3]: Point(1, 2)\n\nIn [4]: println(\"Point p1.x=$(p1.x), p1.y=$(p1.y)\")\nPoint p1.x=1, p1.y=2\n\nIn [5]: typeof(p1) # `Point` is a name of type\nOut[5]: Point\n복합 타입 인스턴스는 특별히 따로 정하지 않았다면 타입이름을 함수처럼 사용하여 생성합니다. 인자는 타입 정의에서 나열된 필드순으로 입력하면 됩니다. 즉 p1=Point(1, 2) 는 x 필드는 1, y 필드는 2 의 값을 갖는 Point 객체 인스턴스를 생성하라는 뜻입니다. 이렇게 타입 인스턴스를 만드는 함수를 생성자(constructor) 라고 합니다. 생성자는 별도로 정의할수도 있지만 위에서처럼 타입 이름을 함수로 사용하여 인자로 필드 값을 나열하는 생성자를 기본 생성자(default constructor) 라고 합니다.\n\n\n\n\n복합타입을 정의 할 때 아래와 같이 타입 매개 변수를 사용하여 정의 할 수 있습니다.\nstruct OneValue{T}\n    val::T\nend\nIn [8]: x=OneValue(3)\nOut[8]: OneValue{Int64}(3)\n\nIn [9]: y=OneValue{Float64}(4)\nOut[9]: OneValue{Float64}(4.0)\n\nIn [10]: typeof(x) == typeof(y)\nOut[10]: false\n\nIn [11]: typeof(x) == typeof(OneValue{Int64}(5))\nOut[11]: true\nstruct OneValue{T} 에서 OneValue 는 타입 이름이며 {T} 에서 {T} 가 타입에 대한 매개변수입니다. 타입에 대한 매개변수는 타입 이름일 수도 있으며 정수, 실수, Symbol 이나 Bool 과 같은 bit 타입의 값이 올 수 있습니다. 일단 매개변수로 받으면 필드의 정의나 생성자의 정의에서 사용 할 수 있습니다. 이 때 x 와 y 의 타입 즉 OneValue{Int64} 와 OneValue{Float64} 는 다른 타입입니다.\nIn [8] 을 봅시다. 매개변수 T 는 필드 val 의 타입으로 정의되었습니다. x=OneValue(3) 처럼 매개변수를 사용하지 않고 인스턴스를 만들면 val 의 타입이 자연스럽게 T 가 됩니다. In [9] 의 경우처럼 y=OneValue{Float64}(4) 와 같이 매개변수를 명시적으로 지정했을 경우에는 필드 val 의 타입이 T==Float64 로 강제로 변환됩니다.\n이렇게 타입 매개변수로 타입을 만들면 그 매개변수를 이후에도 사용 할 수 있습니다. 아래의 isIntType(o::OneValue{T}) 함수는 OneValue{T} 의 T 가 Integer 의 하위타입인지를 확인하는 함수입니다. 물론 o.val 의 타입을 확인할 수도 있지만 아래의 것이 훨씬 깔끔합니다.\nfunction isIntType(o::OneValue{T}) where T\n    if T&lt;:Integer\n        return true\n    else\n        return false\n    end\nend\nOut[13]: isIntType (generic function with 1 method)\n\nIn [14]: isIntType(x)\nOut[14]: true\n\nIn [15]: isIntType(y)\nOut[15]: false\n\n\n\n\n이제 우선 우리에게 아마도 익숙할 복소수 타입을 봅시다. Julia 는 복소수를 다루기 위한 Complex{T} 타입을 내장하고 있습니다. Complex{T} 는 필드로 실수부와 허수부를 가지며 다음과 같이 정의됩니다.\nstruct Complex{T&lt;:Real} &lt;: Number\n    re::T\n    im::T\nend\n\nComplex(x::Real, y::Real) = Complex(promote(x,y)...)\nComplex(x::Real) = Complex(x, zero(x))\n\n&lt;:Number 를 통해 Complex 객체는 Number 의 하위타입으로 정의됩니다.\nComplex{T&lt;:Real} 은 매개변수 T 를 통해 re 와 im 필드의 타입을 제한합니다. T&lt;:Real 이며 re::T, im::T 이므로 두 필드 는 Real 의 동일한 하위타입이어야 합니다. 두 개 이상의 타입이 필요할 경우는 {T1&lt;:Real, T2&lt;:Integer} 와 같이 { } 안에 , 로 분리하여 나열하면 됩니다.\n생성자가 타입 정의 외부에 존재합니다. 이를 외부생성자라고 합니다.\n첫번째 생성자는 x 와 y 가 Real 타입의 하위 타입일 때 타입을 일치시키기 위한 생성자입니다. promote(x, y) 는 x 와 y 변수의 타입을 두 변수를 공통적으로 표현할 수 있는 타입으로 변환시켜 튜플로 반환합니다. 이렇게 다른 타입의 둘 이상의 값을 같은 타입이 되도록 변환하는 것을 julia 에서는 promotion 이라고 합니다. promote(2, 3.0) == (2.0, 3.0) 입니다. 그런데 Complex(promote(2, 3.0)) 은 Complex(2.0, 3.0) 이 아니라 Complex((2.0, 3.0)) 으로 튜플 인자 하나만 주어지며, 따라서 에러가 발생합니다. Complex(promote(2, 3.0)...) 는 promote(2, 3.0) 의 결과로 주어지는 튜플을 풀어서 함수의 인자로 넣도록 합니다. 즉, Complex(promote(2, 3.0)...) 은 결과적으로 Complex(2.0, 3.0) 입니다. 함수를 실행시킬때 인자에서의 사용법 을 참고하시기 바랍니다.\n두번째 생성자는 인자가 하나만 주어졌을 때 im 필드를 인자 re 필드와 같은 타입의 0 으로 간주하여 생성하도록 하는 생성자입니다.\n\nComplex{T&lt;:Real} 은 다음과 같이 사용 할 수 있습니다.\nIn [1]: com1 = Complex{Float32}(3.3, 2.3) #Float32 타입의 필드를 갖는 복소수\nOut[1]: 3.3f0 + 2.3f0im\n\nIn [2]: com2 = Complex(3.3, 2.3) # 3.3, 2.3 이 Float64 이므로 타입의 필드를 갖는 복소수\nOut[2]: 3.3 + 2.3im\n\nIn [3]: com3 = 3.3 + 2.3im # 복소수를 선언하는 두번째 방법\nOut[3]: 3.3 + 2.3im\n\nIn [4]: com2 == com3 # 둘은 같다\nOut[4]: true\ntrue\n\n복합타입 변수의 필드에 접근하기 위해서는 . 를 사용합니다.\nIn [6]: c1 = Complex{Float64}(2.0, 3.0)\nOut[6]: 2.0 + 3.0im\n\nIn [7]: c1.re\nOut[7]: 2.0\n\nIn [8]: c1.im\nOut[8]: 3.0\n\nIn [9]: c1.im = 4.0\nERROR: setfield!: immutable struct of type Complex cannot be changed\n\n복합타입의 경우는 기본적으로 immutable 입니다. 즉 필드의 값을 직접적으로 바꿀 수 없으며 In [9] 에서와 같이 직접적으로 변경하고자 하면 에러가 발생합니다. 복합타입의 필드의 값을 바꿀 수 있는 복합타입은 mutable 이라고 하며 뒤에 변경할 수 있는 복합 타입 에서 다루겠습니다.\n\n\n\n\n복합 타입 선언 내부에서 정의된 생성자를 내부생성자 (inner constructor) 라고 하며 반대로 앞서의 Complex{T&lt;:Real} 처럼 생성자가 복합 타입 선언 밖에서 정의된 생성자를 외부 생성자 (outer constructor) 라고 합니다. 내부생성자에는 new 함수를 사용 할 수 있는데 new 함수는 생성자를 찾지 않고 즉각적으로 멤버에 접근하여 복합 타입을 만들게 해 줍니다. new 함수는 외부생성자에서는 사용 할 수 없습니다.\n코드 유지보수의 관점에서는 아무래도 외부생성자가 편리합니다. 그러나 내부생성자만이 할 수 있는 일은 기본생성자를 변경하는 것입니다. 다음의 예를 봅시다.\nstruct A\n    m::Int64\n    function A(x, y)\n        return new(Int64(x+y))\n    end\nend\n\nstruct B\n    m::Int64\nend\n\nfunction B(x, y)\n    return B(Int64(x+y))\nend\nA 와 B 는 모두 m 이라는 필드 하나만 가지고 있습니다. 이 때 B(3) 은 기본생성자가 호출되어 B.m==3 인 객체가 만들어지지만 A(3) 은 기본생성자가 교체되었으므로 에러가 발생합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "복합 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html#다양한-복합-타입",
    "href": "src/introduction_to_julia/09_composite_types.html#다양한-복합-타입",
    "title": "복합 타입",
    "section": "2 다양한 복합 타입",
    "text": "2 다양한 복합 타입\n\n변경할 수 있는 복합 타입 (mutable struct)\n앞서 언급했듯이 복합타입은 기본적으로 immutable 입니다. 이 말은 한 번 생성된 복합타입의 필드의 값을 바꿀 수 없다는 뜻입니다. 필드의 값을 바꿀 수 있는 복합타입은 struct 앞에 mutable 키워드를 넣습니다.\nmutable struct mycomplex2{T&lt;:Real} &lt;: Number\n    re::T\n    im::T\nend\n\nmycomplex2(x::Real, y::Real) = mycomplex2(promote(x, y)...)\nmycomplex2(x::Real) = mycomplex2(x, zero(x))\n위의 mycomplext2 타입을 생성하고 필드의 값을 바꿀 수 있습니다.\nIn [4]: c2 = mycomplex2(2.0, 3.0)\nOut[4]: mycomplex2{Float64}(2.0, 3.0)\n\nIn [5]: c2.im\nOut[5]: 3.0\n\nIn [6]: c2.im = -3\nOut[6]: -3\n\nIn [7]: c2\nOut[7]: mycomplex2{Float64}(2.0, -3.0)\n\n\n\n싱글톤 타입\n어떤 타입의 인스턴스가 단 하나만 존재할 수 있을 때 이를 싱글톤(singleton) 객체라고 합니다. 예를 들어 Complex(3.0, 4.0) 과 Complex(1.0, 2.0) 은 모두 Complex{Float64} 타입의 서로 다른 인스턴스입니다. 그러나 싱글톤 타입이라면 모든 타입 인스턴스가 같아야 합니다. Julia 에서 싱글톤 타입은 필드가 없는 복합타입입니다.\nstruct mysingleton end\n와 같이 정의합니다. 이 때 모든 mysingleton 타입의 인스턴스는 동일합니다.\nIn [1]: struct mysingleton end;\n\nIn [2]: a, b = mysingleton(), mysingleton();\n\nIn [3]: a===b\nOut[3]: true\n타입 매개변수를 가지는 싱글턴 타입도 존재합니다.\nstruct mysingleton1{T} end\n와 같이 정의합니다. 이 때 T 가 다르면 다른 인스턴스이며, T 가 같으면 같은 인스턴스입니다.\nIn [5]: struct mysingleton1{T} end\n\nIn [6]: c, d = mysingleton1{Int64}, mysingleton1{Int64}\nOut[6]: (mysingleton1{Int64}, mysingleton1{Int64})\n\nIn [7]: c === d\nOut[7]: true\n\nIn [8]: c, d = mysingleton1{Int64}, mysingleton1{Float64}\nOut[8]: (mysingleton1{Int64}, mysingleton1{Float64})\n\nIn [9]: c === d\nOut[9]: false\n\nIn [10]: c == d\nOut[10]: false\n\n당연히 어떤 추상 타입의 하위 타입으로서의 싱글턴 타입도 정할 수 있습니다.\nabstract type AbsSingletonType end\n\nstruct abstype1 &lt;: AbsSingletonType end\n\nJulia 에서 싱글턴 타입은 아주 많이 사용됩니다. 우선 아주 많이 사용하는 nothing 은 Nothing 타입의 싱글턴 객체입니다. 또한 julia 에서의 함수는 추상타입 Function 의 하위타입인 싱글턴 객체입니다.\nIn [15]: typeof(sin)\nOut[15]: typeof(sin) (singleton type of function sin, subtype of Function)\n당신이 당신의 코드 내에서 어떤 유일한 것을 원한다면 그것을 싱글턴 객체로 만들 수 있습니다. 또 하나 중요한것은 싱글턴 객체는 저장공간을 차지하지 않습니다.\n\n\n\n매개변수를 갖는 추상 타입\n우리는 추상적 타입 에 대해 이미 알아보았습니다. 매개변수를 갖는 추상적 타입도 존재합니다. 다음과 같이 선언합니다.\nabstract type PAType{T} end     # parametric abstract type\n\nstruct PCType{T} &lt;: PAType{T}   # parametric concrete type\n    field::T\nend\n이렇게 되면 PCT{T} 는 같은 T 에 대해서만 PAType{T} 의 하위 타입 이 됩니다.\nIn [3]: PCType{Float32} &lt;: PAType{Float32}\nOut[3]: true\n\nIn [4]: PCType{Float32} &lt;: PAType{Int64}\nOut[4]: false\n\n이제 다음과 같은 타입 구조를 봅시다.\nabstract type AA end\n\nabstract type AB{T&lt;:Real} &lt;: AA end\n\nstruct AC{T} &lt;: AB{T}\n    f::T\nend\nAC{T} 의 상위 타입이 AB{T&lt;:Real} 이므로 T 는 Real 의 하위 타입이어야만 합니다. 따라서 AC{String} 로 타입을 정할 수 없습니다. 또한 메서드를 정의할 때 AA 타입으로 인자를 정하면 모든 AC{T} 타입에 대해 사용 할 수 있습니다.\nIn [5]: qad(x::AA) = x.f+3\nOut[5]: qad (generic function with 1 method)\n\nIn [6]: qad(AC{Float32}(4))\nOut[6]: 7.0f0",
    "crumbs": [
      "Julia 언어의 기초",
      "복합 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/09_composite_types.html#연습-모듈러-산술",
    "href": "src/introduction_to_julia/09_composite_types.html#연습-모듈러-산술",
    "title": "복합 타입",
    "section": "3 연습 : 모듈러 산술",
    "text": "3 연습 : 모듈러 산술\n이제 지금까지 했던 것을 가지고 뭔가 좀 고차원적인 일을 해 봅시다. 정수를 다루는 수학의 분야를 정수론이라고 하며 여기서 모듈러 산술이라는 것을 다룹니다. 8 을 5로 나누면 나머지가 3이며 33 도 5로 나누면 나머지가 3입니다. 이것을 다음과 같이 표현합니다.\n\\[\n8 \\equiv 33 \\, (\\textrm{mod}\\, 5)\n\\]\n이것은 8 과 33 은 5로 나눈 나머지가 같다는 뜻입니다.두 정수 \\(a,\\,b\\) 와 자연수 \\(n\\) 에 대해\n\\[\na \\equiv b \\, (\\textrm{mod}\\, n)\n\\]\n은 \\(a\\) 와 \\(b\\) 는 \\(n\\) 으로 나누었을 때의 나머지와 같다는 입니다. 재미있는 것은 이 관계를 이용하여 사칙연산을 할 수 있다는 것입니다. \\(a \\equiv b \\, (\\textrm{mod}\\, n)\\), \\(c \\equiv d\\, (\\textrm{mod}\\, n)\\) 일 때 다음이 성립합니다.\n  (\\(1\\)) \\((a+c) \\equiv (b+d)\\, (\\textrm{mod}\\, n)\\).\n  (\\(2\\)) \\((a-c) \\equiv (b-d)\\, (\\textrm{mod}\\, n)\\).\n  (\\(3\\)) \\(ac \\equiv bd\\, (\\textrm{mod}\\, n)\\).\n  (\\(4\\)) \\(n\\) 이 소수이면 \\(ax \\equiv 1\\, (\\textrm{mod}\\, n)\\) 인 자연수 \\(x\\) 가 존재한다.\n\\(n\\) 이 소수가 아니더라라도 \\(a\\) 와 \\(n\\) 의 최대공약수가 \\(1\\) 이라면, 즉 \\(\\gcd(a,\\, n)=1\\) 이면 \\(ax\\equiv 1\\, (\\textrm{mod}\\, n)\\) 인 \\(x\\) 가 존재하지만 모든 수에 대해 존재하는 것은 아닙니다. \\(n\\) 이 소수일 경우에는 \\(n\\) 보다 작은 모든 자연수 \\(a\\) 에 대해 \\(\\gcd (a,n)=1\\) 이므로 (\\(4\\)) 가 성립합니다. 이 때 \\(x = a^{-1}\\) 이라고 하고 나누기를 \\(b/a := ba^{-1}\\) 로 정의 할 수 있습니다. 그렇다면 소수인 \\(n\\) 에 대해 \\(a^{-1}\\) 값은 어떻게 계산할까요? 그리고 주어진 \\(a\\) 에 대해 \\(ax \\equiv 1 \\, (\\text{mod}\\, n)\\) 인 \\(x\\) 는 오직 하나일까요? 일단 뒤의 문제부터 답하자면 소수 \\(n\\) 에 대해 \\(a^{n-1} \\equiv 1\\, (\\text{mod}\\, n)\\) 이라는 것이 알려져 있습니다\\(^1\\). 따라서 \\(a^{-1} \\equiv a^{n-2}\\, (\\textrm{mod}\\, n)\\) 이다. 또한 \\(ax\\equiv 1\\, (\\textrm{mod}\\, n),\\, ay\\equiv 1\\, (\\textrm{mod}\\, n)\\) 이면 \\(n\\) 이 소수일 때 \\(x \\equiv y\\, (\\textrm{mod}\\, n)\\) 입니다.\\(^1\\) 이를 페르마의 소정리(Fermat’s little theorem) 이라고 합니다.\n이렇게 어떤 자연수(\\(n\\)) 에 대한 나머지로 사칙연산을 수행하는 것을 모듈러 산술(modular arithematic) 이라고 합니다. \\(n\\) 이 소수가 아니라면 덧셈 뺄셈, 곱셈만 정의되며 나눗셈은 정의 할 수 없지만 \\(n\\) 이 소수라면 모두 정의 할 수 있습니다.\n이제 이 모듈러 산술에 대한 자료형과 함수를 만들어 봅시다. \\(n\\) 이 소수인 경우와 소수가 아닌 경우를 구분해야 하기 때문에 소수를 판별하는 함수를 작성해야 합니다. \\(n\\) 이 매우 큰 수가 아니라면 가장 간단하게 사용할 수 있는 알고리즘은 \\(2\\) 부터 \\(\\sqrt{n}\\) 보다 크지 않은 모든 정수에 대해 \\(n\\) 과의 최대공약수가 1 인지를 확인하는 것입니다.\nconst max_modular = 1_000_000_000\n\nfunction isprime(v::Integer)\n    @assert 1&lt;v&lt;max_modular \n    result = true\n    for x in 2:floor(Int64, √v)\n        if v % x == 0\n            result = false\n            break\n        end\n    end\n    return result\nend\nmax_modular 는 \\(n\\) 값이 될 수 있는 최대값으로 정합니다. 너무 큰 수에 대해 계산하는 것을 방지하기 위한 것 말고는 큰 의미가 없습니다.\n우선 최상위의 추상 타입 (코드에서는 AbstractMod{T, N}) 과 \\(n\\) 이 소수일 때, 그리고 소수가 아닐 때를 구별하여 타입을 만듭니다. 각각 PrimeMod 와 Mod 입니다. 값은 여러 정수의 타입을 가질수 있어야 하기 때문에 타입 매개변수 T 를 사용합니다. 더불어 \\(n\\) 값도 복합타입의 매개변수 N 으로 넣습니다.\nabstract type AbstractMod{T, N} end \n\nconst max_modular = 1_000_000_000\n\nfunction isprime(v::Integer)\n    @assert 1&lt;v&lt;max_modular \n    result = true\n    for x in 2:floor(Int64, √v)\n        if v % x == 0\n            result = false\n            break\n        end\n    end\n    return result\nend\n\nstruct PrimeMod{T, N} &lt;: AbstractMod{T, N}\n    value::T\n    \n    function PrimeMod{T, N}(x::Integer) where {T&lt;:Integer, N}\n        @assert N &gt; 1 \"Modulos must be larger than 1\"\n        @assert isprime(N) \"Must be a prime number\"\n        r = (x ≥ 0) ? x%N : (x%N)+N \n        return new{T, N}(r)\n    end\nend\n\nstruct Mod{T, N} &lt;: AbstractMod{T, N}\n    value::T\n\n    function Mod{T, N}(x::Integer) where {T&lt;:Integer, N}\n        @assert N &gt; 1 \"Modulos must be larger than 1\"\n        x = T(x)\n        r = (x ≥ 0) ? x%N : (x%N)+N \n        if isprime(N)\n            return PrimeMod{T, N}(r)\n        else \n            return new{T, N}(r)\n        end\n    end\nend\n\nMod{N}(x::Integer) where {N} = Mod{Int64, N}(x)\nPrimeMod{N}(x::Integer) where {N} = PrimeMod{Int64, N}(x)\n\n\nfunction Base.show(io::IO, x::AbstractMod{T, N}) where {T, N} \n    println(io, \"$(x.value)_$N\")\nend\n\nBase.zero(a::AbstractMod{T, N}) where {T, N}  = Mod{T, N}(0)\nBase.one(a::AbstractMod{T, N}) where {T, N}  = Mod{T, N}(1)\nBase.:-(a::AbstractMod{T, N}) where {T, N}  = Mod{T, N}(-a.value)\nBase.:isequal(a::AbstractMod{T, N}, b::AbstractMod{T, N}) where {T, N} = (a.value == b.value)\n\nfunction Base.:+(a::AbstractMod{T, N}, b::AbstractMod{T, N}) where {T, N} \n    return Mod{T, N}(a.value+b.value)\nend\n\nfunction Base.:-(a::AbstractMod{T, N}, b::AbstractMod{T, N}) where {T, N}  \n    return Mod{T, N}(a.value-b.value)\nend\n\nfunction Base.:*(a::AbstractMod{T, N}, b::AbstractMod{T, N}) where {T, N}  \n    return Mod{T, N}(a.value*b.value)\nend\n\nfunction Base.:inv(a::PrimeMod{T, N}) where {T, N} \n    return Mod{T, N}(a.value^(N-2))\nend\n\nfunction Base.:^(a::AbstractMod{T, N}, n::Integer) where {T, N} \n     return Mod{T, N}(a.value^n)\nend\n\nfunction Base.:/(a::PrimeMod{T, N}, b::PrimeMod{T, N}) where {T, N} \n    if b == zero(b)\n        throw(DivideError)\n    end\n    return a*inv(b)\nend\nMod 와 PrimeMod 둘 다 에게 적용되는 메서드는 AbstractMod 타입을 인자로 받으며 PrimeMod 에만 적용되는 나머지나 곱셈의 역원(Base.:inv) 함수의 경우 인자를 PrimeMod 타입을 받도록 합니다.\n이것은 NAJ.jl 에 포함되어 있으며 다음과 같이 사용합니다.\nIn [2]: using NAJ\n\nIn [3]: a=Mod{13}(5)\nOut[3]: 5_13\n\n\nIn [4]: b=-a\nOut[4]: 8_13\n\nIn [5]: a+b\nOut[5]: 0_13\n\nIn [6]: a*b\nOut[6]: 1_13\n\n\nIn [7]: a^5\nOut[7]: 5_13\n\nIn [8]: a^-2\nOut[8]: 12_13",
    "crumbs": [
      "Julia 언어의 기초",
      "복합 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html",
    "href": "src/introduction_to_julia/06_arrays.html",
    "title": "배열",
    "section": "",
    "text": "Julia 는 0 차원 배열부터 임의의 차원(dimension)의 배열을 지원합니다. 1차원 배열은 Vector, 2차원 배열은 Matrix 라는 별명(alias)을 가지고 있습니다. 0 차원 배열은 성분을 하나 가지고 있는 배열입니다. 각 차원을 축(axis) 이라고 부릅니다. 배열의 형태(shape) 는 각 차원마다 몇개의 성분을 가지는지를 말합니다. 예를 들어 배열의 형태가 (3, 4, 5) 라면 3차원 배열이고 첫번째 차원으로는 3개, 두번째 차원으로는 4개, 세번째 차원으로는 5개의 성분을 가져야 합니다.\n1 차원 배열과 2차원 배열은 다음과 같이 선언됩니다.\nIn [1]: arr1 = [1.0, 2.0, 3.0, 4.0]\nOut[1]: 4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\nIn [2]: arr2 = [4.0; 5; 6]\nOut[2]: 3-element Vector{Float64}:\n 4.0\n 5.0\n 6.0\n\nIn [3]: arr3 = [1 2 3 4]\nOut[3]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [4]: arr4=[3 2;4 5]\nOut[4]: 2×2 Matrix{Int64}:\n 3  2\n 4  5\narr1 과 같이 [ ] 안에 콤마로 분리된 경우와 arr2 와 같이 ; 로 분리된 경우는 1 차원 벡터입니다. Out[1] 의 Vector{Float64} 는 성분이 Float64 타입인 1차원 배열이라는 의미입니다. 앞서 말했듯이 Vector 는 1차원 배열과 같은 의미이며 (alias 라고 하며 본질적으로 같고, 부르는 이름이 다르다는 의미입니다.) Matrix 는 2차원 배열의 alias 입니다. arr3 와 같이 공백으로 분리되는 경우는 2차원 배열입니다. 즉 [1 2] 와 [1, 2] 는 다릅니다. arr4 를 보면 알겠지만 2차원 배열은 행 순서대로 나열하되 같은 행에서는 공백으로 열을 구분하며, 행의 구분은 ; 를 사용합니다. 배열의 각 성분에 접근할 때는 arr2[3] 이나 arr3[1, 1] 과 같이 접근합니다. 이 때 배열의 위치를 나타내는 숫자 혹은 숫자들을 인덱스라고 부릅니다. 인덱스에 대해서는 잠시후 배열의 인덱스 에서 좀 더 자세히 다룹니다.\n; 를 여러 개 겹쳐서 다차원 배열을 선언하는데 사용 할 수 있습니다.\n\nIn [5]: arr3d = [1; 2;; 3; 4;; 5; 6;;; 7; 8;; 9; 10;; 11; 12]\nOut[5]: 2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\nIn [6]: arr5 = [1;;2;;3;;4]\nOut[6]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [7]: arr6 = [1;;;2;;;3;;;4]\nOut[7]: 1×1×4 Array{Int64, 3}:\n[:, :, 1] =\n 1\n\n[:, :, 2] =\n 2\n\n[:, :, 3] =\n 3\n\n[:, :, 4] =\n 4\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\nIn [8]: ndims(arr5)\nOut[8]: 2\n\nIn [9]: size(arr6)\nOut[9]: (1, 1, 4)\n\nIn [10]: sizeof(arr3d)\nOut[10]: 96\n\nIn [11]: length(arr3d)\nOut[11]: 12\nIn [8] 에서 ndims() 함수는 배열의 차원을 반환합니다. 배열의 형태는 size() 함수로 알 수 있습니다. sizeof() 함수는 배열의 크기를 바이트(bytes) 로 나타냅니다. arr3d 는 Int64 타입의 성분으로 이루어져 있으며, Int64 는 8바이트 이고 모두 12 개의 성분을 가지므로 96 바이트를 차지합니다. 일반적인 컨테이너와 같이 length() 함수를 통해 배열에 속하는 모든 성분의 갯수를 알 수 있습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-array",
    "href": "src/introduction_to_julia/06_arrays.html#sec-array",
    "title": "배열",
    "section": "",
    "text": "Julia 는 0 차원 배열부터 임의의 차원(dimension)의 배열을 지원합니다. 1차원 배열은 Vector, 2차원 배열은 Matrix 라는 별명(alias)을 가지고 있습니다. 0 차원 배열은 성분을 하나 가지고 있는 배열입니다. 각 차원을 축(axis) 이라고 부릅니다. 배열의 형태(shape) 는 각 차원마다 몇개의 성분을 가지는지를 말합니다. 예를 들어 배열의 형태가 (3, 4, 5) 라면 3차원 배열이고 첫번째 차원으로는 3개, 두번째 차원으로는 4개, 세번째 차원으로는 5개의 성분을 가져야 합니다.\n1 차원 배열과 2차원 배열은 다음과 같이 선언됩니다.\nIn [1]: arr1 = [1.0, 2.0, 3.0, 4.0]\nOut[1]: 4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\nIn [2]: arr2 = [4.0; 5; 6]\nOut[2]: 3-element Vector{Float64}:\n 4.0\n 5.0\n 6.0\n\nIn [3]: arr3 = [1 2 3 4]\nOut[3]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [4]: arr4=[3 2;4 5]\nOut[4]: 2×2 Matrix{Int64}:\n 3  2\n 4  5\narr1 과 같이 [ ] 안에 콤마로 분리된 경우와 arr2 와 같이 ; 로 분리된 경우는 1 차원 벡터입니다. Out[1] 의 Vector{Float64} 는 성분이 Float64 타입인 1차원 배열이라는 의미입니다. 앞서 말했듯이 Vector 는 1차원 배열과 같은 의미이며 (alias 라고 하며 본질적으로 같고, 부르는 이름이 다르다는 의미입니다.) Matrix 는 2차원 배열의 alias 입니다. arr3 와 같이 공백으로 분리되는 경우는 2차원 배열입니다. 즉 [1 2] 와 [1, 2] 는 다릅니다. arr4 를 보면 알겠지만 2차원 배열은 행 순서대로 나열하되 같은 행에서는 공백으로 열을 구분하며, 행의 구분은 ; 를 사용합니다. 배열의 각 성분에 접근할 때는 arr2[3] 이나 arr3[1, 1] 과 같이 접근합니다. 이 때 배열의 위치를 나타내는 숫자 혹은 숫자들을 인덱스라고 부릅니다. 인덱스에 대해서는 잠시후 배열의 인덱스 에서 좀 더 자세히 다룹니다.\n; 를 여러 개 겹쳐서 다차원 배열을 선언하는데 사용 할 수 있습니다.\n\nIn [5]: arr3d = [1; 2;; 3; 4;; 5; 6;;; 7; 8;; 9; 10;; 11; 12]\nOut[5]: 2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\nIn [6]: arr5 = [1;;2;;3;;4]\nOut[6]: 1×4 Matrix{Int64}:\n 1  2  3  4\n\nIn [7]: arr6 = [1;;;2;;;3;;;4]\nOut[7]: 1×1×4 Array{Int64, 3}:\n[:, :, 1] =\n 1\n\n[:, :, 2] =\n 2\n\n[:, :, 3] =\n 3\n\n[:, :, 4] =\n 4\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\nIn [8]: ndims(arr5)\nOut[8]: 2\n\nIn [9]: size(arr6)\nOut[9]: (1, 1, 4)\n\nIn [10]: sizeof(arr3d)\nOut[10]: 96\n\nIn [11]: length(arr3d)\nOut[11]: 12\nIn [8] 에서 ndims() 함수는 배열의 차원을 반환합니다. 배열의 형태는 size() 함수로 알 수 있습니다. sizeof() 함수는 배열의 크기를 바이트(bytes) 로 나타냅니다. arr3d 는 Int64 타입의 성분으로 이루어져 있으며, Int64 는 8바이트 이고 모두 12 개의 성분을 가지므로 96 바이트를 차지합니다. 일반적인 컨테이너와 같이 length() 함수를 통해 배열에 속하는 모든 성분의 갯수를 알 수 있습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-array_initialization",
    "href": "src/introduction_to_julia/06_arrays.html#sec-array_initialization",
    "title": "배열",
    "section": "2 배열의 생성",
    "text": "2 배열의 생성\n앞에서와 같이 각각 배열의 성분을 입력 할 수도 있겠지만, 배열이 클 경우는 거의 불가능한 방법입니다. Julia 는 배열을 생성하고 초기화 할 수 있는 다양한 방법을 제공합니다.\n\n\nArray comprehension 을 이용한 배열의 생성\n[ ] 안에 루프를 사용하여 배열을 만들 수 있으며 이렇게 배열을 만드는 것을 Array comprehension 이라고 합니다. 1 부터 10 까지의 정수의 제곱을 순서대로 포함하는 배열은 아래와 같이 만들 수 있습니다.\nac1 = [x^2 for x in 1:10]\n다차원 배열도 다음과 같이 만들 수 있습니다.\nIn [6]: [x+y for x = 1:3, y = 1:2]\nOut[6]: 3×2 Matrix{Int64}:\n 2  3\n 3  4\n 4  5\n[ ] 안에 조건을 넣을 수도 있습니다. 예를 들어 앞의 2차원 배열에서 x+y&gt;3 인 경우에는 0 으로 채우고 싶다면,\nIn [7]: [if x+y &gt; 3 0 else x+y end for x = 1:3, y = 1:2]\nOut[7]: 3×2 Matrix{Int64}:\n 2  3\n 3  0\n 0  0\n와 같이 쓸 수 있습니다. 3항 연산자를 사용하여 다음과 같이 쓸 수도 있습니다.\nIn [8]: [(x+y &gt; 3) ? 0 : x+y  for x = 1:3, y = 1:2]\nOut[8]: 3×2 Matrix{Int64}:\n 2  3\n 3  0\n 0  0\n그런데 if 문이 뒤에 가면 전혀 다른 결과가 발생합니다.\nIn [9]: [x for x in 1:10 if x&gt;4]\nOut[9]: 6-element Vector{Int64}:\n  5\n  6\n  7\n  8\n  9\n 10\n\nIn [10]: [x+y for x = 1:3, y = 1:2 if x+y&gt;3]\nOut[10]: 3-element Vector{Int64}:\n 4\n 4\n 5\nIn[7] 과 같이 for 가 if 뒤에 있으면, 중첩된 for 의 갯수에 따라 다차원 배열을 만든 후 연산을 수행합니다. 반대로 In[9] 나 In [10] 과 같이 if 가 for 의 뒤에 있다면 1차원 배열에 대해 if 문이 일종의 filter 함수 역할을 수행하며 이 filter 에 대해 true 인 경우 1차원 배열에 삽입합니다.\n\n간단한 규칙으로 배열을 생성하는 경우 Array comprehension 을 사용하는 것이 for 를 이용하는 것보다 빠른 경우가 많습니다. 예를 들어 \\(A_{ij} = i^{j-1}\\) 의 규칙으로 생성되는 배열을 두가지 방법으로 만들어 봅시다.\n# for loop\nV1 = zeros(Int64,(10, 10))\nfor i ∈ 1:10, j ∈ 1:10\n    V1[i, j] = i^(j-1)\nend\n\n# Array comprehension\nV2 = [i^(j-1) for i ∈ 1:10, j ∈ 1:10]\n두 결과는 같은 결과를 냅니다. BenchmarkTools 패키지의 @btime 매크로로 수행 시간을 측정해보면\nusing BenchmarkTools\n\nV1 = zeros(Int64,(10, 10))\n@btime begin\nfor i ∈ 1:10, j ∈ 1:10\n    V1[i, j] = i^(j-1)\nend\nend\n\n@btime V2 = [i^(j-1) for i ∈ 1:10, j ∈ 1:10]\n두번째 경우가 첫번째 경우보다 6배 이상 빠릅니다. 하지만 배열 작성 규칙이 복잡해지고 배열의 크기가 커질수록 역전되며 array comprehenshion 에서는 복잡한 과정을 넣기 힘들기 때문에 오히려 for 문을 사용하는 것이 좋습니다.\n\n\n\n특정 값으로만 이루어진 배열의 생성\nzeros(), ones(), fill() 함수가 대표적으로 배열을 초기화 하는 함수입니다. zeros(T, dims) 는 T 의 타입에서의 0 값(zero(T))으로 채워진 dims 차원의 배열을 반환합니다. ones(T, dims) 은 one(T) 로 채워진 배열의 형상이dims 인 배열을 반환하며 fill(v, dims) 는 값 v 로 채워진 dims 형상의 배열을 반환합니다. T 가 주어지지 않을 경우는 Float64 타입으로 정해지며 dims 는 1차원 배열의 경우는 정수, 다차원 배열의 경우는 튜플, 혹은 연속적인 정수입니다.\nIn [1]: zeros(Float32, (2, 3))\nOut[1]: 2×3 Matrix{Float32}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\nIn [2]: ones(UInt8, (2,2,2)) # == ones(UInt8, 2,2,2)\nOut[2]: 2×2×2 Array{UInt8, 3}:\n[:, :, 1] =\n 0x01  0x01\n 0x01  0x01\n\n[:, :, 2] =\n 0x01  0x01\n 0x01  0x01\n\nIn [3]: fill(2.0, 1, 3)  # == fill(2.0, (1, 3))\nOut[3]: 1×3 Matrix{Float64}:\n 2.0  2.0  2.0\n\nundef 키워드를 사용하여 타입과 크기만을 지정하고 값을 정하지 않고 초기화 할 수도 있습니다.\nA1 = Vector{Int8}(undef, 4) # 1차원 배열 초기화\nA2 = Matrix{Float64}(undef,10,10) # 2차원 배열 초기화\nA3 = Array{Float32}(undef, 2, 2, 2) #3차원 배열 초기화\n이 경우 배열의 성분은 임의의 값이 정해집니다. 이렇게 임의의 값이 채워진 배열을 초기화 하는 이유는 이렇게 배열을 만드는 것이 특정 값으로 채워서 초기화 하는 것보다 훨씬 빠르기 때문입니다. 제 컴퓨터에서는 Float64 타입의 \\(10000 \\times 10000\\) 배열을 만드는데 zeros 함수를 사용하는 것보다 undef 를 사용하는 것이 50000 배 정도 빨랐습니다. 만약 배열의 모든 성분이 이후의 계산과정에서 채워지는것이 확실하다면 굳이 특정 값으로 초기화 시키지 않고 undef 를 사용하여 배열을 생성하는 것이 좋습니다.\n\n\n\n이미 존재하는 배열과 같은 크기의 배열 생성\n배열의 타입과 크기를 지정하지 않고 이미 존재하는 배열을 이용하여 초기화 할 수 있습니다. 예를 들어 어떤 배열 A 와 같은 크기와 타입을 갖지만 모든 성분이 0 인 배열을 만들 때 zero(A) 를 사용 할 수 있습니다. (zeros(A) 가 아닙니다) A 가 정사각 행렬일 경우 one(A) 는 A 와 같은 크기와 타입을 갖는 항등행렬을 리턴합니다.\nIn [1]: A=[1.0 -2.0 3.0;4.0 -3.0 -1.0]\nOut[1]: 2×3 Matrix{Float64}:\n 1.0  -2.0   3.0\n 4.0  -3.0  -1.0\n\nIn [2]: zero(A)\nOut[2]: 2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\nIn [3]: B=[1 2;3 4]\nOut[3]: 2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nIn [4]: one(B)\nOut[4]: 2×2 Matrix{Int64}:\n 1  0\n 0  1\n\n배열을 초기화 할 때 undef 키워드를 사용하는 것처럼 일단 주어진 배열과 같은 크기와 타입을 갖는, 하지만 그 안에 채워지는 값을 보장하지 않는 배열을 similar() 함수를 통해 만들 수 있습니다. similar() 를 사용하는 이유도 속도 때문이며, undef 키워드로 배열을 만드는 것과 같이, 이후 연산으로 그 값이 다 채워진다면 충분히 사용할 만 합니다.\nIn [8]: C=[1.0 3.0;2.0 -1.0]\nOut[8]: 2×2 Matrix{Float64}:\n 1.0   3.0\n 2.0  -1.0\n\nIn [9]: similar(C)\nOut[9]: 2×2 Matrix{Float64}:\n 0.0           2.39288e-314\n 2.39288e-314  0.0\n\n\n\n배열을 확장하여 생성\n2차원 배열을 생성할 때 [1 3;2 4] 와 같이 열 구별은 공백을, 행 구별은 ; 을 이용하여 생성하는 방법을 이미 알아 보았습니다. 이 방법은 스칼라 뿐만 아니라 배열을 사용 할 수도 있는데 예를 들면\nIn [1]: A=[1 2;3 4];B=[5 ; 6]; C = [7 8]; D=[9]\nOut[1]: 1-element Vector{Int64}:\n 9\n\nIn [2]: A=[1 2;3 4];B=[5 ; 6]; C = [7 8]; D=[9]\nOut[2]: 1-element Vector{Int64}:\n 9\n\nIn [3]: F1=[A B]\nOut[3]: 2×3 Matrix{Int64}:\n 1  2  5\n 3  4  6\n\nIn [4]: F2=[A;C]\nOut[4]: 3×2 Matrix{Int64}:\n 1  2\n 3  4\n 7  8\n\nIn [5]: F3=[A B;C D]\nOut[5]: 3×3 Matrix{Int64}:\n 1  2  5\n 3  4  6\n 7  8  9\n와 같습니다. 즉 부분 행렬을 모아 더 큰 행렬을 만들 때 행 방향으로의 확장은 공백으로, 열 방향으로의 확장은 ; 를 이용합니다. 이렇게 작은 배열을 모아 큰 배열을 만드는 것을 concatenation 이라고 합니다. Concatenation 을 이용할 때는 각 부분행렬의 행과 열의 갯수가 서로 잘 맞도록 해줘야 합니다. [A B; C D] 형태로 concatenation 을 할 때는 A 와 B 의 행의 갯수가 같아야 하며 A 와 C 의 열의 갯수가 같아야 하고 B 의 열의 갯수와 D 의 열의 갯수도 같아야 하며 C 와 D 의 행의 갯수가 같아야 합니다. 복잡하게 설명했지만 결국 크기가 다른 타일을 빈 틈 없이 맞추는 경우로 생각할 수 있겠습니다.\nConcatenation 을 해 주는 함수로는 cat, vcat, hcat, hvcat, hvncat 이 있습니다.\nIn [1]: A=[1 2;3 4];B=[5 6;7 8];C=[-1 -2; -3 -4];\n\nIn [2]: vcat(A, B)\nOut[2]: 4×2 Matrix{Int64}:\n 1  2\n 3  4\n 5  6\n 7  8\n\nIn [3]: hcat(A, B, C)\nOut[3]: 2×6 Matrix{Int64}:\n 1  2  5  6  -1  -2\n 3  4  7  8  -3  -4\n\nIn [4]: hvcat((2, 3), [1 2;3 4], [-1;-2], [5; 6], [7;8], [9;10])\nOut[4]: 4×3 Matrix{Int64}:\n 1  2  -1\n 3  4  -2\n 5  7   9\n 6  8  10\n\nIn [5]: [[1 2;3 4] [-1;-2] ; [5; 6] [7;8] [9;10]]\nOut[5]: 4×3 Matrix{Int64}:\n 1  2  -1\n 3  4  -2\n 5  7   9\n 6  8  10\n\nIn [6]: hvcat(2, [1 2;3 4], [5;6])\nOut[6]: 2×3 Matrix{Int64}:\n 1  2  5\n 3  4  6\nvcat(A, B) 는 [A; B] 와 같으며 hcat(A, B) 는 [A B] 와 같습니다. 즉 vcat 은 배열을 수직으로 위에서 아래로 쌓으며, hcat 은 왼쪽에서 오른쪽으로 쌓습니다. vcat 이나 hcat 의 인자로는 다수의 배열 혹은 숫자가 올 수 있습니다. hvcat 은 인자로서 처음에 정수 혹은 정수의 터플이 오며, 그 다음부터 다수의 배열이 위치합니다. In [4] 의 hcat 함수의 첫번째 인자 (2, 3) 는 첫번째 블록열은 2개의 행렬로, 두번째 블록열은 그 다음 세개의 행렬로 이루어진다는 것을 의미합니다. 즉 [1 2;3 4], [-1;-2] 가 첫번째 열을 이루고, [5; 6], [7;8], [9;10] 가 두번째 열을 이룹니다. 따라서 In [5] 와 같습니다. hvcat 의 첫번째 인자로 정수만 있을 때는 첫번째 블록열로만 이루어집니다.\ncat 함수는 좀 많이 복잡합니다. 우리는 여기서는 1차원과 2차원 배열에 대해서만 다루겠습니다. 우선 cat 함수의 시그너쳐는 다음과 같습니다.\ncat(A...; dims)\ndims 는 자연수, 혹은 자연수의 터플이 올 수 있습니다. Julia 1.8 부터는 Val{x} 타입도 가능하지만 여기서는 다루지 않겠습니다. 자연수가 올 때는 그 차원 방향으로 확장합니다.\nIn [1]: cat(1, [2;3], dims=1)\nOut[1]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\nIn [2]: cat([1;2], [3;4], dims=2)\nOut[2]: 2×2 Matrix{Int64}:\n 1  3\n 2  4\ndims 에 자연수의 컨테이너가 올 때는 마치 블록 대각 행렬을 만드는 것 처럼 확장됩니다. 다음을 봅시다.\nIn [3]: cat(1, [2;3], [4 5; 6 7], dims=(1, 2))\nOut[3]: 5×4 Matrix{Int64}:\n 1  0  0  0\n 0  2  0  0\n 0  3  0  0\n 0  0  4  5\n 0  0  6  7\ndims=(1, 2) 이므로 첫번째 차원(수직) 과 두번째 차원 (수평) 으로 확장되며 주어진 배열 (스칼라는 0차원 배열로 간주됩니다) 대각으로 놓게 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-index_of_array",
    "href": "src/introduction_to_julia/06_arrays.html#sec-index_of_array",
    "title": "배열",
    "section": "3 배열의 인덱스",
    "text": "3 배열의 인덱스\n프로그래밍 언어에서 배열을 다룰 때 첫번째 인덱스가 0 인 언어가 있으며(C/C++, Java, Python, Javascript 등), 1 인 언어(Fortran, Matlab, R 등) 가 있습니다. Julia는 1부터 시작합니다. end 는 각 차원의 마지막 인덱스를 의미하는 키워드입니다. 물론 배열의 차원과 형태를 알고 있다면 인덱스를 직접 써도 됩니다.\nIn [1]: A = [1 4 7 10;2 5 8 11;3 6 9 12] \nOut[1]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [2]: A[1, 1] # a의 1 행 1열\nOut[2]: 1\n\nIn [3]: A[2, end] # a의 2 행 마지막 열\nOut[3]: 11\n\nIn [4]: A[end, end] # a 의 마지막 행 마지막 열\nOut[4]: 12\n\n\n인덱스를 이용한 배열 연산\n인덱스의 범위를 지정할 수도 있습니다. 전체 볌위는 : 로 표기하며, 벡터나 튜플, StepRange 를 사용하여 선택적으로 지정할 수도 있습니다.\nIn [5]: A[:, 1]   # 전체 행, 1 열\nOut[5]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\nIn [6]: A[2, 1:2:end]  # 2행 의 1열부터 끝열까지 2열 간격으로\nOut[6]: 2-element Vector{Int64}:\n 2\n 8\n\nIn [7]: A[3, [2, 3]] # 3행 의 2열과 3열\nOut[7]: 2-element Vector{Int64}:\n 6\n 9\n\nB=A[:, 1] 라고 하면 B 는 A 의 1 행과 같은 값을 갖는 벡터이며 A 의 1행이 아닙니다. 즉 B=A[:, 1] 을 수행하고 B 벡터의 성분을 바꾼다고 해도 A 가 변하지 않습니다. 이에 대해서는 배열의 복사 와 view 와 @view 를 참고하시기 바랍니다.\nIn [9]: B=A[:, 1]\nOut[9]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\nIn [10]: B[2]=-3\nOut[10]: -3\n\nIn [11]: A\nOut[11]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [12]: B\nOut[12]: 3-element Vector{Int64}:\n  1\n -3\n  3\n\n\n\n행렬의 열/행 우선 방식\n예를 들어 \\(\\boldsymbol{A} =\\begin{bmatrix} 1&2\\\\3&4\\end{bmatrix}\\) 를 메모리상에 저장할 때 1행 1열, 1행 2열,… 1행 마지막열, 2행 1열, … 순으로 저장하는 것을 행 우선 순서(row-major order) 라고 하고 1행 1열 2행 1열,…, 마지막행 1열, 2행 1열, 2행 2열,… 순으로 저장하는 것을 열 우선 방식(column-major order)이라고 합니다. 행 우선 방식에서는 배열 A 가 1 2 3 4 의 순으로 저장이 되며 열 우선방식에서는 1 3 2 4 순으로 저장이 됩니다. 행 우선 방식을 쓰는 언어로는 C/C++ 과 Python 의 numpy 가 있고 열 우선 방식을 쓰는 언어로는 Fortran, MATLAB, Julia, R 등이 있습니다. 또한 언어에서 사용하는 자료구조나 함수에 따라 달라질 수 있습니다.\n\n\n\n\n\n\n경고\n\n\n\n이것이 문제가 될 수 있는 경우는 우선순위가 다른 언어나 라이브러리간에 데이터를 교환 할 때 입니다. 예를 들어 julia 의 배열을 파일로 저장 한 후 python 의 numpy 로 읽으면 행과 열이 바뀔 수 있습니다.\n\n\n열/행 우선 방식이 본질적으로 동일한 계산의 계산 속도에 영향을 줄 수 있습니다. 아래의 코드는 \\(10000 \\times 10000\\) 배열의 합을 두가지 방법으로 구하는 코드입니다. 우선 각 행에대헤 열을 순회하며 합을 구하였고, 그 다음은 각 열에 대해 행을 순회하며 합을 구하였습니다.\nusing BenchmarkTools\nM = 10000\nmat= rand(M, M)\n\n@btime begin\n    r1  =0.0\n    for i ∈ 1:M, j ∈ 1:M\n        r1 += mat[i, j]\n    end\nend\n\n@btime begin\n    r2 =  0.0\n    for j ∈ 1:M, i ∈ 1:M\n        r2 += mat[i, j]\n    end\nend\n그 결과는\n  13.454 s (489818979 allocations: 8.79 GiB)\n  8.744 s (489818979 allocations: 8.79 GiB)\n로 아래의 방법이 훨씬 빨랐습니다. 이것은 julia 에서는 배열이 열 우선방식으로 정렬되기 때문이며, 행보다 열을 많이 변화시키는 것이 전체적으로 더 빠릅니다. 같은 열에서 다음 행으로 넘어갈 때는 바로 다음칸으로 넘어가면 되지만, 같은 행에서 다음 열로 넘어갈 때 열의 갯수 +1 만큼 넘어가야 하기 때문입니다. 예를 들어 첫번째 합 계산의 경우, 행이 10000 번 변할 동안 열은 1억번 변하는데, 두번째 계산의 경우는 열이 10000 번 변할 동안 행이 1억번 변합니다. 이 차이가 계산 속도의 차이를 만들어 냅니다.\n\n\n\n데카르트 인덱스와 선형 인덱스\n지금까지 2차원 배열A 의 2행 3열 성분을 A[2, 3] 으로 접근했습니다. 이와 같이 배열의 차원의 갯수만큼의 자연수로 접근하는 것을 데카르트 인덱스(Cartesian index) 혹은 카르테시안 인덱스 라고 합니다. 다른 접근 방법도 있는데, 다차원 배열의 각 성분을 1부터 하나의 자연수로 접근하는 방법도 사용합니다. 이것을 선형 인덱스(linear index) 라고 합니다. 앞서 알아본 열 우선 방식에서 배열을 나열할 때의 차례입니다. 예를 들어 A=[1 3;2 4] 의 경우 A[3]=3 이며 A[4]=4 입니다.프랑스의 철학자이자 과학자인 르네 데카르트(René Descartes) 의 이름에서 따왔습니다. 데카르트의 라틴어명이 Renatus Cartesius 이기 때문에 영어로는 Cartesian index 라고 씁니다.\nIn [13]: A=[1 2;3 4]\nOut[13]: 2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nIn [14]: A[3]\nOut[14]: 2\n데카르트 인덱스로부터 선형 인덱스를, 선형 인덱스로부터 데카르트 인덱스르 얻는 방법이 존재합니다. 배열 A 에 대해 CartesianIndices(A)[10] 은 배열 A 의 선형 인덱스 10 에 대한 데카르트 인덱스를 리턴합니다. A 가 삼차원 배열일 경우 LinearIndices(A)[1, 2, 3] 은 배열 A 의 데카르트 인덱스(1, 2, 3) 에 대한 선형 인덱스를 리턴합니다. 고차원 배열에대해서도 차원의 갯수만큼의 데카르트 인덱스를 받아 선형 인덱스를 리턴합니다.\nIn [1]: A=Array(reshape(1:2*3*4, (2, 3, 4)))\nOut[1]: 2×3×4 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\n[:, :, 3] =\n 13  15  17\n 14  16  18\n\n[:, :, 4] =\n 19  21  23\n 20  22  24\n\nIn [2]: CartesianIndices(A)[10]\nOut[2]: CartesianIndex(2, 2, 2)\n\nIn [3]: LinearIndices(A)[1, 2, 3]\nOut[3]: 15",
    "crumbs": [
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#sec-copy_of_array",
    "href": "src/introduction_to_julia/06_arrays.html#sec-copy_of_array",
    "title": "배열",
    "section": "4 배열의 복사",
    "text": "4 배열의 복사\n배열을 복사할 때는 copy() 혹은 deepcopy() 명령어를 사용합니다. 주의해야 할 것은 배열 A 에 대해 B=A 와 B=copy(A) 는 다르다는 것입니다. 아래 코드를 봅시다.\nIn [13]: A=[1 2]\nOut[13]: 1×2 Matrix{Int64}:\n 1  2\n\nIn [14]: B=A;C=copy(A)\nOut[14]: 1×2 Matrix{Int64}:\n 1  2\n\nIn [15]: B[1, 1]=3\nOut[15]: 3\n\nIn [16]: A\nOut[16]: 1×2 Matrix{Int64}:\n 3  2\n\nIn [17]: C\nOut[17]: 1×2 Matrix{Int64}:\n 1  2\n\nIn [18]: C[1, 2]=-1\nOut[18]: -1\n\nIn [19]: A\nOut[19]: 1×2 Matrix{Int64}:\n 3  2\nB=A 라는 표현식은 B 와 A 변수가 같은 행렬에 대한 변수라는 뜻입니다. 따라서 B 라는 변수를 이용해 행렬 값을 변화시키면 A 변수로 접근하더더라도 변화된 행렬에 접근하게 됩니다. B=copy(A) 는 A 복사본을 만들어 B 라는 변수에 지정합니다. 따라서 B 변수를 이용해 행렬을 바꾸더라도 A 변수에 지정된 행렬은 변화하지 않습니다. B=A[:] 는 B=A 가 아닌 copy(A) 를 의미합니다.\n객체를 복사하는 deepcopy() 함수 가 있습니다. 다음 예를 봅시다.\nIn [1]: A = [1, 2, 3, [4, 5, 6]]\nOut[1]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, 5, 6]\n\nIn [2]: B = A[:]; C=copy(A); D=deepcopy(A);\n\nIn [3]: A[4][2]=-1\nOut[3]: -1\n\nIn [4]: B\nOut[4]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, -1, 6]\n\nIn [5]: C\nOut[5]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, -1, 6]\n\nIn [6]: D\nOut[6]: 4-element Vector{Any}:\n 1\n 2\n 3\n  [4, 5, 6]\nA = [1, 2, 3, [4, 5, 6]] 는 벡터이며 정수와 벡터를 성분으로 갖기 때문에 Any 타입에 대한 벡터가 됩니다. A 의 네번째 성분은 벡터이며 실제로 A 변수에 내부적으로 저장되는것은 벡터 [4, 5, 6] 에 대한 주소입니다. C=copy(A) 명령어는 값 1, 2, 3 과 벡터 [4, 5, 6] 의 복사본을 만들지 않고 단지 주소만을 복사하여 변수 C 에 할당합니다. deepcopy 함수는 벡터 [4, 5, 6] 에 대해서도 복사본을 만들기 때문에 D=deepcopy(A) 명령어로 D 에 할당된 배열은 A 와는 같은 값을 갖는 완전히 별개인 배열이 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06_arrays.html#배열에-대한-함수",
    "href": "src/introduction_to_julia/06_arrays.html#배열에-대한-함수",
    "title": "배열",
    "section": "5 배열에 대한 함수",
    "text": "5 배열에 대한 함수\n\n인덱스 순회에 대한 함수들 : eachindex, CartesianIndex\n배열의 인덱스, 혹은 성분 각각에 대해 for ... end 루프를 수행하는 방법은 여러가지가 있습니다. 배열의 선형 인덱스를 이용하여 순회할 때는 eachindex 를 씁니다.\nIn [1]: A = [1 2; 3 4];\n\nIn [2]: for i in eachindex(A)\n        @show i, A[i]\n        end\n(i, A[i]) = (1, 1)\n(i, A[i]) = (2, 3)\n(i, A[i]) = (3, 2)\n(i, A[i]) = (4, 4)\n\nIn [3]: for i in CartesianIndices(A)\n        @show i, A[i]\n        end\n(i, A[i]) = (CartesianIndex(1, 1), 1)\n(i, A[i]) = (CartesianIndex(2, 1), 3)\n(i, A[i]) = (CartesianIndex(1, 2), 2)\n(i, A[i]) = (CartesianIndex(2, 2), 4)\n위에서 알 수 있듯이 eachindex(A) 는 배열 A 에 대한 선형 인덱스를 사용하여 순회하도록 하며 CartesianIndices(A) 는 데카르트 인덱스를 이용하여 순회합니다.\n\n\n\n타입과 모양의 변환\n우리는 앞서 타입이름이 타입 변환함수로 사용될 수 있다는 것을 보았습니다. 예를 들어 Float32(6) 은 Int64 타입의 6 을 4바이트 부동소수 타입인 Float32 타입으로 변환시킵니다. 또한 우리는 . 연산자를 통해 컨테이너의 각각의 성분에 대해 함수를 적용시킬 수 있다는 것을 알았습니다. 따라서 Float32.([1, 2, 3, 4]) 는 Float32 타입의 성분을 갖는 [1.0f0, 2.0f0, 3.0f0, 4.0f0] 입니다.\n\\(3\\times 5\\) 배열을 \\(5 \\times 3\\) 배열로 바꾸거나 \\(12 \\times 5\\) 배열을 \\(3\\times 4 \\times 5\\) 로 바꾸는 것과 같이 그 크기를 유지하지만 배열의 모양을 바꾸는 함수는 reshape 입니다. 예를 들어 보겠습니다.\nIn [1]: A = Array(1:6)\nOut[1]: 6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nIn [2]: reshape(A, (2, 3))\nOut[2]: 2×3 Matrix{Int64}:\n 1  3  5\n 2  4  6\nIn[1] 에서의 A 는 6개의 성분을 갖는 1차원 벡터였지만 reshape(A, (2, 3)) 를 통해 \\(2 \\times 3\\) 행렬이 되었습니다. 다시 말하지만 원래의 행렬과 변환된 행렬의 총 성분 수는 같아야 합니다. 즉 length 가 같아야 합니다. reshape 는 원래 행렬과 변환 행렬의 선형 인덱스가 같도록 변환됩니다.\n\n\n\nview 와 @view\nview 는 이미 존재하는 배열로부터 특정 부분을 추출하여 만든 배열에 대한 타입이며, 이런 연산을 하는 함수이기도 합니다. 배열 A 에 대해 a=view(A, 1) 은 배열 A 의 첫번째 성분을 가리킵니다. 가리킨다라고 표현한 것은 단지 같은 값을 가질 뿐만 아니라 a 를 변경시키면 A 도 변경되기 때문입니다.\nIn [4]: A= [1 2;3 4];\n\nIn [5]: a = view(A, 1)\nOut[5]: 0-dimensional view(::Vector{Int64}, 1) with eltype Int64:\n1\n\nIn [6]: a[1]=3;\n\nIn [7]: A\nOut[7]: 2×2 Matrix{Int64}:\n 3  2\n 3  4\n다차원 배열의 경우 인덱스를 쓰거나 : 나 배열을 이용하여 범위를 특정 할 수 있습니다.\nIn [8]: B=reshape(Array(1:12), (3, 4))\nOut[8]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [9]: b=view(B, [1, 3], :)  # 1행과 3행, 그리고 열 전체에 대한 view\nOut[9]: 2×4 view(::Matrix{Int64}, [1, 3], :) with eltype Int64:\n 1  4  7  10\n 3  6  9  12\n\nIn [10]: b[2, 2]=-6 # view 의 변경\nOut[10]: -6\n\nIn [11]: B\nOut[11]: 3×4 Matrix{Int64}:\n 1   4  7  10\n 2   5  8  11\n 3  -6  9  12\n앞서 B[:, 3] 과 같이 이미 존재하는 배열로부터 그 부분을 성분으로 갖는 배열을 생성하는 방법을 보았습니다. @view 매크로는 view 함수를 쓰지 않고 B[:, 3] 과 같은 방법으로 view 를 생성합니다. 매크로에 대해서는 메타프로그래밍과 매크로 를 참고하시기 바랍니다. 일단은 @ 로 시작하는 명령문은 매크로 라고 하며 명령문 뒤에 주어진 인자나 함수에 대한 특별한 기능을 한다는 정도만 알아 둡시다\nIn [21]: B=reshape(Array(1:12), (3, 4))\nOut[21]: 3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\nIn [22]: B[:, [2, 3]]\nOut[22]: 3×2 Matrix{Int64}:\n 4  7\n 5  8\n 6  9\n\nIn [23]: @view B[:, [2, 3]]\nOut[23]: 3×2 view(::Matrix{Int64}, :, [2, 3]) with eltype Int64:\n 4  7\n 5  8\n 6  9\nB[:, [2, 3]] 은 B 의 2행과 3행만을 선택하여 새로운 배열을 만들기 때문에, 일단 만든 다음에는 원래의 B 값과 무관하게 변경시킬 수 있습니다. @view B[:, [2, 3]] 는 B 의 부분에 대한 view 를 만들기 때문에 C=@view B[:, [2, 3]] 를 통해 C 에 할당한다면 C 를 변경하는 것은 B 를 변경하는 것이 됩니다.\nIn [24]: C=@view B[:, [2, 3]]\nOut[24]: 3×2 view(::Matrix{Int64}, :, [2, 3]) with eltype Int64:\n 4  7\n 5  8\n 6  9\n\nIn [25]: C[1, 1]=-1;\n\nIn [26]: B\nOut[26]: 3×4 Matrix{Int64}:\n 1  -1  7  10\n 2   5  8  11\n 3   6  9  12\nview 나 @view 가 필요한 이유는 메모리와 시간을 절약해 주기 때문입니다. 아주 큰 배열을 다룰 때 그 부분 배열에 대해 연산이 필요하다고 합시다. 배열을 새로 생성한다면 그만큼의 메모리와 배열의 생성과 복사를 위한 시간이 필요하지만 view 를 사용한다면 이미 존재하는 배열을 사용하기 때문에 약간의 메모리에서의 빈 공간만으로 연산을 수행 할 수 있습니다. 다만 view 나 @view 를 이용해 얻은 부분배열을 변경할 경우 원래의 배열도 변경된다는 사실을 명심해야 합니다.\n\n\n\n다차원 배열에서의 도트연산\n앞서 컨테이너 에서 도트 연산, 즉 연산자 앞이나 함수 뒤에 . 를 붙여 성분별 연산을 수행하는 것을 다루었습니다. 다차원 배열의 경우 차원이 같으면(즉 차원의 갯수와, 각 차원별 원소의 갯수가 같으면) 도트 연산을 수행할 수 있지만 차원이 다를 경우에는 차원을 확장하여 수행합니다.\n\n도트 연산에서의 차원 확장은 그 차원이 정의되어 있지 않거나 차원의 성분의 갯수가 1개 일때만 이루어집니다. 즉 [1 2] .+ [1 2; 3 4] 나 [1 2;] .+ [1 2; 3 4]는 가능하지만 [1 2;3 4] .+ [1 2 3; 2 3 4] 는 에러를 발생시킵니다.\n차원 확장은 차원이 없거나 1차원인 차원으로 원래의 배열을 반복합니다. [1 2] .+ [1 2; 3 4] 의 경우는 [1 2] 를 배열로 변환시킬 때 \\(1 \\times 2\\) 배열이 되며 첫번째 차원이 하나의 성분을 가지므로 첫번째 차원에 대해 두번 반복한 [1 2;1 2] 와 [1 2;3 4] 의 연산을 수행하게 됩니다.\n따라서 스칼라나 영차원 배열은 모든 차원의 다차원 배열에 대해 도트 연산이 가능합니다.\n\nIn [1]: [1;;2] .+ [1 2;3 4]\nOut[1]: 2×2 Matrix{Int64}:\n 2  4\n 4  6\n\nIn [2]: [1; 2] .+ [1 2;3 4]\nOut[2]: 2×2 Matrix{Int64}:\n 2  3\n 5  6\n\nIn [3]: [3] .* [1 2; 3 4]\nOut[3]: 2×2 Matrix{Int64}:\n 3   6\n 9  12\n[1;;2] 는 \\(1 \\times 2\\) 배열이므로 \\(2 \\times 2\\) 배열과 연산할 때는 [1 2; 1 2] 로 바뀌어 연산됩니다. [1 ; 2] 는 \\(2 \\times 1\\) 배열이므로 \\(2 \\times 2\\) 배열과 연산할 때는 [1 1; 2 2] 로 바뀌어 연산됩니다.\n컨테이너에서의 도트 연산과 같이 @. 매크로도 동작합니다. @. 매크로를 앞에 붙이면 뒤에 나오는 함수나 연산자에 . 를 붙이지 않아도 julia 가 알아서 연산을 해 줍니다.\n\n\n\nbroadcast\nbroadcast(f, As...) 함수는 하나 이상의 값 혹은 컨테이너인 As... 에 함수 혹은 연산자 f 를 적용합니다. map 함수와 같은것이라고 생각 할 수 있지만, 실제로는 julia 에서 차원과 크기가 다른 컨테이너에 함수를 적용할 때는 이 함수가 기본이 되기 때문에 다차원 배열의 연산을 이해하기 위해서는 이 함수를 이해해야 합니다.\n\nf 를 제외한 인자가 스칼라나 0차원 배열일 경우 스칼라를 반환합니다.\nf 를 제외한 인자에 튜플이 포함되며, 튜플을 제외한 나머지 인자가 스칼라이면 튜플을 반환합니다.\nf 를 제외한 인자가 위의 두 경우와 다르다면 배열을 반환합니다.\nf 를 제외한 인자가 배열이나 스칼라라면 위의 도트 연산시의 차원 확장 규칙에 따라 차원을 확장하여 도트 연산으로 계산합니다.\n\nIn [1]: broadcast(+, 2, 3)\nOut[1]: 5\n\nIn [2]: ones()\nOut[2]: 0-dimensional Array{Float64, 0}:\n1.0\n\nIn [3]: broadcast(+, 1, ones())\nOut[3]: 2.0\n\nIn [4]: broadcast(*, 2, (1, 2, 3))\nOut[4]: (2, 4, 6)\n\nIn [5]: broadcast(*, (1, 2, 3), [-1, 1, 0])\nOut[5]: 3-element Vector{Int64}:\n -1\n  2\n  0\nIn [6]: broadcast(sin, range(0, π, length = 5))\nOut[6]: 5-element Vector{Float64}:\n 0.0\n 0.7071067811865475\n 1.0\n 0.7071067811865476\n 1.2246467991473532e-16\n크기가 다른 배열의 경우 다차원 배열의 도트 연산 과 같은 규칙으로 계산됩니다. 실제로는 도트 연산의 자체가 broadcast 함수를 사용하여 정의되었으므로 당연한 것입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "배열"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04_containers.html",
    "href": "src/introduction_to_julia/04_containers.html",
    "title": "컨테이너",
    "section": "",
    "text": "여러 개의 데이터를 저장하고 처리하기 위한 데이터 타입을 컨테이너(container)이라고 하며, 대표적으로 배열(Array), 튜플(Tuple), 사전(Dict), StepRange, 집합(Set) 등이 있습니다. 컨테이너은 기본적으로 length 함수를 통해 포함되어 있는 아이템의 갯수를 알 수 있으며, 아이템을 하나하나 순회할 수 있습니다. 순서가 있는 컨테이너일 경우 순서대로 1, 2, … 의 인덱스를 가지며 포함하는 객체에 접근하여 값을 가져오거나 값을 변경할 때 정수 인덱스로 접근 할 수 있습니다. 순서가 중요하지 않은 컨테이너 일 경우 값마다 지정된 키(key) 인덱스를 통해 접근할 수 있습니다. 집합 타입의 컨테이너의 경우는 인덱스로도, 키로도 접근할 수 없습니다. 컨테이너에서 아이템을 더하거나 뺄 수 있는 컨테이너를 mutable 하다고 하며, 한번 생성된 컨테이너을 변경 할 수 없다면 immutable 하다고 합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "컨테이너"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04_containers.html#sec-collections",
    "href": "src/introduction_to_julia/04_containers.html#sec-collections",
    "title": "컨테이너",
    "section": "1 대표적인 컨테이너들",
    "text": "1 대표적인 컨테이너들\nJulia 에서는 많은 종류의 컨테이너를 기본적으로 제공하며, 이 가운데 가장 많이 사용되는 것들의 특징을 정리하였습니다.\n\n\n\n표 1: 대표적인 컨테이너과 그 특징\n\n\n\n\n\n이름\n정수 인덱스로 접근\n키 인덱스로 접근\nmutable\n\n\n\n\n배열 (Array)\no\nx\no\n\n\n튜플 (Tuple)\no\nx\nx\n\n\n기명 튜플 (NamedTuple)\no\no\nx\n\n\n사전 (Dictionary)\nx\no\no\n\n\nStepRange (StepRange)\no\nx\nx\n\n\n집합 (Set)\nx\nx\no\n\n\n배열 (Array)\no\nx\no\n\n\n\n\n\n\n\n\n배열 (Array)\n배열은 정수 인덱스로 접근하는 같은 타입의 성분을 갖는 다차원 컨테이너로 mutable 입니다. 배열과 다른 컨테이너의 가장 큰 차이점은 배열은 메모리상에서 시작 성분부터 각각 연속적으로 위치합니다. 따라서 각 원소의 위치를 찾기가 용이합니다. 수치 해석에서 기본이 되는 벡터, 행렬과 이미지 등은 대부분 배열로 처리됩니다. 배열은 Julia 에서 특히 수치 해석에서 너무나 중요하기 때문에 이후 배열 에서 자세히 다루고 여기서는 1차원 배열에 대해서만 간단히 다루도록 하겠습니다.\n\n\n\n1차원 배열 (Vector)\n1차원 배열은 Vector 라고 불리며 [ ] 안에 쉼표로 분리되어 나열된 아이템을 성분으로 갖는 컨테이너 입니다. 수를 비롯하여 모든 타입의 아이템을 포함할 수 있으며 삽입과 삭제가 자유로운 mutable 타입으로 정수 인덱스로 접근합니다. 다음과 같이 정의합니다.\nIn [1]: vec1 = [1, 2, \"a\", 3.4, \"bbc\"]\nOut[1]: 5-element Vector{Any}:\n 1\n 2\n  \"a\"\n 3.4\n  \"bbc\"\n\nIn [2]: vec2=[2,3,4,5]\nOut[2]: 4-element Vector{Int64}:\n 2\n 3\n 4\n 5\n이 때 vec1[1]=1 이며 vec1[5]=\"bbc\" 입니다. Vector 옆의 {Any} 나 {Int64} 는 벡터의 성분(벡터에 포함된 아이템을 성분(entry, element) 라고 합니다) 의 타입입니다. Any 타입은 모든 타입을 포함하는 타입입니다. 베열이 생성될 때 정해지며, 일단 정해진 벡터의 타입은 변경 될 수 없습니다. 다만 타입을 변경한 새로운 벡터를 만들 수 있습니다. 배열은 mutable 이므로 성분을 인덱스로 접근하여 변경 할 수 있습니다.\nIn [5]: vec1[2]=2.2; vec1\nOut[5]: 5-element Vector{Any}:\n 1\n 2.2\n  \"a\"\n 3.4\n  \"bbc\"\n\n\n\n\n\n\n\n명령문 끝의 ;\n\n\n\n위의 In [5] 에서와 같이 Julia REPL 에서 명령어 다음에 세미콜론 ; 을 붙이면 명령을 수행하지만 그 결과는 출력하지 않습니다. Jupyter 나 vscode 환경에서도 마찬가지 입니다.\n\n\n\n벡터에 성분을 마지막에 추가하고 싶으면 append!(vec1, item1, item2, .. ) 처럼 사용합니다. 그렇게 되면 vec1 에 item1, item2 가 차례대로 추가됩니다. 만약 item1, item2… 들이 컨테이너이라면 vec1 에 item1 를 순서대로 합칩니다.\n\n\n\n\n\n\n\n함수명 끝의 !\n\n\n\nJulia 에서는 함수명을 붙일 때 함수의 어떤 인자를 변경하는 함수라면 관례적으로 그 이름 끝에 ! 를 붙입니다. 다음부터 나올 push! 나 pop! 함수 이름에 ! 가 붙은것은 이 함수가 직접 인자를 변경하기 때문입니다. 직접 변경하지 않을 때는 ! 를 붙이지 않습니다.\n\n\n\n\n예제 1 append!(vec1, [2, 4], [\"k\", \"g\"]) 를 수행해 보세요.\n\n\n어떤 정해진 인덱스에 삽입하려면 insert!(vec1, index1, item1) 처럼 사용합니다. 그렇게 되면 vec1[index1] == item1 이 되며 원래 index1 에 위치했던 아이템과 그 뒤의 아이템들의 인덱스가 하나씩 늘어나게 됩니다. item 이 컨테이너이라도 append! 처럼 컨테이너의 아이템이 순서대로 삽입되지 않고 컨테이너 자체로 삽입됩니다. (타입이 지정된 벡터이면 에러가 발생합니다.)\nIn [6]: vec1 = [1, 2, \"a\", 3.4, \"bbc\"];\n\nIn [7]: insert!(vec1, 3, \"II\")\nOut[7]: 6-element Vector{Any}:\n 1\n 2\n  \"II\"\n  \"a\"\n 3.4\n  \"bbc\"\n특정 인덱스의 아이템을 삭제하고 싶으면 deleteat! 함수를 사용합니다. 만약 vec1[4] 인 “a” 를 삭제하고 싶으면 deleteat!(vec1, 4) 처럼 사용합니다.\nJulia 의 모든 타입은 Any 로부터 가지처럼 뻗어나가는 계층 구조를 가지고 있습니다. 여기에 대해서는 타입의 계층구조 에서 좀 더 자세히 알아 볼 것입니다. 벡터를 정의할 때 vec1 처럼 여러 타입을 가진 아이템을 포함한다면 julia 가 알아서 적절한 타입으로 변환합니다. 정수와 부동소수만으로 이루어진 배열은 자동적으로 부동소수로 변환됩니다. Any 는 모든 타입을 포함 할 수 있는 타입이므로 임의의 타입을 위한 배열의 타입으로 사용됩니다. 당분간은 배열은 특정한 타입만을 포함 할 수 있으며, 임의의 타입을 포함하고 싶을때는 Vector 다음에 {Any} 를 명시적으로 붙인다고 알고 있겠습니다.\n\n\n\n\n\n\nPromotion\n\n\n\n연산에서 같은 타입이 아닐 때 타입을 조정하는것을 promotion 이라고 합니다. 예를 들자면 2+3.0 이나 3.3 + π 을 계산하는 경우 둘의 타입이 다르기 때문에 julia 가 적절한 타입, 이 경우는 둘 다 부동소수로 타입으로 변환합니다.\n\n\nIn [1]: vec2=Vector{Any}([1,2,3]);\n\nIn [2]: ec3=Vector([1,2,3]);\nvec2 와 vec3 는 모두 세 정수로 이루어진 벡터이지만 vec2 는 Any 타입으로 지정되었습니다. 따라서 insert!(vec2, 2, \"A\") 는 동작하지만 insert!(vec3, 2, \"A\") 는 동작하지 않습니다.\npush! 와 pop! 은 벡터의 미지막에 어떤 아이템을 추가하거나, 마지막 아이템을 제거하는 명령입니다. push!(vec3, 5) 나 pop!(vec3) 처럼 사용합니다. pop! 의 경우 제거된 아이템을 반환합니다.\nIn [3]: push!(vec3, 5)\nOut[3]: 4-element Vector{Int64}:\n 1\n 2\n 3\n 5\n\nIn [4]: pop!(vec3)\nOut[4]: 5\n\nIn [5]: vec3\nOut[5]: 3-element Vector{Int64}:\n 1\n 2\n 3\n\n연습문제 1 pushfirst!, popfirst!, empty! 함수를 알아보고 벡터를 변형시켜 봅시다.\n\n\n\n\nStepRange\n일정한 간격으로 나열되는 수를 위한 immutable 컨테이너입니다. 대표적으로 start:step:end 형식이나 start:end 형식으로 할당하며, 후자의 경우 start 와 end 의 타입으로부터 1 혹은 1.0 의 간격을 갖도록 만들어집니다.\n\nrange1 = start:step:end 형식으로 만들 경우 1 부터 시작하는 인덱스 i 에 대해 range1[i] == start + (i-1)*step 값을 가지며 당연히 end 값을 넘지 않습니다. 그리고 end 값을 포함 할 수 있습니다. 1:1:5 의 경우는 5번째 값은 5 입니다. \nend &gt; start 일 경우는 step 값이 0 보다 작아야 합니다.\n\npython 의 경우 range(1, 5) 나 numpy.arange(1, 5) 로 생성하는 배열은 5 를 포함하지 않습니다.\n연습문제 2 start &gt; end 일 때, step 값을 양수로 정의해 보거나, start &lt; end 일 때 step 값을 음수로 정의하고 인덱스를 통해 접근해 보기 바랍니다. 또한 start == end 일 때는 어떻게 되는지 확인해 보기 바랍니다.\n\nrange 함수를 통해서도 생성 할 수 있습니다. range(1, 10, step=1) 은 1:1:10 과 같습니다. 또한 range(start=0.0, stop=π, length=100) 은 0 부터 \\(\\pi\\) 까지 100 개의 길이를 가진 Range 만듭니다. 자세한 것은 julia 의 기본 문서에서 range 를 검색해 보기 바랍니다.\n많은 경우 StepRange 는 벡터처럼 동작하지만 immutable 이므로 수정 할 수 없습니다. 그리고 많은 경우 수학 함수에 적용되면 결과가 벡터로 변환됩니다.\nIn [6]: sin.(0.0:0.1:π)\nOut[6]: 32-element Vector{Float64}:\n 0.0\n 0.09983341664682815\n 0.19866933079506122\n 0.2955202066613396\n 0.3894183423086505\n 0.479425538604203\n 0.5646424733950355\n 0.6442176872376911\n ⋮\n 0.5984721441039564\n 0.5155013718214642\n 0.4273798802338298\n 0.33498815015590466\n 0.23924932921398198\n 0.1411200080598672\n 0.04158066243329049\n\nStepRange 값을 벡터로 변환할 때는 collect 함수를 사용합니다. collect 함수는 컨테이너를 인자로 받아 이것을 벡터로 바꾸어 주는 함수입니다.\nIn [6]: collect(1:2:11)\nOut[6]: 6-element Vector{Int64}:\n  1\n  3\n  5\n  7\n  9\n 11\n\n\nrange 함수\nStepRange 와 비슷한 기능을 하는 range 함수가 있습니다. REPL 에서 ?range 로 알 수 있는 range 함수의 시그너쳐는 다음과 같습니다.\n  range(start, stop, length)\n  range(start, stop; length, step)\n  range(start; length, stop, step)\n  range(;start, length, stop, step)\nrange(1, 10, 10) 은 시작과 끝, 그리고 길이를 지정하는 첫번째 시그너쳐에 따라 생성합니다. 0.0:0.1:10.0 에서는 간격이 주어지지만 range 는 간격 대신 길이를 지정 할 수 있습니다.\n\n\n\n\n튜플 (Tuple)\n튜플은 벡터처럼 인덱스를 통해 포함하는 아이템에 접근 할 수 있지만 새로운 아이템을 추가할 수도 없고, 포함하는 아이템을 삭제할 수도 없습니다. 즉 immutable 입니다. 튜플은 tuple1 = (1, 3.3, 'A', cos, (2, \"a\", sin)) 과 같이 ( ) 안에서 , 로 구분하여 선언합니다. 여기서 A 는 Char 타입, “a” 는 String 타입이며, sin, cos 는 함수입니다. (Julia 에서 함수는 Function 타입입니다.) 튜플에서는 1 부터 시작되는 인덱스를 이용하여 포함된 아이템에 접근 할 수 있습니다. 앞서의 tuple1 의 경우, tuple1[1]==1 이며, typle1[3]=='A' 입니다. tuple[5]== (2, \"a\", sin) 이므로 tuple1[5][2]==\"a\" 입니다. tuple1[5][3]==sin 인 함수이므로 다음과 같은 결과를 얻을 수 있습니다.\nIn [1]: tuple1 = (1, 3.3, 'A', cos, (2, \"a\", sin))\nOut[1]: (1, 3.3, 'A', cos, (2, \"a\", sin))\n\nIn [2]: tuple1[5][3](π/2)\nOut[2]: 1.0\ntuple 은 immutable 한 컨테이너이므로 tuple1[2]=4.4 와 같은 방식으로 아이템을 변경 할 수 없으며, 성분을 추가하거나 삭제할 수도 없습니다.\n\n\n연습문제 3 임의의 튜플을 만든 후 인덱스를 통해 아이템을 변경해 보고 그 에러를 확인해 보세요.\n\n\n튜플이 벡터와 구별되는 것 가운데 하나는 포함되는 아이템의 타입을 일치시키려 하지 않는 점 입니다. 앞서 보았듯이 vec0 = [1, 2.0] 를 수행하면 맨 처음의 1 은 벡터가 되면서 2.0 의 타입을 고려하여 Float64 타입인 1.0 으로 변경됩니다. 이것은 vec0 = Vector{Any}([1, 2.0]) 를 해도 마찬가지 입니다. 그러나 튜플은 다릅니다.\nIn [1]: tup0 = (1, 2.0)\nOut[1]: (1, 2.0)\n와 같이 타입을 일치시키려 하지 않습니다.\n\n튜플이 가장 흔하게 사용되는 곳은 함수의 return 에서 입니다. 만약 함수가 아래와 같이 여러개의 값을 , 로 구분하여 반환한다면 이것은 이 값들을 순서대로 묶은 튜플을 반환하는 것입니다. 아래의 return3() 함수는 그냥 1, 2, 3 을 반환하는 함수인데, 리턴값은 이 값을 묶은 튜플입니다. 아래의 함수는 1, 2, 3 을 반환하는 함수입니다.\nfunction return3()\n    return 1, 2, 3\nend\n이 함수를 실행시키면 튜플 (1, 2, 3) 을 반환합니다.\nIn [3]: return3()\nOut[3]: (1, 2, 3)\n\n튜플을 사용하는 기법중의 하나가 두 변수의 값을 서로 바꿀 때 입니다. 예를 들어 다음 코드를 봅시다.\nIn [4]: a=1;b=2;a, b = b, a\nOut[4]: (2, 1)\n\nIn [5]: println(\"a=$a, b= $b\")\na=2, b= 1\n우선 a, b 에 각각 1 과 2 를 할당했습니다. 그 다음의 a, b = b, a 를 봅시다. 우선 등호의 오른쪽 b, a 를 수행하여 (b, a) 인 튜플을 만듭니다. 그리고 a, b=b, a 를 통해 a=(b, a)[1] 과 b=(b, a)[2] 를 수행합니다. 즉 (b, a) 인 새로운 튜플을 만들고 그 값을 순서대로 a, b 에 할당하는 것이기 때문에 결과적으로 두 변수의 값을 서로 교환하게 된 것입니다.\n\n\n\n기명 튜플 (NamedTuple)\n기명 튜플은 튜플과 유사하나 성분 하나마다 특별한 이름이 붙으며, 성분에 접근할 때 인덱스를 이용할 수도 있고, 그 이름을 이용할 수도 있습니다. 기명튜플도 immutable 이므로 값을 변경하거나, 성분을 추가하거나 삭제 할 수 없습니다.\nIn [6]: ntup1 = (b=1, a=2)\nOut[6]: (b = 1, a = 2)\n\nIn [7]: ntup1.a\nOut[7]: 2\n\nIn [8]: ntup1[1]\nOut[8]: 1\n\n\n\n사전 (Dictionary)\n사전은 키(key)-값(value) 를 묶어서 여러 타입을 저장하는 컨테이너으로 성분의 값을 변경 할 수 있는 mutable 타입입니다. 아래와 같이 Dict 를 통해 선언하며 [ ] 를 통해 접근하거나 값을 변경 할 수 있습니다. 기명 튜플과는 달리 인덱스로는 접근 할 수 없습니다. 사전은 아래에서 보듯이 명시적으로 키와 와 값의 타입을 알려주지 않았더라도, 그 타입이 정의되며 만들어집니다. 아래의 dict1 은 키인 \"a\", 와 \"b\" 가 모두 문자열이기 때문에 키는 문자열 타입으로, 값인 1 과 2 가 모두 Int64 타입이므로 값은 Int64 타입으로 정의되었습니다. 즉 dict1 을 만들었을 때의 출력 Dict{String, Int64} 는 키가 문자열(String) 타입이며 값이 64비트 정수(Int64) 타입으로 한정된 사전이라는 것을 의미합니다. 원래 사전은 mutable 타입이므로 새로운 키-값 을 추가 할 수 있지만, 이것은 처음 정의될 때의 사전의 키-값 타입이 허용하는 범위 안에 있을 때만 가능합니다.\nIn [10]: dict1=Dict(\"a\"=&gt;1, \"b\"=&gt;2) # 사전 선언\nOut[10]: Dict{String, Int64} with 2 entries:\n  \"b\" =&gt; 2\n  \"a\" =&gt; 1\n\nIn [11]: dict1[\"a\"] # 사전의 성분 접근\nOut[11]: 1\n\nIn [12]: dict1[\"a\"]=3 # 사전의 값 변경\nOut[12]: 3\n\nIn [13]: dict1\nOut[13]: Dict{String, Int64} with 2 entries:\n  \"b\" =&gt; 2\n  \"a\" =&gt; 3\n\nIn [14]: dict1[\"c\"]=-2 # 사전에 새로운 키-값 추가\nOut[14]: -2\n\nIn [15]: dict1\nOut[15]: Dict{String, Int64} with 3 entries:\n  \"c\" =&gt; -2\n  \"b\" =&gt; 2\n  \"a\" =&gt; 3\n\nIn [16]: dict1[\"d\"]=3.3 # 사전의 값의 타입 범위를 벗어나는 키-값 추가 시도는 실패한다.\nERROR: InexactError: Int64(3.3)\n...\nkeys(), values() 함수를 통해 사전의 key 와 value 를 얻을 수 있으며, haskey() 함수를 통해 해당 key 가 사전에 존재하는지 확인 할 수 있습니다.\nIn [17]: keys(dict1)\nOut[17]: KeySet for a Dict{String, Int64} with 3 entries. Keys:\n  \"c\"\n  \"b\"\n  \"a\"\n\nIn [18]: values(dict1)\nOut[18]: ValueIterator for a Dict{String, Int64} with 3 entries. Values:\n  -2\n  2\n  3\n\nIn [19]: haskey(dict1, \"a\")\nOut[19]: true\n\nIn [20]: haskey(dict1, \"c\")\nOut[20]: true\n사전에 key, value 를 추가할때는 dict1[\"f\"]=5 와 같이 합니다. 사전의 값을 호출할때는 dict1[\"a\"] 처럼 사용합니다.\n사전을 처음 선언 할 때 타입을 정할 수 있습니다. 또한 임의의 타입의 키-값을 갖는 사전도 정할 수 있습니다. 예를 들어 아래의 In [21] 과 같이 Dict{Any, Any} 로 시작하는 정의를 사용하면 모든 타입의 키와 값 을 가질 수 있습니다. Any 는 Int64 나 Rational 과 같은 타입 이름으로 모든 타입을 포함하는 최상위 타입입니다. 타입에 대해 자세한것은 타입 계층 구조 에서 알아볼 것입니다.\nIn [21]: dict3=Dict{Any, Any}(\"a\"=&gt;1)\nOut[21]: Dict{Any, Any} with 1 entry:\n  \"a\" =&gt; 1\n\nIn [22]: dict3[4]=\"abcd\"\nOut[22]: \"abcd\"\n\nIn [24]: dict3[\"sinfunction\"]=sin\nOut[24]: sin (generic function with 14 methods)\n\nIn [25]: dict3[\"sinfunction\"](π/2)\nOut[25]: 1.0\n이 때 dict3[4] 의 4 는 인덱스가 아닌 키 입니다. 정수 뿐 아니라, 부동소수나 복소수도 키가 될 수 있습니다. In [24] 는 사전의 값으로 함수가 오는 것을 보여줍니다. In [25] 에서 볼 수 있듯이 사전과 키를 이용하여 함수처럼 사용 할 수 있습니다.\n\n\n\n문자열 (String)\n앞서 타입에서 알아본 문자열(String) 도 개별적인 문자에 인덱스로 접근 할 수 있으며 length() 함수로 그 길이를 알 수 있다는 점에서 컨테이너입니다. 개별적인 문자에 인덱스로 접근 할 수 있지만 바꿀 수 없으므로 immutable 입니다.\n\n\n\n집합 (Set)\n집합은 아이템의 추가나 삭제는 가능하지만 인덱스로도, 키로도 접근 할 수 없는 mutable collection 입니다. 수학적인 집합과 동일하게 같은 값을 두 개 이상 가질 수 없습니다. 예를 들어 tuple1 = (1, 2, 3, 1) 은 1 값을 두개 가지고 있지만 set1 = Set([1, 2, 3, 1]) 은 1 이 중복되므로 아이템의 갯수는 3개 입니다. 아이템을 추가할때는 push! 함수를 사용하여 push!(set1, 5) 와 같이 하며, 아이템을 제거할때는 pop!(set1, 3) 처럼 사용합니다. 마치 수학의 집합처럼 합집합 ∪(\\cup + [tab]) 나 교집합 ∩(\\cap + [tab]) 연산자를 통해 합집합과 교집합을 계산 할 수 있습니다. 실제로 ∪ 나 ∩ 는 다른 컨테이너 타입에도 사용 할 수 있습니다.\nIn [11]: A=Set([1,2, 3]);B= Set([-1, 0, 1]);\n\nIn [12]: A ∪ B\nOut[12]: Set{Int64} with 5 elements:\n  0\n  2\n  -1\n  3\n  1\n\nIn [13]: A ∩ B\nOut[13]: Set{Int64} with 1 element:\n  1\n\nIn [14]: intersect(A, B)\nOut[14]: Set{Int64} with 1 element:\n  1\n\nIn [15]: union(A, B)\nOut[15]: Set{Int64} with 5 elements:\n  0\n  2\n  -1\n  3\n  1\n\nIn [16]: (1,2, 3) ∩ [ 3, 4, 5]\nOut[16]: 1-element Vector{Int64}:\n 3",
    "crumbs": [
      "Julia 언어의 기초",
      "컨테이너"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04_containers.html#일반적인-컨테이너에-대한-연산",
    "href": "src/introduction_to_julia/04_containers.html#일반적인-컨테이너에-대한-연산",
    "title": "컨테이너",
    "section": "2 일반적인 컨테이너에 대한 연산",
    "text": "2 일반적인 컨테이너에 대한 연산\n\n∈, ∉\n우선 in 혹은 ∈ (\\in+[tab]) 은 어떤 아이템이 컨테이너에 속해있는지 여부를 true/false 로 반환합니다. 반대로 ∉(\\notin+[tab]) 은 아이템이 컨테이너에 포함되어 있지 않을 때 true 를 반환합니다. StepRange, 벡터, 집합에의 포함 여부는 다음과 같이 알 수 있습니다.\nIn [10]: 1 ∈ 1:10\nOut[10]: true\n\nIn [11]: \"a\" ∈ (2, \"5\", \"a\")\nOut[11]: true\n\nIn [12]: \"a\" ∉ (2, \"5\", \"a\")\nOut[12]: false\n\nJulia 는 키-값 쌍을 Pair 라는 객체로 처리합니다. 사전에 어떤 키가 포함되어있는지, 값이 포함되어 있는지는 keys, values 함수로 알 수 있습니다. 키-값 쌍이 있는지는 다음과 같이 확인 할 수 있습니다.\nIn [13]: Pair(\"a\", 1) ∈ Dict(\"a\"=&gt;1, \"b\"=&gt;2)\nOut[13]: true\n\n우리는 앞서 홑따옴표 ' ' 안에는 글자 하나만 포함 될 수 있으며 Char 타입이고 겹따옴표 \" \" 는 한줄 문자열, 세겹따옴표는 \"\"\" \"\"\" 여러줄 문자열을 포함한다는 것을 알았습니다. 따라서 ∈ 나 ∉ 연산자로 포함 여부를 확인할 때 연산자의 왼쪽에는 Char 형식의 한 글자에 대해서만 가능합니다. 즉\nIn [19]: 'a' ∈ \"abc\"\nOut[19]: true\n\nIn [20]: \"a\" ∈ \"abc\"\nERROR: use occursin(needle, haystack) for string containment\n...\n의 결과를 보입니다. \"a\" 는 하나의 성분을 갖는 컨테이너이므로 ∈ 나 ∉ 의 왼쪽에 올 수 없습니다.\n\n\n\nlength\nlength 함수는 컨테이너에 포함된 아이템의 갯수를 반환합니다.\nIn [1]: length(Dict(\"a\"=&gt;1, \"b\"=&gt;2))\nOut[1]: 2\n\nIn [2]: length([1, 2, (3, 4, 5)])\nOut[2]: 3\n\n\n\neltype\neltype 은 컨테이너에 포함된 아이템의 타입을 반환합니다.\nIn [1]: eltype([1.0, 2.0, 3.0])\nOut[1]: Float64\n\nIn [2]: eltype(['a', 'b', 'c'])\nOut[2]: Char\n\n\n\nunique\n컨테이너에 포함된 아이템 가운데 중복되는 것을 제외한 아이템들을 벡터로 반환합니다.\njulia&gt; unique((1, 2, 3, 1, 2, 4))\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\n\n\n... 연산자\n... 연산자가 함수의 정의나 실행시에 사용되는 것에 대해서는 Interude : ‘…’ 연산자 에 대해 좀 더 자세히 다루었습니다.\n순서가 있는 컨테이너에서 앞부분의 몇개만 중요할 때 사용할 수 있습니다. 예를 들어\nIn [1]: a, b, c... = [4, 8, 15, 16, 23, 42]\nOut[1]: 6-element Vector{Int64}:\n  4\n  8\n 15\n 16\n 23\n 42\n\nIn [2]: a\nOut[2]: 4\n\nIn [3]: b\nOut[3]: 8\n\nIn [4]: c\nOut[4]: 4-element Vector{Int64}:\n 15\n 16\n 23\n 42\n입니다. 즉 1차원 배열 A 에 대해 첫번째 두개만 중요할 경우 a, b, c.. = arr1 와 같이 사용하면 a==A[1], b==A[2] 이며 c==A[3:end] 가 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "컨테이너"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04_containers.html#주로-수로-이루어진-순서가-있는-컨테이너에서-이루어지는-연산",
    "href": "src/introduction_to_julia/04_containers.html#주로-수로-이루어진-순서가-있는-컨테이너에서-이루어지는-연산",
    "title": "컨테이너",
    "section": "3 주로 수로 이루어진 순서가 있는 컨테이너에서 이루어지는 연산",
    "text": "3 주로 수로 이루어진 순서가 있는 컨테이너에서 이루어지는 연산\n여기서는 벡터나 StepRange 같은 인덱스로 접근 가능한 컨테이너에 대해 성분이 모두 수로 이루어졌을 때 사용할 수 있는 연산에 대해 다루도록 하겠습니다. 많은 경우 수가 아닌 경우에도 사용 할 수 있지만 여기서는 수로 이루어진 컨테이너에 대해서만 논의하기로 합니다.\n\n\n. 연산 (도트 연산)\n벡터나 튜플, StepRange 같은 컨테이너의 아이템 마다 함수나 연산자를 적용시킬 때 도트 연산자 . 를 사용할 수 있습니다. 함수 이름의 끝에 . 를 붙이거나, 연산자의 앞에 . 를 붙입니다. 이를 도트 연산이라고 합니다.\n\n스칼라와 컨테이너의 연산에서는 컨테이너의 각 성분과 스칼라와의 연산 결과를 반환합니다.\n순서가 있는 컨테이너과 컨에티너의 연산에서는 컨테이너의 각 순서별 성분끼리 연산합니다.\n순서가 없는 컨테이너(예를 들어 집합(Set)) 에 도트연산을 수행 할 수 있지만 그 순서가 유지되지 않으며, 어쨋든 계산이 되면 그 결과는 벡터가 됩니다.\n\n아래의 코드를 봅시다.\n# 스칼라와 컨테이너의 도트 연산\nIn [13]: 3 .* (1, 2, 3)\nOut[13]: (3, 6, 9)\n\n# 순서가 있는 컨테이너의 도트 연산\nIn [14]: [1, 2, 3] .* [-1, 0, 1]\nOut[14]: 3-element Vector{Int64}:\n -1\n  0\n  3\n\n# 함수에서의 도트 연산. 함수 이름 끝에 . 를 붙이기만 하면 됩니다.\nIn [15]: sin.([-π/2, 0.0, π/2])\nOut[15]: 3-element Vector{Float64}:\n -1.0\n  0.0\n  1.0\n\n# 순서가 없는 컨테이너에 대한 도트 연산. 순서가 유지되지 않음.\nIn [16]: 3.0 .* Set([1, 2, 3])\nOut[16]: 3-element Vector{Float64}:\n 6.0\n 9.0\n 3.0\n\n함수나 연산자마다 . 을 붙여주는 것이 코드의 가독성을 해치거나 오류의 원인이 될 수 있습니다. 이때는 표현식 앞에 @. 를 붙여주면 julia 는 모든 연산자와 함수에 필요할 때 . 가 붙은 것처럼 작동하도록 합니다. @ 로 시작하는 명령문은 매크로라고 하며 특정한 기능을 하는 함수로 julia 의 핵심적인 기능중의 하나입니다. 자세한 것은 메타프로그래밍과 매크로 에서 다루겠습니다. 일단 다음 코드를 봅시다.\nIn [1]: @. 3+[1,2,3,4]\nOut[1]: 4-element Vector{Int64}:\n 4\n 5\n 6\n 7\n\nIn [2]: @. sin(0.0:0.1:π)\nOut[2]: 32-element Vector{Float64}:\n 0.0\n 0.09983341664682815\n 0.19866933079506122\n 0.2955202066613396\n 0.3894183423086505\n 0.479425538604203\n ⋮\n 0.4273798802338298\n 0.33498815015590466\n 0.23924932921398198\n 0.1411200080598672\n 0.04158066243329049\n\nIn [3]: a = @. 3 * [1,2,3]\nOut[3]: 3-element Vector{Int64}:\n 3\n 6\n 9\n\n\n\n\n\n\n도트연산자와 소숫점의 혼동\n\n\n\n3.*[1, 2, 3] 수행하면 (3 과 .* 사이에 공백이 없는 경우 입니다) 에러가 발생합니다. Julia 에서는 정수 다음에 . 이 붙을 경우 부동소수로 간주합니다. 예를 들어 julia 는 -1. 을 -1.0 으로 해석합니다. 따라서 3.*[1, 2, 3] 는 (3.0) * [1, 2, 3] 로 해석 될 수도 있고 (3) .* [1, 2, 3] 으로 해석 될 수도 있습니다. .* 와 같이 도트를 앞에 붙여서 사용하는 연산의 경우는 . 앞에 공백을 앞에 두는 습관을 들이는 것이 좋습니다.\n\n\n1차원 컨테이너 끼리의 도트 연산을 위해서는 컨테이너의 크기가 같아야 합니다. 다차원 배열의 경우는 배열 에서 다루겠습니다.\n\n\n\nminimum, maximum, extrema\n이 함수들은 컨테이너에 포함되는 값 가운데의 최소값(minimum), 최대값(maximum), 그리고 둘 다(extrema)를 반환합니다. 단 이때는 컨테이너의 모든 아이템들이 서로 비교 가능해야 합니다. 예를 들어 정수와 부동소수는 비교가능 하지만 수와 문자열은 서로 크기를 비교 할 수 없습니다. 따라서 수와 문자열을 같이 포함하는 컨테이너에서는 위의 함수들을 사용 할 수 없습니다.\nIn [23]: extrema(1:5)\nOut[23]: (1, 5)\n\nIn [24]: maximum([1, 2, \"ab\"])\nERROR: MethodError: no method matching isless(::String, ::Int64)\n...\n이 함수들은 어떤 컨테이너의 극값 뿐만 아니라 컨테이너에 함수를 적용했을 때의 최대값 최소값을 구하는 데도 사용 할 수 있습니다. 예를 들어,\nIn [25]: extrema(cos, 0:π/1000:π)\nOut[25]: (-1.0, 1.0)\n는 0:π/1000:π 에 대한 각각의 cos 값의 최소값과 최대값을 반환합니다.\n\n\n\nargmin, argmax, findmin, findmax\nargmin, argmax 는 각각 컨테이너에서 최소값과 최대값의 인덱스를 반환하며, 그 값이 여러개일 경우 첫번째 인덱스를 반환합니다. findmin, findmax 는 각각 최대값, 최소값에 대해 값과 인덱스를 튜플로 반환합니다.\nIn [29]: argmin([2, 3, 1, 2, 3, 1, 4, 1, 6])\nOut[29]: 3\n\nIn [30]: findmax([2, 3, 1, 2, 3, 1, 4, 1, 6])\nOut[30]: (6, 9)\n함수에 대한 결과값의 최대, 최소를 구할 수도 있습니다.\nIn [35]: findmax(cos, range(0.0, π, length=30))\nOut[35]: (1.0, 1)\n\n\n\n\n\n\nargmin, argmax 의 주의사항\n\n\n\nargmin, argmax 도 함수를 입력하면 에러가 나지 않지만 우리가 기대하는 행동을 하지 않습니다. 예를 들어\nIn [37]: argmin(cos, range(0.0, π, length=30))\nOut[37]: 3.141592653589793\n의 경우 range(0.0, π, length=30) 에 cos 함수를 적용시켰을 때 최소값이 나오는 인덱스(이경우30) 이 나오길 기대할 수 있지만 cos 함수를 최소화하는 range(0.0, π, length=30) 에서의 값을 반환합니다. argmax 도 같은 방식으로 동작합니다. 혼란을 줄 수 있으므로 왠만하면 argmin, argmax 는 사용하지 말고 findmin, findmax 를 사용하시기를 권합니다.\n\n\n\n\n\nmap\n함수 f 와 컨테이너 c 에 대해 map(f, c) 는 c 의 개별적인 성분에 f 를 적용한 값을 리턴합니다.\nIn [1]: map(abs, [1, -1, 2, -2, 3, -5])\nOut[1]: 6-element Vector{Int64}:\n 1\n 1\n 2\n 2\n 3\n 5\n\n인자가 여러개인 함수에 대해서는 여러개의 컨테이너를 인자로 입력합니다.\nIn [4]: f(x, y) = x+y\nOut[4]: f (generic function with 1 method)\n\nIn [5]: map(f, [1,2, 3], [3, 4,5])\nOut[5]: 3-element Vector{Int64}:\n 4\n 6\n 8\n\n인자로 주어지는 컨테이너의 갯수가 다를 때는 길이가 최소인 컨테이너에 맞추며 나머지 컨테이너의 성분은 무시합니다.\nIn [6]: map(f, [1,2, 3], [3, 4,5, 6, 7])\nOut[6]: 3-element Vector{Int64}:\n 4\n 6\n 8\n\n함수 뿐만 아니라 연산자가 올 수 도 있습니다.\nIn [8]: map(÷, [4, 7, 9], [2, 3, 5])\nOut[8]: 3-element Vector{Int64}:\n 2\n 2\n 1\n\n\n익명 함수의 사용\nmap 뿐만 아니라 바로 뒤에 나올 reduce, mapreduce, filter 에 익명 함수 가 아주 유용하게 사용될 수 있습니다. 예를 들어\nIn [3]: map(x-&gt;cos(x)+1, range(0, π, length=4))\nOut[3]: 4-element Vector{Float64}:\n 2.0\n 1.5\n 0.5000000000000002\n 0.0\n를 봅시다. range(0, π, length=4) 는 0 부터 π 까지 같은 간격을 가진 4개의 성분을 가진 배열을 만듭니다. 이 배열의 각각의 성분에 cos 함수를 취한후 1 을 더하는 익명함수 x-&gt;cos(x)+1 을 적용시킨 결과입니다. 도트 연산자르르 사용하면 똑같은 일을 할 수 있지만 아무래도 map 함수 쪽이 훨씬 읽기 편합니다.\nIn [3]: cos.(range(0, π, length=4)) .+ 1\n\n\n\ndo ... end, begin ... end 의 사용\ndo ... end 구문이나 begin ... end 구문 역시 일종의 익명 함수를 만드는 데 사용될 수 있습니다. 당연히 컨테이너에만 사용되는 것은 아니지만 컨테이에 대한 연산, 특히 map 이나 앞으로 나올 reduce, filter 등의 함수에 유용하게 사용 할 수 있습니다. 일단 In [3] 와 같은 결과를 내는 코드는 다음과 같습니다.\\(^\\ast\\) \\(^\\ast\\) 함수의 정의에서 return 문이 없다면 end 바로전의 표현식의 결과를 반환한다는 것을 알았습니다. 아래 코드에서도 마찬가지로 return cos(x)+1 대신에 cos(x)+1 만 있어도 실행됩니다.\nIn [4]: map(range(0, π, length=4)) do x\n        return cos(x)+1\n        end\n\nIn [5]: map( x-&gt; begin\n        return cos(x) +1\n        end\n        , range(0, π, length=4))\n우선 함수 f1 을 첫번째 인자로 받는 함수 mfunc(f1, b...) 에서 f1 의 정의를 mfunc(b...) do x 로 시작합니다. 이 때 x 는 f1 의 인자입니다. 그 이후 구문은 end 가 나올 때 까지 f1 을 정의하는 구문과 같습니다. do ... end 구문이나 begin ... end 구문에서는 변수를 선언하여 활용 할 수 있습니다.\nmap(0.0:0.1:π) do x\n    y = sqrt(x)\n    z = x^2\n    cos(y+z)\nend\n이 코드는 다음과 두 코드와 각각 같습니다.\nfunction f1(x)\n    y = sqrt(x)\n    z = x^2\n    cos(y+z)\nend\n\nmap(f1, 0.0:0.1:π)\nmap(x-&gt;begin\n    y = sqrt(x)\n    z = x^2\n    cos(y+z)\n    end, \n    0.0:0.1:π)\n\n\n\n\nreduce\nmap 이 컨테이너의 각 성분에 연산을 수행한다면, 그래서 결과는 입력된 컨테이너의 길이와 같은 벡터가 된다면 reduce 는 컨테이너에 대해 각각의 성분에 대해 연산을 수행하여 하나의 값을 얻는데 사용합니다. 예를 들어\nreduce(+, [1,2, 3, 4])\n를 봅시다. reduce 는 우선 첫번째와 두번째 성분으로 주어진 연산자나 함수에 대해 계산한 후 결과값을 세번째성분과 계산하고 이것을 마지막 성분까지 계속합니다. 즉 위의 코드는 (((1+2)+3)+4) 와 같습니다. 그렇다면\nreduce(-, [1,2, 3, 4])\n는 (((1-2)-3)-4) 와 같습니다.\n\n\n\nmapreduce\nmapreduc 는 map 과 reduce 를 합친 기능을 합니다. mapreduce(f, op, iter) 는 reduce(op, map(f, iter)) 와 같은 역할을 합니다. 예를 들어 다음 두 명령어는 기능적으로 같습니다. 1 에서 10 까지의 정수를 제곱한 배열을 만든 후 그 배열의 합을 구하는 것입니다.\nmapreduce(x-&gt;x^2, +, 1:10)\nreduce(+, map(x-&gt;x^2, 1:10))\n\n\nfilter\nfilter(f, c) 에서 f 는 true 혹은 false 를 반환하는 함수나 연산자이어야 합니다. 컨테이너의 성분에 함수를 적용했을 때 참인 성분만을 골라 반환합니다. 예를 들어,\nIn [1]: filter(x-&gt;(x&gt;3), [1,2,3,4,5])\nOut[1]: 2-element Vector{Int64}:\n 4\n 5\n를 봅시다. x-&gt;(x&gt;3) 은 익명함수로 x&gt;3 의 조건을 만족하면 true, 그렇지 않다면 false 를 리턴합니다. 따라서 이 조건을 만족하는 [4, 5] 만을 반환합니다.\n참고로 3보다 큰 성분을 배열로 리턴하는 것이 아니라 3보다 크면 1, 3보다 작으면 0 을 리턴하도록 하려면 어떻게 하면 될까요? 아래를 보고 왜 이렇게 작동하는지 생각해 보시기 바랍니다.\nIn [2]: [1, 2, 3, 4, 5] .&gt; 3\nOut[2]: 5-element BitVector:\n 0\n 0\n 0\n 1\n 1",
    "crumbs": [
      "Julia 언어의 기초",
      "컨테이너"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html",
    "href": "src/introduction_to_julia/02_variables_basic_types.html",
    "title": "변수와 기본 타입",
    "section": "",
    "text": "많은 프로그래밍 언어처럼 변수에 어떤 값을 지정할 수 있습니다. 이것을 변수 할당이라고 하며 = 기호를 사용합니다. a 문자에 3 이라는 값을 값을 할당하고, 거기에 2 를 곱한 결과를 얻는 것은 다음과 같이 할 수 있습니다. 이 때 변수는 = 기호의 왼쪽에, 값은 오른쪽에 위치해야 합니다.\nIn [1]: a=3\nOut[1]: 2\n수학에서처럼 값이 할당된 변수는 계산에 사용되거나 함수에 인자로 사용 될 수 있습니다.\nIn [2]: a*2\nOut[2]: 6\n\nIn [3]: abs(a)\nOut[3]: 3\n변수에 할당 될 수 있는 것은 수(number) 뿐만이 아닙니다. 앞으로 배울 거의 모든 것이 변수에 할당 될 수 있습니다. 예를 들어 sin(x) 은 짐작 할 수 있듯이 x 에 대한 sin 함수값을 반환하는 함수입니다. 그런데 myfunc = sin 하면 어떻게 될까요?\nIn [1]: myfunc = sin\nOut[1]: sin (generic function with 14 methods)\n\nIn [2]: myfunc(π)\nOut[2]: 0.0\n\nIn [3]: myfunc(2π)\nOut[3]: -2.4492935982947064e-16\nmyfunc 가 sin 함수가 되어 버렸습니다. 이것에 대해 길게 이야기 할 수 있겠지만 일단은 함수도 변수에 할당 될 수 있다는 것을 알아두면 좋겠습니다.\n\n\n\n\n변수 이름에는 제한이 있습니다. 우선 첫문자는 알파벳 대문자(A-Z) 혹은 소문자(a-z) 나 밑줄 _ 혹은 00A0 보다 큰 유니코드 문자 가운데 특정 범주에 속하는 문자들이 와야 합니다. 유니코드 및 수학 기호 지원 를 참고하시기 바랍니다. 한글은 허용됩니다. 자세한 것은 julia 공식 문서 가운데 Variables 을 참고 하십시요. 두번째 글자부터는 첫번째 글자로 허용된 문자에 ! 나 숫자가 올 수 있습니다.\nIn [4]: 파이 = π\nOut[4]: π = 3.1415926535897...\n\nIn [5]: 2*파이\nOut[5]: 6.283185307179586\n\nIn [6]: 맑뚫 = 3; 맑뚫*3\nOut[6]: 9\n\n앞서 유니코드 및 수학 기호 지원 에서 언급했듯이 π 나 ℯ 는 이미 값이 지정되어 있습니다. 그 외의 θ(\\theta + [tab]), φ(\\varphi + [tab]), ϕ(\\phi + [tab]), Γ(\\Gamma + [tab]) 와 같이 수학, 과학, 공학에서 많이 사용되는 기호들을 변수로 사용 할 수 있습니다.\nIn [1]: θ = π/4; cos(θ)\nOut[1]: 0.7071067811865476",
    "crumbs": [
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#변수",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#변수",
    "title": "변수와 기본 타입",
    "section": "",
    "text": "많은 프로그래밍 언어처럼 변수에 어떤 값을 지정할 수 있습니다. 이것을 변수 할당이라고 하며 = 기호를 사용합니다. a 문자에 3 이라는 값을 값을 할당하고, 거기에 2 를 곱한 결과를 얻는 것은 다음과 같이 할 수 있습니다. 이 때 변수는 = 기호의 왼쪽에, 값은 오른쪽에 위치해야 합니다.\nIn [1]: a=3\nOut[1]: 2\n수학에서처럼 값이 할당된 변수는 계산에 사용되거나 함수에 인자로 사용 될 수 있습니다.\nIn [2]: a*2\nOut[2]: 6\n\nIn [3]: abs(a)\nOut[3]: 3\n변수에 할당 될 수 있는 것은 수(number) 뿐만이 아닙니다. 앞으로 배울 거의 모든 것이 변수에 할당 될 수 있습니다. 예를 들어 sin(x) 은 짐작 할 수 있듯이 x 에 대한 sin 함수값을 반환하는 함수입니다. 그런데 myfunc = sin 하면 어떻게 될까요?\nIn [1]: myfunc = sin\nOut[1]: sin (generic function with 14 methods)\n\nIn [2]: myfunc(π)\nOut[2]: 0.0\n\nIn [3]: myfunc(2π)\nOut[3]: -2.4492935982947064e-16\nmyfunc 가 sin 함수가 되어 버렸습니다. 이것에 대해 길게 이야기 할 수 있겠지만 일단은 함수도 변수에 할당 될 수 있다는 것을 알아두면 좋겠습니다.\n\n\n\n\n변수 이름에는 제한이 있습니다. 우선 첫문자는 알파벳 대문자(A-Z) 혹은 소문자(a-z) 나 밑줄 _ 혹은 00A0 보다 큰 유니코드 문자 가운데 특정 범주에 속하는 문자들이 와야 합니다. 유니코드 및 수학 기호 지원 를 참고하시기 바랍니다. 한글은 허용됩니다. 자세한 것은 julia 공식 문서 가운데 Variables 을 참고 하십시요. 두번째 글자부터는 첫번째 글자로 허용된 문자에 ! 나 숫자가 올 수 있습니다.\nIn [4]: 파이 = π\nOut[4]: π = 3.1415926535897...\n\nIn [5]: 2*파이\nOut[5]: 6.283185307179586\n\nIn [6]: 맑뚫 = 3; 맑뚫*3\nOut[6]: 9\n\n앞서 유니코드 및 수학 기호 지원 에서 언급했듯이 π 나 ℯ 는 이미 값이 지정되어 있습니다. 그 외의 θ(\\theta + [tab]), φ(\\varphi + [tab]), ϕ(\\phi + [tab]), Γ(\\Gamma + [tab]) 와 같이 수학, 과학, 공학에서 많이 사용되는 기호들을 변수로 사용 할 수 있습니다.\nIn [1]: θ = π/4; cos(θ)\nOut[1]: 0.7071067811865476",
    "crumbs": [
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#sec-primary_number_types",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#sec-primary_number_types",
    "title": "변수와 기본 타입",
    "section": "2 기본적인 수 타입",
    "text": "2 기본적인 수 타입\n수(number) 를 포함하는 julia 에서 사용하는 모든 값(value) 은 타입(type) 을 갖습니다. 여기서는 julia 언어 자체에서 정의된 기본 타입 가운데 수(number) 에 관련된 타입은 아래와 같습니다.\n\n\n\n\n\n\n\n타입 종류\n타입들\n\n\n\n\n부호 없는 정수 타입\nUInt8, UInt16, UInt32, UInt64, UInt128\n\n\n정수 타입\nInt8, Int16, Int32, Int64, Int128, BigInt\n\n\n유리수 타입\nRational\n\n\n부동소수 타입\nFloat16, Float32, Float64, BigFloat\n\n\n무리수 타입\nIrrational\n\n\n복소수 타입\nComplex\n\n\n불 타입\nBool\n\n\n\n\n부호 없는 정수는 0 과 양의 정수를 말합니다.\n앞서 언급한 π (\\(\\pi\\), 원주율) 나 ℯ (\\(e\\), 자연로그의 밑) 는 무리수 타입으로, 연산할 때 가장 적절한 타입으로 변환되어 계산됩니다.\n타입 이름은 다른 타입의 값을 타입으로 변환시키는 함수처럼 사용 할 수 있습니다. Float64(1) 은 1 을 Float64 타입으로 변환시킵니다.\n실제 Julia 의 타입 구조는 이보다 훨씬 복잡합니다. 이후 타입 계층 구조 에서 좀 더 자세히 설명하도록 하겠습니다.\n\n\n어떤 변수나 값의 타입을 알기 위해서는 typeof() 함수를 사용 할 수 있습니다.\nIn [4]: typeof(UInt8(2))\nOut[4]: UInt8\n\n\n정수형 타입\n우선 부호 없는 정수타입, 정수타입, 부동소수 타입의 이름의 끝부분에 붙는 8, 16, 32, 64, 128 은 각 타입의 값이 차지하는 비트(bit) 수 입니다. 비트는 on/off 혹은 0/1 로 구분되는 정보 단위입니다. 예를 들어 UInt8 의 경우는 8개의 비트로 수를 표현합니다. 2진수로 00000000 은 0 이며 2진수 11111111 은 255 입니다. UInt8 은 이렇게 0 부터 255 까지의 값을 표현 할 수 있습니다. UInt64 는 64 개의 비트로 숫자를 저장하며, 따라서 0부터 264-1 까지의 숫자를 표현 할 수 있습니다.\nInt8 의 경우는 8비트로 정수를 저장하지만 한 비트는 음수/양수 를 구분하기 위해 사용됩니다. -128 부터 127 까지의 정수를 표현 할 수 있습니다. Int64 는 -232 부터 232-1 까지의 숫자를 표현 할 수 있습니다.\n\n\n\n타입\n부호\n비트수\n최소값\n최대값\n\n\n\n\nInt8\no\n8\n-27\n27 - 1\n\n\nUInt8\nx\n8\n0\n28 - 1\n\n\nInt16\no\n16\n-215\n215 - 1\n\n\nUInt16\nx\n16\n0\n216 - 1\n\n\nInt32\no\n32\n-231\n231 - 1\n\n\nUInt32\nx\n32\n0\n232 - 1\n\n\nInt64\no\n64\n-263\n263 - 1\n\n\nUInt64\nx\n64\n0\n264 - 1\n\n\nInt128\no\n128\n-2127\n2127 - 1\n\n\nUInt128\nx\n128\n0\n2128 - 1\n\n\nBool\nN/A\n8\nfalse (0)\ntrue (1)\n\n\n\n\nmyint=3 처럼 변수를 할당하면 시스템 마다 지정된 기본 타입으로 처리됩니다. 보통의 경우는 Int64 이며 시스템에 따라 Int32 나 다른 타입일 수 있습니다. 보통 Int 가 기본 정수형과 같은 의미로 사용되므로 다음과 같은 입력을 통해 기본 정수형을 알 수 있습니다.\nIn [1]: Int\nOut[1]: Int64\n긴 숫자를 표현할 때 오류를 줄이는 방법으로 밑줄 _ 을 사용할 수 있습니다. 예를 들어 a=123_4567_89_12 는 밑줄을 없엔 a=12345678912 와 같습니다. 다만 두개 이상의 밑줄을 연속적으로 사용 할 수는 없습니다. 1_2 는 사용 할 수 있지만 1__2는 에러를 냅니다.\nIn [2]: a=123_4567_89_12\nOut[2]: 12345678912\n\n\nOverflow\n타입이 허용하는 범위의 값을 넘어서는 값을 할당하려 할 때에는 에러가 발생합니다.\nIn [1]: a::UInt8 = 300\nERROR: InexactError: trunc(UInt8, 300)\n...\na::UInt8 = 300 은 UInt8 타입의 변수 a 에 값 300 을 할당하는 명령어입니다. 만얄 a::UInt8=2 라면 2 는 UInt8 범위 내의 수이기 때문에 문제가 발생하지 않지만 300 은 UInt8 의 범위를 벗어나기 떼문에 에러가 발생합니다. 아래의 경우는 에러가 발생되지 않고 틀린 결과가 나옵니다.\nIn [2]: b = UInt8(200)+UInt8(56)\nOut[2]: 0x00\n200 과 56 은 모두 UInt8 의 범위 안이지만 그 합 256 은 범위를 벗어납니다. 이렇게 정수 타입에서 범위를 넘어서는 값이 할당되거나 계산될 때 실제 계산되어야 할 값과는 다른 값이 나오는 것을 overflow 라고 합니다. 해결책은 연산을 잘 조작하여 타입의 범위 내에서 원하는 결과를 얻을 수 있게 하거나, 당신의 변수가 가질 수 있을 가능성이 있는 값을 모두 포함하는 타입을 쓰는 것 밖에는 없습니다. Overflow 시 결과가 어떻게 나오는 지 알고 싶다면 공식 매뉴얼의 Overflow behavior 를 참고하시기 바랍니다.\n\n\n\n\n부동소수 타입\n부동소수는 일반적인 실수 (real number) 를 표현하기 위한 타입으로 가장 많이 사용하며, 부동소수의 기본타입인 Float64 타입의 경우 fn1 = 3.33 나 fn2=2.3e-4 처럼 사용합니다. 후자의 경우는 2.3 × 10-4 와 같습니다. 그리고 e 대신 E 를 사용해도 됩니다. e 나 E 대신 f 를 사용하면 Float32 타입으로 지정됩니다.(F 는 사용 할 수 없습니다.) 2.3f0 의 경우는 Float32 타입의 2.3 을 의미하며 2.3f2 와 2.3f-2 의 경우는 각각 Float32 타입의 2.3 × 102 와 2.3 × 10-2 를 의미합니다. 부동정수형과 마찬가지로 숫자 사이에 밑줄을 넣어서 사용 할 수 있습니다. 혹은 정수에서와 같이 a::Float32=3.3 처럼 변수에 타입을 지정할 수 있습니다. 이 경우 할당되는 값이 지정된 타입(여기서는 Float32)으로 변환됩니다.\nIn [1]: 3.14_1592\nOut[1]: 3.141592\n\nIn [2]: c::Float32=3.3\nOut[2]: 3.3\n\nIn [3]: typeof(c)\nOut[3]: Float32\n\nIn [4]: c\nOut[4]: 3.3f0\n\n\n\n유리수 타입 (Rational) 과 복소수 타입 (Complex)\n유리수 타입은 두개의 정수 타입을 이용하여 하나는 분모, 하나는 분자로 사용하여 유리수를 표현합니다. 복소수 타입은 두개의 실수를 이용하여 하나는 실수부, 하나는 허수부로 사용하여 복소수를 표현합니다.\nRational 타입의 경우 // 연산자를 이용하거나 Rational(3, 4) 와 같이 할당합니다.. a=1//3 는 Rational(1, 3) 과 같고, a 라는 변수에 \\(\\frac{1}{3}\\) 을 저장합니다. 유리수값끼리의 혹은 유리수값과 정수의 사칙연산은 유리수가 되며, 자동적으로 약분하여 가장 간단한 값으로 처리됩니다.\nIn [1]: 6//5 + 1 # 유리수와 정수의 연산\nOut[1]: 11//5\n\nIn [2]: 1//2 + 1.0 # 유리수와 실수의 연산\nOut[2]: 1.5\n\nIn [3]: 27//12   # 유리수 입력은 자동으로 약분된다.\nOut[3]: 9//4\n\nIn [4]: 1//12 + 2//12 # 유리수 연산 후 약분된다.\nOut[4]: 1//4\n\nComplex 타입의 경우는 2.0 + 3.0im 혹은 Complex(2.0, 3.0) 과 같이 할당합니다. Julia 에서 im 은 \\(\\sqrt{-1}\\) 로 정의되었으며 i 나 j 와 같은 문자를 사용하지 않습니다. conj() 함수는 켤레복소수를 반환합니다.\nIn [7]: (1.0+1.0im)*(1.0-1.0im)\nOut[7]: 2.0 + 0.0im\n\nIn [8]: conj(Complex(1.0, 1.0))\nOut[8]: 1.0 - 1.0im\n\n\n\n불(Bool) 타입\n불(Bool) 타입은 참을 나타내는 true 와 거짓을 나타내는 false 의 두 값만을 표현하는 정수형 타입입니다. 수로 변환하면 true 는 1 이며 false 는 0 입니다. 거꾸로 수를 불 타입으로 변환하는 경우 1 혹은 1 과 같다고 평가되는 1.0f0 와 같은 수는 true 로 0 혹은 0 과 같다고 평가되는 0.0 은 false 로 변환됩니다. Python 과 같은 언어에서는 0 혹은 0 과 같다고 평가되는 수만 False 이고 나머지 수는 모두 True 로 평가됩니다.\nIn [1]: Bool(-3)\nERROR: InexactError: Bool(-3)\n...\n\nIn [2]: Bool(1.0)\nOut[2]: true\n\nIn [3]: Bool(1.0f0)\nOut[3]: true\n\nIn [4]: Bool(3//3)\nOut[4]: true\n\nIn [5]: Bool(0//1)\nOut[5]: false\n\n\n\n타입 확인\n변수의 값이 특정 타입인지를 비교해야 할 때 가장 간단하게 사용할 수 있는 함수는 isa 입니다. isa 는 함수이기도 하지만 연산자이기도 합니다.\nIn [1]: isa(3.3f0, Float32)   # isa 를 함수처럼 사용할 경우\nOut[1]: true\n\nIn [2]: 3.3f0 isa Float64     # isa 를 연산자처럼 사용할 경우\nOut[2]: false\n\n\n\n타입 변환\n앞서 언급했듯이 타입 이름은 그 타입으로 변환시키는 함수처럼 사용 할 수 있습니다.\nIn [5]: Float32(3.32)\nOut[5]: 3.32f0\n어떤 언어에서는 실수를 정수로 변환할 때 억지로라도 변환시켜주지만 julia 에서는 실수가 정수와 같지 않으면 에러가 발생합니다.\nIn [6]: Int64(2.0)\nOut[6]: 2\n\nIn [7]: Int64(2.001)\nERROR: InexactError: Int64(2.001)\n...\n이때는 반올림 (round), 내림(floor), 올림(ceil) 함수를 사용 할 수 있습니다. 이 함수들은 입력값의 타입으로 반올림한 값을 반환합니다. round(3.3) 처럼 사용해도 되지만 특정 정수 타입으로 변환할때는 ceil(UInt16, 4.2) 처럼 타입을 명시하여 변환해야 합니다.\nIn [8]: round(2.3)\nOut[8]: 2.0\n\nIn [9]: floor(4.3f0)\nOut[9]: 4.0f0\n\nIn [10]: ceil(UInt16, 4.2)\nOut[10]: 0x0005",
    "crumbs": [
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#sec-char_and_string_types",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#sec-char_and_string_types",
    "title": "변수와 기본 타입",
    "section": "3 문자와 문자열, 기호 타입",
    "text": "3 문자와 문자열, 기호 타입\n\nChar 와 String 타입\nChar 는 ascii 나 유니코드 하나의 문자에 대한 타입이며 String 은 하나 이상의 문자를 포함하는 문자열에 대한 타입입니다. Char 타입은 'a' 와 같이 따옴표 ' 로 감싸서 선언합니다. 한줄 문자열은 겹따옴표(\") 로 감싸고 여러줄 문자열은 겹따옴표 세개(\"\"\")로 감쌉니다. 문자열을 출력할때는 println 함수를 사용합니다. println 함수의 경우 인자를 , 로 분리하여 계속 써 주면 각각의 인자를 문자열로 변환하여 연결시켜 하나의 문자열을 출력합니다.\nIn [11]: char1='가'\nOut[11]: '가': Unicode U+AC00 (category Lo: Letter, other)\n\nIn [12]: str1 = \"Hello, world.\\n\"\nOut[12]: \"Hello, world.\\n\"\n\nIn [13]: str2 = \"\"\"Julia is\n                a good programing\n                language\"\"\"\nOut[13]: \"Julia is\\na good programing\\nlanguage\"\n\nIn [14]: println(str2)\nJulia is\na good programing\nlanguage\n\nIn [15]: println(1, \"ab\", \" c_d \", 3.3)\n1ab c_d 3.3\n문자열 내의 \\n 은 개행문자라고 해서 출력할 때 줄바꿈을 해 주는 문자입니다. asciii 는 컴퓨터 자판에서 보이는 숫자, 영어 알파벳과 기호를 포함하며 각 문자가 1바이트를 차지합니다. ascii 문자로 이루어진 문자열은 1부터 시작하는 인덱스로 접근 할 수 있습니다.\nIn [16]: str3 = \"I love Julia language !!!\"\nOut[16]: \"I love Julia language !!!\"\n\nIn [17]: str3[1], str3[end], str3[end-4]\nOut[17]: ('I', '!', 'e')\n인덱스에서 end 는 맨 마지막 인덱스를 의미하며 end-4 은 마지막에서 다섯번째 글자를 의미합니다. end-2 는 마지막에서 세번째입니다. 정확히 말하면 str3[3] 은 문자열 str3 에서 세번째 글자가 아니라 세번째 바이트에서 시작하는 문자를 의미합니다. ascii 에서는 각 문자가 1 바이트를 차지하기 때문에 세번째 바이트에서 시작하는 문자와 세번째 문자가 같지만 2 바이트 이상을 차지하는 문자에서는 다른 의미가 됩니다.\n\n\n\n유니코드(Unicode)\n유니코드(unicode) 는 전 세계의 모든 문자를 다룰 수 있도록 제정된 표준 문자 처리 방식입니다. 유니코드를 표기할때는 U+0A03 처럼 U+ 와 16진수의 결합으로 표현합니다. 앞서 언급한 Unicode Input 에 julia 에서 표현 할 수 있는 문자들이 나열되어있습니다.\n유니코드를 문자열로 표현할 때는 탭으로 완성되는 문자를 사용 할 수도 있고 다음처럼 \\u 혹은 \\U 로 시작되는 문자로 표현 할 수도 있습니다. \\u 다음에는 4개까지의 16진수 문자가 올 수 있으며 \\U 다음에는 8개까지의 16진수 문자가 올 수 있고 \\u 를 포함하여 더 많은 문자를 표현 할 수 있습니다. \\u 나 \\U 다음에 오는 숫자 가운데 자릿수를 차지하는 0 은 생략 할 수 있습니다. 예를 들어 \\u0033 은 \\u33 과 같습니다. 그리고 \\U000000 부터 \\U00FFFF 까지는 \\u0000 과 \\uffff 까지와 같습니다. 유니코드는 다음과 같이 사용합니다.\nIn [18]: unistr = \"\\u2200 x \\u2203 y\"\nOut[18]: \"∀ x ∃ y\"\nJulia 에서 유니코드는 UTF-8 로 인코딩 되어 있습니다. UTF-8 에서는 각 문자당 차지하는 바이트수가 다르기 때문에 ascii 와 같은 인덱스를 사용 할 수 없습니다. 앞서 설명했듯이 unistr[2] 는 문자열 unistr 의 2번째 바이트에서 시작하는 문자를 의미하는데 \\u2200 은 3 바이트 문자이므로 2번째 바이트에서 시작하는 문자가 없으므로 에러가 발생합니다.\nIn [19]: unistr[1]\nOut[19]: '∀': Unicode U+2200 (category Sm: Symbol, math)\n\nIn [20]: unistr[2]\nERROR: StringIndexError: invalid index [2], valid nearby indices [1]=&gt;'∀', [4]=&gt;' '\n...\n\nIn [21]: unistr[4]\nOut[21]: ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n그렇다면 문자열의 \\(n\\) 번째 문자는 어떻게 추출할까요? 불편하긴 하지만 collect 함수를 사용할 수 있습니다. collect 함수는 문자열을 분리하여 배열(Array) 로 만듭니다. 즉 unistr[2] 는 문자가 아니지만 collect(unistr)[2] 는 unistr 문자열의 두번째 문자입니다.\n\n\n\n\n\n\n\n유니코드 문자열의 인덱스\n\n\n\n유니코드 문자열을 다룰 때 인덱스의 의미는 언어마다 다릅니다. 예를 들어 Python 에서는 인덱스 가 i 일 때 i 번째 문자를 의미합니다. 아래는 Python shell 에서 같은 일을 한 결과입니다. 참고로 julia 는 인덱스가 1부터 시작하지만 python 은 0 부터 시작하기 때문에 인덱스가 차이가 납니다.\n&gt;&gt;&gt; unistr = \"\\u2200 x \\u2203 y\"\n&gt;&gt;&gt; unistr\n'∀ x ∃ y'\n&gt;&gt;&gt; unistr[0]\n'∀'\n&gt;&gt;&gt; unistr[1]\n' '\n&gt;&gt;&gt; unistr[2]\n'x'\n\n\n\n\n\n문자열 연산과 함수\n\n결합과 반복\n문자열을 합칠 때는 * 연산자를 이용하거나 string() 함수를 이용하며, 여러번 반복할때는 ^ 연산자 나 repeat() 함수를 이용합니다. 실제로 string() 함수는 인자를 차례대로 문자열로 바꾸어 주는 함수입니다.\nIn [1]: \"가나다라\"*\"마바사\" # 문자열 합치기\nOut[1]: \"가나다라마바사\"\n\nIn [2]: string(\"가나다라\", \"abc\", 'π', 5) # 문자열 합치기\nOut[2]: \"가나다라abcπ5\"\n\nIn [3]: \"αβγ\"^3 # 문자열 반복\nOut[3]: \"αβγαβγαβγ\"\n\nIn [4]: repeat(\"Δ=\", 5) # 문자열 반복\nOut[4]: \"Δ=Δ=Δ=Δ=Δ=\"\n문자열의 길이는 length() 함수를 사용하며 문자열에 접근할 때는 str1[3] 과 같이 인덱스를 사용합니다. Julia 에서는 처음 인덱스는 0 이 아닌 1 입니다.\nIn [5]: str3=\"abcdefg\";str3[2]\nOut[5]: 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n\n\n\n문자열 보간(Interpolation)\n문자열에 $ 기호를 통해 이미 정의된 변수를 사용하여 문자열을 구성 할 수 있습니다.\nIn [6]: aa=1;bb=22.2;cc=\"C12\";\n\nIn [7]: \"\"\"aa=$aa, bb=$bb, cc=$cc\"\"\"\nOut[7]: \"aa=1, bb=22.2, cc=C12\"\n보간 이전에 값을 평가해야 할 경우에는 괄호(( )) 안에 식을 넣을 수 있습니다. 예를 들어 \"$sin(π)\" 는 문자열 \"sin(π)\" 지만 \"$(sin(π))\" 는 sin(π) 를 평가한 0.0 이 문자열로 입력됩니다.\nIn [9]: \"$sin(π)\"\nOut[9]: \"sin(π)\"\n\nIn [10]: \"$(sin(π))\"\nOut[10]: \"0.0\"\n\n\n\n비교\n문자열을 사전순으로 비교 할 수 있습니다. 즉 'a' &lt; 'b' 이며 \"aa\" &lt; \"ab\" 입니다.\nIn [11]: \"abracadabra\" &lt; \"xylophone\"\nOut[11]: true\n\nIn [12]: \"abracadabra\" == \"xylophone\"\nOut[12]: false\n\nIn [13]: \"Hello, world.\" != \"Goodbye, world.\"\nOut[13]: true\n\nIn [14]: \"1 + 2 = 3\" == \"1 + 2 = $(1 + 2)\"\nOut[14]: true\n\n\n\n문자열 함수\nfindfirst(a, str) 은 문자열 str 에서 문자 혹은 문자열 a 가 나타는 첫번째 인덱스를 리턴합니다. findlast(a, str) 는 마지막 인덱스를 리턴합니다. findprev(a, str, i) 는 문자열 str 에서 문자 혹은 문자열 a 를 찾는데 인덱스 i 부터 앞으로 찾아가서 나오는 첫번째 인덱스를 반환합니다. findnext(a, str, i) 는 인덱스 i 부터 뒤로 찾아가서 나오는 첫번째 인덱스를 반환합니다. 네가지 경우 모두 찾지 못한다면 nothing 을 반환합니다. a 가 문자열일 경우는 a 와 일치하는 인덱스의 범위를 리턴합니다. 6:7 은 인덱스 6에서 인덱스 7 까지란 의미입니다. occursin(a, str) 은 문자 혹은 문자열 a 가 문자열 str 에 포함되어 있는지만을 확인하여 true 나 false 를 리턴합니다.\nIn [15]: findfirst('a', \"biography\")\nOut[15]: 6\n\nIn [16]: findfirst(\"ap\", \"biography\")\nOut[16]: 6:7\n\nIn [17]: occursin(\"gr\", \"biography\")\nOut[17]: true\n\nIn [18]: occursin(\"rp\", \"biography\")\nOut[18]: false\n\nrepeat(a, n) 은 문자열 a 를 n 번 반복한 문자열을 반환합니다. 여러 문자열을 결합할 때는 join() 함수를 사용합니다.\nIn [19]: repeat(\".:Z:.\", 10)\nOut[19]: \".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.\"\n\nIn [20]: join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\nOut[20]: \"apples, bananas and pineapples\"\njoin 함수의 두번째 인자 \", \" 는 결합하는 문자열 사이에 \", \" 를 끼워 결합하라는 의미입니다. 세번째 인자 \" and \" 는 마지막 두 문자열을 결합할때는 \", \" 대신에 \" and \" 를 사용하라는 의미입니다. 자세한 것은 julia 의 공식 도움말을 참고하시기 바랍니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#sec-symbol_types",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#sec-symbol_types",
    "title": "변수와 기본 타입",
    "section": "4 심볼 타입",
    "text": "4 심볼 타입\n심볼(Symbol) 타입은 문자열과 비슷하지만 다릅니다. 심볼(Symbol) 타입은 : 다음의 문자열, 혹은 Symbol 이라는 타입 이름을 함수로 사용하여 다음과 같이 선언할 수 있습니다.\nIn [21]: a=Symbol(\"bc\") # `Symbol` 함수를 이용한 선언\nOut[21]: :bc\n\nIn [22]: b=:bc # 콜론 `:` 을 이용한 선언\nOut[22]: :bc\n\nIn [23]: a==b # 두 선언은 같다.\nOut[23]: true\n심볼 타입은 Julia 에서 소위 메타 프로그래밍 개념의 핵심이지만 여기서는 자세히 다루지 않겠습니다. 심볼 타입이 많이 쓰이는 다른 경우는 함수에 인자로 전달할 때 입니다. 예를 들어 그래프를 빨간 색으로 그리고 싶을 때, 다른 언어라면 \"red\" 라는 문자열을 함수의 인자로 입력하는 경우가 많은데, Julia 에서는 이렇게 문자열을 쓸 수도 있지만 :red 라는 심볼 타입을 전달하는 경우가 많습니다. 이 경우 비교가 문자열보다 빠릅니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/02_variables_basic_types.html#변수의-타입-지정과-타입-유니온",
    "href": "src/introduction_to_julia/02_variables_basic_types.html#변수의-타입-지정과-타입-유니온",
    "title": "변수와 기본 타입",
    "section": "5 변수의 타입 지정과 타입 유니온",
    "text": "5 변수의 타입 지정과 타입 유니온\n\n변수의 타입 지정\n예를 들어 변수 a 에 UInt8 타입의 3 을 할당한다고 해 봅시다. a=UInt8(3) 와 a::UInt8=3 과 같은 두가지 방법을 사용 할 수 있습니다. 그러나 두번째 경우에는 a 라는 변수가 UInt8 타입으로 지정되기 때문에 UInt8 타입 이외의 값으로 변경할 수 없습니다.\nIn [1]: a::UInt8=3\nOut[1]: 3\n\nIn [2]: a=4\nOut[2]: 4\n\nIn [3]: a=-1\nERROR: InexactError: trunc(UInt8, -1)\nStacktrace:\nIn [2] 에서는 4 가 UInt8 타입으로 a 에 저장됩니다. 그러나 UInt8 은 음수를 저장 할 수 없으므로 In [3] 의 입력은 에러를 냅니다. 그러나 b=UInt8(3) 과 같이 할당하면 a 변수에 대한 타입 제한은 없습니다.\nIn [4]: b=UInt8(3)\nOut[4]: 0x03\n\nIn [5]: b=-1\nOut[5]: -1\n\n\n\n타입 유니온\n타입 유니온은 변수가 가질 수 있는 타입을 하나가 아닌 여러개중 하나로 할 때 사용되며 Union{T1, T2} 처럼 사용됩니다. T1, T2 는 변수가 가질 수 있는 타입이며 두개 이상일 경우에는 , 로 구분하여 나열합니다. 다음 보기를 봅시다.\nIn [1]: a::Union{Int, AbstractString}=\"a\"\nOut[1]: \"a\"\n\nIn [2]: b::Union{Int, AbstractString}=3\nOut[2]: 3\n\nIn [3]: c::Union{Int, AbstractString, Nothing}=nothing\n\nIn [4]: (a, b, c)\nOut[4]: (\"a\", 3, nothing)\nIn [1] 의 경우는 입력값이 문자열이므로 a 는 문자열 타입이 되고, b 는 입력값이 정수이므로 정수 타입이 되었습니다. c 는 세가지 타입중에 선택하도록 하는 것입니다. 이런 방법 역시 일반적인 변수에 값을 할당할 때 보다 함수의 인자의 타입을 제한 할 때 사용됩니다. 그리고 nothing 은 값이고 Nothing 은 nothing 에 대한 타입입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "변수와 기본 타입"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/unittest.html",
    "href": "src/ecosystem_of_julia/unittest.html",
    "title": "유닛테스트 : Test.jl",
    "section": "",
    "text": "유닛테스트(Unit test) 혹은 단위테스트는 작성한 함수의 실행 결과가 기대했던 것과 일치하는지 여부를 확인하는 것을 말합니다. 이를 위해 Test.jl 을 설치합니다.\n여기서는 유닛테스트의 기초적인 내용을 다룹니다. 자세한 내용은 Julia 공식 매뉴얼의 Unit Testing 을 참고하시기 바랍니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "유닛테스트 : Test.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/unittest.html#test-매크로를-사용한-유닛테스트",
    "href": "src/ecosystem_of_julia/unittest.html#test-매크로를-사용한-유닛테스트",
    "title": "유닛테스트 : Test.jl",
    "section": "1 @test 매크로를 사용한 유닛테스트",
    "text": "1 @test 매크로를 사용한 유닛테스트\n가장 간단한 단위테스트 입니다. 어떤 표현식 ex 에 대해 아래와 같은 네가지 방법으로 사용할 수 있습니다.\n@test ex\n@test f(args...) key=val ...\n@test ex broken=true\n@test ex skip=true\n\n\n1.1 @test\n@test 다음에 true 혹은 false 를 반환하는 표현식이 올 경우 true 이면 테스트를 통과한 것으로, false 이면 실패한 것으로 간주합니다.\nIn [1]: using Test\n\nIn [2]: @test 2+3 == 5\nOut[2]: Test Passed\n\nIn [3]: @test 3 == 5\nTest Failed at REPL[3]:1\n  Expression: 3 == 5\n   Evaluated: 3 == 5\n\nERROR: There was an error during testing\n\n\n\n1.2 @test f(args...) key=val ...\nisapprox(a, b; atol=1.0e-10) 함수는 norm(b-a) 가 atol 키워드 인자로 주어진 값보다 작으면 true 를 아니면 false 를 반환합니다. (isapprox 함수는 수 뿐만 아니라 배열에 대해서도 사용할 수 있으며 atol 이외의 키워드 인자도 입력 할 수 있습니다. Julia 에 포함된 공식 문서를 참고하시기 바랍니다.) 이 함수에 대해 다음과 같이 테스트 할 수 있습니다.\nIn [2]: @test isapprox(1.0e-7, 0.0, atol=1.0e-5)\nOut[2]: Test Passed\n\nIn [3]: @test isapprox(1.0e-7, 0.0) atol=1.0e-5\nOut[3]: Test Passed\n@test 다음에 함수가 올 때는 키워드 인자를 함수의 ( ) 안에 넣어도 되고 밖에 넣어도 됩니다.\n\n\n\n1.3 broken=true 혹은 broken=false 조건\n단위테스트에서는 어떤 표현식이 틀리거나 예외를 발생시키 것으로 함수의 기능을 확인해야 할 때가 있는데 이런 경우에 사용합니다. broken 인자는 true 이거나 false 이어야 합니다. broken=true 조건에서는 ex 표현식이 false 이거나 예외를 발생시킬 때 테스트를 통과한 것으로 간주합니다. broken=true 조건이라면 일반적인 @test ex 와 같습니다.\nIn [1]: @test [2, 3] + \"a\"  broken=true\nOut[1]: Test Broken\n  Expression: [2, 3] + \"a\"\n\nIn [2]: @test 3==4 broken=true\nOut[2]: Test Broken\n  Expression: 3 == 4\n\nIn [3]: @test 2+3==5 broken=false\nOut[3]: Test Passed\n\nIn [4]: @test 2+3==5 broken=true\nError During Test at REPL[15]:1\n Unexpected Pass\n Expression: 2 + 3 == 5\n Got correct result, please change to @test if no longer broken.\nIn [1] 의 경우 [2, 3] + \"a\" 는 예외를 발생시켜야 하는데 broken=true 조건으로 인해 테스트를 통과하게 됩니다. 일반적인 통과가 아니므로 출력 메시지가 Test Broken 이 됩니다. In [2] 의 경우 3==4 는 false 이므로 역시 broken test 를 통과합니다.\nIn [3] 에서 broken=false 를 주면 @test 와 동일하다는 것을 확인할 수 있습니다.\nIn [4] 에서는 표현식이 true 이며 broken=true 옵션이 주어지면 에러가 발생한다는 것을 보여줍니다.\n\n\n\n1.4 skip=true 혹은 skip=false 조건\n이 옵션은 주로 아직 구현되지 않은 함수에 대해 미리 테스트 구문을 만들어 놓을 때 사용합니다. skip=true 이면 무조건 Test Broken 을 리턴합니다. skip=false 이면 skip 옵션을 지정하지 않은것과 같습니다.\nIn [27]: @test 2==3 skip=true\nOut[27]: Test Broken\n  Skipped: 2 == 3\n\nIn [28]: @test 2==3 skip=true\nOut[28]: Test Broken\n  Skipped: 2 == 3",
    "crumbs": [
      "Julia 언어 생태계",
      "유닛테스트 : Test.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/unittest.html#test_throws",
    "href": "src/ecosystem_of_julia/unittest.html#test_throws",
    "title": "유닛테스트 : Test.jl",
    "section": "2 @test_throws",
    "text": "2 @test_throws\n@thest_throws exception expr 구문은 표현식 expr 이 실제로 예외 exception 을 발생시키는지를 확인합니다.\nIn [1]: f(x) = [x x+1 x+2]\nOut[1]: f (generic function with 1 method)\n\nIn [2]: @test_throws BoundsError f(3)[4]\nOut[2]: Test Passed\n      Thrown: BoundsError\n함수 f(x) 는 [x x+1 x+2] 라는 길이가 3인 배열을 반환하므로 f(3)[4] 는 BoundsError 를 발생시킵니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "유닛테스트 : Test.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/unittest.html#testset",
    "href": "src/ecosystem_of_julia/unittest.html#testset",
    "title": "유닛테스트 : Test.jl",
    "section": "3 @testset",
    "text": "3 @testset\n\n3.1 @testset\n아주 간단한 함수를 테스트하는 것이 아니라 어느 정도 규모가 있는 모듈이나 패키지를 테스트한다면 테스트 구문이 여러개 필요합니다. 일단 begin ... end 블록으로 처리 할 수 있을 것 같습니다. 아래의 예를 봅시다.\nIn [11]: begin\n         @test 2^2==4\n         @test 3+3==6\n         end\nOut[14]: Test Passed\n테스트가 통과했다는 메시지가 나옵니다. 만약 첫번째 테스트 구문을 통과하지 못한다면 어떻게 될지 확인해 봅시다.\nIn [12]: begin\n        @test 1+1==3\n        @test 3+3==6\n        end\nTest Failed at REPL[6]:2\n  Expression: 1 + 1 == 3\n   Evaluated: 2 == 3\nbegin, end 블록 안에 여러개의 @test 혹은 @test_throws 구문을 넣었을 때 중간에 테스트가 실패한다면 거기서 즉시 멈추고 이후의 테스트를 수행하지 않습니다. 위에서는 @test 1+1==3 에서 테스트가 실패했기 때문에 그 다음의 @test 3+3==6 을 수행하지 않았습니다.\n여러개의 테스트를 수행하며, 중간에 테스트를 실패하더라도 계속 수행하고, 최종적으로 성공한 테스트와 실패한 테스트에 대해 보고해주는 매크로가 @testset 매크로 입니다. 기본적으로 @testset 은 함수 내에 사용 되거나 @testset 이후의 begin ... end , for ... end, let ... end 블럭으로 사용됩니다.\n\n\n\n3.2 @testset 이름과 옵션\n@testset 매크로는 별도의 이름을 부여할 수 있습니다. 또한 옵션도 줄 수 있습니다.\nIn [19]: @testset \"Simple Test Set\" showtiming=true begin\n         @test 2^2==4\n         @test 3+3==6\n         end;\nTest Summary:   | Pass  Total  Time\nSimple Test Set |    2      2  0.0s\n@testset [테스트셋 이름] [옵션] begin ... end 형식으로 begin 과 end 사이에 @test, @test_throws 혹은 다른 @testset 구문이 들어 갈 수 있습니다. 즉 @testset 은 중첩 될 수 있습니다. [테스트셋 이름] 은 문자열 이며 생략 될 수 있습니다. [옵션] 은 아래의 세가지가 있으며 역시 생략 될 수 있습니다.\n\n\n\n표 1: @testset 옵션\n\n\n\n\n\n\n\n\n\n옵션\n설명\n\n\n\n\nverbose\ntrue 이면 중첩된 @testset 구문의 결과도 모두 보여줍니다. 기본값은 false 이며 이 경우 중첩된 @testset 이 모두 Pass 이면 결과를 보여주지 않습니다.\n\n\nshowtiming\ntrue 이면 테스트 수행 시간을 보여줍니다. 기본값은 true 입니다.\n\n\nfailfast\ntrue 이면 중간에 테스트가 실패할 경우 이후 테스트를 수행하지 않고 그때까지의 결과값을 반환합니다. 환경변수 JULIA_TEST_FAILFAST 를 통해 기본값을 설정 할 수 있으며 이 변수값이 설정되지 않았을 경우에는 기본값은 false 입니다.\n\n\n\n\n\n\n\n\n\n3.3 @testset for ... end\n@testset 에 for ... end 블럭을 결합한 것입니다. 아래와 같이 사용합니다.\nIn [24]: @testset for k ∈ 1:4\n         @test sin(-k*π) ≈ - sin(k*π)\n         @test cos(-k*π) ≈ cos(k*π)\n         end;\nTest Summary: | Pass  Total  Time\nk = 1         |    2      2  0.0s\nTest Summary: | Pass  Total  Time\nk = 2         |    2      2  0.0s\nTest Summary: | Pass  Total  Time\nk = 3         |    2      2  0.0s\nTest Summary: | Pass  Total  Time\nk = 4         |    2      2  0.0s\n여기서 ≈ 는 주어진 부동소수의 오차 내에서 일치하는지에 대한 연산자로 내부적으로 isapprox 함수를 사용합니다.\n\n\n\n3.4 @testset let ... end\n임시로 함수나 변수를 정하여 사용할 수 있습니다.\nIn [25]: @testset let logi = log(im)\n         @test imag(logi) == π/2\n         @test !iszero(real(logi))\n         end;\nTest Failed at REPL[25]:3\n  Expression: !(iszero(real(logi)))\n     Context: logi = 0.0 + 1.5707963267948966im\n\nERROR: There was an error during testing",
    "crumbs": [
      "Julia 언어 생태계",
      "유닛테스트 : Test.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/random.html",
    "href": "src/ecosystem_of_julia/random.html",
    "title": "난수 발생",
    "section": "",
    "text": "Random 모듈에 대해서는 자세한 사항은 공식 매뉴얼 Random Numbers 를 참고하라.",
    "crumbs": [
      "Julia 언어 생태계",
      "난수 발생"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/random.html#rand-함수",
    "href": "src/ecosystem_of_julia/random.html#rand-함수",
    "title": "난수 발생",
    "section": "1 rand 함수",
    "text": "1 rand 함수\nrand 함수는 추가 모듈 호출 없이 사용 할 수 있으며 기본적인 난수 기능을 제공한다.\n\n1.1 기본적인 사용\n기본적인 난수 발생 함수이다. rand() 는 \\([0,\\,1)\\) 범위, 즉 \\(0\\le x &lt; 1\\) 범위의 의 난수를 하나 발생시킨다. rand(3,3) 은 \\([0,\\,1)\\) 범위의 난수를 \\(3\\times 3\\) 배열꼴로 발생시킨다.\nIn [1]: rand()\nOut[1]: 0.8828172727992498\n\nIn [2]: rand(3,3)\nOut[2]: 3×3 Matrix{Float64}:\n 0.184347   0.367585  0.487483\n 0.0646924  0.306758  0.0969628\n 0.395878   0.802534  0.682208\n\n\n\n1.2 컬렉션을 이용한 난수 생성\nrand() 함수의 첫번째 인자로 컬렉션을 주고, 두번째 인자로 배열의 차원을 주면 컬렉션에서 배열의 차원에 맞게 임의로 뽑은 배열을 반환한다.\nIn [4]: rand(1:10, (2, 2))\nOut[4]: 2×2 Matrix{Int64}:\n 3  5\n 2  1\n\nIn [5]: rand(\"abcdefgh\", (3, 1))\nOut[5]: 3×1 Matrix{Char}:\n 'f': ASCII/Unicode U+0066 (category Ll: Letter, lowercase)\n 'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n 'f': ASCII/Unicode U+0066 (category Ll: Letter, lowercase)\n\n\n\n1.3 부동소수, 복소수형 난수 발생\nrand() 함수의 첫번째 인자로 부동소수형 타입(Float32, Float64 등) 두번째 인자로 배열의 크기를 입력 하면 지정된 부동소수 타입에 맞도록 \\([0,\\,1)\\) 범위의 난수를 반환한다.\nIn [7]: rand(Float32, (2, 3))\nOut[7]: 2×3 Matrix{Float32}:\n 0.15381   0.329045  0.566583\n 0.543246  0.985837  0.49038\n부동소수 타입 대신에 복소수 타입(ComplexF32,ComplexF64` 등) 을 입력하면 실수부와 허수부가 각각 \\([0,\\,1)\\) 범위인 난수 배열을 반환한다.\nIn [11]: rand(ComplexF64, (3, 3))\nOut[11]: 3×3 Matrix{ComplexF64}:\n 0.714389+0.362708im  0.181131+0.355622im  0.246163+0.414729im\n 0.970722+0.402822im   0.71223+0.460335im  0.833319+0.389379im\n 0.100495+0.14951im   0.333517+0.47611im   0.981335+0.175562im\n\n\n\n1.4 정수형 난수 발생\n타입에 정수형 타입(UInt64, Int32 등) 을 입력하면 정수 범위 내에서의 주어진 배열 크기에 맞는 난수를 반환한다.\nIn [12]: rand(Int32, (4, 4))\nOut[12]: 4×4 Matrix{Int32}:\n 1196699858  -1854481187    772846765  -1708392714\n 1188189451   -465314003   -575000325   1969484502\n  754045126  -1342873240   -776187378  -2017122961\n -134558519    576240888  -1734804352   -613011413\n어떤 범위에 대한 난수를 발생시키고 싶으면 컬렉션을 지정하면 된다. 예를 들어 -100 에서 100 사이의 난수를 발생시키고 싶다면 다음과 같이 하면 된다.\nIn [16]: rand(-100:1:100, (3, 3))\nOut[16]: 3×3 Matrix{Int64}:\n  5  -88   28\n 52   28  -52\n 26  -68  -87",
    "crumbs": [
      "Julia 언어 생태계",
      "난수 발생"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/random.html#random-모듈",
    "href": "src/ecosystem_of_julia/random.html#random-모듈",
    "title": "난수 발생",
    "section": "2 Random 모듈",
    "text": "2 Random 모듈\n다양한 난수 발생가와 난수 기능을 사용하기 위해서는 Random 모듈을 사용한다. Julia 기본 패키지이므로 추가로 설치할 필요 없이 using Random 과 같이 사용하면 된다.\n\n\n2.1 의사 난수 발생기(Pseudo random number generator)\n실제 자연 현상으로부터 난수를 발생시키는 난수 발생기(Hardware random number generator, HRNG) 와 달리 컴퓨터 알고리즘으로 난수를 발생시키는 것을 의사 난수 발생기(Pseudo random number generator, PRNG) 라고 하며, julia 언어는 기본값으로 Xoshiro256++ 난수 발생기를 사용한다. 둘을 핲텨 난수발생기(RNG) 라고 하며 앞에서의 난수발생은 바로 이 RNG 를 사용한 것이다. 참고로 Xoshiro 는 XOR, Shift, Rotation 에서 순서대로 두문자를 따온 것이라고 한다.\nJulia 언어의 Random 모듈은 4가지 의사난수발생기를 지원한다 : TaskLocalRNG, Xoshiro, RandomDevice, MersenneTwister 자세한 사항은 공식 매뉴얼을 참고하라.\n\n\n\n2.2 seed\nSeed 는 의사난수발생기를 초기화 하는데 사용되는 숫자이다. 모든 RNG 가 seed 를 필요로 하는 것은 아니다. 예를 들어 RandomDevice RNG 의 경우는 seed 를 필요로 하지 않는다. 서로 다른 시드로 생성된 RNG 는 다른 난수발생기로 간주된다. Seed 가 필요한 난수발생기에 Seed 가 주어지지 않았다면 내부적으로 생성된 seed 를 사용한다.\nSeed 를 사용하면 동일한 난수를 발생시킬 수 있다. 예를 들어 Xoshiro 난수발생기에 seed 를 11 로 입력하면\nIn [1]: using Random\n\nIn [2]: rand(Xoshiro(11), 2,2)\nOut[2]: 2×2 Matrix{Float64}:\n 0.58051   0.862848\n 0.714139  0.702579\n\nIn [3]: rand(Xoshiro(11), 2,2)\nOut[3]: 2×2 Matrix{Float64}:\n 0.58051   0.862848\n 0.714139  0.702579\n이 된다. 그러나 일단 난수발생기를 생싱시키면 그 난수발생기는 지속적으로 다른 난수를 발생한다. 다음을 보라. Out[4] 와 Out[5] 는 다르다.\nIn [3]: rng = Xoshiro(11)\nOut[3]: Xoshiro(0x0991231718e930cb, 0x28e1460087a5d0ff, 0x4d62c780da1946f0, 0x764f51fefd621192, 0x434e1895e0078176)\n\nIn [4]: rand(rng, 2,2)\nOut[4]: 2×2 Matrix{Float64}:\n 0.58051   0.862848\n 0.714139  0.702579\n\nIn [5]: rand(rng, 2, 2)\nOut[5]: 2×2 Matrix{Float64}:\n 0.861659   0.919821\n 0.0130147  0.901326\n\n다른 julia 나 Random 버젼에서도 rand(Xoshiro(11), 2,2) 의 값이 유지되는 것을 기대하면 안된다. 즉 위에 나온 난수는 현재 저자가 사용하는 버젼에서의 랜덤값이며, 다른 버젼에서 작동한다면 그 버젼 내의 일관성은 유지되더라도 서로 다른 버젼간의 일관성을 보장할 수 없다. 즉 특정 난수 생성기와 seed 값에 의존하는 코드를 짜면 안된다.",
    "crumbs": [
      "Julia 언어 생태계",
      "난수 발생"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/random.html#distributions.jl",
    "href": "src/ecosystem_of_julia/random.html#distributions.jl",
    "title": "난수 발생",
    "section": "3 Distributions.jl",
    "text": "3 Distributions.jl\n지금까지의 난수는 모든 값에 대해 동일한 확률을 갖는 난수였다. 즉 rand() 함수로 발생되는 난수는 모든 \\([0,\\,1)\\) 범위내의 모든 작은 \\(dx\\) 에 대해 \\([a, a+dx)\\) 구간의 값이 나올 확률과 \\([b, b+dx)\\) 구간의 값이 나올 확률이 동일하다. 특정 분포를 따르는 난수가 필요할 경우 대표적으로 Distributions.jl 패키지를 사용 할 수 있다. 이것은 기본 패키지가 아니므로 추가 설치가 필요하다. 설치는 ]add Distributions.\n\n\n3.1 정규 분포\nNormal(μ, σ) 은 평균 μ, 표준편차 σ 인 정규분포를 생성하며, rand 함수를 통해 난수를 생성한다.\nusing CairoMakie, Random, Distributions\n\nnorm1 = Normal(3, 5)\nx = rand(norm1, 1000000)\nx 는 평균이 3, 표준편차가 5 인 정규분포를 따르는 난수 백만개를 가진 벡터이다. 난수에 대한 평균과 표준편차를 확인 할 수 있다.\nprintln(\"mean = $(mean(x)), std = $(std(x))\")\n실제 분포를 보자.\nhist(x, bins=100)\n\n\n\n\n\n\n그림 1: 정규 분포",
    "crumbs": [
      "Julia 언어 생태계",
      "난수 발생"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/makie.html",
    "href": "src/ecosystem_of_julia/makie.html",
    "title": "Makie 로 Plotting",
    "section": "",
    "text": "Jupyter 혹은 vscode notebook 을 사용하여 그래프를 그리거나 혹은 julia script 로 그래프를 파일로 저장할 수 있는 패키지는 여러가지가 있으며, 대표적으로 Plots 와 Makie\\(^1\\), Python 의 matplotlib 을 그대로 쓰게 해주는 PyPlot.jl 가 있다. 여기서는 Makie 를 소개한다.\\(^1\\) Makie.jl 의 공식 홈페이지에 따르면 Mah-kee 로 발음한다고 하며 어원은 일본의 마키에(蒔絵, まきえ) 이다.",
    "crumbs": [
      "Julia 언어 생태계",
      "Makie 로 Plotting"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/makie.html#julia-언어의-plotting-패키지",
    "href": "src/ecosystem_of_julia/makie.html#julia-언어의-plotting-패키지",
    "title": "Makie 로 Plotting",
    "section": "",
    "text": "Jupyter 혹은 vscode notebook 을 사용하여 그래프를 그리거나 혹은 julia script 로 그래프를 파일로 저장할 수 있는 패키지는 여러가지가 있으며, 대표적으로 Plots 와 Makie\\(^1\\), Python 의 matplotlib 을 그대로 쓰게 해주는 PyPlot.jl 가 있다. 여기서는 Makie 를 소개한다.\\(^1\\) Makie.jl 의 공식 홈페이지에 따르면 Mah-kee 로 발음한다고 하며 어원은 일본의 마키에(蒔絵, まきえ) 이다.",
    "crumbs": [
      "Julia 언어 생태계",
      "Makie 로 Plotting"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/makie.html#backends",
    "href": "src/ecosystem_of_julia/makie.html#backends",
    "title": "Makie 로 Plotting",
    "section": "2 Backends",
    "text": "2 Backends\n정확히 말하면 Makie 는 프론트엔드로서 플로팅에 대한 여러가지 내부적인 기능을 가지고 있으며, 실제 그래프가 보여지는 것은 백엔드를 통해서이다. 물론 어떤 기능은 특정한 백엔드에서만 가능하다. 2024년 6월 현재 Makie 는 4가지 백엔드가 존재한다.\n\n\n\n\n\n\n\nPackage\nDescription\n\n\n\n\nGLMakie.jl\n독립적인 윈도우에서 플로팅되며 GPU-기반의 대화형(interactive) 2D, 3D 플로팅에 사용된다.\n\n\nCairoMakie.jl\nCairo.jl 기반의 비대화형(non-interactive) 2D, 3D 플로팅에 사용된다.\n\n\nWGLMakie.jl\nWebGL 기반의 대화형 2D, 3D 플로팅에 사용되며 웹브라우저로 플로팅한다.\n\n\nRPRMakie.jl\n실험적인 ray-tracing 패키지\n\n\n\nWGLMakie.jl 과 RPRMakie.jl 은 아직은 불안정하므로 CairoMakie.jl 이나 GLMakie.jl 을 사용하는 것을 추천한다. 보통 상호작용이 필요할 때는 GLMakie.jl 을 그렇지 않고 고품질의(publication quality) 의 정적인 플로팅을 원할때는 CairoMakie.jl 을 사용한다.",
    "crumbs": [
      "Julia 언어 생태계",
      "Makie 로 Plotting"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/makie.html#cairomakie",
    "href": "src/ecosystem_of_julia/makie.html#cairomakie",
    "title": "Makie 로 Plotting",
    "section": "3 CairoMakie",
    "text": "3 CairoMakie\nJulia REPL 에서 ]add CairoMakie 로 설치한다. Makie.jl 이 설치가 안되었다면 자동으로 설치해준다. Jupyter 환경이나 Pluto 환경에서는 자동적으로 그 환경에서 출력해준다. 가장 간단한 플로팅을 해 보자.\nt = 1:0.1:(4*π)\nlines(t, cos.(t))\n\n\n\n\n\n\n그림 1: Makie Plot 1\n\n\n\nlines 함수는 위의 그림과 같이 선 그래프를 만든다. 다음을 보자.\nt = 1:0.1:(4*π)\nfig, ax, ls = lines(t, cos.(t))\nlines!(ax, t, sin.(t))\nfig\n\n\n\n\n\n\n그림 2: Makie Plot 2\n\n\n\nfig, ax, ls = lines(t, cos.(t)) 에서 fig 는 Figure 타입, ax 는 Axis 타입, ls 는 Lines 타입의 객체이다. Figure 는 우리가 그리고자 하는 전체 그림을 표현한다. Axis 는 우리가 그래프를 그리는 좌표계와 그 좌표계에서 출력되는 선, 도형, 숫자들을 의미한다. Lines 는 우리가 그린 선 그래프의 선을 의미한다. 이 때 Axis 는 Figure 에 포함되어 있으며, Lines 는 Axis 에 포함된다.\nlines!(ax, t, sin.(t)) 를 보자. 앞서 여러번 설명했듯이 Julia 는 관례적으로 어떤 함수가 변수로 입력되는 인스턴스를 변경한다면 함수 이름 끝에 ! 를 붙인다. 이 명령어는 앞의 fig, ax, ls = lines(t, cos.(t)) 로 만들어진 ax 객체를 변경하기 때문에 ! 를 붙였다. 앞서 만들어진 Axis 인스턴스 ax 에 새로은 선그래프를 추가한다. 마지막줄은 fig 를 출력하라는 의미이다. 마지막줄이 없다면 그림이 만들어지긴 하지만 출력되지는 않는다.\n\n이제 좀 더 그럴듯한 그림을 그려보자.\nusing LaTeXStrings\nt=0.0:0.5:25.0\ndata = 4.0 .* exp.(-0.4 .* t) .+ (rand(length(t)) .- 0.5)\nfig = Figure()\nax = Axis(fig[1, 1],\n    title = \"Exponential Decay and Fit\",\n    xlabel = \"Time [Arb. Unit]\",\n    ylabel = \"Value\",\n)\nscatter!(\n    ax,\n    t,\n    data,\n    color = :tomato,\n    label = \"Measurements\"\n)\nlines!(\n    ax,\n    t,\n    4.0 .* exp.(-0.4 .* t),\n    color = :blue,\n    linestyle = :dash,\n    label = L\"f(x) = \\exp(-0.4 t)\",\n)\naxislegend(position = :rt)\nfig\n\n\n\n\n\n\n그림 3: Makie Plot 3\n\n\n\nfig = Figure() 는 Figure 객체를 생성하여 fig 변수에 할당한다. ax 는 Axis 인스턴스로 맨 앞의 fig[1, 1] 은 그림에 포함되는 여러 부분 가운데 첫번째라는 의미이다. 각 Axis 마다 title, xlabel, ylabel 등을 지정 할 수 있다. 그 다음의 scatter! 나 lines! 명령어는 Scatter 그래프와 선그래프를 그리라는 명령어이며, axislegend 함수는 각 그래프의 label 과 모양을 표시하라는 의미아다. position=:rt 는 위치를 Axis 의 오른쪽(right) 위(top) 에 표현하라는 의미이다.",
    "crumbs": [
      "Julia 언어 생태계",
      "Makie 로 Plotting"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/fileio.html",
    "href": "src/ecosystem_of_julia/fileio.html",
    "title": "파일시스템과 파일입출력",
    "section": "",
    "text": "Julia 스크립트가 실행 될 때 몇가지 파일과 경로에 대한 정보를 가지고 실행됩니다. 예를 들어 다음의 julia 스크립트 파일로 저장하고 실행시켜봅시다\n#! /usr/bin/env julia\n\nprintln(homedir())\nprintln(pwd())\nprintln(@__DIR__)\nprintln(@__FILE__)\nJulia 스크립트는 보통 확장자로 jl 을 사용합니다. 위의 코드를 pathes.jl 로 저장해 봅시다. 맨 앞줄의 #! /usr/bin/env julia 는 Shebang 이라고 하며 일반적으로 셸스크립트나 파이썬스크립트와 같은 스크립트의 실행 정보를 담고 있습니다. Linux 나 맥 OSX 같은 유닉스 계열의 OS 라면 터미널에서\njulia pathes.jl\n명령어로서 실행합니다. 실행이 제대로 된다면 4줄을 출력할 것입니다.\n\nhomedir() 은 사용자의 홈 디렉토리의 경로를 문자열로 반환하는 함수입니다.\npwd() 는 스크립트가 어떤 작업을 할 때의 기준 디렉토리 즉 작업디렉토리를 문자열로 반환하는 함수입니다.\n@__DIR__ 은 매크로로 이 매크로를 호출한 파일의 디렉토리를 반환합니다.\n@__FILE__ 역시 매크로로 이 매크로를 호출한 파일의 파일명을 포함하는 전체 경로를 반환합니다.\n\n\n\n\n\n여기서는 함수 이름만 나열합니다. 자세한 사용법은 Julia 의 도움말을 확인하기 바랍니다.\n\n\n\n표 1: 파일 입출력 함수\n\n\n\n\n\n기능\n함수\n\n\n\n\nhome directory\nhomedir()\n\n\nworking directory 확인\npwd()\n\n\nworking directory 변경\ncd()\n\n\nworking directory를 home directory로 변경\ncd()\n\n\ndirectory내 파일 및 폴더 리스트 확인\nreaddir()\n\n\ndirectory 만들기\nmkpath()\n\n\n파일/폴더 이동\nmv()\n\n\n파일/폴더 삭제\nrm()\n\n\n폴더인지 확인\nisdir()\n\n\n파일인지 확인\nisfile()\n\n\n유효한 경로인지 확인\nispath()\n\n\n절대경로 확인\nabspath()\n\n\n절대경로인지 확인\nisabspath()\n\n\n경로 합성\njoinpath()\n\n\n디렉토리 이름과 파일 이름으로 분할\nsplitdir()\n\n\n경로를 세부 단위로 분할\nsplitpath()\n\n\n파일크기 확인\nfilesize()\n\n\n파일의 세부 정보 얻기\nstat()",
    "crumbs": [
      "Julia 언어 생태계",
      "파일시스템과 파일입출력"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/fileio.html#파일-시스템",
    "href": "src/ecosystem_of_julia/fileio.html#파일-시스템",
    "title": "파일시스템과 파일입출력",
    "section": "",
    "text": "Julia 스크립트가 실행 될 때 몇가지 파일과 경로에 대한 정보를 가지고 실행됩니다. 예를 들어 다음의 julia 스크립트 파일로 저장하고 실행시켜봅시다\n#! /usr/bin/env julia\n\nprintln(homedir())\nprintln(pwd())\nprintln(@__DIR__)\nprintln(@__FILE__)\nJulia 스크립트는 보통 확장자로 jl 을 사용합니다. 위의 코드를 pathes.jl 로 저장해 봅시다. 맨 앞줄의 #! /usr/bin/env julia 는 Shebang 이라고 하며 일반적으로 셸스크립트나 파이썬스크립트와 같은 스크립트의 실행 정보를 담고 있습니다. Linux 나 맥 OSX 같은 유닉스 계열의 OS 라면 터미널에서\njulia pathes.jl\n명령어로서 실행합니다. 실행이 제대로 된다면 4줄을 출력할 것입니다.\n\nhomedir() 은 사용자의 홈 디렉토리의 경로를 문자열로 반환하는 함수입니다.\npwd() 는 스크립트가 어떤 작업을 할 때의 기준 디렉토리 즉 작업디렉토리를 문자열로 반환하는 함수입니다.\n@__DIR__ 은 매크로로 이 매크로를 호출한 파일의 디렉토리를 반환합니다.\n@__FILE__ 역시 매크로로 이 매크로를 호출한 파일의 파일명을 포함하는 전체 경로를 반환합니다.\n\n\n\n\n\n여기서는 함수 이름만 나열합니다. 자세한 사용법은 Julia 의 도움말을 확인하기 바랍니다.\n\n\n\n표 1: 파일 입출력 함수\n\n\n\n\n\n기능\n함수\n\n\n\n\nhome directory\nhomedir()\n\n\nworking directory 확인\npwd()\n\n\nworking directory 변경\ncd()\n\n\nworking directory를 home directory로 변경\ncd()\n\n\ndirectory내 파일 및 폴더 리스트 확인\nreaddir()\n\n\ndirectory 만들기\nmkpath()\n\n\n파일/폴더 이동\nmv()\n\n\n파일/폴더 삭제\nrm()\n\n\n폴더인지 확인\nisdir()\n\n\n파일인지 확인\nisfile()\n\n\n유효한 경로인지 확인\nispath()\n\n\n절대경로 확인\nabspath()\n\n\n절대경로인지 확인\nisabspath()\n\n\n경로 합성\njoinpath()\n\n\n디렉토리 이름과 파일 이름으로 분할\nsplitdir()\n\n\n경로를 세부 단위로 분할\nsplitpath()\n\n\n파일크기 확인\nfilesize()\n\n\n파일의 세부 정보 얻기\nstat()",
    "crumbs": [
      "Julia 언어 생태계",
      "파일시스템과 파일입출력"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/fileio.html#저수준-파일-입출력",
    "href": "src/ecosystem_of_julia/fileio.html#저수준-파일-입출력",
    "title": "파일시스템과 파일입출력",
    "section": "2 저수준 파일 입출력",
    "text": "2 저수준 파일 입출력\n\n파일 열고 닫기\n일반적인 프로그래밍 언어에서 기본적으로 파일을 다루는 것은 파일을 열고(open), 읽거나(read) 쓰고(write), 닫는(close) 절차로 이루어집니다. 파일을 연다는 것은 특정 파일을 지정하여 그 파일에 접근할 수 있는 통로의 문을 여는 것으로 이해 할 수 있습니다. 워드나 편집기 프로그램과 다른것은 파일을 연다는 것이 여기서는 파일의 내용을 읽는것이 아니라는 것입니다. 파일을 닫는것은 이제 그 파일에 접근할 필요가 없으므로 그 통로를 닫는다는 것으로 이해 할 수 있습니다. 파일을 지우거나 고치거나 하지 않습니다.\nJulia 에서 파일을 열고 닫는 방법은 보통 두가지가 많이 쓰입니다. 하나는 open() 함수로 명시적으로 열고 close() 함수로 명시적으로 닫는 것입니다. 예를 들어 앞의 pathes.jl 파일의 절대경로가 /Users/juliano/pathes.jl 라고 하면 다음과 같이 합니다. 현재 디렉토리(pwd() 명령어로 확인할 수 있습니다) 에 대한 상대경로를 사용할 수도 있습니다.\nf = open(\"/Users/juliano/pathes.jl\")\n    # f 를 이용하여 일을 한다.\nclose(f)\n나머지 하나는 do 블럭을 이용하는 것입니다. 이 방법은 close() 함수를 명시적으로 호출할 필요가 없습니다.\nopen(\"/Users/juliano/pathes.jl\") do f\n    # f 를 이용하여 일을 한다.\nend\n\n\n\n파일 접근 모드\n파일을 열 때는 몇가지 모드가 있으며 open 함수의 두번째 인자로 전달되거나 키워드 인자로 전달됩니다. 어떤 모드도 지정되지 않았다면 \"r\" 모드입니다. 아래의 표는 가능한 모드들입니다. 아래의 표에서 [truncate] 는 기존의 파일이 있다면 그 파일의 내용을 지우고 빈 파일로 만든다는 의미입니다. 따라서 파일이 지워져서는 안되는 파일이라면 미리 확인해야 합니다.(ispath(), 나 isfile() 함수로 확인 할 수 있습니다.) [새로 만들기] 는 지정된 경로에 파일이 없다면 파일을 새로 만든다는 뜻입니다. [새로 만들기] 모드가 없고 지정된 경로에 파일이 없다면 에러가 발생합니다. [덧붙이기] 는 기존의 파일을 유지하면서 기존 파일의 끝부터 내용을 쓴다는 의미입니다.\n\n\n\n표 2: 파일 접근 모드\n\n\n\n\n\n\n\n\n\n\n모드\n키워드 인자\n설명\n\n\n\n\n\"r\"\n\n읽기\n\n\n\"w\"\nwrite = true\n쓰기, 새로 만들기, 제거하기\n\n\n\"a\"\nappend = true\n쓰기, 새로 만들기, 덧붙이기\n\n\n\"r+\"\nread = true, write = true\n읽기, 쓰기\n\n\n\"w+\"\ntruncate = true, read = true\n읽기, 쓰기, 새로 만들기, 제거하기\n\n\n\"a+\"\nappend = true, read = true\n읽기, 쓰기, 새로 만들기, 덧붙이기\n\n\n\n\n\n\n\n다음의 명령어는 동일합니다.\nopen(\"/Users/juliano/pathes.jl\")\nopen(\"/Users/juliano/pathes.jl\", \"r\")\n아래의 두 명령어도 동일합니다.\nopen(\"/Users/juliano/pathes/jl\", \"w\")\nopen(\"/Users/juliano/pathes/jl\"; write = true)\n\n\n\n파일 읽기\n앞에서 open 파일은 실제로 파일에서 내용을 읽지 않는다고 언급했습니다. 파일을 열게 되면 IOStream 객체가 생성 됩니다. 이 객체에 대한 정보는 stat() 함수를 통해 얻을 수 있습니다. IOStream 객체는 바이트별로 데이터를 처리할 수 있으며 현재의 위치를 기억합니다. 현재의 위치는 position() 함수를 통해 알 수 있으며, 파일을 읽거나 쓰면 그만큼 현재의 위치가 이동합니다. 위치는 사용자가 바이트 단위로 옮길 수가 있는데 0 이 시작위치이며 끝 위치는 filesize() 함수로 얻을 수 있습니다.\nIn [1]: f1=open(\"pathes.jl\")\nOut[1]: IOStream(&lt;file pathes.jl&gt;)\n\nIn [2]: stat(f1)\nOut[2]: StatStruct for RawFD(20)\n   size: 93 bytes\n device: 16777220\n  inode: 49833799\n   mode: 0o100755 (-rwxr-xr-x)\n  nlink: 1\n    uid: 501 (jiyong)\n    gid: 20 (staff)\n   rdev: 0\n  blksz: 4096\n blocks: 8\n  mtime: 2023-12-04T18:11:59+0900 (19 hours ago)\n  ctime: 2023-12-04T18:11:59+0900 (19 hours ago)\n\nIn [3]: position(f1)\nOut[3]: 0\n\nIn [4]: read(f1, 3)\nOut[4]: 3-element Vector{UInt8}:\n 0x23\n 0x21\n 0x20\n\nIn [5]: position(f1)\nOut[5]: 3\n\nIn [6]: seek(f1, 0)\nOut[6]: IOStream(&lt;file pathes.jl&gt;)\n\nIn [7]: position(f1)\nOut[7]: 0\n파일에서 내용을 읽는 것은 read(), readline(), readlines() 함수를 이용합니다. read() 함수는 현재의 위치부터 인자로 전달되는 바이트 수 만큼을 읽고 Vector{UInt8} 로 반환합니다. 인자가 없다면 현재의 위치부터 끝까지 읽습니다. readline() 함수는 현재의 위치부터 다음 개행문자까지 읽고 문자열로 반환합니다. readlines() 함수는 현재의 위치부터 끝까지 읽고, 개행문자로 분할하여 문자열의 1차원 배열로 반환합니다. 개행문자는 일반 아스키나 유니코드 텍스트 파일에서 줄바꿈을 나타내는 문자이며 운영체제마다 다르지만 지금 사용하는 함수에서는 알아서 구분하여 분할해 줍니다.\n\n그런데 위의 세 함수 read, readline, readlines 는 open 함수를 통해 파일에 접근하는 IOStream 객체를 만들지 않고 직접 파일 이름을 첫번째 인자로 입력하여 똑같은 일을 할 수 있습니다. 차이가 있다면 IOStream 을 통해 접근하면 파일에서의 현재위치(position 함수로 알 수 있는)가 유지되는 반면에 read 함수 등으로 직접 접근하면 함수를 호출할 때마다 파일의 현재위치가 초기화 된다는 것입니다.\n\n\n텍스트 파일 읽고 쓰기\n이제 실제로 읽고 써 봅시다. 다음의 내용을 담은 파일을 기록한다고 해 봅시다.\n# 실험자 : 홍길동\n# 실험 일시 : 2023년 12월 10일\n# 데이터\n\n10\n4\n7\n6\n33\n5\n2\n하나의 문자열로 만든 다음에 통째로 data1.txt 파일로 적겠습니다. 현재 디렉토리가 파일로 저장하고자 하는 디렉토리라고 하고 상대경로를 사용하겠습니다.\nIn [1]: p=\"\"\"\n        # 실험자 : 홍길동\n        # 실험 일시 : 2023년 12월 10일\n        # 데이터\n\n        10\n        4\n        7\n        6\n        33\n        5\n        2\"\"\"\nOut[1]: \"# 실험자 : 홍길동\\n# 실험 일시 : 2023년 12월 10일\\n# 데이터\\n\\n10\\n4\\n7\\n6\\n33\\n5\\n2\"\n\nIn [2]: open(\"data1.txt\", \"w\") do f\n        f.write(p)\n        end\n이제 data1.txt 에 위의 내용이 기록되어 있음을 확인 할 수 있을 것입니다. 이제 이 파일을 읽고 처리하도록 하겠습니다. 가장 쉬운 방법은 readlines()로 통째로 줄 단위로 읽는 것입니다. 파일 전체를 읽을 것이므로 readlines() 함수를 통해 읽겠습니다.\nIn [1]: p = readlines(\"data1.txt\")\nOut[1]: 11-element Vector{String}:\n \"# 실험자 : 홍길동\"\n \"# 실험 일시 : 2023년 12월 10일\"\n \"# 데이터\"\n \"\"\n \"10\"\n \"4\"\n \"7\"\n \"6\"\n \"33\"\n \"5\"\n \"2\"\n문자열의 베열을 얻었으며, 빈 줄 역시 \"\" 로 표현됩니다. 네번째 줄부터 데이터이므로 이것을 정수의 배열로 바꾸겠습니다. parse(T, x) 는 값 x 를 타입 T 로 변경해주는 함수입니다.\nIn [11]: data = [parse(Int64, x) for x in p[5:end]]\nOut[11]: 7-element Vector{Int64}:\n 10\n  4\n  7\n  6\n 33\n  5\n  2\n\n\n\n이진 파일 읽고 쓰기\n텍스트 파일과 이진 파일은 파일 자체로는 본질적으로 차이가 없고 읽을 때 개행문자를 어떻게 처리하는지의 차이가 있을 뿐입니다. 예를 들어 UInt8 타입의 정수 12개를 기록한다고 해 봅시다. 정수 하나가 1바이트이므로 총 8바이트를 기록하게 됩니다.\nIn [1]: p = collect(UInt8, 1:1:8)\nOut[1]: 8-element Vector{UInt8}:\n 0x01\n 0x02\n 0x03\n 0x04\n 0x05\n 0x06\n 0x07\n 0x08\n\nIn [2]: write(\"data2.bin\", p)\nOut[2]: 8\n\nIn [3]: read(\"data2.bin\")\nOut[3]: 8-element Vector{UInt8}:\n 0x01\n 0x02\n 0x03\n 0x04\n 0x05\n 0x06\n 0x07\n 0x08\n\n여기까지는 큰 문제가 없습니다. 만약 Float64 타입의 실수 4개를 기록한다고 합시다.\nIn [4]: nb = collect(Float64, 0.0:1.0:3.0)\nOut[4]: 4-element Vector{Float64}:\n 0.0\n 1.0\n 2.0\n 3.0\n\nIn [6]: write(\"data3.bin\", nb)\nOut[6]: 32\n\nIn [7]: read(\"data3.bin\")\nOut[7]: 32-element Vector{UInt8}:\n 0x00\n 0x00\n 0x00\n 0x00\n 0x00\n...\nFloat64 부동소수는 8바이트이므로 4개의 Float64 부동소수는 32 바이트를 차지합니다. 따라서 우리는 32 개의 UInt8 정수를 얻었으며 이것을 다시 Float64 로 변환해야 합니다. 대신에 데이터가 저장될 배열을 생성하고 read! 함수를 사용해 봅시다.\nIn [12]: v=Vector{Float64}(undef, 4);\n\nIn [13]: read!(\"data3.bin\", v)\nOut[13]: 4-element Vector{Float64}:\n 0.0\n 1.0\n 2.0\n 3.0\nv 는 읽어들일 데이터가 저장될 배열입니다. 데이터를 읽고 배열을 변경하기 때문에 julia 의 관례에 따라 함수 이름 끝에 ! 가 붙었습니다.\n\n지금까지 텍스트 파일과 이진 파일의 저수준 입출력에 관해 간단히 알아보았습니다. 텍스트 파일은 메모장이나 텍스트 편집기로 파일 내용을 읽고 쓸수 있다는 큰 장점이 있습니다. 이진파일은 그 내용을 보더라도 의미를 알기 힘듭니다. 그러나 큰 데이터를 저장할 때 텍스트 파일은 이진 파일보다 몇배의 공간을 차지하기 때문에 큰 데이터를 저장하는데 적합하지 않습니다.\n또하나 생각해야 할 것은 파일에 데이터 뿐만 아니라 데이터에 대한 다양한 정보(이를 메타데이터라고 합니다)까지 같이 저장하는 경우 어디서부터가 어떤 형식의 데이터인지를 정확히 알아야 하며 그것에 맞추어 코딩을 해야 하는데 이것이 때때로 매우 번거롭습니다. 하지만 이미 존재하는 많은 파일 형식들과 그것을 쉽게 읽고 쓸 수 있도록 해주는 많은 라이브러리들이 있습니다. 이제 이것을 알아봅시다.",
    "crumbs": [
      "Julia 언어 생태계",
      "파일시스템과 파일입출력"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/fileio.html#포맷이-정해진-파일의-입출력",
    "href": "src/ecosystem_of_julia/fileio.html#포맷이-정해진-파일의-입출력",
    "title": "파일시스템과 파일입출력",
    "section": "3 포맷이 정해진 파일의 입출력",
    "text": "3 포맷이 정해진 파일의 입출력\nJulia 에서 파일 입출력을 지원하는 FileIO.jl 패키지가 있습니다. 많은 파일 형식에 관한 입출력 함수는 이 패키지의 load 함수와 save 함수를 메소드 디스패치하여 지원됩니다. 예를 들어 아래에 설명될 CSV 파일을 읽기 위해서는 CSV.jl 패키지가 필요한데, 이 CSV.jl 패키지에서 파일 입출력은 FileIO.jl 패키지를 이용하여 구현되었다는 의미입니다. Registry table 에는 FileIO.jl 의 load/save 를 이용하여 읽고 쓸 수 있는 포맷들이 나열되어 있습니다.\n\nCSV\n데이터를 저장하는데 아주 많이 사용되는 포멧입니다. 아래와 같은 테이블을 생각합시다.\n\nFruit prices\n\n\nvalue1\nvalue2\nvalue3\n\n\n\n\n1\n3\n5\n\n\n4\n2\n7\n\n\n\n위의 테이블이 아래와 같은 문자열로 저장되는 것이 CSV 입니다.\nvalue1,value2,value3\n1,3,5\n4,2,7 \n텍스트 포멧이며 모든 값은 “,” 로 구분됩니다. CSV 의 이름 자체가 comma-separated values, 즉 콤마로 구분되는 값들 이라는 의미입니다. 보통은 주 데이터 뿐만 아니라 주 데이터에 대한 설명을 포함합니다. 가장 간단한 방법은 CSV.jl 패키지를 사용하는 것입니다. 링크된 홈페이지에 자세히 설명이 되어 있습니다.\n\n\n\nHDF5\nHDF5 는 단순히 하나 혹은 유사한 데이터의 나열이 아니라 구조적이고 거대한 데이터를 저장하는데 목적을 둔 데이터 포맷입니다. Julia 의 사전 자료형을 생각하면 됩니다. HDF5.jl 을 참고하시기 바랍니다. C/C++ 을 비롯한 많은 언어에서 HDF5 파일을 읽고 쓸 수 있게 해 주는 라이브러리를 지원합니다. 다양한 언어에서 사용할 구조화된 대용량 데이터 포맷으로는 가장 적합합니다.\n\n\n\nJLD2\nHDF5 와 유사하지만 Julia 에서 사용하기 훨씬 편하며 다른 언어에서는 거의 사용할 수 없습니다. Julia 언어 내부에서만 사용할 경우에는 이 포맷이 좋습니다. JLD2.jl 를 참고하시기 바랍니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "파일시스템과 파일입출력"
    ]
  },
  {
    "objectID": "src/application_of_julia/string_literal.html",
    "href": "src/application_of_julia/string_literal.html",
    "title": "문자열 리터럴",
    "section": "",
    "text": "우선 리터럴 (literal) 이란 용어에 대해 알아봅시다.\nv = 1\n위의 코드는 변수 v 에 Int64 타입의 1 을 할당하는 것입니다. 이 때 v 는 변수이며, 등호 오른쪽의 1 은 코드상 Int64 타입의 정수 1 을 의미하며 이 Int64 타입의 1 을 리터럴 이라고 합니다. 즉 실제로 변수에 할당되는 값을 표현하는 코드입니다.\n\nc1 = 'a'\ns1 = \"abc\"\n작은따옴표 '' 안의 하나의 문자는 Char 타입의 값이며 겹따옴표 \"\" 안의 문자열은 String 타입의 값입니다. 즉 Char 타입과 String 타입을 표현하기 위해 홑따옴표와 겹따옴표가 리터럴에 사용되었습니다.\n\n\n\n\nv = 11\n을 봅시다. 당연히 십진수로 생각하겠지만 이것을 이진수로 생각하면 십진수 3 이며 16진수로 생각하면 십진수 17 입니다. 16 진수 값을 할당할 때는 앞에 0x 를 붙입니다.\nIn [1]: h=0xf42\nOut[1]: 0x0f42\n\nIn [2]: Int(h)\nOut[2]: 3906\n16진수 f42 는 10 진수 3906 과 같습니다. Julia 는 의외로 10 진수 리터럴을 16 진수 리터럴로 바꾸는 단순한 함수를 제공하지 않습니다. (Python 에는 hex 함수가 있는데….) 다만 다음과 같은 방법을 사용 할 수 있습니다.\nIn [1]: hex(h) = \"0x\"*string(h, base=16)\nOut[1]: hex (generic function with 1 method)\n\nIn [2]: hex(33)\nOut[2]: \"0x21\"",
    "crumbs": [
      "Julia 언어의 활용",
      "문자열 리터럴"
    ]
  },
  {
    "objectID": "src/application_of_julia/string_literal.html#리터럴",
    "href": "src/application_of_julia/string_literal.html#리터럴",
    "title": "문자열 리터럴",
    "section": "",
    "text": "우선 리터럴 (literal) 이란 용어에 대해 알아봅시다.\nv = 1\n위의 코드는 변수 v 에 Int64 타입의 1 을 할당하는 것입니다. 이 때 v 는 변수이며, 등호 오른쪽의 1 은 코드상 Int64 타입의 정수 1 을 의미하며 이 Int64 타입의 1 을 리터럴 이라고 합니다. 즉 실제로 변수에 할당되는 값을 표현하는 코드입니다.\n\nc1 = 'a'\ns1 = \"abc\"\n작은따옴표 '' 안의 하나의 문자는 Char 타입의 값이며 겹따옴표 \"\" 안의 문자열은 String 타입의 값입니다. 즉 Char 타입과 String 타입을 표현하기 위해 홑따옴표와 겹따옴표가 리터럴에 사용되었습니다.\n\n\n\n\nv = 11\n을 봅시다. 당연히 십진수로 생각하겠지만 이것을 이진수로 생각하면 십진수 3 이며 16진수로 생각하면 십진수 17 입니다. 16 진수 값을 할당할 때는 앞에 0x 를 붙입니다.\nIn [1]: h=0xf42\nOut[1]: 0x0f42\n\nIn [2]: Int(h)\nOut[2]: 3906\n16진수 f42 는 10 진수 3906 과 같습니다. Julia 는 의외로 10 진수 리터럴을 16 진수 리터럴로 바꾸는 단순한 함수를 제공하지 않습니다. (Python 에는 hex 함수가 있는데….) 다만 다음과 같은 방법을 사용 할 수 있습니다.\nIn [1]: hex(h) = \"0x\"*string(h, base=16)\nOut[1]: hex (generic function with 1 method)\n\nIn [2]: hex(33)\nOut[2]: \"0x21\"",
    "crumbs": [
      "Julia 언어의 활용",
      "문자열 리터럴"
    ]
  },
  {
    "objectID": "src/application_of_julia/string_literal.html#비표준-문자열-리터럴",
    "href": "src/application_of_julia/string_literal.html#비표준-문자열-리터럴",
    "title": "문자열 리터럴",
    "section": "2 비표준 문자열 리터럴",
    "text": "2 비표준 문자열 리터럴\nJulia 에서는 r\"\\((.*)\\)\" 이나 raw\"\\\\ \\\\\\\"\" 와 같이 겹따옴표 앞에 r 이나 raw 와 같은 특별한 구문이 오는 경우가 있습니다. 이런 것들을 비표준 문자열 리터럴이라고 하며 많이 사용됩니다. 보통 이런 리터럴은 객체의 생성자로 사용됩니다.\n\n\nr 로 시작되는 비표준 문자열 리터럴 : 정규표현식\nr 로 시작되는 비표준 문자열 리터럴은 정규표현식 객체를 생성하는 생성자입니다. 여기서 정규표현식에 대해 자세히 다루지는 않겠습니다. 예를 들어 다음을 봅시다.\nIn [4]: re = r\"^\\s*(?:#|$)\"\nOut[4]: r\"^\\s*(?:#|$)\"\n\nIn [5]: typeof(re)\nOut[5]: Regex\n\nIn [6]: occursin(re, \"# a comment\")\nOut[6]: true\nre = r\"^\\s*(?:#|$)\" 는 정규표현식 객체 re 를 생성합니다.\n\n\n\nb 로 시작되는 비표준 문자열 리터럴 : 바이트 배열\nIn [13]: barr = b\"123456\\xff\\u2200\"\nOut[13]: 10-element Base.CodeUnits{UInt8, String}:\n 0x31\n 0x32\n 0x33\n 0x34\n 0x35\n 0x36\n 0xff\n 0xe2\n 0x88\n 0x80\n\nIn [14]: barr[1]\nOut[14]: 0x31\nb\"...\" 리터럴은 바이트 배열을 생성하며 배열이므로 인덱스로 접근 할 수 있습니다. 문자 1 은 ASCII 의 49 번에 할딩되었으므로 49 의 16진수 표현인 0x31 를 값으로 가집니다. \\xff 는 16진수 ff 인 정수 255 를 의미합니다. \\u2200 은 3바이트를 차지하는 유니코드 표현으로 226, 136, 128 로 표현됩니다.\n\n\n\nv 로 시작되는 비표준 문자열 리터럴 : 버젼 넘버\n프로그램이나 패키지 등의 버젼은 보통 major, minor, patch 의 세가지 숫자로 2.3.6 과 같이 표기합니다. 이 때 2 는 major, 3 은 minor, 6 은 patch 버젼입니다.\nIn [18]: v1 = v\"2.3.4\"\nOut[18]: v\"2.3.4\"\n\nIn [19]: v2 = v\"2.5.7\"\nOut[19]: v\"2.5.7\"\n\nIn [20]: v1&lt;v2\nOut[20]: true\n2.5.7 버젼은 2.3.4 버젼보다 이후 버젼이므로 v1 &lt; v2 는 참입니다.\n\n\n\nraw 로 시작되는 비표준 문자열 리터럴 : Raw string\n\\n 과 같이 \\ 로 시작하여 하나의 문자가 붙는 문자열은 표준 문자열에서 탈출 문자(escape character) 라고 하여 문자 이외의 어떤 기능을 의미합니다. 예를 들어 \\u 는 유니코드에 대한 접두어이며 \\n 은 줄바꿈을 의미하죠. 그러나 raw 로 시작하는 문자열 리터럴에서는 이런 것들이 모두 무시됩니다. 또한 $ 를 사용하는 문자열 보간도 무시됩니다.\nIn [1]: s=\"abc\"\nOut[1]: \"abc\"\n\nIn [2]: \"123$s\"\nOut[2]: \"123abc\"\n\nIn [3]: raw\"123$s\"\nOut[3]: \"123\\$s\"",
    "crumbs": [
      "Julia 언어의 활용",
      "문자열 리터럴"
    ]
  },
  {
    "objectID": "src/application_of_julia/string_literal.html#비표준-문자열-리터럴의-작성",
    "href": "src/application_of_julia/string_literal.html#비표준-문자열-리터럴의-작성",
    "title": "문자열 리터럴",
    "section": "3 비표준 문자열 리터럴의 작성",
    "text": "3 비표준 문자열 리터럴의 작성\n위에서 보았듯이 비표준 문자열 리터럴은 특정한 객체를 생성하는 생성자로 사용됩니다. 이런 비표준 문자열 리터럴에 대한 규칙은 매크로를 이용하여 만들 수 있습니다. 예를 들어 어떤 문자열이 수와 문자가 공백으로 구분되어 있으며, 이중 정수형 만을 골라내어 배열로 만들고자 한다고 합시다. 즉 \"1 23 a 3.3 5\" 의 문자열에서 정수만을 뽑아내어 배열 [1, 23, 5] 를 생성하는 일을 비표준 문자열 리터럴로 해 봅시다.\n비표준 문자열 리터럴은 구분자 와 _str 을 합친 이름의 매크로를 작성하면 됩니다. 즉 앞의 문자열을 A\"1 23 a 3.3 5\" 로 사용하고자 한다면 A_str 라는 이름을 갖도록 매크로를 작성합니다. 버젼 넘버 리터럴은 v_str 매크로를 통해 구현었으며 Raw string 리터럴은 raw_str 매크로를 통해 구현되었습니다. 우리가 앞서 언급했던 것을 매크로로 구현해 봅시다.\nmacro A_str(s)\n    split(s)\n    filter!(!isnothing,[if tryparse(Int64, a) != nothing parse(Int64, a) else nothing end for a in split(s)])\nend\n여기에\np = A\"1 23 a 3.3 5\"\n를 실행시키면 원하는 정수 배열을 얻을 수 있습니다. isnothing, tryparse, parse 함수는 직접 알아보기 바랍니다. 배열 생성에 array comprehension 과 내부의 if ... else ... end 구문을 사용하는 것은 Array comprehension 을 이용한 배열의 생성 를 참고하십시요.\n만약 “A 3 2 12” 와 같은 문자열이 주어졌다면 다음을 통해 A\"...\" 리터럴로 바꾸고, 자연스럽게 배열을 만들 수 있습니다.\ns = \"A 3 2 12\"\neval(Meta.parse(\"A\\\"$s\\\"\"))\n혹은\ns2=\"A\\\"\" * s * \"\\\"\"\neval(Meta.parse(s2))\n와 같이 할 수 있습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "문자열 리터럴"
    ]
  },
  {
    "objectID": "src/application_of_julia/multithreads.html",
    "href": "src/application_of_julia/multithreads.html",
    "title": "다중스레딩",
    "section": "",
    "text": "프로그램은 최소한 하나의 프로세스로 실행되며, 프로세스는 최소한 하나의 쓰레드로 실행됩니다. 프로그램이 여러개의 프로세스로 실행되는 것을 멀티 프로세싱(multi-processing) 이라고 하며, 하나의 프로세스가 여려개의 쓰레드로 실행되는 것을 다중 스레딩(multi-threading) 이라고 합니다. Julia 에서의 다중스레딩에 대한 다음의 블로그 Announcing composable multi-threaded parallelism in Julia 는 줄리아의 창시자들의 블로그로 많은 도움이 됩니다.\n하나의 프로세스는 메모리상에 독립적으로 실행 코드와 데이터가 함께 기록됩니다. 쓰레드는 프로세스에 종속되며 프로세스상의 공통 자원에 접근 할 수 있습니다. 그러나 프로세스간에는 자원을 공유 할 수 없으며 IPC(inter-process communication) 를 통해 데이터를 주고 받을 수 있을 뿐입니다. 데이터를 주고 받는 것일 뿐 이 데이터는 각각의 프로세스에서 각각의 메모리 공간에 기록될 뿐 한 프로세스에서 다른 프로세스의 자원에 접근 할 수 있는 것은 아닙니다.\nJulia 는 실행시킬 때나 사용자 환경변수(JULIA_NUM_THREADS)로 지정하지 않았을 때는 단일 쓰레드로 실행됩니다. 현재의 Julia 에서 사용할 수 있는 스레드의 갯수는 Threads.nthreads() 함수로 확인 할 수 있는데, 저자의 경우 환경변수로 지정했기 때문에 Julia 가 실행 될 때 마다 12 개의 스레드로 시작합니다.\nJulia REPL 을 시작할 때 julia --thread 4 혹은 julia -t 4와 같이 스레드 갯수를 지정할 수 있습니다. 혹은 환경변수로 지정하여 자동으로 스레드 수를 정하는 방법이 있습니다. 환경변수로 지정하는 것은 운영체제마다, 혹은 당신이 사용하는 shell 마다 다를 수 있기 때문에 여기서는 다루지 않겠습니다. Sys.CPU_THREADS 변수는 최대로 사용할 수 있는 쓰레드의 갯수를 보여줍니다. 이 값보다 약간 작은 값을 사용하는것이 좋습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "다중스레딩"
    ]
  },
  {
    "objectID": "src/application_of_julia/multithreads.html#for-루프에서의-theads.threads",
    "href": "src/application_of_julia/multithreads.html#for-루프에서의-theads.threads",
    "title": "다중스레딩",
    "section": "1 for 루프에서의 Theads.@threads",
    "text": "1 for 루프에서의 Theads.@threads\nfor 루프 앞에 Threads.@threads 를 쓰면 자동적으로 다중스레딩으로 수행합니다.. 아래 코드는 \\([0, 1)\\) 구간에서의 임의의 수로 이루어진 10000 × 10000 행렬을 만든 후 각행과 열에에 대한 합을 구하는 코드를 싱글 스레드와 다중스레드로 구현한 것입니다.\nusing BenchmarkTools\n\nN = 1000\nbb = rand(N, N)\n\n# 행에 대한 합, 단일스레드\nr1 = zeros(N)\n@btime begin\n    for i in 1:N\n        r1[i] = sum(bb[i, : ])\n    end\nend\n\n# 행에 대한 합, 다중스레드\nr2 =  zeros(N)\n@btime begin\n    Threads.@threads for i in 1:N\n        r2[i] = sum(bb[i, :])\n    end\nend\n\n# 열에 대한 합, 단일스레드\nr3 =  zeros(N)\n@btime begin\n    for i in 1:N\n        r3[i] = sum(bb[:, i])\n    end\nend\n\n# 열에 대한 합, 다중스레드\nr4 =  zeros(N)\n@btime begin\n    Threads.@threads for i in 1:N\n        r4[i] = sum(bb[:, i])\n    end\nend\n결과는 다음과 같습니다.\n  3.375 ms (5957 allocations: 7.84 MiB)\n  635.961 μs (5030 allocations: 7.82 MiB)\n  1.744 ms (5957 allocations: 7.84 MiB)\n  393.205 μs (5028 allocations: 7.82 MiB)\n12개의 스레드를 이용했을 때 단일 스레드보다 약 4~5배 이상 빨라졌으며, 행에 대한 합보다 열에 대한 합이 더 빠릅니다. 열에 대한 합이 더 빠른 것은 julia 가 배열에서 행 우선 방식을 사용하기 때문입니다. 행렬의 열/행 우선 방식 를 참고하십시요.",
    "crumbs": [
      "Julia 언어의 활용",
      "다중스레딩"
    ]
  },
  {
    "objectID": "src/application_of_julia/multithreads.html#안전한-스레드",
    "href": "src/application_of_julia/multithreads.html#안전한-스레드",
    "title": "다중스레딩",
    "section": "2 안전한 스레드",
    "text": "2 안전한 스레드\n다음의 코드를 봅시다.\ns = 1\nThreads.@threads for i in 1:5\n    global s += (-1)^(s+i)\n    @show i, s\nend\nprintln(s)\n실행시킬 때마다 i 값과 s 값, 그리고 결과로서 나오는 s 값이 달라진다는 것을 확인 할 수 있습니다. 즉 1 에서 5 사이에 있는 i 값중 어떤 값을 가진 스레드가 먼저 실행되어 s 값을 결정하는지에 대한 순서는 무작위적이며, 따라서 결과로서 나오는 s 값도 그때 그때 달라집니다. 이렇게 여러 스레드 혹은 프로세스가 공유하는 값(여기서는 s) 에 접근하는데 그 접근 순서가 결과값에 영항을 줄 수 있는 상태를 경쟁 상태 (race condition) 라고 하며 실제제로 데이터 값이 변하는 것을 데이터 레이스 (data race) 라고 합니다.\n데이터 레이스가 발생하는 더 심각한 상태는 여러 개의 스레드가 동시에 접근하여 동시에 읽거나 쓸 때 입니다. 다음의 코드를 봅시다.\nBase.@kwdef mutable struct ms\n    a::Int\n    b::Int\nend\n\nc=ms(1, 1)\nThreads.@threads for i in 1:30\n    c.a = i\n    c.b +=round(Int64, c.a*cos(i))\nend\n\nprintln(c)\n만약 한 스레드가 ms 객체를 읽고 쓸 때 다른 스레드가 멈추고 있다면 이 객체의 값은 항상 같을 것입니다. 이 코드를 여러번 실행시켜봐 가며 확인해보면 알듯이 그 값이 실행시킬 때마다 다릅니다. 그것은 여러 스레드가 동시에 읽고 쓰고 있다는 의미입니다. 그것을 막기 위해 Threads.ReentrantLock() 함수를 이용하여 다음과 같이 할 수 있습니다.\nlk = Threads.ReentrantLock()\nd=ms(1, 1)\nThreads.@threads for i in 1:30\n    lock(lk) do\n        d.a = i\n        d.b +=round(Int64, d.a*cos(i))\n    end\nend\nprintln(d)\n이 때 최종적으로 d 객체에 접근하는 스레드는 다르기 때문에 d.a 값은 다르지만, 한 스레드가 읽고 쓰는 동안 다른 스레드가 읽고 쓸 수 없기때문에 d.b 의 값은 항상 같게 됩니다.\n최종적으로 데이터 레이스에 대한 책임은 전적으로 여러분에게 있습니다. 위의 방법은 도움이 될 수 있지만 모든 경우에 적용될 수 있는 것도 아닙니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "다중스레딩"
    ]
  },
  {
    "objectID": "src/application_of_julia/asynchronous.html",
    "href": "src/application_of_julia/asynchronous.html",
    "title": "비동기 프로그래밍",
    "section": "",
    "text": "프로그램이 수행하는 일로서의 작업과 비동기 프로그래밍의 개념으로서의 작업(Task) 를 구분하기 위해 후자를 항상 Task 로 표기하며 전자는 한글로 작업 이라고 표기합니다.\n프로그램이 외부 세계와 상호 작용해야 할 때(예: 인터넷을 통해 다른 컴퓨터와 통신) 프로그램의 작업이 예측할 수 없는 순서로 진행되어야 할 수 있습니다. 프로그램에서 파일을 다운로드해야 한다고 가정해 보겠습니다. 다운로드 작업을 시작하고 완료될 때까지 다른 작업을 수행한 다음 다운로드된 파일이 필요한 코드를 사용할 수 있게 되면 다시 시작하고 싶습니다. 이런 종류의 시나리오는 비동기 프로그래밍의 영역에 속하며, 때로는 동시 프로그래밍이라고도 합니다(개념적으로 여러 가지가 동시에 발생하기 때문입니다).\n이러한 시나리오를 해결하기 위해 Julia는 Task 라는 기능을 제공합니다. 이 Task 는 대칭 코루틴(symmetric coroutines), 경량 스레드(lightweight threads), 협력적 멀티태스킹(cooperative multitasking) 또는 원샷 연속(one-shot continuations)과 같은 다른 여러 이름으로 불리기도 합니다. 어떤 실제의 컴퓨팅 작업(특정 함수 실행)이 Task 로 지정되면 다른 작업으로 전환하여 작업을 중단할 수 있습니다. 원래 작업은 나중에 다시 시작할 수 있으며, 이때 중단된 지점에서 바로 시작합니다. 처음에는 함수 호출과 유사해 보일 수 있습니다. 그러나 두 가지 주요 차이점이 있습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "비동기 프로그래밍"
    ]
  },
  {
    "objectID": "src/application_of_julia/asynchronous.html#task-의-기본-기능",
    "href": "src/application_of_julia/asynchronous.html#task-의-기본-기능",
    "title": "비동기 프로그래밍",
    "section": "1 Task 의 기본 기능",
    "text": "1 Task 의 기본 기능\nTask 는 인자가 없는 함수 f 에 대해 Task(f) 와 같이 호출하거나 앞에 @task 매크로를 사용하여 생성합니다. 수행하면 5초를 기다렸다가(sleep(5)) 이후 done 을 출력하는 작업을 Task 로 생성해 봅시다. 아래의 두 코드는 동일한 기능을 합니다.\nIn [5]: t = @task begin; sleep(5); println(\"done\"); end\nOut[5]: Task (runnable) @0x000000010e231120\nIn [6]: f() = begin sleep(5);println(\"done\") end\nOut[6]: f (generic function with 1 method)\n\nIn [7]: t = Task(f)\nOut[7]: Task (runnable) @0x000000010db386a0\n여기까지는 준비가 되었을 뿐 실행을 시작하지 않은 상태이며. schedule 함수를 통해 실행 할 수 있습니다. Julia REPL 에서 다음과 같이 수행해 봅시다.\nIn [10]: schedule(t)\nOut[10]: Task (runnable) @0x000000010db386a0\n5초 후 REPL 에 아래와 같은 메시지가 찍힙니다.\nIn [11]: done\nIn [11]:\nTask 인 t 에 대해 wait(t) 는 t 가 종료될 때까지 기다리게 합니다.\nIn [15]: t = @task begin; sleep(5); println(\"done\"); end\nOut[15]: Task (runnable) @0x000000010e231120\n\nIn [16]: schedule(t1);wait(t1)\ndone1\n단순히 schedule(t) 만 했을 때는 즉각 REPL 로 제어권이 넘어오지만, 즉 새로운 입력 프롬프트가 보이지만 schedule(t);wait(t) 했을 때는 Task t 가 끝난 후에야 REPL 의 새로운 입력 프롬프트가 보입니다.\n앞으로 많이 사용하게 될 @asynk x 매크로는 schedule(@task x) 와 같습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "비동기 프로그래밍"
    ]
  },
  {
    "objectID": "src/application_of_julia/asynchronous.html#채널channel-과의-통신",
    "href": "src/application_of_julia/asynchronous.html#채널channel-과의-통신",
    "title": "비동기 프로그래밍",
    "section": "2 채널(Channel) 과의 통신",
    "text": "2 채널(Channel) 과의 통신\nJulia 에서 Channel 은 여러 Task 가 읽고 쓸 수 있는 대기 가능한 선입 선출(first-in first-out) 큐(Que) 입니다. 큐는 컨테이너로 put! 함수를 통해 추가하고 take! 함수를 통해 컨테이너의 성분을 반환받으며 컨테이너에서 제거합니다. 먼저 put! 한 순서대로 take! 됩니다.\nIn [1]: function producer(c::Channel)\n                   put!(c, \"start\")\n                   for n=1:4\n                       put!(c, 2n)\n                   end\n                   put!(c, \"stop\")\n               end;\n\nIn [2]: chnl = Channel(producer);\n\nIn [3]: take!(chnl)\nOut[3]: \"start\"\n\nIn [4]: take!(chnl)\nOut[4]: 2\n\nIn [4]: take!(chnl)\nOut[4]: 4\n\nIn [4]: take!(chnl)\nOut[4]: 6\n\nIn [4]: take!(chnl)\nOut[4]: 8\n\nIn [4]: take!(chnl)\nOut[4]: \"stop\"\n\nIn [4]: take!(chnl)\nERROR: InvalidStateException: Channel is closed.\nIn [1] 에서 Channel 을 인자로 받는 함수 procedure 를 정의했습니다. In [2] 에서 Channel 객체를 procedure 함수를 통해 생성시켰습니다. \"start\", 2, 4, 6, 8 \"end\" 순서로 입력되었으므로 take!(chnl) 로 빼낼때 역시 같은 순서로 나옵니다. 그리고 마지막의 원소가 빠져 빈 큐가 된 상태에서 take! 를 수행하면 에러가 발생합니다.\nChannel 은 반복자이므로 for 루프에 사용 할 수 있습니다.\nIn [11]: chnl = Channel(producer);\n\nIn [12]: [x for x in chnl]\nOut[12]: 6-element Vector{Any}:\n  \"start\"\n 2\n 4\n 6\n 8\n  \"stop\"",
    "crumbs": [
      "Julia 언어의 활용",
      "비동기 프로그래밍"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "Summary",
    "section": "",
    "text": "Summary\nIn summary, this book has no content whatsoever."
  },
  {
    "objectID": "src/introduction_to_julia/11_polynomial.html",
    "href": "src/introduction_to_julia/11_polynomial.html",
    "title": "Introduction To Julia",
    "section": "",
    "text": "이제 일변수 다항식 (\\(x\\) 에 대한 다항식)을 특별한 자료형으로 Julia 언어에서 구현해보자. 다항식은 기본적인 함수일 뿐만 아니라 수치해석에도 널리 사용된다. 여기서는 다항식에 대한 객체를 만들어 앞으로도 사용하고자 한다. Julia 자체는 다항식에 대한 자료구조나 객체를 포함하지 않지만 2022 년 현재 Polynomials.jl 이라는 라이브러리가 널리 사용된다. 그러나 여기서는 이 책에서 계속 사용할 다항식 객체를 만들고자 한다.\n\n\n\nJulia 에서 함수는 1급 객체로, 변수에 할당 될 수 있으며, 타입을 가질 수 있고, 함수의 리턴값으로 사용 될 수 있다. 이를 이용하면 계수를 1차원 배열인 벡터로 전달하여 익명 함수를 리턴하는 함수를 작성 할 수 있다. 다음 poly1 함수는 다항식의 전체 계수 벡터 coeff 를 인자로 받아 coeff[i] 가 다항식의 \\(i-1\\) 차 계수가 되는 함수를 리턴한다.\nfunction poly1(coeff::Vector{T}) where T&lt;:Number\n    return x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1))))\nend\n우리는 이 함수가 잘 작동함을 확인 할 수 있다.\nIn [2]: ff = poly1([1.0, -2.0, 1.0])\nOut[2]: #3 (generic function with 1 method)\n\nIn [3]: ff(1.0)\nOut[3]: 0.0\n함수 시그니쳐의 poly1(coeff::Vector{T}) where T&lt;:Number 에서 poly1(coeff::Vector{T}) 는 poly1 함수가 T 타입의 벡터를 인자로 받는다는 뜻이며 뒤의 where T&lt;:Number 는 T 가 Number 의 서브타입만을 허락한다는 의미이다. Number 는 추상 타입(abstract type) 이므로 변수에 할당 될 수 없다. 따라서 coeff 가 벡터가 아니거나, 수 타입에 대한 벡터가 아니면 에러가 발생한다.\nIn [4]: poly1(3)\nERROR: MethodError: no method matching poly1(::Int64)\n\nIn [5]: poly1([sin, 1])\nERROR: MethodError: no method matching poly1(::Vector{Any})\nreturn 뒤의 x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1)))) 구문은 익명함수를 만드는 구문이다. 수를 받아 다항식을 계산하는 익명 함수를 반환한다. 이렇게 하면 ff = poly1([1.0, -2.0, 1.0]) 라 하면 ff(x) 는 \\(1-2x+x^2\\) 를 나타내는 다항식이다. 이 다항식의 함수에서 리턴 타입은 coeff 와 x 의 타입의 연산 규칙에 다라 결정된다.\n때에 따라서는 이것도 충분하며, 타입을 고려하지 않는다면 심지어 이것보다 간단한 버젼도 가능하다. 그러나 보통 다항식을 나타내는 자료구조를 생각하면, 최소한 다항식간의 덧셈, 뺄셈, 곱셈이 가능하면 좋을 것이다. 그리고 행렬의 다항식도 가능하다면 구현하면 좋을 것이다.\n익명 함수로는 이것이 힘들다. structure 를 이용하여 다항식 객체를 만들어 보자. 이미 널리 사용되는 Polynomials.jl 패키지가 있으므로 SimplePolynomial 이라는 객체를 만들도록 하자.\n\n\n\n\nstruct SimplePolynomial{T} \n    coeffs :: Vector{T}\n    \n    function SimplePolynomial(a::AbstractVector{P}) where P &lt;: Number\n        if length(a) == 0 \n            return new{P}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{P}(a[1:a_last])\n        end\n    end\n\n    function SimplePolynomial{T}(a::AbstractVector{P}) where {T &lt;: Number, P&lt;:Number}\n        if length(a) == 0 \n            return new{T}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{T}(convert.(T, a[1:a_last]))\n        end\n    end\n\nend\nSimplePolynomial 은 immutable 한 객체로 구현되었다. 즉 coeffs 속성은 변경 될 수 없다.\nIn [1]: a = SimplePolynomial([1, 3])\nOut[1]: SimplePolynomial{Int64}([1, 3])\n\nIn [2]: a.coeffs = [3.0, 4.0]\nERROR: setfield!: immutable struct of type SimplePolynomial cannot be changed\nstruct 구문 내부의 function SimplePolynomial 로 시작하는 구문은 내부생성자 (inner constructor) 구문이다. SimplePolynomial 자체가 타입매개변수 T 를 정할수 있는 타입이기 때문에 하나는 타입매개변수가 지정되지 않았을 때 타입을 계수로 주어진 인자 a 의 성분의 타입으로 정하고, 남은 하나는 a 를 타입 인자 T 로 주어지는 타입으로 변환시켜 다항식을 만들어 내게 된다.\n이제 SimplePolynomial 객체를 이용하여 수 형식, 혹은 정사각 행렬에 대한 다항식을 계산하는 함수를 만들자.\nusing LinearAlgebra\n\nfunction (p::SimplePolynomial)(x::Number)\n    return evalpoly(x, p.coeffs)\nend\n\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Matrix{N} where N&lt;:Number\n    r = UniformScaling(p.coeffs[1])\n\n    @assert size(x)[1] == size(x)[2] # 정사각 행렬에 대해서만 가능하다.\n    for i in 2:length(p.coeffs)\n        @inbounds r +=  p.coeffs[i]*x^(i-1)\n    end\n    return r\nend\n단위행렬의 상수배를 나타내는 연산자 UniformScaling을 위해 LinearAlgebra 모듈을 임포트 했다. 정사각 행렬임을 확인하기 위해 @assert size(x)[1] == size(x)[2] 를 삽입하였다. REPL 에서의 아래의 결과를 보면 정확히 구현되었음을 알 수 있다.\nIn [1]: a1 = SimplePolynomial([1.0, 2.0, 3.0])\nOut[1]: SimplePolynomial{Float64}([1.0, 2.0, 3.0])\n\nIn [2]: a1(1.0)\nOut[2]: 6.0\n\nIn [3]: a1([4 3; 2 4])\nOut[3]: 2×2 Matrix{Float64}:\n 75.0  78.0\n 52.0  75.0\n\nIn [4]: a1([4 3 3; 2 4 3])\nERROR: AssertionError: (size(x))[1] == (size(x))[2]\n다항식의 덧셈, 뺄셈, 곱셈을 정의하기 전에 다항식의 차수에 관련된 값을 리턴하는 함수를 만들자. 일반적으로 배열은 length 함수로 원소의 갯수를 알 수 있는데, 다항식에서는 계수의 갯수-1 이 차수가 된다. Base.length 함수에 대한 디스패치를 작성하여 이 함수를 이용하자.\nfunction Base.:length(b::P) where {P&lt;: SimplePolynomial}\n    return length(b.coeffs)\nend\n이제 SimpllePolynomial 객체 사이에 혹은 SimplePolynomial 객체와 상수간의 +, -, *, / 연산을 정의 할 수 있다. / 의 경우 일단은 다항식/상수 만을 정의한다. 이것에 대한 구현은 polynomial.jl 파일에 존재한다. Julia REPL 이나 Jupyter notebook 등에서 include 명령을 통해 사용 할 수 있다.\ninclude(\"path_to_polynomial.jl\")\n다항식 \\(p(x) = a_0 + a_1 x + \\cdots + a_n x^n\\) 일 때,\n\\[\n\\begin{aligned}\n\\dfrac{d}{dx}p(x) &= a_1 + 2a_2 x + \\cdots + na_n x^{n-1},\\\\\n\\int_x p(t)\\, dt &=a_0 x + \\dfrac{a_1}{2}x^2 + \\cdots + \\dfrac{a_n}{n+1}x^{n+1} + \\text{const.}\n\\end{aligned}\n\\]\n임을 안다. 이것을 이용하여 다항식을 미분하는 함수 differentiate(p::Polynomial{T}) 와 정적분 함수 integrate(p::Polynomial{T}, c) 함수를 구현하였다. 여기서 c 는 정적분의 상수항이다.\n\n\n\n\n다항식 \\(p(x)\\) 의 전체 근이 \\(x_1,\\,x_2,\\ldots,\\,x_n\\) 라고 하면 이 다항식은 상수 \\(c\\) 에 대해\n\\[\np(x) = c \\prod_{i=1}^n (x-x_i)\n\\]\n의 꼴을 갖는다. 우리는 이미 다항식의 곱셈을 구현했으므로 이를 쉽게 구현 할 수 있다. 여기서는 \\(c=1\\) 로 정해진 다항식을 리턴한다.\nfunction polynomial_from_roots(xp::Vector{T}) where T&lt;:Number\n    r = one(T)\n    for i in 1:length(xp) \n        @inbounds r = r* SimplePolynomial([-xp[i],  1])\n    end\n    return r\nend\n그렇다면,\njulia&gt; pp3 = polynomial_from_roots([1.0, 1.0, 2.0])\nSimplePolynomial :  + 1.0 x^3 - 4.0 x^2 + 5.0 x^1 - 2.0 \n의 결과가 나온다. \\((x-1)^2(x-2)= x^3-4x^2+5x-2\\) 이므로 정확한 결과가 나왔다."
  },
  {
    "objectID": "src/introduction_to_julia/11_polynomial.html#일변수-다항식의-julia-구현",
    "href": "src/introduction_to_julia/11_polynomial.html#일변수-다항식의-julia-구현",
    "title": "Introduction To Julia",
    "section": "",
    "text": "이제 일변수 다항식 (\\(x\\) 에 대한 다항식)을 특별한 자료형으로 Julia 언어에서 구현해보자. 다항식은 기본적인 함수일 뿐만 아니라 수치해석에도 널리 사용된다. 여기서는 다항식에 대한 객체를 만들어 앞으로도 사용하고자 한다. Julia 자체는 다항식에 대한 자료구조나 객체를 포함하지 않지만 2022 년 현재 Polynomials.jl 이라는 라이브러리가 널리 사용된다. 그러나 여기서는 이 책에서 계속 사용할 다항식 객체를 만들고자 한다.\n\n\n\nJulia 에서 함수는 1급 객체로, 변수에 할당 될 수 있으며, 타입을 가질 수 있고, 함수의 리턴값으로 사용 될 수 있다. 이를 이용하면 계수를 1차원 배열인 벡터로 전달하여 익명 함수를 리턴하는 함수를 작성 할 수 있다. 다음 poly1 함수는 다항식의 전체 계수 벡터 coeff 를 인자로 받아 coeff[i] 가 다항식의 \\(i-1\\) 차 계수가 되는 함수를 리턴한다.\nfunction poly1(coeff::Vector{T}) where T&lt;:Number\n    return x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1))))\nend\n우리는 이 함수가 잘 작동함을 확인 할 수 있다.\nIn [2]: ff = poly1([1.0, -2.0, 1.0])\nOut[2]: #3 (generic function with 1 method)\n\nIn [3]: ff(1.0)\nOut[3]: 0.0\n함수 시그니쳐의 poly1(coeff::Vector{T}) where T&lt;:Number 에서 poly1(coeff::Vector{T}) 는 poly1 함수가 T 타입의 벡터를 인자로 받는다는 뜻이며 뒤의 where T&lt;:Number 는 T 가 Number 의 서브타입만을 허락한다는 의미이다. Number 는 추상 타입(abstract type) 이므로 변수에 할당 될 수 없다. 따라서 coeff 가 벡터가 아니거나, 수 타입에 대한 벡터가 아니면 에러가 발생한다.\nIn [4]: poly1(3)\nERROR: MethodError: no method matching poly1(::Int64)\n\nIn [5]: poly1([sin, 1])\nERROR: MethodError: no method matching poly1(::Vector{Any})\nreturn 뒤의 x -&gt; sum(coeff .* (x .^ (0:(length(coeff)-1)))) 구문은 익명함수를 만드는 구문이다. 수를 받아 다항식을 계산하는 익명 함수를 반환한다. 이렇게 하면 ff = poly1([1.0, -2.0, 1.0]) 라 하면 ff(x) 는 \\(1-2x+x^2\\) 를 나타내는 다항식이다. 이 다항식의 함수에서 리턴 타입은 coeff 와 x 의 타입의 연산 규칙에 다라 결정된다.\n때에 따라서는 이것도 충분하며, 타입을 고려하지 않는다면 심지어 이것보다 간단한 버젼도 가능하다. 그러나 보통 다항식을 나타내는 자료구조를 생각하면, 최소한 다항식간의 덧셈, 뺄셈, 곱셈이 가능하면 좋을 것이다. 그리고 행렬의 다항식도 가능하다면 구현하면 좋을 것이다.\n익명 함수로는 이것이 힘들다. structure 를 이용하여 다항식 객체를 만들어 보자. 이미 널리 사용되는 Polynomials.jl 패키지가 있으므로 SimplePolynomial 이라는 객체를 만들도록 하자.\n\n\n\n\nstruct SimplePolynomial{T} \n    coeffs :: Vector{T}\n    \n    function SimplePolynomial(a::AbstractVector{P}) where P &lt;: Number\n        if length(a) == 0 \n            return new{P}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{P}(a[1:a_last])\n        end\n    end\n\n    function SimplePolynomial{T}(a::AbstractVector{P}) where {T &lt;: Number, P&lt;:Number}\n        if length(a) == 0 \n            return new{T}(zeros(T, 1))\n        else \n            last_nz = findlast(!iszero, a)\n            a_last = max(1, isnothing(last_nz) ? 0 : last_nz)\n            return new{T}(convert.(T, a[1:a_last]))\n        end\n    end\n\nend\nSimplePolynomial 은 immutable 한 객체로 구현되었다. 즉 coeffs 속성은 변경 될 수 없다.\nIn [1]: a = SimplePolynomial([1, 3])\nOut[1]: SimplePolynomial{Int64}([1, 3])\n\nIn [2]: a.coeffs = [3.0, 4.0]\nERROR: setfield!: immutable struct of type SimplePolynomial cannot be changed\nstruct 구문 내부의 function SimplePolynomial 로 시작하는 구문은 내부생성자 (inner constructor) 구문이다. SimplePolynomial 자체가 타입매개변수 T 를 정할수 있는 타입이기 때문에 하나는 타입매개변수가 지정되지 않았을 때 타입을 계수로 주어진 인자 a 의 성분의 타입으로 정하고, 남은 하나는 a 를 타입 인자 T 로 주어지는 타입으로 변환시켜 다항식을 만들어 내게 된다.\n이제 SimplePolynomial 객체를 이용하여 수 형식, 혹은 정사각 행렬에 대한 다항식을 계산하는 함수를 만들자.\nusing LinearAlgebra\n\nfunction (p::SimplePolynomial)(x::Number)\n    return evalpoly(x, p.coeffs)\nend\n\nfunction (p::SimplePolynomial)(x::T) where T &lt;: Matrix{N} where N&lt;:Number\n    r = UniformScaling(p.coeffs[1])\n\n    @assert size(x)[1] == size(x)[2] # 정사각 행렬에 대해서만 가능하다.\n    for i in 2:length(p.coeffs)\n        @inbounds r +=  p.coeffs[i]*x^(i-1)\n    end\n    return r\nend\n단위행렬의 상수배를 나타내는 연산자 UniformScaling을 위해 LinearAlgebra 모듈을 임포트 했다. 정사각 행렬임을 확인하기 위해 @assert size(x)[1] == size(x)[2] 를 삽입하였다. REPL 에서의 아래의 결과를 보면 정확히 구현되었음을 알 수 있다.\nIn [1]: a1 = SimplePolynomial([1.0, 2.0, 3.0])\nOut[1]: SimplePolynomial{Float64}([1.0, 2.0, 3.0])\n\nIn [2]: a1(1.0)\nOut[2]: 6.0\n\nIn [3]: a1([4 3; 2 4])\nOut[3]: 2×2 Matrix{Float64}:\n 75.0  78.0\n 52.0  75.0\n\nIn [4]: a1([4 3 3; 2 4 3])\nERROR: AssertionError: (size(x))[1] == (size(x))[2]\n다항식의 덧셈, 뺄셈, 곱셈을 정의하기 전에 다항식의 차수에 관련된 값을 리턴하는 함수를 만들자. 일반적으로 배열은 length 함수로 원소의 갯수를 알 수 있는데, 다항식에서는 계수의 갯수-1 이 차수가 된다. Base.length 함수에 대한 디스패치를 작성하여 이 함수를 이용하자.\nfunction Base.:length(b::P) where {P&lt;: SimplePolynomial}\n    return length(b.coeffs)\nend\n이제 SimpllePolynomial 객체 사이에 혹은 SimplePolynomial 객체와 상수간의 +, -, *, / 연산을 정의 할 수 있다. / 의 경우 일단은 다항식/상수 만을 정의한다. 이것에 대한 구현은 polynomial.jl 파일에 존재한다. Julia REPL 이나 Jupyter notebook 등에서 include 명령을 통해 사용 할 수 있다.\ninclude(\"path_to_polynomial.jl\")\n다항식 \\(p(x) = a_0 + a_1 x + \\cdots + a_n x^n\\) 일 때,\n\\[\n\\begin{aligned}\n\\dfrac{d}{dx}p(x) &= a_1 + 2a_2 x + \\cdots + na_n x^{n-1},\\\\\n\\int_x p(t)\\, dt &=a_0 x + \\dfrac{a_1}{2}x^2 + \\cdots + \\dfrac{a_n}{n+1}x^{n+1} + \\text{const.}\n\\end{aligned}\n\\]\n임을 안다. 이것을 이용하여 다항식을 미분하는 함수 differentiate(p::Polynomial{T}) 와 정적분 함수 integrate(p::Polynomial{T}, c) 함수를 구현하였다. 여기서 c 는 정적분의 상수항이다.\n\n\n\n\n다항식 \\(p(x)\\) 의 전체 근이 \\(x_1,\\,x_2,\\ldots,\\,x_n\\) 라고 하면 이 다항식은 상수 \\(c\\) 에 대해\n\\[\np(x) = c \\prod_{i=1}^n (x-x_i)\n\\]\n의 꼴을 갖는다. 우리는 이미 다항식의 곱셈을 구현했으므로 이를 쉽게 구현 할 수 있다. 여기서는 \\(c=1\\) 로 정해진 다항식을 리턴한다.\nfunction polynomial_from_roots(xp::Vector{T}) where T&lt;:Number\n    r = one(T)\n    for i in 1:length(xp) \n        @inbounds r = r* SimplePolynomial([-xp[i],  1])\n    end\n    return r\nend\n그렇다면,\njulia&gt; pp3 = polynomial_from_roots([1.0, 1.0, 2.0])\nSimplePolynomial :  + 1.0 x^3 - 4.0 x^2 + 5.0 x^1 - 2.0 \n의 결과가 나온다. \\((x-1)^2(x-2)= x^3-4x^2+5x-2\\) 이므로 정확한 결과가 나왔다."
  },
  {
    "objectID": "src/introduction_to_julia/09I_pretty_printing.html",
    "href": "src/introduction_to_julia/09I_pretty_printing.html",
    "title": "Interlude : 객체를 보기좋게 출력하기",
    "section": "",
    "text": "Interlude : 객체를 보기좋게 출력하기\n복소수를 나타내는 Complex 타입은 복합 타입이며 복소수에 대한 출력은 다음과 같습니다.\nIn [1]: c1 = Complex(2.0, 3.0)\nOut[1]: 2.0 + 3.0im\n당신이 만약 당신만의 복소수 타입을 복합타입으로 만들었다고 합시다.\nIn [2]: struct mycomplex\n        re\n        im\n        end\n\nIn [3]: c2 = mycomplex(2.0, 3.0)\nOut[3]: mycomplex(2.0, 3.0)\n보통 복합 타입의 출력은 위와 같이 타입 이름 뒤에 괄호로 그 필드의 값을 정의된 순서대로 나열합니다. 만약 어떤 타입에 많은 필드가 있지만 실제로 사용하면서 확인해야 할 필드는 소수라면, 굳이 여러개의 필드를 보여주지 않아도 됩니다. 혹은 Complex 타입에서 순허수 \\(\\sqrt{-1}\\) 를 im 으로 표기하는 것이 당신의 미적 감각에 거슬릴 수도 있습니다. 이 때 Base.show 함수를 mycomplex 타입에 대한 메서드로 만든다면 그 출력을 바꿀 수 있습니다.\nIn [12]: Base.show(io::IO, cc::mycomplex) = print(io, cc.re , \" + i\",  cc.im)\n\nIn [13]: c2\nOut[13]: 2.0+ i 3.0\n\nIn [14]: [mycomplex(2.0, 3.0); mycomplex(3.0, 4.0)]\nOut[14]: 2-element Vector{mycomplex}:\n 2.0 + i3.0\n 3.0 + i4.0\n그런데 허수부가 음수일 경우에는 별로 보기 안좋습니다.\nIn [20]: mycomplex(2.0, -1.0)\nOut[20]: 2.0 + i-1.0\n이것은 표준적인 복소수 표기법에 어긋나죠. 우리가 원하는 것은 2.0 - i1.0 입니다.\nIn [23]: function Base.show(io::IO, cc::mycomplex)\n         if cc.im &gt;= 0.0\n             print(io, cc.re, \" + i\", cc.im)\n         else\n             print(io, cc.re, \" - i\", abs(cc.im))\n         end\n         end\n\nIn [24]: mycomplex(2.0, -1.0)\nOut[24]: 2.0 - i1.0\n이젠 좀 괜찮아 진 것 같습니다. 물론 mycomplex 타입은 기본적인 사칙연산도 정의가 안되어 있기 때문에 쓸모 없긴 합니다. repr 함수는 Base.show 함수로 출력하는 문자열을 리턴합니다. 예를 들어\nIn [25]: c=mycomplex(1.0, -1.0)\nOut[25]: 1.0 - i1.0\n\nIn [26]: c\nOut[26]: 1.0 - i1.0\n\nIn [27]: repr(c)\nOut[27]: \"1.0 - i1.0\"\n입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 객체를 보기좋게 출력하기"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07I_sort.html",
    "href": "src/introduction_to_julia/07I_sort.html",
    "title": "Interlude : 정렬",
    "section": "",
    "text": "Interlude : 정렬\n정렬(sorting)이란 데이터를 정해진 순서에 따라 나열하는 것을 말합니다. 예를 들어 \\(1, 3, 2\\) 를 오름차순으로 정렬하면 \\(1, 2, 3\\) 이 되고, 내림차순으로 정렬하면 \\(3, 2, 1\\) 이 됩니다. 일반적으로 정렬이라고 하면 오름차순 정렬을 말합니다.\n정렬은 컴퓨터로 아주 많이 수행하는 연산중의 하나이며, 정렬을 효율적으로 하기 위해 많은 알고리즘이 제안되기도 하였습니다. 여기서는 그 알고리즘을 다루지는 않으며, 기본적인 정렬 함수와 그 사용법에 대해서만 다루도록 합니다. 좀 더 자세히 알고 싶으면 julia 문서 Soring and Related Functions 를 참고하시기 바랍니다.\nsort() 가 정렬을 수행하는 기본적인 함수입니다. sort(a) 는 컨테이너 a 를 정렬한 컨테이너를 반환하며 a 자체를 바꾸지는 않습니다. 그러나 sort!(a) 는 a 를 정렬된 상태로 바꿉니다. 그리고 함수 인자에 rev = true 를 입력하면 내림차순으로 정렬합니다.\nIn [1]: a=[1, 3, 5, 2]; b = sort(a)\nOut[1]: 4-element Vector{Int64}:\n 1\n 2\n 3\n 5\n\nIn [2]: sort!(b, rev = true);\n\nIn [3]: b\nOut[3]: 4-element Vector{Int64}:\n 5\n 3\n 2\n 1\nsortperm() 함수는 컨테이너가 정렬되었을 때의 인덱스를 반환합니다. 예를 들어 v=[11, 3, 22] 일 때 v 를 정렬하면 [3, 11, 22] 될 것이며 원래 v 의 입장에서는 v[2], v[1],v[3]가 될 것입니다.sortperm()함수는 바로 그 인덱스[2, 1, 3]` 을 반환합니다.\nIn [1]: v = [11, 3, 22]\nOut[1]: 3-element Vector{Int64}:\n 11\n  3\n 22\n\nIn [2]: sortperm(v)\nOut[2]: 3-element Vector{Int64}:\n 2\n 1\n 3\n배열 a 에 대해 a[[1, 3, 2, 4]] 는 [a[1], a[3], a[2], a[4]] 와 같습니다. 즉 a[sortperm(a)] 는 sort(a) 와 같습니다. sortperm 함수는 어떤 컨테이너의 정럴 순서로 다른 컨테이너를 정렬 할 수 있게 해 줍니다. 예를 들어 우리가 다음과 같은 데이터를 얻었다고 합시다.\n\n\n\nx\ny\n\n\n\n\n5\n10\n\n\n2\n3\n\n\n1\n6\n\n\n7\n12\n\n\n\n배열 x 는 [5, 2, 1, 7] 이고 y 는 [10, 3, 6, 12] 입니다. 이것을 보기 좋게 x 의 순서대로 y 까지 정렬해 봅시다..\nIn [10]: x=[5, 2, 1, 7];y=[10, 3, 6, 12];\n\nIn [11]: v = sortperm(x); x1 = x[v]; y1 = y[v]\nOut[11]: 4-element Vector{Int64}:\n  6\n  3\n 10\n 12\n\nIn [12]: for (x, y) in zip(x1, y1)\n         @show x, y\n         end\n(x, y) = (1, 6)\n(x, y) = (2, 3)\n(x, y) = (5, 10)\n(x, y) = (7, 12)\nx1 과 y1 이 각각 x 의 순서대로 x 와 y 를 정렬한 것임을 확인 할 수 있습니다..\n\n\n함수에 의한 정렬\n함수 f 에 대해 b = sort(a, by = f) 는 함수 f 의 결과값에 따라 a 를 정렬한 배열입니다. 다음 예를 봅시다. sort(0, by=cos) 은 a[perm(cos.(0))] 와 같습니다. 물룐 rev=true 를 인자로 넣으면 역순으로 정렬합니다.\nIn [1]: θ = [0, π/2, π, 3*π/2]\nOut[1]: 4-element Vector{Float64}:\n 0.0\n 1.5707963267948966\n 3.141592653589793\n 4.71238898038469\n\nIn [2]: θ[sortperm(cos.(θ))]\nOut[2]: 4-element Vector{Float64}:\n 3.141592653589793\n 4.71238898038469\n 1.5707963267948966\n 0.0\n\nIn [3]: sort(θ, by = cos)\nOut[3]: 4-element Vector{Float64}:\n 3.141592653589793\n 4.71238898038469\n 1.5707963267948966\n 0.0\n\nIn [4]: sort(θ, by = cos, rev=true)\nOut[4]: 4-element Vector{Float64}:\n 0.0\n 1.5707963267948966\n 4.71238898038469\n 3.141592653589793",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 정렬"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04I_splat_operator.html",
    "href": "src/introduction_to_julia/04I_splat_operator.html",
    "title": "Interlude : ... 연산자",
    "section": "",
    "text": "… 연산자 에서 튜플이나 배열의 첫번째 몇개만 취할 때 ... 연산자를 사용 할 수 있다는 것을 알아보았습니다. Julia 에서 ... 연산자는 두가지 용법으로 사용됩니다.\n\n\n\n튜플이나 StepRange 혹은 1차원 배열과 같이 순서가 있는 컨테이너에 대해서는 직관적으로 알 수 있습니다.\nIn [1]: a1, a2, a3... = (1, \"a\", (2, 3), 4, sin)\nOut[1]: (1, \"a\", (2, 3), 4, sin)\n\nIn [2]: a1, a2\nOut[2]: (1, \"a\")    \n\nIn [3]: b1, b2, b3... = 1:10\nOut[3]: 1:10\n\nIn [4]: b1, b2\nOut[4]: (1, 2)\n\nIn [5]: c1, c2, c3... = [1, 2, 3, 4, 5];\n\nIn [6]: c1, c2\nOut[6]: (1, 2)\n\n집합이나 사전과 같은 순서가 없는 컨테이너에 대해서는 에러를 발생시키지는 않지만 그 결과의 일관성을 보장할 수 없습니다.\nIn [14]: d1, d2, d3... = Set([1, 2, 3, 4]);\n\nIn [15]: d1, d2\nOut[15]: (4, 2)\n\nIn [16]: d1, d2, d3... = Set([1, 2, 3, 4, 5]);\n\nIn [17]: d1, d2\nOut[17]: (5, 4)\n\nIn [18]: a, b, c... = Dict(\"A\"=&gt;1, \"B\"=&gt;2, \"C\"=&gt;3, \"D\"=&gt;4)\nOut[18]: Dict{String, Int64} with 4 entries:\n  \"B\" =&gt; 2\n  \"A\" =&gt; 1\n  \"C\" =&gt; 3\n  \"D\" =&gt; 4\n\nIn [19]: a\nOut[19]: \"B\" =&gt; 2\n\nIn [20]: b\nOut[20]: \"A\" =&gt; 1\n\nIn [21]: c\nOut[21]: Base.Iterators.Rest{Dict{String, Int64}, Int64}(Dict(\"B\" =&gt; 2, \"A\" =&gt; 1, \"C\" =&gt; 3, \"D\" =&gt; 4), 4)\n\n다차원 배열의 경우 선형 인덱스에 따라 일차원 배열로 변환됩니다.\nIn [18]: x1, x2, x3... = [1 2;3 4; 5 6];\n\nIn [19]: x1\nOut[19]: 1\n\nIn [20]: x2\nOut[20]: 3\n\nIn [21]: x3\nOut[21]: 4-element Vector{Int64}:\n 5\n 2\n 4\n 6\n\n\n\n\n정해진 수의 인자를 받는 것이 아니라 다양한 수의 인자를 받는 함수를 가변 인자 함수 (function of variable number of arguments) 라고 하며 ... 연산자를 사용합니다. 다음을 봅시다.\nIn [6]: function ps(xs...)\n        println(typeof(xs))\n        return xs[1], xs[2]\n        end\nOut[6]: ps (generic function with 1 method)\n\nIn [7]: ps(1,2,3,\"c\")\nTuple{Int64, Int64, Int64, String}\nOut[7]: (1, 2)\n함수 정의에서 인자로 xs... 가 사용되었습니다. 이것은 인자를 모두 xs 라는 변수의 튜플로 받는다는 뜻입니다. 즉 In [7] 에서 함수 내부적으로 인자는 (1, 2, 3, \"c\") 입니다. 일부의 인자에 대해서만 사용할 경우에는 다음과 같습니다.\nIn [9]: function ps2(x1, xs...)\n        return xs[1], xs[2]\n        end\nOut[9]: ps2 (generic function with 1 method)\n\nIn [10]: ps2(1,2,3,4,5,6)\nOut[10]: (2, 3)\n키워드 인자도 역시 ... 를 사용하여 받을 수 있습니다. 다음의 함수를 봅시다. 예를 들어,\nfunction ps3(xs...;vs...)\n   ...         \nend\n와 같은 함수는 키워드가 없는 인자들은 xs 라는 변수의 튜플로, 키워드로 제시된 인자들은 vs 라는 기명 튜플(NamedTuple) 인자로 받습니다.\nIn [6]: function ps3(xs...; vs...)\n        return vs\n        end\nOut[6]: ps3 (generic function with 1 method)\n\nIn [7]: ps3(color=\"red\", number=4, location=\"Daejeon\")\nOut[7]: pairs(::NamedTuple) with 3 entries:\n  :color    =&gt; \"red\"\n  :number   =&gt; 4\n  :location =&gt; \"Daejeon\"\n\n\n\n\n함수의 정의에서는 인자를 튜플로 묶는다면 함수를 사용할 때는 컨테이너를 풉니다. 예를 들어,\nIn [12]: function ps3(a1, a2, a3)\n         return a1+(a2*a3)\n         end\n와 같은 함수를 사용해야 한다고 합시다. 그런데 다른 함수의 계산 결과로 aa=(a1, a2, a3) 를 얻었다고 합시다. ps3(aa[1], aa[2], aa[3]) 와 같이 실행 시킬 수도 있지만\nIn [13]: aa=(2, 3, 4)\nOut[13]: (2, 3, 4)\n\nIn [14]: ps3(aa...)\nOut[14]: 14\n처럼 ps3 함수를 실행 시킬 때 인자로 a... 를 쓰면 튜플이 풀려서 ps3(aa[1], aa[2], aa[3]) 를 실행시킨 것과 같게됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : `...` 연산자"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_for_containers",
    "href": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_for_containers",
    "title": "Interlude : ... 연산자",
    "section": "",
    "text": "튜플이나 StepRange 혹은 1차원 배열과 같이 순서가 있는 컨테이너에 대해서는 직관적으로 알 수 있습니다.\nIn [1]: a1, a2, a3... = (1, \"a\", (2, 3), 4, sin)\nOut[1]: (1, \"a\", (2, 3), 4, sin)\n\nIn [2]: a1, a2\nOut[2]: (1, \"a\")    \n\nIn [3]: b1, b2, b3... = 1:10\nOut[3]: 1:10\n\nIn [4]: b1, b2\nOut[4]: (1, 2)\n\nIn [5]: c1, c2, c3... = [1, 2, 3, 4, 5];\n\nIn [6]: c1, c2\nOut[6]: (1, 2)\n\n집합이나 사전과 같은 순서가 없는 컨테이너에 대해서는 에러를 발생시키지는 않지만 그 결과의 일관성을 보장할 수 없습니다.\nIn [14]: d1, d2, d3... = Set([1, 2, 3, 4]);\n\nIn [15]: d1, d2\nOut[15]: (4, 2)\n\nIn [16]: d1, d2, d3... = Set([1, 2, 3, 4, 5]);\n\nIn [17]: d1, d2\nOut[17]: (5, 4)\n\nIn [18]: a, b, c... = Dict(\"A\"=&gt;1, \"B\"=&gt;2, \"C\"=&gt;3, \"D\"=&gt;4)\nOut[18]: Dict{String, Int64} with 4 entries:\n  \"B\" =&gt; 2\n  \"A\" =&gt; 1\n  \"C\" =&gt; 3\n  \"D\" =&gt; 4\n\nIn [19]: a\nOut[19]: \"B\" =&gt; 2\n\nIn [20]: b\nOut[20]: \"A\" =&gt; 1\n\nIn [21]: c\nOut[21]: Base.Iterators.Rest{Dict{String, Int64}, Int64}(Dict(\"B\" =&gt; 2, \"A\" =&gt; 1, \"C\" =&gt; 3, \"D\" =&gt; 4), 4)\n\n다차원 배열의 경우 선형 인덱스에 따라 일차원 배열로 변환됩니다.\nIn [18]: x1, x2, x3... = [1 2;3 4; 5 6];\n\nIn [19]: x1\nOut[19]: 1\n\nIn [20]: x2\nOut[20]: 3\n\nIn [21]: x3\nOut[21]: 4-element Vector{Int64}:\n 5\n 2\n 4\n 6",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : `...` 연산자"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_in_function_definition",
    "href": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_in_function_definition",
    "title": "Interlude : ... 연산자",
    "section": "",
    "text": "정해진 수의 인자를 받는 것이 아니라 다양한 수의 인자를 받는 함수를 가변 인자 함수 (function of variable number of arguments) 라고 하며 ... 연산자를 사용합니다. 다음을 봅시다.\nIn [6]: function ps(xs...)\n        println(typeof(xs))\n        return xs[1], xs[2]\n        end\nOut[6]: ps (generic function with 1 method)\n\nIn [7]: ps(1,2,3,\"c\")\nTuple{Int64, Int64, Int64, String}\nOut[7]: (1, 2)\n함수 정의에서 인자로 xs... 가 사용되었습니다. 이것은 인자를 모두 xs 라는 변수의 튜플로 받는다는 뜻입니다. 즉 In [7] 에서 함수 내부적으로 인자는 (1, 2, 3, \"c\") 입니다. 일부의 인자에 대해서만 사용할 경우에는 다음과 같습니다.\nIn [9]: function ps2(x1, xs...)\n        return xs[1], xs[2]\n        end\nOut[9]: ps2 (generic function with 1 method)\n\nIn [10]: ps2(1,2,3,4,5,6)\nOut[10]: (2, 3)\n키워드 인자도 역시 ... 를 사용하여 받을 수 있습니다. 다음의 함수를 봅시다. 예를 들어,\nfunction ps3(xs...;vs...)\n   ...         \nend\n와 같은 함수는 키워드가 없는 인자들은 xs 라는 변수의 튜플로, 키워드로 제시된 인자들은 vs 라는 기명 튜플(NamedTuple) 인자로 받습니다.\nIn [6]: function ps3(xs...; vs...)\n        return vs\n        end\nOut[6]: ps3 (generic function with 1 method)\n\nIn [7]: ps3(color=\"red\", number=4, location=\"Daejeon\")\nOut[7]: pairs(::NamedTuple) with 3 entries:\n  :color    =&gt; \"red\"\n  :number   =&gt; 4\n  :location =&gt; \"Daejeon\"",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : `...` 연산자"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_in_function_argument",
    "href": "src/introduction_to_julia/04I_splat_operator.html#sec-splat_operator_in_function_argument",
    "title": "Interlude : ... 연산자",
    "section": "",
    "text": "함수의 정의에서는 인자를 튜플로 묶는다면 함수를 사용할 때는 컨테이너를 풉니다. 예를 들어,\nIn [12]: function ps3(a1, a2, a3)\n         return a1+(a2*a3)\n         end\n와 같은 함수를 사용해야 한다고 합시다. 그런데 다른 함수의 계산 결과로 aa=(a1, a2, a3) 를 얻었다고 합시다. ps3(aa[1], aa[2], aa[3]) 와 같이 실행 시킬 수도 있지만\nIn [13]: aa=(2, 3, 4)\nOut[13]: (2, 3, 4)\n\nIn [14]: ps3(aa...)\nOut[14]: 14\n처럼 ps3 함수를 실행 시킬 때 인자로 a... 를 쓰면 튜플이 풀려서 ps3(aa[1], aa[2], aa[3]) 를 실행시킨 것과 같게됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : `...` 연산자"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/00_part3.html",
    "href": "src/ecosystem_of_julia/00_part3.html",
    "title": "Julia 언어 생태계",
    "section": "",
    "text": "Julia 언어 생태계\nJulia 언어와 추가로 설치 할 수 있는 패키지들, 개발 환경들 등 julia 언어의 우산 아래 사용 하능한 것들을 생태계라고 표현합니다. 여기서는 Julia 기본 설치 이외의 것들을 소개하도록 합니다.",
    "crumbs": [
      "Julia 언어 생태계"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "소개",
    "section": "",
    "text": "Julia 언어에 대해 공부한 것들을 정리하기 위해 만들었습니다. Julia 언어 자체가 2012년 발표된 신생 언어이며, 미국에서 개발되었으므로 참고할 만한 자료가 부족하며, 한국어 문서는 더더욱 부족합니다. 여기서는 julia 언어의 기본적인 문법과 패키지에 대해 설명합니다.\n\n\n\nJulia 는 이제 나온지 10년이 조금 넘어가는 신생 언어입니다. 2024년 2월 현재 최신 버젼이 1.10 입니다. 많이 비교되는 파이썬은 30년이 조금 넘었으며 현재 최신 버젼이 3.10 입니다. 제가 파이썬을 처음 접한게 25년쯤 전이었는데 25년동안의 파이썬의 위상은 엄청나게 바뀌었습니다. 25년전의 파이썬은 배우기 쉽고 써먹기 좋은 언어로만 인식되었습니다. 그때는 numpy 도 없었으며(혹시나 해서 numpy 공식 사이트에서 확인해보니 2005년에 등장했군요), 과학/공학 분야에서도 코딩이 빠른 언어였지 진지한 계산에 사용할 만한 언어라는 인식은 별로 없었습니다. 파이썬으로 한시간 코딩해서 한시간동안 돌려서 결과를 볼것이냐, C/C++ 로 하루 코딩해서 1분만에 결과를 볼것이냐 하는 문제였죠. 현재는 다양한 파이썬 생태계로 인해 과학/공학 분야에서 널리 쓰이고 있으며 특히 인공지능 분야에서는 그 위치가 엄청나죠.\nJulia 에 대해 설명할 때 파이썬 만큼 쉽고 C 만큼 빠르다 라고 합니다. 어떤 면에서는 맞는 말입니다. 그런데 20년전의 파이썬과 비교해 봤을때 파이썬도 많이 어려워졌거든요. 파이썬도 잘 쓰려면 배워야 할 것이 많습니다. 그런 의미에서 Julia 가 파이썬 만큼 쉬우냐 하는 질문에는 제 경험상 큰 차이는 나지 않는다고 말하겠습니다. 또 C/C++/Fortran 으로 작성하여 컴파일한것을 파이썬에서 읽어서 실행시키는 부분은 C/C++/Fortran 직접 실행시켰을 때와 거의 차이가 나지 않습니다. 즉 어떤 부분에서는 (비록 내부적으로는 최적화된 C/C++/Fortran 으로 작성된 실행 코드를 돌릴지라도) 파이썬의 속도가 느리지 않습니다. 그리고 30년 동안 이루어진 파이썬의 생태계도 엄청나게 거대하죠. Julia 언어는 numpy 와 비교해서도 많은 부분에서 상당히 빠릅니다. 특히 이미 존재하는 함수를 그냥 가져다 쓰는 것이 아닌 경우, julia 로 for 루프를 돌리는 것이 아주 빠른 경우가 많습니다. 파이썬으로 대규모의 루프를 돌리는 것은 별로 권장할 만하지 않죠. 그렇다고 julia 가 C/C++/Fortran 만큼 빠르냐고 하면 꼭 그렇지는 않습니다. 하지만 연산 속도를 증가시키는 여러 테크닉(주로 매크로)을 사용할 때 비슷한 속도가 나오는 경우도 많습니다.\n저에게 있어 julia 언어의 장점중의 하나는 멀티스레딩입니다. 파이썬은 (적어도 공식적인 CPython 의 경우) 멀티스레딩이 가능하지만 소위 GIL(global interprter lock) 때문에 진정한 멀티스레딩이라고 보기 힘들며, 더더욱 수치해석적인 면에서 의미가 없습니다. Julia 는 멀티스레딩을 아주 편하게 사용 할 수 있으며, 강력합니다.\n반면 Julia 언어의 최대의 단점은 아직은 부족한 생태계입니다. 파이썬이나 매트랩에서 이미 구현되어 널리 사용되고 있는 어떤 기능이 Julia 에 없어서 당신이 필요한 계산을 하기 위해 바닥부터 코드를 작성해야 할 수 도 있습니다. 하지만 특히 과학/공학 분야에서 점점 사용자가 많아지고 있기 때문에 이 단점은 점점 감소될 것이라고 예상합니다. 또 연산이 매우 빠른 스크립트 언어라는 장점은 과학/공학 분야 뿐만 아니라 다른 분야에서도 아주 유용하기 때문에 Julia 의 사용이 점점 확산 될 것이라고 생각합니다.\n\n\n\n\n\n\n\nJulia 언어 공식 사이트 : 보통 여기터 시작합니다.\nJulia 공식 문서 : Julia 언어를 가장 정확하게 배울 수 있는 문서입니다.\nYoutube, JuliaLanguage : Julia 언어 개발팀의 공식 유튜브 사이트입니다.\n\nJulia 공식 문서에 대한 한국어 번역이 있지만 많은 부분의 번역이 아직 이루어 지지 않았고, 이전 버젼의 문서인 채로 남아있는 것도 상당수입니다.\n\n\n\n\n\nJulia Packages : Julia 패키지를 분야별로 찾아볼 수도 있고 검색할 수도 있습니다."
  },
  {
    "objectID": "index.html#목적",
    "href": "index.html#목적",
    "title": "소개",
    "section": "",
    "text": "Julia 언어에 대해 공부한 것들을 정리하기 위해 만들었습니다. Julia 언어 자체가 2012년 발표된 신생 언어이며, 미국에서 개발되었으므로 참고할 만한 자료가 부족하며, 한국어 문서는 더더욱 부족합니다. 여기서는 julia 언어의 기본적인 문법과 패키지에 대해 설명합니다."
  },
  {
    "objectID": "index.html#julia-언어",
    "href": "index.html#julia-언어",
    "title": "소개",
    "section": "",
    "text": "Julia 는 이제 나온지 10년이 조금 넘어가는 신생 언어입니다. 2024년 2월 현재 최신 버젼이 1.10 입니다. 많이 비교되는 파이썬은 30년이 조금 넘었으며 현재 최신 버젼이 3.10 입니다. 제가 파이썬을 처음 접한게 25년쯤 전이었는데 25년동안의 파이썬의 위상은 엄청나게 바뀌었습니다. 25년전의 파이썬은 배우기 쉽고 써먹기 좋은 언어로만 인식되었습니다. 그때는 numpy 도 없었으며(혹시나 해서 numpy 공식 사이트에서 확인해보니 2005년에 등장했군요), 과학/공학 분야에서도 코딩이 빠른 언어였지 진지한 계산에 사용할 만한 언어라는 인식은 별로 없었습니다. 파이썬으로 한시간 코딩해서 한시간동안 돌려서 결과를 볼것이냐, C/C++ 로 하루 코딩해서 1분만에 결과를 볼것이냐 하는 문제였죠. 현재는 다양한 파이썬 생태계로 인해 과학/공학 분야에서 널리 쓰이고 있으며 특히 인공지능 분야에서는 그 위치가 엄청나죠.\nJulia 에 대해 설명할 때 파이썬 만큼 쉽고 C 만큼 빠르다 라고 합니다. 어떤 면에서는 맞는 말입니다. 그런데 20년전의 파이썬과 비교해 봤을때 파이썬도 많이 어려워졌거든요. 파이썬도 잘 쓰려면 배워야 할 것이 많습니다. 그런 의미에서 Julia 가 파이썬 만큼 쉬우냐 하는 질문에는 제 경험상 큰 차이는 나지 않는다고 말하겠습니다. 또 C/C++/Fortran 으로 작성하여 컴파일한것을 파이썬에서 읽어서 실행시키는 부분은 C/C++/Fortran 직접 실행시켰을 때와 거의 차이가 나지 않습니다. 즉 어떤 부분에서는 (비록 내부적으로는 최적화된 C/C++/Fortran 으로 작성된 실행 코드를 돌릴지라도) 파이썬의 속도가 느리지 않습니다. 그리고 30년 동안 이루어진 파이썬의 생태계도 엄청나게 거대하죠. Julia 언어는 numpy 와 비교해서도 많은 부분에서 상당히 빠릅니다. 특히 이미 존재하는 함수를 그냥 가져다 쓰는 것이 아닌 경우, julia 로 for 루프를 돌리는 것이 아주 빠른 경우가 많습니다. 파이썬으로 대규모의 루프를 돌리는 것은 별로 권장할 만하지 않죠. 그렇다고 julia 가 C/C++/Fortran 만큼 빠르냐고 하면 꼭 그렇지는 않습니다. 하지만 연산 속도를 증가시키는 여러 테크닉(주로 매크로)을 사용할 때 비슷한 속도가 나오는 경우도 많습니다.\n저에게 있어 julia 언어의 장점중의 하나는 멀티스레딩입니다. 파이썬은 (적어도 공식적인 CPython 의 경우) 멀티스레딩이 가능하지만 소위 GIL(global interprter lock) 때문에 진정한 멀티스레딩이라고 보기 힘들며, 더더욱 수치해석적인 면에서 의미가 없습니다. Julia 는 멀티스레딩을 아주 편하게 사용 할 수 있으며, 강력합니다.\n반면 Julia 언어의 최대의 단점은 아직은 부족한 생태계입니다. 파이썬이나 매트랩에서 이미 구현되어 널리 사용되고 있는 어떤 기능이 Julia 에 없어서 당신이 필요한 계산을 하기 위해 바닥부터 코드를 작성해야 할 수 도 있습니다. 하지만 특히 과학/공학 분야에서 점점 사용자가 많아지고 있기 때문에 이 단점은 점점 감소될 것이라고 예상합니다. 또 연산이 매우 빠른 스크립트 언어라는 장점은 과학/공학 분야 뿐만 아니라 다른 분야에서도 아주 유용하기 때문에 Julia 의 사용이 점점 확산 될 것이라고 생각합니다."
  },
  {
    "objectID": "index.html#참고자료",
    "href": "index.html#참고자료",
    "title": "소개",
    "section": "",
    "text": "Julia 언어 공식 사이트 : 보통 여기터 시작합니다.\nJulia 공식 문서 : Julia 언어를 가장 정확하게 배울 수 있는 문서입니다.\nYoutube, JuliaLanguage : Julia 언어 개발팀의 공식 유튜브 사이트입니다.\n\nJulia 공식 문서에 대한 한국어 번역이 있지만 많은 부분의 번역이 아직 이루어 지지 않았고, 이전 버젼의 문서인 채로 남아있는 것도 상당수입니다.\n\n\n\n\n\nJulia Packages : Julia 패키지를 분야별로 찾아볼 수도 있고 검색할 수도 있습니다."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Introduction\nThis is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\n\n참고문헌\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "src/application_of_julia/00_part2.html",
    "href": "src/application_of_julia/00_part2.html",
    "title": "Julia 언어의 활용",
    "section": "",
    "text": "Julia 언어의 활용\n여기서는 Julia 언어의 활용에 대해 다룹니다. 대부분의 내용은 추가 설치 없는 기본 패키지에 대해 다루며, 필요할 경우 추가 패키지에 대해 소개할 수 있습니다. 물론 julia 언어의 기초를 알고 있다고 생각하고 내용을 전개해 나갑니다.",
    "crumbs": [
      "Julia 언어의 활용"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/00_part1.html",
    "href": "src/introduction_to_julia/00_part1.html",
    "title": "Julia 언어의 기초",
    "section": "",
    "text": "Julia 언어의 기초\n여기서는 Julia 언어 설치와 개발 환경 구성, 그리고 언어 문법에 대해 소개합니다. 특별한 언급이 없다면 여기에 사용되는 코드들은 julia 의 기본 시스템으로 실행 가능합니다."
  },
  {
    "objectID": "src/introduction_to_julia/06I_function_composition_and_piping.html",
    "href": "src/introduction_to_julia/06I_function_composition_and_piping.html",
    "title": "Interlude : 함수의 합성과 전달",
    "section": "",
    "text": "함수의 합성은 ∘ 연산자를 이용하며 \\circ + [탭키] 로 입력합니다. 예를 들어\nIn [1]: (sqrt ∘ +)(9, 16)\nOut[1]: 5.0\n를 봅시다. 두개의 인자 9 와 16 을 더한 후 제곱근을 반환하며, 이것은 보통의 수학적인 합성함수의 정의와 일치합니다. 한 함수의 반환값을 다른 함수의 입력값으로 사용 할 때 함수의 합성을 사용하며, 함수의 합성은 다수의 함수에 대해서도 가능합니다.\nIn [2]: (sin ∘ sqrt ∘ -)(π, π/4)\nOut[2]: 0.9993590241845508\n\n합성연산자는 컨테이너에 대한 도트 연산을 수행할 수 없습니다. 합성연산자와 비슷한 기능을 하며 도트 연산도 수행할 수 있는 것이 전달연산자 |&gt; 입니다.\n\n\n\n\n|&gt; 는 기본적으로 합수의 합성과 같습니다. In [1] 과 In [2] 를 |&gt; 을 사용한 표현으로 바꾸면 다음과 같습니다.\nIn [3]: +(9, 16) |&gt; sqrt\nOut[3]: 5.0\n\nIn [4]: -(π, π/4) |&gt; sqrt |&gt; sin\nOut[4]: 0.9993590241845508\n|&gt; 의 오른쪽의 연산 결과를 |&gt; 왼쪽 함수에 대한 입력으로 사용합니다. In [4] 에서와 같이 |&gt; 연산자를 이어서 사용 할 수도 있습니다.\n앞서 말한 것처럼 .|&gt; 와 같은 도트 연산도 가능합니다.\nIn [6]: 0:0.01:π .|&gt; cos |&gt; maximum\nOut[6]: 1.0\n익명 함수를 사용할 수도 있습니다.\nIn [2]: -π:0.001:π .|&gt; (x-&gt;x^2 * cos(x)) |&gt; maximum\nOut[2]: 0.5497738913075754\n여기서 가운데의 (x-&gt;x^2 * cos(x)) 에서 가장 바깥의 괄호를 표기하지 않으면 julia 는 연산자의 우선순위 상 -π:0.001:π .|&gt; x-&gt; (x^2 * cos(x)) |&gt; maximum) 로 해석을 하기 때문에 다른 결과가 나옵니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 함수의 합성과 전달"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06I_function_composition_and_piping.html#합성연산자",
    "href": "src/introduction_to_julia/06I_function_composition_and_piping.html#합성연산자",
    "title": "Interlude : 함수의 합성과 전달",
    "section": "",
    "text": "함수의 합성은 ∘ 연산자를 이용하며 \\circ + [탭키] 로 입력합니다. 예를 들어\nIn [1]: (sqrt ∘ +)(9, 16)\nOut[1]: 5.0\n를 봅시다. 두개의 인자 9 와 16 을 더한 후 제곱근을 반환하며, 이것은 보통의 수학적인 합성함수의 정의와 일치합니다. 한 함수의 반환값을 다른 함수의 입력값으로 사용 할 때 함수의 합성을 사용하며, 함수의 합성은 다수의 함수에 대해서도 가능합니다.\nIn [2]: (sin ∘ sqrt ∘ -)(π, π/4)\nOut[2]: 0.9993590241845508\n\n합성연산자는 컨테이너에 대한 도트 연산을 수행할 수 없습니다. 합성연산자와 비슷한 기능을 하며 도트 연산도 수행할 수 있는 것이 전달연산자 |&gt; 입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 함수의 합성과 전달"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/06I_function_composition_and_piping.html#전달-연산자",
    "href": "src/introduction_to_julia/06I_function_composition_and_piping.html#전달-연산자",
    "title": "Interlude : 함수의 합성과 전달",
    "section": "",
    "text": "|&gt; 는 기본적으로 합수의 합성과 같습니다. In [1] 과 In [2] 를 |&gt; 을 사용한 표현으로 바꾸면 다음과 같습니다.\nIn [3]: +(9, 16) |&gt; sqrt\nOut[3]: 5.0\n\nIn [4]: -(π, π/4) |&gt; sqrt |&gt; sin\nOut[4]: 0.9993590241845508\n|&gt; 의 오른쪽의 연산 결과를 |&gt; 왼쪽 함수에 대한 입력으로 사용합니다. In [4] 에서와 같이 |&gt; 연산자를 이어서 사용 할 수도 있습니다.\n앞서 말한 것처럼 .|&gt; 와 같은 도트 연산도 가능합니다.\nIn [6]: 0:0.01:π .|&gt; cos |&gt; maximum\nOut[6]: 1.0\n익명 함수를 사용할 수도 있습니다.\nIn [2]: -π:0.001:π .|&gt; (x-&gt;x^2 * cos(x)) |&gt; maximum\nOut[2]: 0.5497738913075754\n여기서 가운데의 (x-&gt;x^2 * cos(x)) 에서 가장 바깥의 괄호를 표기하지 않으면 julia 는 연산자의 우선순위 상 -π:0.001:π .|&gt; x-&gt; (x^2 * cos(x)) |&gt; maximum) 로 해석을 하기 때문에 다른 결과가 나옵니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 함수의 합성과 전달"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/08I_documentation.html",
    "href": "src/introduction_to_julia/08I_documentation.html",
    "title": "Interlude : 문서화",
    "section": "",
    "text": "Interlude : 문서화\n함수나 연산자에 대해 알고 싶을 때 도움말은 다음과 같이 사용 할 수 있습니다.\n\nJulia REPL : ? 를 쳐 들어가는 help? 프롬프트에 함수 이름 등을 입력하고 엔터를 누른다.\nJupyter Notebook/Lab : 입력 셀에 ? 이후 함수 이름등을 입력하고 실행시킨다.\nvscode notebook : 입력 셀에 함수 이름 등을 입력하고 마우스 포인터를 위로 이동시킨다.\n\n여기서 보이는 도움말은 별도의 문서가 있는 것이 아니라 해당 함수나 뒤에 나올 복합타입 등의 위에 세겹 따옴표 \"\"\" 를 사용하여 표기합니다. 예를 들어 다음을 doctest01.jl 로 저장해 봅시다.\n\"\"\"\n    bps(a::Number) \n\n`a` 에 2를 곱한다.\n\n# Example\n\n```julia-repl\njulia&gt; bps([1 2;3 4])\n\n2×2 Matrix{Int64}:\n 2  4\n 6  8\n\n\"\"\"\nfunction bps(a::Number) \n    return a*2\nend\njulia REPL 이나 jupyter 노트북에서는\ninclude(\"doctest01.jl\")\n를 이용하여 파일을 포함하면 각각의 방법을 통해 bps 에 대한 도움말을 볼 수 있습니다. vscode 에서는 2023년 8월 현재 단순히 include 를 통해 포함시킨 julia 함수에 대한 도움말을 볼 수는 없는 것 같습니다.\n함수 혹은 객체에 대한 도움말을 작성 할 때 julia 언어에서 권고하는 몇가지 방침이 있습니다. 여기에 공식 문서 Documentations 의 지침을 요약하여 설명합니다. 영어를 기준으로 기술되었기 때문에 한국어와는 잘 안맞을 수도 있습니다.\n\nJulia 마크다운(markdown) 문법으로 작성합니다.\n\nJulia 의 마크다운은 일반적인 마크다운과 약간 다릅니다. 예를 들어 일반적인 마크다운에서 문장내 수식이 $\\sin x$ 형식으로 가능하지만 julia 마크다운에서는 문장 내 수식이 불가능하며 코드블럭을 이용하여 다음과 같이 사용합니다.\n\n\n```math\nf(a) = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} (\\alpha+R\\cos(\\theta))d\\theta\n```\n```\n\n4개의 공백으로 들여쓰기를 한후 함수의 시그너쳐를 표현합니다.\n\n기본적으로 함수 정의의 시그너쳐를 그대로 쓰지만 시그너쳐가 너무 길 경우 인자의 타입을 생략하는 등의 간략화도 가능합니다.\n기본값이 정해진 선택적 인자는 그 기본값도 표시합니다. func(x, y=1) 과 같이 표현합니다.\n기본값이 없는 선택적 인자는 [ ] 안에 표현합니다. func(x, [y]) 나 func(x[, y[, z]]) 와 같이 표현합니다. 혹은 각각의 경우에 대해 별도의 문단에서 설명 할 수 있습니다.\n키워드 인자를 받는 함수의 경우 키워드 인자의 갯수가 많으면 func(x; &lt;keyword arguments&gt;) 와 같이 쓰고 뒤에 별도로 셜명합니다.\n\n시그너쳐 아랫줄의 설명은 함수가 어떤 기능을 하는지 한 문장으로 짧게 설명하는 것으로 시작합니다. 이 한문장 설명 이후 두번째 문장부터는 필요하다면 상세히 설명합니다.\n\n첫번째 한문장으로 설명하는 문장은 명령문 혹은 지시문의 형태를 사용하며 함수를 주어로 하는 3인칭을 사용하지 않으며 마침표로 끝납니다.\n함수의 의미를 간단 명료하게 요약하기 힘들 경우, 각각의 분야에 대해 자세하며 전체적으로는 일관된 기술로 대신 할 수 있습니다.\n\n반복은 피하십시요.\n\n예를 들어 첫줄의 함수 시그너쳐 부분에 함수 이름이 있기 때문에 다음에 나오는 한문장 설명이 bps 함수는 으로 시작될 필요가 없습니다. 또한 인자 유형이 시그너쳐에 표현될 경우 굳이 그것을 다시 설명할 필요도 없습니다.\n\n꼭 필요할 경우에만 인자들의 목록을 제시합니다.\n\n간단한 함수의 경우는 인자들의 역할만 기술합니다.\n키워드 인자가 많은 경우와 같이 함수 시그너쳐가 복잡할 경우는 인자들의 목록을 제시하는 것이 오히려 나을 경우가 있습니다.\n\n관련된 함수에 대한 정보를 제공합니다.\n\nsin 함수에 대한 도움말에\n\nSee also [`sind`](@ref), [`sinpi`](@ref), [`sincos`](@ref), [`cis`](@ref), [`asin`](@ref).\n라고 쓰인 것처럼 하면 됩니다.\n# Example 절에 예를 들어 줍니다. 마크다운 문법에서 코드블럭은 ```jldoctetst 로 시작해서 ``` 로 끝납니다.\n\n\"\"\"\nSome nice documentation here.\n\n# Examples\n```jldoctest\njulia&gt; a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n```\n\"\"\"\n# Examples 섹션은 패키지가 제대로 설치되었는지 확인할 수 있는 간단한 코드를 넣습니다. 가능하면 julia REPL 에서 실행하는 코드를 넣는것이 좋습니다. 임의의 수를 생성하는 rand 함수 같은 것은 실행할 때 마다 결과가 다를 수 있기 때문에 꼭 필요한 경우가 아니라면 사용하지 않는 것이 좋습니다.\n\n물론 이 원칙이 항상 적용되는 것도 아니며, 많은 유명한 패키지들도 이런 원칙을 다 지키는 것은 아니지만 이런 것들을 따르는 것이 도움이 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 문서화"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10I_exception.html",
    "href": "src/introduction_to_julia/10I_exception.html",
    "title": "Interlude : 예외 처리",
    "section": "",
    "text": "예를 들어 길이가 3인 일차원 벡터의 네번째 성분에 접근할 경우, julia 인터프리터는 BoundsError 를 발생시키고 실행을 종료합니다.\nIn [1]: aa=[1,2,3];println(aa[4]);println(\"End\")\nERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]\nStacktrace:\n이렇게 줄리아 코드가 실행중일 때 실행을 지속시키지 못하거나 후속 처리가 필요한 중대한 조건을 예외(Exception) 라고 합니다. 위의 경우처럼 julia 인터프리터가 예외를 발생시킬 수도 있으며, 프로그래머가 의도적으로 예외를 발생시킬 수도 있습니다. 발생한 예외에 대해서는 프로그램 실행을 중단시킬 수도 있고, 예외에 따라 적합한 처리를 수행할 수도 있습니다. 이를 예외 처리(Exception handling) 라고 합니다.\nJulia 에서 기본적으로 제공하는 예외는 기본 매뉴얼의 Built-in Exceptions 에 나와 있습니다. Julia 에서 제공하는 에러 가운데 자주 사용되는 것들을 표 1 에 정리하였습니다.\n\n\n\n표 1: Julia 의 주요 에러\n\n\n\n\n\n\n\n\n\n\n에러\n설명\n예\n\n\n\n\nArgumentError\n함수에 유효하지 않은 인자가 입력된경우\nparse(Int, \"abc\")\n\n\nBoundsError\n인덱스로 접근하는 컨테이너에 범위를 벗어나는 인덱스로 접근했을 때\na=[1, 2];b=a[3]\n\n\nDimensionMismatch\n호출된 객체가 차원에 대한 불일치가 발생할 때\n[1 2;3 4]+[1 2]\n\n\nDivideError\ndiv 함수를 사용하며 정수를 0 으로 나눌 때\ndiv(5, 0)\n\n\nDomainError\n함수의 정의역 집합을 벗어나는 인자를 제시했을 때\nsqrt(-1)\n\n\nErrorException\n일반적인 에러에 대한 예외\n\n\n\nKeyError\n사전형 컨테이너에서 존재하지 않는 키로 접근했을 때\nd1=Dict(\"a\"=&gt;1);d1[\"b\"]\n\n\nMethodError\n주어진 인자에 대한 메서드가 존재하지 않을 때\ncos(\"a\")\n\n\nTypeError\ntypeassert 함수를 이용한 타입 주장이 실패하거나 isa 와 같은 julia 고유 함수에 잘못된 타입의 인자가 제시될 때\nisa(3, 4)\n\n\n\n\n\n\n\n\n\n\nthrow 함수를 통해 에러를 발생시킬 수 있습니다. 만약 당신이 물리 시뮬레이션에서 물체의 속력 \\(v\\) 에 대한 어떤 계산을 수행하고 있는데 \\(v\\) 가 빛의 속력 \\(c\\) 보다 커서는 안된다고 해 봅시다. 그렇다면\nmsg = \"speed must not larger than speed of light\"\nv = (v&gt;c) ? throw(DomainError(v, msg)) : next_calc(v)\n와 같이 DomainError 를 에러 메시지(여기서는 msg) 와 함께 발생시킬 수 있습니다.\n표 1 를 포함한 Julia 의 예외는 ( ) 없이 이름만 사용될 경우는 예외 타입의 이름일 뿐이며 실제 예외를 발생시키기 위해서는 DomainError(v, msg) 와 같이 호출되어야 합니다. 인자로는 메시지 뿐만 아니라 에러에 대한 정확한 정보를 제공하기 위해 변수나 함수 이름이 포함되어야 합니다.\n예외적으로 ErrorException 은 error(msg) 함수로 발생시킬 수 있습니다. ErrorExeption 은 일반적인 오류에 대한 예외이며 가장 간편하게 예외를 발생시켜 프로그램 실행을 중단 시킬 수 있는, 그래서 가장 흔히 사용하는 예외 발생 방법입니다. error(msg) 는 ErrorExeption 을 발생시키며 문자열 msg 를 출력합니다.\nIn [11]: error(\"AttributeError :  aabb\")\nERROR: AttributeError :  aabb\n...\nIn [13]: throw(ErrorException(\"AttributeError : aabb\"))\nERROR: AttributeError : aabb\n...\n\n\n\n\n예외가 발생하면 실행이 중단되는데, 실행을 중단시키지 않고 어떤 처리를 통해 처리를 계속 진행 시킬 수 있습니다. 이 경우는 try ... catch ... end 구문을 통해 처리 할 수 있습니다. 예를 들어 sqrt() 함수에 인자를 음수로 넣으면 DomainError 가 발생합니다. 아래의 코드를 봅시다.\ntry\n    v = sqrt(x)\ncatch e\n    v= 0\nend\n우선 try 블럭을 봅시다. 여기서는 v=sqrt(x) 를 평가합니다. 만약 x 가 음수라면 DomainError 가 발생하지만 try 문은 일단 프로그램 정지를 막고 예외가 발생할 경우 catch e 와 end 사이의 코드를 수행하게 됩니다. 즉 v=0 이 됩니다. catch e 에서 e 는 예외 객체입니다. 어쨌든 예외가 발생하면 v=0 을 수행하게 됩니다. 어떤 예외라도 상관 없다면 e 없이 catch 만 사용해도 됩니다. 위의 코드는 아래와 동일한 기능을 합니다.\ntry v=sqrt(x) catch; v=0 end\nJulia 1.8 부터는 예외가 발생 하지 않았을 경우를 처리하는 else 구문이 추가되었으며 예외가 발생 하든 안하든 어떤 일을 수행하는 finally 구문이 존재합니다. 즉\ntry\n    # 예외가 발생할 수도 있는 처리\ncatch e\n    # 예외가 발생했을 경우의 처리\nelse \n    # 예외가 발생하지 않았을 경우의 처리\nfinally\n    # 어쨌든 처리\nend\n형식이 됩니다.\n\n\n\n\n예를 들어 시뮬레이션에서 입자의 속도가 광속을 넘는 경우를 방지하기 위한 예외가 필요하다고 해 봅시다. 이를 OverSpeedOfLightException 라고 합시다. 예외는 추상 타입인 Exception 의 하위타입이어야 하며, 속도와 메시지를 표현해주기 위한 필드를 가져야 하기 때문에 다음과 같이 표현 할 수 있습니다.\nstruct OverSpeedOfLightException &lt;: Exception\n    speed::Number\n    msg::String\nend\n다음과 같이 오류를 발생 시킬 수 있습니다.\nIn [2]: throw(OverSpeedOfLightException(10000000, \"speed must be smaller than c\"))\nERROR: OverSpeedOfLightException(10000000, \"speed must be smaller than c\")",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 예외 처리"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10I_exception.html#julia-에서의-에러",
    "href": "src/introduction_to_julia/10I_exception.html#julia-에서의-에러",
    "title": "Interlude : 예외 처리",
    "section": "",
    "text": "예를 들어 길이가 3인 일차원 벡터의 네번째 성분에 접근할 경우, julia 인터프리터는 BoundsError 를 발생시키고 실행을 종료합니다.\nIn [1]: aa=[1,2,3];println(aa[4]);println(\"End\")\nERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]\nStacktrace:\n이렇게 줄리아 코드가 실행중일 때 실행을 지속시키지 못하거나 후속 처리가 필요한 중대한 조건을 예외(Exception) 라고 합니다. 위의 경우처럼 julia 인터프리터가 예외를 발생시킬 수도 있으며, 프로그래머가 의도적으로 예외를 발생시킬 수도 있습니다. 발생한 예외에 대해서는 프로그램 실행을 중단시킬 수도 있고, 예외에 따라 적합한 처리를 수행할 수도 있습니다. 이를 예외 처리(Exception handling) 라고 합니다.\nJulia 에서 기본적으로 제공하는 예외는 기본 매뉴얼의 Built-in Exceptions 에 나와 있습니다. Julia 에서 제공하는 에러 가운데 자주 사용되는 것들을 표 1 에 정리하였습니다.\n\n\n\n표 1: Julia 의 주요 에러\n\n\n\n\n\n\n\n\n\n\n에러\n설명\n예\n\n\n\n\nArgumentError\n함수에 유효하지 않은 인자가 입력된경우\nparse(Int, \"abc\")\n\n\nBoundsError\n인덱스로 접근하는 컨테이너에 범위를 벗어나는 인덱스로 접근했을 때\na=[1, 2];b=a[3]\n\n\nDimensionMismatch\n호출된 객체가 차원에 대한 불일치가 발생할 때\n[1 2;3 4]+[1 2]\n\n\nDivideError\ndiv 함수를 사용하며 정수를 0 으로 나눌 때\ndiv(5, 0)\n\n\nDomainError\n함수의 정의역 집합을 벗어나는 인자를 제시했을 때\nsqrt(-1)\n\n\nErrorException\n일반적인 에러에 대한 예외\n\n\n\nKeyError\n사전형 컨테이너에서 존재하지 않는 키로 접근했을 때\nd1=Dict(\"a\"=&gt;1);d1[\"b\"]\n\n\nMethodError\n주어진 인자에 대한 메서드가 존재하지 않을 때\ncos(\"a\")\n\n\nTypeError\ntypeassert 함수를 이용한 타입 주장이 실패하거나 isa 와 같은 julia 고유 함수에 잘못된 타입의 인자가 제시될 때\nisa(3, 4)",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 예외 처리"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10I_exception.html#throw-를-통한-예외-발생",
    "href": "src/introduction_to_julia/10I_exception.html#throw-를-통한-예외-발생",
    "title": "Interlude : 예외 처리",
    "section": "",
    "text": "throw 함수를 통해 에러를 발생시킬 수 있습니다. 만약 당신이 물리 시뮬레이션에서 물체의 속력 \\(v\\) 에 대한 어떤 계산을 수행하고 있는데 \\(v\\) 가 빛의 속력 \\(c\\) 보다 커서는 안된다고 해 봅시다. 그렇다면\nmsg = \"speed must not larger than speed of light\"\nv = (v&gt;c) ? throw(DomainError(v, msg)) : next_calc(v)\n와 같이 DomainError 를 에러 메시지(여기서는 msg) 와 함께 발생시킬 수 있습니다.\n표 1 를 포함한 Julia 의 예외는 ( ) 없이 이름만 사용될 경우는 예외 타입의 이름일 뿐이며 실제 예외를 발생시키기 위해서는 DomainError(v, msg) 와 같이 호출되어야 합니다. 인자로는 메시지 뿐만 아니라 에러에 대한 정확한 정보를 제공하기 위해 변수나 함수 이름이 포함되어야 합니다.\n예외적으로 ErrorException 은 error(msg) 함수로 발생시킬 수 있습니다. ErrorExeption 은 일반적인 오류에 대한 예외이며 가장 간편하게 예외를 발생시켜 프로그램 실행을 중단 시킬 수 있는, 그래서 가장 흔히 사용하는 예외 발생 방법입니다. error(msg) 는 ErrorExeption 을 발생시키며 문자열 msg 를 출력합니다.\nIn [11]: error(\"AttributeError :  aabb\")\nERROR: AttributeError :  aabb\n...\nIn [13]: throw(ErrorException(\"AttributeError : aabb\"))\nERROR: AttributeError : aabb\n...",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 예외 처리"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10I_exception.html#try-...-catch-...-end-를-통한-예외-처리",
    "href": "src/introduction_to_julia/10I_exception.html#try-...-catch-...-end-를-통한-예외-처리",
    "title": "Interlude : 예외 처리",
    "section": "",
    "text": "예외가 발생하면 실행이 중단되는데, 실행을 중단시키지 않고 어떤 처리를 통해 처리를 계속 진행 시킬 수 있습니다. 이 경우는 try ... catch ... end 구문을 통해 처리 할 수 있습니다. 예를 들어 sqrt() 함수에 인자를 음수로 넣으면 DomainError 가 발생합니다. 아래의 코드를 봅시다.\ntry\n    v = sqrt(x)\ncatch e\n    v= 0\nend\n우선 try 블럭을 봅시다. 여기서는 v=sqrt(x) 를 평가합니다. 만약 x 가 음수라면 DomainError 가 발생하지만 try 문은 일단 프로그램 정지를 막고 예외가 발생할 경우 catch e 와 end 사이의 코드를 수행하게 됩니다. 즉 v=0 이 됩니다. catch e 에서 e 는 예외 객체입니다. 어쨌든 예외가 발생하면 v=0 을 수행하게 됩니다. 어떤 예외라도 상관 없다면 e 없이 catch 만 사용해도 됩니다. 위의 코드는 아래와 동일한 기능을 합니다.\ntry v=sqrt(x) catch; v=0 end\nJulia 1.8 부터는 예외가 발생 하지 않았을 경우를 처리하는 else 구문이 추가되었으며 예외가 발생 하든 안하든 어떤 일을 수행하는 finally 구문이 존재합니다. 즉\ntry\n    # 예외가 발생할 수도 있는 처리\ncatch e\n    # 예외가 발생했을 경우의 처리\nelse \n    # 예외가 발생하지 않았을 경우의 처리\nfinally\n    # 어쨌든 처리\nend\n형식이 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 예외 처리"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10I_exception.html#사용자-정의-오류",
    "href": "src/introduction_to_julia/10I_exception.html#사용자-정의-오류",
    "title": "Interlude : 예외 처리",
    "section": "",
    "text": "예를 들어 시뮬레이션에서 입자의 속도가 광속을 넘는 경우를 방지하기 위한 예외가 필요하다고 해 봅시다. 이를 OverSpeedOfLightException 라고 합시다. 예외는 추상 타입인 Exception 의 하위타입이어야 하며, 속도와 메시지를 표현해주기 위한 필드를 가져야 하기 때문에 다음과 같이 표현 할 수 있습니다.\nstruct OverSpeedOfLightException &lt;: Exception\n    speed::Number\n    msg::String\nend\n다음과 같이 오류를 발생 시킬 수 있습니다.\nIn [2]: throw(OverSpeedOfLightException(10000000, \"speed must be smaller than c\"))\nERROR: OverSpeedOfLightException(10000000, \"speed must be smaller than c\")",
    "crumbs": [
      "Julia 언어의 기초",
      "Interlude : 예외 처리"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/index.html",
    "href": "src/introduction_to_julia/index.html",
    "title": "Introduction to Julia",
    "section": "",
    "text": "Introduction to Julia\nJulia 는 이제 나온지 10년이 조금 넘어가는 신생 언어입니다. 2024년 2월 현재 최신 버젼이 1.10 입니다. 많이 비교되는 파이썬은 30년이 조금 넘었으며 현재 최신 버젼이 3.10 입니다. 제가 파이썬을 처음 접한게 25년쯤 전이었는데 25년동안의 파이썬의 위상은 엄청나게 바뀌었습니다. 25년전의 파이썬은 배우기 쉽고 써먹기 좋은 언어로만 인식되었습니다. 그때는 numpy 도 없었으며(혹시나 해서 numpy 공식 사이트에서 확인해보니 2005년에 등장했군요), 과학/공학 분야에서도 코딩이 빠른 언어였지 진지한 계산에 사용할 만한 언어라는 인식은 별로 없었습니다. 파이썬으로 한시간 코딩해서 한시간동안 돌려서 결과를 볼것이냐, C/C++ 로 하루 코딩해서 1분만에 결과를 볼것이냐 하는 문제였죠. 현재는 다양한 파이썬 생태계로 인해 과학/공학 분야에서 널리 쓰이고 있으며 특히 인공지능 분야에서는 그 위치가 엄청나죠.\nJulia 에 대해 설명할 때 파이썬 만큼 쉽고 C 만큼 빠르다 라고 합니다. 어떤 면에서는 맞는 말입니다. 그런데 20년전의 파이썬과 비교해 봤을때 파이썬도 많이 어려워졌거든요. 파이썬도 잘 쓰려면 배워야 할 것이 많습니다. 그런 의미에서 Julia 가 파이썬 만큼 쉬우냐 하는 질문에는 제 경험상 큰 차이는 나지 않는다고 말하겠습니다. 또 C/C++/Fortran 으로 작성하여 컴파일한것을 파이썬에서 읽어서 실행시키는 부분은 C/C++/Fortran 직접 실행시켰을 때와 거의 차이가 나지 않습니다. 즉 어떤 부분에서는 (비록 내부적으로는 최적화된 C/C++/Fortran 으로 작성된 실행 코드를 돌릴지라도) 파이썬의 속도가 느리지 않습니다. 그리고 30년 동안 이루어진 파이썬의 생태계도 엄청나게 거대하죠. Julia 언어는 numpy 와 비교해서도 많은 부분에서 상당히 빠릅니다. 특히 이미 존재하는 함수를 그냥 가져다 쓰는 것이 아닌 경우, julia 로 for 루프를 돌리는 것이 아주 빠른 경우가 많습니다. 파이썬으로 대규모의 루프를 돌리는 것은 별로 권장할 만하지 않죠. 그렇다고 julia 가 C/C++/Fortran 만큼 빠르냐고 하면 꼭 그렇지는 않습니다. 하지만 연산 속도를 증가시키는 여러 테크닉(주로 매크로)을 사용할 때 비슷한 속도가 나오는 경우도 많습니다.\n저에게 있어 julia 언어의 장점중의 하나는 멀티스레딩입니다. 파이썬은 (적어도 공식적인 CPython 의 경우) 멀티쓰레딩이 가능하지만 수치해석적인 면에서 의미가 없습니다. Julia 는 멀티쓰레딩을 아주 편하게 사용 할 수 있으며, 강력합니다.\n반면 Julia 언어의 최대의 단점은 아직은 부족한 생태계입니다. 파이썬이나 매트랩에서 이미 구현되어 널리 사용되고 있는 어떤 기능이 Julia 에 없어서 당신이 필요한 계산을 하기 위해 바닥부터 코드를 작성해야 할 수 도 있습니다. 하지만 특히 과학/공학 분야에서 점점 사용자가 많아지고 있기 때문에 이 단점은 점점 감소될 것이라고 예상합니다. 또 연산이 매우 빠른 스크립트 언어라는 장점은 과학/공학 분야 뿐만 아니라 다른 분야에서도 아주 유용하기 때문에 Julia 의 사용이 점점 확산 될 것이라고 생각합니다."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "src/application_of_julia/more_on_types.html",
    "href": "src/application_of_julia/more_on_types.html",
    "title": "타입에 대해 더 알아보기",
    "section": "",
    "text": "우리는 변수와 기본 타입, 타입의 계층구조와 메서드 디스패치, 복합 타입 에서 Julia 언어의 타입에 대해 알아보았다. 여기서는 앞서 다루지 않았던 것들에 대해 좀 더 알아보기로 하자.",
    "crumbs": [
      "Julia 언어의 활용",
      "타입에 대해 더 알아보기"
    ]
  },
  {
    "objectID": "src/application_of_julia/more_on_types.html#sec-operations_on_types",
    "href": "src/application_of_julia/more_on_types.html#sec-operations_on_types",
    "title": "타입에 대해 더 알아보기",
    "section": "1 타입에 대한 연산",
    "text": "1 타입에 대한 연산\nisa(a, t::Type) 은 a 가 t 타입 혹은 t 의 하위타입의 인스턴스라면 true, 아니면 false 를 반환한다.\nIn [9]: isa(1.0, AbstractFloat)\nOut[9]: true\n\ntypeof(a) 함수는 a 의 타입을 반환한다.",
    "crumbs": [
      "Julia 언어의 활용",
      "타입에 대해 더 알아보기"
    ]
  },
  {
    "objectID": "src/application_of_julia/more_on_types.html#sec-declared_types",
    "href": "src/application_of_julia/more_on_types.html#sec-declared_types",
    "title": "타입에 대해 더 알아보기",
    "section": "2 선언된 타입(Declared Types)",
    "text": "2 선언된 타입(Declared Types)\n추상 타입, 원시 타입, 복합 타입 은 몇가지 공통점이 존재한다.\n\n명시적으로 선언되었다.\n이름이 있다.\n명시적으로 선언된 상위타입이 있다.\n타입 매개변수를 가질 수 있다.\n\n추상 타입, 원시 타입, 복합 타입은 내부적으로 DataType 이란 타입의 인스턴스이다. 즉 DataType 은 타입에 대한 타입이다.\nIn [11]: typeof(Real)\nOut[11]: DataType\n\nIn [13]: typeof(Array{Float32, 1})\nOut[13]: DataType\nDataType 은 추상적 이거나 구체적일 수 있다. 구체적인 DataType 은 정해진 크기, 저장 레이아웃을 가지며, 선택적으로 필드 이름을 가진다. 즉 원시 타입은 크기가 0이 아닌 필드 이름이 없는 DataTyppe 이다. 복합 타입은 필드 이름을 가지거나 비어 있는(크기가 0인) DataType 이다. 시스템의 모든 구체적인 값은 어떤 데이터 타입의 인스턴스입니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "타입에 대해 더 알아보기"
    ]
  },
  {
    "objectID": "src/application_of_julia/more_on_types.html#sec-unionall_type",
    "href": "src/application_of_julia/more_on_types.html#sec-unionall_type",
    "title": "타입에 대해 더 알아보기",
    "section": "3 UnionAll 타입",
    "text": "3 UnionAll 타입",
    "crumbs": [
      "Julia 언어의 활용",
      "타입에 대해 더 알아보기"
    ]
  },
  {
    "objectID": "src/application_of_julia/more_on_types.html#sec-tuple_types",
    "href": "src/application_of_julia/more_on_types.html#sec-tuple_types",
    "title": "타입에 대해 더 알아보기",
    "section": "4 튜플 타입",
    "text": "4 튜플 타입\n튜플은 함수의 자체를 제외한 인수들의 추상화이다. 예를 들어 f(x, y) = x+y 에서 인자로 전달되는 x, y 는 그 순서와 타입이 중요한데 이것을 추상화 한 것이 컨테이너인 튜플이다. 따라서 튜플 타입은 각 매개변수가 하나의 필드 타입인 매개변수화된 불변 타입과 유사하다. 튜플 (x, y) 는 다음과 같은 2개의 필드를 갖는 복합타입과 닮았다.\nstruct Tup2{A, B}\n    a::A\n    b::B\nend\n그러나 세가지의 차이점이 있는데,\n\n튜플 타입은 몇개든 매개변수를 가질 수 있다.\n튜플 타입은 타입 매개변수에 대해 공변적(covariant) 하다. Tuple{Int} 는 Tuple{Any} 의 하위타입이며 따라서 Tuple{Any} 는 추상 타입으로 여겨질 수도 있다. 튜플 타입은 타입 매개변수가 구체적일 때만 구체적인 타입이다.\n튜플은 필드 이름이 존재하지 않으며 인덱스로만 접근 할 수 있다.\n\n우리가 알다시피 튜플은 괄호와 콤마로 (1, \"a\", [1, 2]) 와 같이 선언된다. 이것의 타입은 Tuple{Int64, String, Vector{Int64}} 이다.\n\n\nVararg Tuple Types\n예를 들면\nvartup = Tuple{AbstractString, Vararg{Int}}\n에서 vartup 는 첫번째 성분은 AbstractString 타입(혹은 그 하위 타입) 이며 그 다음부터는 모두 정수이며 갯수는 제한되지 않은 타입을 의미한다.\nIn [8]: typeof((\"a\", 1,2,3)) &lt;: vartup\nOut[8]: true\n\nIn [9]: typeof((\"a\", 1,2,3.0)) &lt;: vartup\nOut[9]: false\n\nIn [10]: typeof((\"a\", 1,2,3,4,5)) &lt;: vartup\nOut[10]: true\n타입 T 와 정수 N 에 대해 Vararg{T, N} 는 변수의 개수가 제한된다. 아래의 vartup2 는 AbstractString 타입 혹은 그 하위타입, 이후에 정수 2개를 포함하는 튜플 타입을 의미한다.\nIn [11]: vartup2= Tuple{AbstractString, Vararg{Int, 2}}\nOut[11]: Tuple{AbstractString, Int64, Int64}\n\nIn [12]: typeof((\"a\", 1,2,3)) &lt;: vartup2\nOut[12]: false\n\nIn [13]: typeof((\"a\", 1,2)) &lt;: vartup2\nOut[13]: true\n\nIn [15]: Tuple{AbstractString, Int, Int} &lt;: vartup2\nOut[15]: true\n\nIn [16]: Tuple{AbstractString, Int} &lt;: vartup2\nOut[16]: false\n\nIn [17]: Tuple{AbstractString, Int, Int, Int} &lt;: vartup2\nOut[17]: false",
    "crumbs": [
      "Julia 언어의 활용",
      "타입에 대해 더 알아보기"
    ]
  },
  {
    "objectID": "src/application_of_julia/more_on_types.html#sec-type_selector",
    "href": "src/application_of_julia/more_on_types.html#sec-type_selector",
    "title": "타입에 대해 더 알아보기",
    "section": "5 Type{T}",
    "text": "5 Type{T}\n타입 T 에 대해 Type{T} 는 매개화된 추상타입으로 유일한 인스턴스는 T 이다. 즉 Type{T} 는 인스턴스가 T 인 싱글턴 타입이다.\nIn [1]: isa(Float32, Type{Float32})\nOut[1]: true\n\nIn [2]: isa(Int32, Type{Real})\nOut[2]: false\n매개변수 없는 Type 은 모든 타입을 그 인스턴스로 갖는 추상 타입이다.\nIn [3]: isa(Int32, Type)\nOut[3]: true\n\nIn [4]: isa(1, Type)\nOut[4]: false",
    "crumbs": [
      "Julia 언어의 활용",
      "타입에 대해 더 알아보기"
    ]
  },
  {
    "objectID": "src/application_of_julia/more_on_types.html#sec-type-alias",
    "href": "src/application_of_julia/more_on_types.html#sec-type-alias",
    "title": "타입에 대해 더 알아보기",
    "section": "6 Type Alias",
    "text": "6 Type Alias\n예를 들어 Float32 를 F32 로 사용하고 싶다면\nF32 = Float32\n라고 해주면 된다.\nIn [1]: F32=Float32\nOut[1]: Float32\n\nIn [2]: F32(3)\nOut[2]: 3.0f0\n\nIn [3]: A=Array{F32}([1,2,3])\nOut[3]: 3-element Vector{Float32}:\n 1.0\n 2.0\n 3.0",
    "crumbs": [
      "Julia 언어의 활용",
      "타입에 대해 더 알아보기"
    ]
  },
  {
    "objectID": "src/application_of_julia/more_on_types.html#sec-value_types",
    "href": "src/application_of_julia/more_on_types.html#sec-value_types",
    "title": "타입에 대해 더 알아보기",
    "section": "7 Value Types",
    "text": "7 Value Types\n매개변수가 있는 타입에 대해 매개변수로 값을 가질 수 있다. 이경우 값은 “순수 비트” 값(타입, 심볼, 정수, 부동 소수, 튜플 등)을 타입 매개변수로 포함할 수 있다. 가장 흔한 예는 타입 T 의 성분을 갖는 N 차원 배열 Array{T,N} 이며, 이 경우 N 은 정수이다.\n자신만의 타입을 생성하여 값을 매개변수로 받고, 이를 사용해 커스텀 타입의 디스패치를 제어할 수 있다. 이 아이디어를 설명하기 위해, Val{x} 라는 매개변수화된 타입과 그 생성자 Val(x) = Val{x}() 를 알아보자. 이는 보다 복잡한 계층 구조가 필요 없는 경우 이 기법을 활용하는 일반적인 방법으로 사용된다. Val 은 다음과 같이 정의되었다.\nstruct Val{x}\nend\n\nVal(x) = Val{x}()\n이것 이외에는 없다. Julia 의 일부 표준 라이브러리는 Val 인스턴스를 인자로 받으며 당신은 이것을 당신의 함수에 사용 할 수 있다. 예를 들면\nIn [1]: firstlast(::Val{true}) = \"First\"\nOut[1]: firstlast (generic function with 1 method)\n\nIn [2]: firstlast(::Val{false}) = \"Last\"\nOut[2]: firstlast (generic function with 2 methods)\n\nIn [3]: firstlast(Val(true))\nOut[3]: \"First\"\n\nIn [4]: firstlast(Val(false))\nOut[4]: \"Last\"\n이다.\nJulia 전반에 걸친 일관성을 유지하기 위해 호출 시에는 항상 타입을 사용하는 대신 Val 인스턴스를 전달해야 한다. 즉, foo(Val{:bar}) 대신 foo(Val(:bar)) 를 사용하는 것이 좋다.\n배개변수를 가진 Valyue type, 특히 Val 을 잘못 사용하기 쉬우며 경우에 따라 코드의 성능을 크게 저하시킬 수 있다. 특히, 앞서 예시의 방식대로 실제 코드를 작성하는 것은 피하는 것이 좋다. Val의 적절한 사용과 부적절한 사용에 대한 더 자세한 정보는 Julia 성능 팁 에서의 논의를 참고하라.",
    "crumbs": [
      "Julia 언어의 활용",
      "타입에 대해 더 알아보기"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html",
    "href": "src/application_of_julia/pkg.html",
    "title": "Pkg.jl",
    "section": "",
    "text": "Pkg.jl 문서 에 대한 개인적인 번역\nver : 2024.11.17",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html#sec-introduction",
    "href": "src/application_of_julia/pkg.html#sec-introduction",
    "title": "Pkg.jl",
    "section": "1 들어가며",
    "text": "1 들어가며\nJulia의 패키지 관리자인 Pkg의 문서에 오신 것을 환영합니다. 이 문서는 예를 들어 패키지 설치 관리, 패키지 개발, 패키지 레지스트리 작업 등과 같은 많은 내용을 다룹니다.\n설명서 전체에서 Pkg에 대한 REPL 인터페이스인 Pkg REPL 모드가 예제에서 사용됩니다. 대화식으로 작업하지 않을 때 선호되는 함수적 API도 있습니다. 이 API는 API Reference 섹션에 설명되어 있습니다.\n\n\n1.1 배경과 설계\n기존 패키지 관리자와 달리 Pkg는 독립적인 패키지 세트로서 개별 프로젝트에 한정 될 수 있는 “환경(environment)”를 중심으로 설계되었습니다. 환경은 개별 프로젝트에 국한되될 수도 있고 이름으로 공유되거나 선택될 수 있는 독립적인 패키지 집합입니다. 환경의 정확한 패키지 및 버전 목록은 manifest 파일(manifest.toml) 에 기록되며, 이 파일은 프로젝트 저장소에 체크인하고 버전 관리 시스템에서 추적할 수 있습니다. 이를 통해 프로젝트의 재현성이 크게 향상됩니다. 한동안 사용하지 않았던 코드를 실행하려고 시도했지만, 프로젝트에서 사용하던 패키지 중 일부를 업데이트하거나 제거한 후 작동하지 않는 상황을 경험해 보셨다면, 이런 접근 방식의 필요성을 이해할 수 있을 것입니다. Pkg에서는 각 프로젝트가 독립적인 패키지 버전 집합을 유지하기 때문에 이런 문제는 더 이상 발생하지 않습니다. 게다가 새로운 시스템에서 프로젝트를 체크아웃한 경우, manifest 파일에 설명된 환경을 단순히 구현(materialize) 하면, 안정성이 검증된 의존성 세트를 즉시 사용할 수 있습니다.\n환경이 서로 독립적으로 관리되고 업데이트되기 때문에 Pkg에서는 소위 “의존성 지옥(dependency hell)”이 크게 완화됩니다. 새 프로젝트에서 일부 패키지의 가장 최신 버전을 사용하고 싶지만 다른 프로젝트에서 이전 버전에 갇혀 있는 경우 문제가 되지 않습니다. 별도의 환경이 있기 때문에 서로 다른 버전을 사용할 수 있습니다. 시스템의 다른 위치에 동시에 설치됩니다. 각 패키지 버전의 위치는 표준적이므로 환경에서 동일한 버전의 패키지를 사용하는 경우 설치를 공유하여 불필요한 패키지 복제를 방지할 수 있습니다. 어떤 환경에서도 더 이상 사용되지 않는 이전 패키지 버전은 패키지 관리자에 의해 주기적으로 “가비지 수집(garbage collected)”됩니다.\n로컬 환경에 대한 Pkg의 접근 방식은 Python의 virtualenv 또는 Ruby의 bundler를 사용해 본 사람들에게 친숙한 방식입니다. Julia에서는 환경(environment) 을 지원하기 위해 언어의 코드 로딩 메커니즘을 해킹하는 대신 Julia가 기본적으로 이를 이해한다는 이점이 있습니다. 또한 Julia 환경은 “적층 가능(stackable)”합니다. 하나의 환경을 다른 환경에 덮을(overlay) 수 있으므로 기본 환경 외부의 추가 패키지에 액세스할 수 있습니다. 이를 통해 기본 환경(environment)을 제공하는 프로젝트에서 쉽게 작업할 수 있으며 환경에 프로파일러, 디버거 등과 같은 모든 일반적인 개발 도구들을 로드 경로(load path) 에 추가하여, REPL에서 이 개발도구들에 계속 액세스할 수 있습니다.\n마지막으로, Pkg는 분산 패키지 레지스트리(federated package registries)를 지원하도록 설계되었습니다. 즉, 여러 주체가 관리하는 레지스트리를 원활하게 상호작용할 수 있습니다. 특히, 기업 방화벽 뒤에 존재할 수 있는 비공개 레지스트리(private registries)가 포함됩니다. 이를 통해 공식 Julia 패키지를 설치하고 관리할 때 사용하는 동일한 도구와 워크플로를 활용하여 비공개 레지스트리에서 패키지를 설치 및 업데이트할 수 있습니다. 예를 들어, 회사의 제품에 중요한 공용 패키지에 긴급 패치(hotfix)가 필요하다면, 해당 패키지의 비공식 버전을 회사의 내부 레지스트리에 태그하여 신속하게 개발자 및 운영 팀에 제공할 수 있습니다. 이렇게 하면 상위 패치가 승인되고 배포되기를 기다릴 필요 없이 빠르게 문제를 해결할 수 있습니다. 이후 공식 수정 버전이 배포되면, 의존성을 업그레이드하여 다시 공식 릴리스로 돌아갈 수 있습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html#sec-getting_started",
    "href": "src/application_of_julia/pkg.html#sec-getting_started",
    "title": "Pkg.jl",
    "section": "2 시작하기",
    "text": "2 시작하기\n다음은 Julia의 패키지 관리자인 Pkg에 대한 개요입니다. 새로운 사용자가 기본 Pkg 기능에 익숙해지는 데 도움이 됩니다.\n\n\n\n\n\n\n노트\n\n\n\n\n이 섹션에서는 기본 가이드에 집중하기 위해 일부 Pkg 출력 내용이 생략되었습니다. 이는 적절한 속도를 유지하고 세부사항에 치우치지 않도록 돕기 위함입니다. 더 많은 세부정보가 필요하다면, Pkg 매뉴얼의 후속 섹션을 참고하시기 바랍니다.\n이 가이드는 Pkg 명령어를 실행하기 위해 Pkg REPL을 사용합니다. 비대화형(non-interactive) 용도로는 Pkg API를 사용하는 것을 권장합니다. Pkg API는 Pkg 문서의 API Reference 섹션에 완전히 문서화되어 있습니다.\n\n\n\n\n\n2.1 기본 사용법\nPkg 는 REPL과 함께 제공됩니다. Julia REPL에서 ] 를 눌러 Pkg REPL 에 진입합니다. Julia REPL로 돌아가려면 백스페이스 또는 ^C 를 누릅니다.\n\nPkg REPL 에 진입하면 유사한 프롬프트가 표시됩니다.\n(@v1.9) pkg&gt;\n패키지를 설치하려면 add 를 사용합니다 :\n(@v1.9) pkg&gt; add Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/.julia/environments/v1.9/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `~/.julia/environments/v1.9/Manifest.toml`\n  [7876af07] + Example v0.5.3\n\n패키지를 설치한 후 Julia 세션에서 로드 할 수 있습니다.\njulia&gt; import Example\n\njulia&gt; Example.hello(\"friend\")\n\"Hello, friend\"\n다수의 패키지를 한번에 지정 할 수 있습니다.\n(@v1.9) pkg&gt; add JSON StaticArrays\nstatus 명령어(혹은 줄여서 st 명령어) 를 통해 설치된 패키지를 확인 할 수 있습니다.\n(@v1.9) pkg&gt; st\nStatus `~/.julia/environments/v1.6/Project.toml`\n  [7876af07] Example v0.5.3\n  [682c06a0] JSON v0.21.3\n  [90137ffa] StaticArrays v1.5.9\n\n\n\n\n\n\n노트\n\n\n\nstatus 에 대한 st 이외에도 일부 Pkg REPL 명령어에 대한 이런 약식 명령어가 있습니다.\n\n\n패키지를 제거하기 위해서는 rm 을 사용합니다.\n(@v1.9) pkg&gt; rm JSON StaticArrays\nup 혹은 update 명령어를 사용하여 설치된 패키지를 업데이트 합니다.\n(@v1.9) pkg&gt; up\n이 가이드를 따라 진행했다면, 설치된 패키지들이 이미 최신 버전일 가능성이 높고, 그렇다면 up 명령은 아무 작업도 수행하지 않을 것입니다. 아래에서는 Example 패키지의 이전 버전을 의도적으로 설치한 후 이를 업그레이드하는 경우의 상태 출력 예시를 보여줍니다:\n(@v1.9) pkg&gt; st\nStatus `~/.julia/environments/v1.9/Project.toml`\n⌃ [7876af07] Example v0.5.1\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\n\n(@v1.9) pkg&gt; up\n    Updating `~/.julia/environments/v1.9/Project.toml`\n  [7876af07] ↑ Example v0.5.1 ⇒ v0.5.3\n상태 출력에서 새 버전이 사용 가능함을 알 수 있으며, up 명령이 해당 패키지를 업그레이드한다는 것을 확인할 수 있습니다.\n패키지 관리에 대한 자세한 내용은 문서의 [Managing Packages] 섹션을 참고하세요.\n\n\n\n2.2 환경(Environments)과 함께 시작하기\n지금까지는 기본적인 패키지 관리 즉 추가, 업데이트 및 제거 에 대해 다루었습니다.\nREPL 프롬프트에서 (@v1.9) 을 발견했을 수 있습니다. 이를 통해 v1.9이 현재 활성화된 환경이라는 것을 알 수 있습니다. 활성 환경은 add, rm 및 update와 같은 Pkg 명령에 의해 수정될 환경입니다.\n새로운 환경을 설정해 봅시다. 활성 환경을 설정하려면 activate 명령을 사용합니다.\n(@v1.9) pkg&gt; activate tutorial\n[ Info: activating new environment at `~/tutorial/Project.toml`.\nPkg는 새로운 환경을 생성 중임을 알려주며, 이 환경이 ~/tutorial 디렉터리에 저장된다고 안내합니다. 새로운 환경의 경로는 REPL의 현재 작업 디렉터리를 기준으로 상대 경로로 생성됩니다.\n또한, Pkg는 새로 활성화된 환경을 반영하기 위해 REPL 프롬프트도 업데이트했습니다:\n(tutorial) pkg&gt;\nstatus 를 사용하여 활성화된 환경에 대한 정보를 요청할 수 있습니다.\n(tutorial) pkg&gt; status\n    Status `~/tutorial/Project.toml`\n   (empty environment)\n~/tutorial/Project.toml 은 활성 환경의 프로젝트 파일의 위치입니다. 프로젝트 파일은 TOML 파일로 Pkg는 명시적으로 설치된 패키지를 이 프로젝트 파일에 저장합니다. 이 새 환경은 비어 있습니다. 패키지를 추가하고 관찰해 보겠습니다.\n(tutorial) pkg&gt; add Example JSON\n...\n\n(tutorial) pkg&gt; status\n    Status `~/tutorial/Project.toml`\n  [7876af07] Example v0.5.3\n  [682c06a0] JSON v0.21.3\n이제 tutorial 이 Example 과 JSON 을 의존성으로 포함하는 것을 볼 수 있습니다.\n\n\n\n\n\n\n\n노트\n\n\n\n동일한 패키지(버전까지 같은)가 여러 환경에 설치되어 있는 경우, 해당 패키지는 하드 드라이브에 한 번만 다운로드 되고 저장됩니다. 이러한 특성으로 인해 환경은 매우 가볍고 사실상 무료로 생성할 수 있습니다.\nJulia에서 초보자가 흔히 저지르는 실수 중 하나는, 많은 수의 패키지를 기본 환경(default environment) 에만 설치하는 것입니다. 환경을 효과적으로 사용하는 방법을 배우면 Julia 패키지를 활용하는 경험이 크게 향상될 것입니다.\n\n\n\n환경에 대해 좀 더 알아보고 싶다면 환경을 이용한 작업 절을 참고하세요.\n\n\n2.3 도움 요청\n언제든지 문제가 생기면, Pkg에 도움을 요청할 수 있습니다:\n(@v1.9) pkg&gt; ?\n사용 가능한 명령어와 이에 대한 간략한 설명을 볼 수 있습니다. 특정 명령어에 대해 더 자세한 도움을 원하면, 해당 명령어를 지정하여 도움을 요청할 수 있습니다.\n(@v1.9) pkg&gt; ?develop\n이 가이드는 Pkg를 시작하는 데 도움을 줄 것입니다. Pkg는 강력한 패키지 관리 기능을 많이 제공하므로, 더 많은 정보를 원하시면 전체 매뉴얼을 읽어보세요!\n\n\n2.4 의존성 변경\nExample 에서 작업 중이고 새로운 기능이 필요하다고 느낀다고 가정해 보겠습니다. 소스 코드를 어떻게 수정할 수 있습니까? 우리는 Example 패키지의 git 클론을 설정하기 위해 develop 명령을 사용할 수 있습니다.\n(tutorial) pkg&gt; develop --local Example\n...\n\n(tutorial) pkg&gt; status\n    Status `/tmp/tutorial/Project.toml`\n  [7876af07] Example v0.5.1+ [`dev/Example`]\n피드백이 변경된것을 확인 할 수 있습니다. dev/Example 은 새로 생성된 클론의 위치를 나타냅니다. /tmp/tutorial 디렉토리를 보면 다음 파일이 있음을 알 수 있습니다.\ntutorial\n├── dev\n│   └── Example\n├── Manifest.toml\n└── Project.toml\n등록된 버전의 Example 을 로드하는 대신 Julia는 tutorial/dev/Example 에 포함된 소스 코드를 로드합니다.\n자 이제 한번 해봅시다. 먼저 tutorial/dev/Example/src/Example.jl 에서 파일을 수정하고 간단한 함수를 추가합니다.\nplusone(x::Int) = x + 1\n이제 Julia REPL로 돌아가서 패키지를 로드할 수 있습니다.\njulia&gt; import Example\n\n경고\n패키지는 Julia 세션당 한 번만 로드할 수 있습니다. 현재 Julia 세션에서 import Example 을 실행한 경우 Julia를 다시 시작하고 Pkg REPL에서 activate tutorial 을 다시 실행해야 합니다. Revise.jl은 이 이 과정을 훨씬 쾌적하게 만들 수 있지만 그것을 설정하는 것은 이 가이드의 범위를 벗어납니다.\n\n\nJulia는 새 코드를 로드해야 합니다. 테스트해 봅시다:\njulia&gt; Example.plusone(1)\n2\n우리가 생각이 바뀌어서 세상이 그런 우아한 코드를 받아들일 준비가 되어 있지 않다고 결정했다고 가정해 봅시다. Pkg에게 로컬 복제본 사용을 중지하고 대신 등록된 버전을 사용하도록 지시할 수 있습니다. free 를 사용합니다.\n(tutorial) pkg&gt; free Example\ntutorial 실험을 마치면 인수 없이 activate 를 실행하여 기본 환경으로 돌아갈 수 있습니다.\n(tutorial) pkg&gt; activate\n\n(v1.1) pkg&gt;",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html#sec-managing_packages",
    "href": "src/application_of_julia/pkg.html#sec-managing_packages",
    "title": "Pkg.jl",
    "section": "3 패키지 관리",
    "text": "3 패키지 관리\n\n\n3.1 패키지 추가\nadd 명령 또는 dev 명령으로 패키지를 추가 할 수 있습니다. 더 많이 사용되는 add 를 먼저 설명합니다.\n\n\n등록된 패키지 추가\nPkg REPL에서 add 명령 다음에 패키지 이름을 사용하여 패키지를 추가할 수 있습니다. 예를 들면 다음과 같습니다.\n(@v1.8) pkg&gt; add JSON\n  Installing known registries into `~/`\n   Resolving package versions...\n   Installed Parsers ─ v2.4.0\n   Installed JSON ──── v0.21.3\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [682c06a0] + JSON v0.21.3\n    Updating `~/environments/v1.9/Manifest.toml`\n  [682c06a0] + JSON v0.21.3\n  [69de0a69] + Parsers v2.4.0\n  [ade2ca70] + Dates\n  [a63ad114] + Mmap\n  [de0858da] + Printf\n  [4ec0a83e] + Unicode\nPrecompiling environment...\n  2 dependencies successfully precompiled in 2 seconds\n현재 프로젝트에 JSON 패키지를 추가했습니다. 여기서는 새로 설치된 Julia 를 사용하고 있으며 Pkg를 사용하여 패키지를 추가하는 것은 이번이 처음입니다. 기본적으로 Pkg는 Julia의 General 레지스트리를 설치하고 이 레지스트리를 사용하여 현재 환경에 추가할 패키지를 찾습니다. 상태 업데이트에서는 왼쪽에 짧은 형식의 패키지의 UUID(일종의 고유식별자 입니다), 패키지 이름 및 버전을 표시합니다. 마지막으로 새로 설치된 패키지는 “사전 컴파일(precompiled)”됩니다.\n다수의 패키지를 한번에 설치할 때는 다음과 같이 합니다. pkg&gt; add A B C.\n상태 출려은 당신이 추가한 패키지에 대해 출력합니다. 이경우 JSON 입니다.\n(@v1.11) pkg&gt; st\n    Status `~/.julia/environments/v1.8/Project.toml`\n  [682c06a0] JSON v0.21.3\nmanifest 상태는 재귀적 의존성을 포함하여 환경의 모든 패키지를 보여줍니다.\n(@v1.11) pkg&gt; st -m\nStatus `~/environments/v1.9/Manifest.toml`\n  [682c06a0] JSON v0.21.3\n  [69de0a69] Parsers v2.4.0\n  [ade2ca70] Dates\n  [a63ad114] Mmap\n  [de0858da] Printf\n  [4ec0a83e] Unicode\nDates 와 같은 표준 라이브러리는 Julia 와 같이 제공되므로 버젼이 없습니다.\n특정 버전(또는 버전 집합)의 패키지를 사용하려면 compat 명령을 사용합니다. 예를 들어 JSON 패키지의 v0.21 시리즈에서 v0.21.4 이후의 모든 패치 릴리스를 요구하려면 다음과 같이 compat 명령을 호출합니다:\n(@1.11) pkg&gt; compat JSON 0.21.4\n      Compat entry set:\n  JSON = \"0.21.4\"\n     Resolve checking for compliance with the new compat rules...\n       Error empty intersection between JSON@0.21.3 and project compatibility 0.21.4 - 0.21\n  Suggestion Call `update` to attempt to meet the compatibility requirements.\n\n(@1.11) pkg&gt; update\n    Updating registry at `~/.julia/registries/General.toml`\n    Updating `~/.julia/environments/1.11/Project.toml`\n  [682c06a0] ↑ JSON v0.21.3 ⇒ v0.21.4\n    Updating `~/.julia/environments/1.11/Manifest.toml`\n  [682c06a0] ↑ JSON v0.21.3 ⇒ v0.21.4\ncompat 을 사용하는 것에 대해 더 알고싶다면 Compatibility 을 참고하세요.\n패키지가 프로젝트에 추가되면 Julia에서 로드할 수 있습니다.\njulia&gt; using JSON\n\njulia&gt; JSON.json(Dict(\"foo\" =&gt; [1, \"bar\"])) |&gt; print\n{\"foo\":[1,\"bar\"]}\n\n\n\n\n\n\n\n노트\n\n\n\nadd 명령어로 추가된 패키지만 로딩할 수 있습니다. 이 패키지는 Pkg REPL에서 st 명령을 사용할 때 표시되는 패키지들입니다. 반면, 의존성으로만 추가된 패키지(예: 위 예시의 Parsers 패키지)는 로딩할 수 없습니다.\n\n\n@ 기호 뒤에 버전을 추가하여, 즉 패키지 이름 뒤에 @v0.4 와 같이 써서 특정 버전을 설치할 수 있습니다.\n(@v1.8) pkg&gt; add JSON@0.21.1\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n⌃ [682c06a0] + JSON v0.21.1\n    Updating `~/environments/v1.9/Manifest.toml`\n⌃ [682c06a0] + JSON v0.21.1\n⌅ [69de0a69] + Parsers v1.1.2\n  [ade2ca70] + Dates\n  [a63ad114] + Mmap\n  [de0858da] + Printf\n  [4ec0a83e] + Unicode\n        Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ ar\n위에서 볼 수 있듯이, Pkg는 패키지가 최신 버전으로 설치되지 않은 경우 일부 정보를 제공합니다.\n버전 번호가 세 자리가 아닌 경우, 예를 들어 0.21만 주어진다면, 0.21.x의 최신 등록된 버전이 설치됩니다.\nExample 패키지의 브랜치(또는 특정 커밋)에 핫픽스가 포함되어 있지만, 아직 등록된 버전에는 포함되지 않은 경우, 해당 브랜치(또는 커밋)를 명시적으로 추적할 수 있습니다. 이를 위해 패키지 이름 뒤에 #branchname (또는 #commitSHA1)을 추가합니다:\n(@v1.8) pkg&gt; add Example#master\n     Cloning git-repo `https://github.com/JuliaLang/Example.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`\n    Updating `~/environments/v1.9/Manifest.toml`\n  [7876af07] + Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master`\n이제 상태 출력에 Example의 master branch 를 추적하고 있음이 표시됩니다. 패키지를 업데이트할 때 해당 분기에서 업데이트를 가져옵니다.\n\n\n\n\n\n\n노트\n\n\n\n만약 브랜치 이름 대신 커밋 ID를 지정하면, 예를 들어 add Example#025cf7e 와 같이 입력하면, 해당 커밋에 “고정(pinned)”된 패키지를 사용하게 됩니다. 이는 커밋 ID가 항상 동일한 내용을 가리키기 때문입니다. 반면, 브랜치는 업데이트될 수 있기 때문에 특정 시점의 커밋을 고정하려면 커밋 ID를 사용하는 것이 좋습니다.\n\n\n\nExample 의 레지스트리 버전 추적으로 돌아가려면 free 명령을 사용합니다.\n(@v1.8) pkg&gt; free Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3\n    Updating `~/environments/v1.9/Manifest.toml`\n  [7876af07] ~ Example v0.5.4 `https://github.com/JuliaLang/Example.jl.git#master` ⇒ v0.5.3\n\n\n\n등록되지 않은 패키지 추가\n패키지가 레지스트리에 없는 경우 Git 저장소에 대한 URL을 지정하여 패키지를 추가할 수 있습니다.\n(@v1.8) pkg&gt; add https://github.com/fredrikekre/ImportMacros.jl\n     Cloning git-repo `https://github.com/fredrikekre/ImportMacros.jl`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [92a963f6] + ImportMacros v1.0.0 `https://github.com/fredrikekre/ImportMacros.jl#master`\n    Updating `~/environments/v1.9/Manifest.toml`\n  [92a963f6] + ImportMacros v1.0.0 `https://github.com/fredrikekre/ImportMacros.jl#master`\n등록되지 않은 패키지가 의존하는 패키지(여기서는 MacroTools)가 설치되었습니다. 등록되지 않은 패키지의 경우 등록된 패키지와 마찬가지로 #을 사용하여 추적하기 위해 브랜치 이름(또는 커밋 SHA1)을 제시할 수 있습니다.\nSSH 기반 git 프로토콜을 사용하여 패키지를 추가하려면 URL에 @ 가 포함되어 있으므로 따옴표를 사용해야 합니다. 예를 들어,\n(@v1.8) pkg&gt; add \"git@github.com:fredrikekre/ImportMacros.jl.git\"\n    Cloning git-repo `git@github.com:fredrikekre/ImportMacros.jl.git`\n   Updating registry at `~/.julia/registries/General`\n  Resolving package versions...\nUpdating `~/.julia/environments/v1/Project.toml`\n  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`\nUpdating `~/.julia/environments/v1/Manifest.toml`\n  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`\n\n\n\n저장소의 서브디렉토리에 있는 패키지 추가하기\n만약 URL 로 설치하기를 원하는 패키지가 저장소의 루트 디렉토리가 아닌 서브디렉토리에 위치한다면 : 를 사용합니다. 예를 들어 SnoopComple 저장소의 SnoopcompileCore 패키지 를 설치하고자 한다면 다음과 같이 합니다.\npkg&gt; add https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore\n    Cloning git-repo `https://github.com/timholy/SnoopCompile.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [e2b509da] + SnoopCompileCore v2.9.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [e2b509da] + SnoopCompileCore v2.9.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`\n  [9e88b42a] + Serialization\n\n\n로칼 패키지 추가\nGit 저장소의 URL을 제공하는 대신, 로컬 경로를 지정하여 Git 저장소를 추가할 수도 있습니다. 이는 URL을 추가하는 것과 유사하게 작동합니다. 로컬 저장소가 지정되면, 해당 저장소의 특정 브랜치를 추적하게 되며, 패키지를 업데이트할 때 그 로컬 저장소에서 업데이트를 가져옵니다\n\n\n\n\n\n\n경고\n\n\n\n다음 섹션에서 설명하겠지만 add 명령어로 패키지를 추적하는 것과 develop 명령어를 사용하는 것은 다릅니다. 로컬 Git 저장소에서 add 를 사용하여 패키지를 추가하면 로컬 패키지 저장소에서 파일을 수정해도 그 변경 사항이 즉시 로드되는 패키지에 반영되지 않습니다. 변경 사항은 커밋되고, 패키지를 업데이트해야만 반영됩니다.\n대부분의 경우, 로컬 경로에서 작업할 때는 add 보다는 develop 을 사용하는 것이 적합합니다. develop 은 로컬 패키지의 변경 사항을 실시간으로 추적하고 반영할 수 있도록 해줍니다.\n\n\n\n\n\n패키지 개발\nadd 만 사용하면 환경은 항상 재현 가능한 상태 를 유지합니다. 즉, 사용된 레지스트리와 저장소가 여전히 접근 가능하다면, 환경 내 모든 의존성의 정확한 상태를 다시 가져올 수 있습니다. 이 방식의 장점은 Project.toml 과 Manifest.toml 파일을 다른 사람에게 보내면, 그 사람이 해당 환경을 Pkg.instantiate 명령을 통해 동일한 상태로 재현할 수 있다는 점입니다. 하지만 패키지를 개발할 때는 패키지를 현재 상태에서 로드하는 것이 더 편리합니다. 이를 위해 dev 명령어가 존재합니다. dev 는 로컬 경로에 있는 패키지를 개발 중인 상태로 추적하고, 즉시 반영할 수 있게 해줍니다.\n등록된 패키지를 dev 해 봅시다:\n(@v1.8) pkg&gt; dev Example\n  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] + Example v0.5.4 `~/.julia/dev/Example`\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] + Example v0.5.4 `~/.julia/dev/Example`\ndev 명령은 패키지의 전체 복사본을 ~/.julia/dev/ 로 가져옵니다(경로는 JULIA_PKG_DEVDIR 환경 변수를 설정하여 변경할 수 있으며 기본값은 joinpath(DEPOT_PATH[1],\"dev\") 입니다). Example 을 가져올 때 julia는 이제 ~/.julia/dev/Example 에서 가져오고 해당 경로의 파일에 대한 모든 로컬 변경 사항이 결과적으로 로드된 코드에 반영됩니다. add 를 사용할 때 우리는 패키지 저장소를 추적한다고 말했지만 여기에서는 경로 자체를 추적한다고 말합니다. 패키지 관리자는 추적된 경로에 있는 파일을 건드리지 않는다는 것에 주의하십시요. 따라서 업데이트 가져오기, 브랜치 변경 등은 사용자에게 달려 있습니다. ~/.julia/dev/ 패키지 매니저 에 이미 존재하는 어떤 브랜치의 패키지를 dev 하면, 단순히 기존 경로를 사용합니다. 로컬 경로에서 dev 를 사용하면, 그 경로가 기록되고 패키지를 로드할 때 사용됩니다. 이 경로는 프로젝트 파일을 기준으로 상대 경로로 기록되며, 절대 경로로 제공된 경우에는 절대 경로로 기록됩니다.\n~/.julia/dev/Example/src/Example.jl 파일을 수정하여 간단한 함수를 추가해보겠습니다.\nplusone(x::Int) = x + 1\n이제 Julia REPL 로 돌아가 패키지를 로드하고 새로운 함수를 실행시켜 봅시다.\njulia&gt; import Example\n[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]\n\njulia&gt; Example.plusone(1)\n2\n\n\n\n\n\n\n경고\n\n\n\n한 Julia 세션에서 패키지는 한 번만 로드될 수 있습니다. 따라서 현재 세션에서 import Example 을 실행한 경우, Example 패키지의 변경 사항을 확인하려면 Julia 세션을 재시작해야 합니다.\n이 과정은 Revise.jl 을 사용하면 훨씬 더 편리하게 처리할 수 있습니다. Revise.jl 은 패키지의 소스 코드가 변경될 때마다 자동으로 새로 고침하여 세션을 재시작하지 않고도 변경 사항을 즉시 반영할 수 있게 해줍니다. 하지만 Revise.jl 의 설정은 이 가이드의 범위를 벗어나므로, 더 자세한 설정 방법은 Revise.jl 문서를 참고하는 것이 좋습니다.\n\n\n경로를 추적하는 것을 멈추고 다시 등록된 버젼을 사용하고 싶다면 free 명령어를 사용합니다.\n(@v1.8) pkg&gt; free Example\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ~ Example v0.5.4 `~/.julia/dev/Example` ⇒ v0.5.3\n    Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.4 `~/.julia/dev/Example` ⇒ v0.5.3\ndev 명령어를 사용하면 프로젝트가 본질적으로 상태 저장(stateful) 방식이 됩니다. 즉, 프로젝트의 상태는 해당 경로에 있는 파일들의 현재 내용에 의존하게 됩니다. 이 경우, Manifest는 프로젝트의 정확한 상태를 “인스턴스화”하는 데 사용할 수 없습니다. 다른 사람이 동일한 상태로 프로젝트를 실행하려면 해당 패스에서 추적하는 모든 패키지의 정확한 내용을 알아야 합니다.\n또한, 로컬 경로를 추적하는 패키지에 의존성을 추가하면 Manifest(전체 의존성 그래프를 포함하는)가 실제 의존성 그래프와 일치하지 않게 됩니다. 즉, Manifest에 해당 의존성이 기록되지 않기 때문에 패키지는 그 의존성을 로드할 수 없습니다. 이를 해결하려면, resolve 명령어를 사용하여 Manifest를 동기화해야 합니다.\n또한, add 와 dev 명령은 상대 경로(relative paths)도 지원합니다. 이 경우, 활성 프로젝트에서 패키지까지의 상대 경로가 저장됩니다. 이는 패키지의 절대 경로보다 상대적인 위치가 더 중요한 경우에 유용합니다. 예를 들어, 추적하는 의존성들이 활성 프로젝트 디렉토리 내에 있을 때, 해당 디렉토리 전체를 이동시켜도 Pkg는 의존성의 상대 경로를 통해 여전히 의존성을 찾을 수 있습니다. 이는 절대 경로가 변경되었더라도, 상대 경로가 유지되기 때문입니다.\n\n\n\n\n3.2 패키지 제거\npkg&gt; rm Package 를 사용하여 현재 프로젝트에서 패키지를 제거할 수 있습니다. 이렇게 하면 프로젝트에 있는 패키지만 제거됩니다. 의존성으로만 존재하는 패키지를 제거하려면 pkg&gt; rm --manifest DepPackage 를 사용하십시오. 이렇게 하면 DepPackage에 의존하는 모든 패키지가 제거됩니다.\n\n\n\n3.3 패키지 업데이트\n프로젝트에서 사용 중인 패키지의 새 버전이 릴리스되면 업데이트하는 것이 좋습니다. up 을 호출하기만 하면 프로젝트의 모든 의존성을 최신 호환 버전으로 업데이트하려고 시도합니다. 가끔은 이것을 원하지 않을 수도 있습니다. up 에 인수로 제공하여 업그레이드할 의존성의 하위 집합을 지정할 수 있습니다:\n(@v1.8) pkg&gt; up Example\n위의 명령은 오직 Example 만 업그레이드 하도록 합니다. --preserve=direct 플래그를 사용하면, Example 패키지의 의존성 중 직접 의존하는 패키지들만 업그레이드할 수 있게 됩니다. 즉, 프로젝트에 명시적으로 추가된 패키지들은 업그레이드되지 않지만, 간접적으로 의존하는 패키지들은 업데이트될 수 있습니다.\n(@v1.8) pkg&gt; up --preserve=direct Example\n만약 Example 패키지의 의존성뿐만 아니라 프로젝트에 명시적으로 추가된 의존성도 업그레이드하고 싶다면, --preserve=none 플래그를 사용할 수 있습니다. 이 플래그를 사용하면 직접 의존성과 간접 의존성 모두 업그레이드가 허용됩니다.\n(@v1.8) pkg&gt; up --preserve=none Example\n\n\n\n3.4 패키지 고정\n고정된 패키지는 절대 업데이트되지 않습니다. pin 을 사용하여 패키지를 고정할 수 있습니다. 예를 들면 다음과 같습니다.\n(@v1.8) pkg&gt; pin Example\n Resolving package versions...\n  Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ~ Example v0.5.3 ⇒ v0.5.3 ⚲\n  Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.3 ⇒ v0.5.3 ⚲\n패키지가 고정되었음을 나타내는 핀 기호 ⚲에 유의하십시오. 핀 제거는 free 를 사용합니다.\n(@v1.8) pkg&gt; free Example\n  Updating `~/.julia/environments/v1.8/Project.toml`\n  [7876af07] ~ Example v0.5.3 ⚲ ⇒ v0.5.3\n  Updating `~/.julia/environments/v1.8/Manifest.toml`\n  [7876af07] ~ Example v0.5.3 ⚲ ⇒ v0.5.3\n\n\n\n3.5 패키지 테스트\n패키지에 대한 테스트는 test 명령을 사용하여 실행할 수 있습니다.\n(@v1.8) pkg&gt; test Example\n...\n   Testing Example\n   Testing Example tests passed\n\n\n\n3.6 패키지 빌드\n패키지의 빌드 단계는 패키지가 처음 설치될 때 자동으로 실행됩니다. 빌드 프로세스의 출력은 파일로 보내집니다. 패키지의 빌드 단계를 명시적으로 실행하려면 build 명령을 사용합니다.\n(@v1.8) pkg&gt; build IJulia\n    Building Conda ─→ `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/6e47d11ea2776bc5627421d59cdcc1296c058071/build.log`\n    Building IJulia → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/98ab633acb0fe071b671f6c1785c46cd70bb86bd/build.log`\n\njulia&gt; print(read(joinpath(homedir(), \".julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/98ab633acb0fe071b671f6c1785c46cd70bb86bd/build.log\"), String))\n[ Info: Installing Julia kernelspec in /home/kc/.local/share/jupyter/kernels/julia-1.8\n\n\n\n3.7 버젼 충돌의 해석과 해소\n환경은 상호 호환 가능한 패키지 세트로 구성됩니다. 때로는 동시에 사용하려는 두 패키지의 요구 사항이 호환되지 않는 상황에 처할 수 있습니다. 이러한 경우 “충족할 수 없는 요구 사항(Unsatisfiable requirements)” 오류가 발생합니다.\npkg&gt; add A\nUnsatisfiable requirements detected for package D [756980fe]:\n D [756980fe] log:\n ├─possible versions are: 0.1.0 - 0.2.1 or uninstalled\n ├─restricted by compatibility requirements with B [f4259836] to versions: 0.1.0\n │ └─B [f4259836] log:\n │   ├─possible versions are: 1.0.0 or uninstalled\n │   └─restricted to versions * by an explicit requirement, leaving only versions: 1.0.0\n └─restricted by compatibility requirements with C [c99a7cb2] to versions: 0.2.0 — no versions left\n   └─C [c99a7cb2] log:\n     ├─possible versions are: 0.1.0 - 0.2.0 or uninstalled\n     └─restricted by compatibility requirements with A [29c70717] to versions: 0.2.0\n       └─A [29c70717] log:\n         ├─possible versions are: 1.0.0 or uninstalled\n         └─restricted to versions * by an explicit requirement, leaving only versions: 1.0.0\n이 메시지는 D 라는 패키지에 버전 충돌이 있음을 의미합니다. D 를 직접 추가한 적이 없더라도 사용하려는 다른 패키지에서 D 가 필요한 경우 이러한 종류의 오류가 발생할 수 있습니다.\n\n\n\n\n\n\n노트\n\n\n\n이러한 충돌을 해결할 때는 우선 프로젝트가 커질수록 이런 일이 발생할 가능성이 더 높다는 점을 고려하십시오. 어떤 주어진 과업에는 해당하는 프로젝트를 사용하는 것이 좋습니다. 사용하지 않는 의존성을 제거하는 것은 이러한 문제가 발생할 때 좋은 첫 번째 단계입니다. 예를 들어 일반적인 함정은 기본(예: (@1.8)) 환경에 몇 개 이상의 패키지가 있고 이를 julia를 사용하는 모든 작업의 환경으로 사용하는 것입니다. 작업 중인 작업을 위한 전용 프로젝트를 만들고 거기에 의존성을 최소화하는 것이 좋습니다. 자세한 내용은 환경을 이용한 작업을 참조하십시오.\n\n\n\n오류 메시지에는 중요한 정보가 많이 있습니다. 낱낱이 해석하는 것이 가장 쉬울 수 있습니다.\nUnsatisfiable requirements detected for package D [756980fe]:\n D [756980fe] log:\n ├─possible versions are: [0.1.0, 0.2.0-0.2.1] or uninstalled\n위의 메시지는 D 에 v0.1.0, v0.2.0 및 v0.2.1 의 세 가지 릴리스 버전이 있음을 의미합니다. 전혀 설치하지 않는 옵션도 있습니다. 이러한 각 옵션은 설치할 수 있는 다른 패키지 집합에 대해 서로 다른 의미를 가질 수 있습니다.\n결정적으로 획문자(수직 및 수평선)와 들여쓰기를 확인하십시오. 이들은 메시지와 특정 패키지를 연결하는데 같이 사용됩니다. 예를 들어 ├─ 의 오른쪽 획은 오른쪽에 있는 메시지(possible versions...)가 수직 획(D)이 가리키는 패키지에 연결되어 있음을 나타냅니다. 다음 줄에도 동일한 원칙이 적용됩니다.\n ├─restricted by compatibility requirements with B [f4259836] to versions: 0.1.0\n여기서 세로 획도 D 아래에 정렬되어 있으므로 이 메시지는 D 를 참조합니다. 특히 D 의 버전 v0.1.0 에 의존하는 다른 패키지 B가 있습니다. 이것은 D 의 최신 버전이 아닙니다.\n다음은 B에 대한 정보입니다.\n │ └─B [f4259836] log:\n │   ├─possible versions are: 1.0.0 or uninstalled\n │   └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0\n첫 번째 줄 아래의 두 줄에는 B 와 정렬되는 세로 획이 있으므로 B 에 대한 정보를 제공합니다. B 에 v1.0.0 릴리스가 하나만 있음을 알려줍니다. B 의 특정 버전을 지정하지 않았지만(restricted to versions *은 모든 버전이 가능함을 의미합니다) 명시적 요구 사항은 B 가 환경의 일부가 되도록 요청했음을 의미합니다(예: pkg&gt; add B). 이전에 B를 요청했을 수 있으며 요구 사항이 여전히 유효합니다.\n선으로 인해 충돌이 분명해집니다.\n└─restricted by compatibility requirements with C [c99a7cb2] to versions: 0.2.0 — no versions left\n여기서 다시 세로 획은 D 와 정렬됩니다. 이것은 D 가 다른 패키지 C 에도 필요함을 의미합니다. C 에는 D 의 v0.2.0 이 필요하며 이는 D 의 v0.1.0 에 대한 B의 요구와 충돌합니다. 이것이 충돌을 설명합니다.\n하지만 잠깐, C 가 무엇이고 왜 C 가 필요한지 물을 수 있습니다. 다음 몇 줄은 문제를 소개합니다.\n   └─C [c99a7cb2] log:\n     ├─possible versions are: [0.1.0-0.1.1, 0.2.0] or uninstalled\n     └─restricted by compatibility requirements with A [29c70717] to versions: 0.2.0\n이는 C 에 대한 자세한 정보를 제공하며 v0.1.0, v0.1.1 및 v0.2.0 의 3개 릴리스 버전이 있음을 나타냅니다. 또한 C 는 다른 패키지 A 에 필요합니다. 실제로 A 의 요구 사항은 C 의 v0.2.0 이 필요하다는 것입니다. A 의 출처는 다음 줄에 표시됩니다.\n       └─A [29c70717] log:\n         ├─possible versions are: 1.0.0 or uninstalled\n         └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0\n따라서 A 가 명시적으로 필요하다는 것을 알 수 있습니다. 이 경우에는 A 를 환경에 추가하려고 했기 때문입니다.\n요약하면 우리는 명시적으로 A 와 B 를 사용하도록 요청했지만 이로 인해 D 와 충돌이 발생했습니다. 그 이유는 B 와 C 가 충돌하는 버전의 D 를 필요로 하기 때문입니다. C 는 우리가 명시적으로 요청한 것이 아니지만 A 가 필요로 했습니다.\n이러한 오류를 수정하려면 다음과 같은 여러 가지 옵션이 있습니다.\n\n패키지 업데이트를 시도하십시오. 패키지의 개발자가 최근 상호 호환되는 새 버전을 출시했을 가능성이 있습니다.\n환경에서 A 또는 B 를 제거하십시오. 아마도 B 는 이전에 작업하던 작업에서 남겨져 더 이상 필요하지 않을 수 있습니다. A 와 B 가 동시에 필요하지 않은 경우 문제를 해결하는 가장 쉬운 방법입니다.\n충돌을 보고합니다. 이 경우 B 에는 오래된 버전의 D 가 필요하다고 추론할 수 있었습니다. 따라서 B.jl 의 개발 저장소에서 업데이트된 버전을 요청하는 이슈를 보고할 수 있습니다.\n문제를 직접 해결해 보십시오. Project.toml 파일과 파일이 호환성 요구 사항을 선언하는 방법을 이해하면 이 작업이 더 쉬워집니다. 충돌 해결에서 이 예제로 돌아갑니다.\n\n\n\n\n3.8 오래되고 사용되지 않는 패키지를 가비지 컬렉팅 하기\n패키지가 업데이트되고 프로젝트가 삭제되면 설치된 패키지 버전과 아티팩트는 필연적으로 오래되어 기존 프로젝트에서 사용되지 않습니다. Pkg 는 사용된 모든 프로젝트의 로그를 유지하므로 로그를 통해 어떤 프로젝트가 여전히 존재하고 해당 프로젝트에서 어떤 패키지/아티팩트가 사용되었는지 정확히 확인할 수 있습니다. 패키지 또는 아티팩트가 프로젝트에서 사용된 것으로 표시되지 않은 경우 고아 패키지(orphaned package) 목록에 추가됩니다. 다시 사용하지 않고 30일 동안 고아 목록에 있는 패키지 및 아티팩트는 다음 가비지 수집 시 시스템에서 삭제됩니다. 이 시점은 Pkg.gc()에 대한 collect_delay 키워드 인수를 통해 설정할 수 있습니다. 값이 0이면 사용하지 않는 항목이 고아목록을 건너뛰고 즉시 삭제됩니다. 디스크 공간이 부족하고 사용하지 않는 패키지와 아티팩트를 가능한 한 많이 정리하려는 경우 이 방법을 시도해 볼 수 있지만 이러한 버전이 다시 필요한 경우 다시 다운로드해야 합니다. 기본 인수를 사용하여 일반적인 가비지 수집을 실행하려면 pkg&gt; REPL에서 gc 명령을 사용하면 됩니다.\n(@v1.8) pkg&gt; gc\n    Active manifests at:\n        `~/BinaryProvider/Manifest.toml`\n        ...\n        `~/Compat.jl/Manifest.toml`\n    Active artifacts:\n        `~/src/MyProject/Artifacts.toml`\n\n    Deleted ~/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB\n    Deleted ~/.julia/packages/Cassette/BXVB: 795.557 KiB\n   ...\n   Deleted `~/.julia/artifacts/e44cdf2579a92ad5cbacd1cddb7414c8b9d2e24e` (152.253 KiB)\n   Deleted `~/.julia/artifacts/f2df5266567842bbb8a06acca56bcabf813cd73f` (21.536 MiB)\n\n   Deleted 36 package installations (113.205 MiB)\n   Deleted 15 artifact installations (20.759 GiB)\n~/.julia/packages 에 포함된 패키지만 삭제되는 것을 확인 할 수 있습니다.\n\n\n\n3.9 오프라인 모드\n오프라인 모드에서 Pkg는 인터넷에 연결하지 않고 가능한 한 많은 일을 하려고 합니다. 예를 들어 패키지를 추가할 때 Pkg는 버전 확인에서 이미 다운로드된 버전만 고려합니다.\n오프라인 모드에서 작업하려면 import Pkg 를 사용하십시오. Pkg.offline(true) 또는 환경 변수 JULIA_PKG_OFFLINE 을 “true” 로 설정합니다.\n\n\n\n3.10 Pkg 클라이언트/서버\n등록된 패키지를 새로 추가하면 일반적으로 다음 세 가지가 발생합니다.\n\n레지스트리 업데이트,\n패키지의 소스 코드 다운로드,\n사용할 수 없는 경우 패키지에 필요한 아티팩트를 다운로드.\n\nGeneral 레지스트리와 그 안에 있는 대부분의 패키지는 Github 에서 개발되며 아티팩트 데이터는 다양한 플랫폼에서 호스팅됩니다. Github 및 AWS S3에 대한 네트워크 연결이 안정적이지 않은 경우 일반적으로 패키지를 설치하거나 업데이트하는 것은 좋은 경험이 아닙니다. 다행스럽게도 pkg 클라이언트/서버 기능은 다음과 같은 측면에서 경험을 향상시킵니다.\n\n설정된 경우 pkg 클라이언트는 먼저 pkg 서버에서 데이터 다운로드를 시도합니다.\n실패하면 원래 소스(예: Github)에서 다시 다운로드합니다.\n\n기본적으로, Pkg 클라이언트는 서버에 최대 8개의 동시 요청을 보냅니다. 이 동시 요청의 수는 JULIA_PKG_CONCURRENT_DOWNLOADS 환경 변수를 설정하여 조정할 수 있습니다.\nJulia 1.5부터 JuliaLang 이 제공하는 기본 패키지 서버는 https://pkg.julialang.org 입니다. 대다수의 경우 이는 투명하게 작동하므로 사용자가 별도로 설정할 필요가 없습니다. 그러나 필요할 경우 사용자들은 환경 변수 JULIA_PKG_SERVER를 통해 직접 패키지 서버를 설정하거나 해제할 수 있습니다.\n# manually set it to some pkg server\njulia&gt; ENV[\"JULIA_PKG_SERVER\"] = \"pkg.julialang.org\"\n\"pkg.julialang.org\"\n\n# unset to always download data from original sources\njulia&gt; ENV[\"JULIA_PKG_SERVER\"] = \"\"\n\"\"\n명확하게 하자면, 일부 소스는 Pkg 서버에서 제공하지 않습니다.\n\ngit을 통해 가져온 패키지/레지스트리\n\n]add https://github.com/JuliaLang/Example.jl.git\n]add Example#v0.5.3 (이것은 ]add Example@0.5.3과 다릅니다)\n]registry add https://github.com/JuliaRegistries/General.git, 1.4 이전에 Julia가 설치한 레지스트리 포함됨\n\n다운로드 정보가 없는 아티팩트\n\nTestImages\n\n\n\n\n\n\n\n\n노트\n\n\n\npkg 서버를 통해 새 레지스트리를 설치한 경우 이전 Julia 버전이 레지스트리를 업데이트하는 것은 불가능합니다. 1.4 이전의 Julia는 새 데이터를 가져오는 방법을 모르기 때문입니다. 따라서 여러 julia 버전 간에 자주 전환하는 사용자의 경우 git 제어 레지스트리를 계속 사용하는 것이 좋습니다.\n\n\n\npkg 서버 배포에 대해서는 PkgServer.jl을 참조하십시오.",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html#sec-working_with_environment",
    "href": "src/application_of_julia/pkg.html#sec-working_with_environment",
    "title": "Pkg.jl",
    "section": "4 환경을 이용한 작업",
    "text": "4 환경을 이용한 작업\n다음은 Pkg와 환경의 상호 작용에 대해 설명합니다. 코드를 로드할 수 있는 환경의 “스택”을 포함하여 코드를 로딩할 때의 환경의 역할에 대한 자세한 내용은 Julia 설명서의 이 섹션을 참조하세요.\n\n\n4.1 당신의 프로젝트를 생성하기\n지금까지 ~/.julia/environments/v1.9 의 기본 프로젝트에 패키지를 추가했습니다. 그러나 다른 독립적인 프로젝트를 만드는 것은 쉽습니다. 이 접근 방식은 Project.toml 및 원하는 경우 Manifest.toml 을 코드와 함께 버전 제어(예: git)에 체크인할 수 있는 이점이 있습니다. 두 프로젝트가 동일한 버전의 동일한 패키지를 사용하는 경우 이 패키지의 내용이 중복되지 않는다는 점에 유의해야 합니다. 새 프로젝트를 만들려면 디렉터리를 만든 다음 해당 디렉터리를 활성화하여 패키지 작업이 처리하는 “활성 프로젝트(active project)”로 만듭니다.\njulia&gt; mkdir(\"MyProject\")\n\njulia&gt; cd(\"MyProject\")\n/Users/kristoffer/MyProject\n\n# we can now use \".\" instead of a longer relative or full path:\n(v1.0) pkg&gt; activate .\n\n(MyProject) pkg&gt; st\n    Status `Project.toml`\n새 프로젝트가 활성화되면 REPL 프롬프트가 변경되었습니다. 이것은 새로 생성된 프로젝트이므로 상태 명령은 패키지가 포함되어 있지 않으며 실제로 패키지를 추가할 때까지 프로젝트 또는 메니패스트 파일이 없음을 보여줍니다.\njulia&gt; isdir(\"MyProject\")\nfalse\n\n(MyProject) pkg&gt; add Example\n   Resolving package versions...\n   Installed Example ─ v0.5.3\n    Updating `~/MyProject/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `~~/MyProject/Manifest.toml`\n  [7876af07] + Example v0.5.3\nPrecompiling environment...\n  1 dependency successfully precompiled in 2 seconds\n\njulia&gt; readdir(\"MyProject\")\n2-element Vector{String}:\n \"Manifest.toml\"\n \"Project.toml\"\n\njulia&gt; print(read(joinpath(\"MyProject\", \"Project.toml\"), String))\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\njulia&gt; print(read(joinpath(\"MyProject\", \"Manifest.toml\"), String))\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = \"1.9.4\"\nmanifest_format = \"2.0\"\nproject_hash = \"2ca1c6c58cb30e79e021fb54e5626c96d05d5fdc\"\n\n[[deps.Example]]\ngit-tree-sha1 = \"46e44e869b4d90b96bd8ed1fdcf32244fddfb6cc\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"0.5.3\"\n이 새로운 환경은 이전에 사용했던 환경과 완전히 별개입니다. 더 자세한 설명은 Projexct.toml 과 Manifest.toml 을 확인하시기 바랍니다.\n\n\n\n4.2 다른 사람의 프로젝트를 사용하기\ngit clone 을 사용하여 프로젝트를 복제하고 cd 를 통해 프로젝트 디렉토리로 이동한 후 호출합니다.\nshell&gt; git clone https://github.com/JuliaLang/Example.jl.git\nCloning into 'Example.jl'...\n...\n\n(@v1.9) pkg&gt; activate Example.jl\nActivating project at `~/Example.jl`\n\n(Example) pkg&gt; instantiate\n  No Changes to `~/Example.jl/Project.toml`\n  No Changes to `~/Example.jl/Manifest.toml`\n프로젝트에 Manifest.toml 이 포함되어 있다면, 해당 매니페스트에 정의된 상태로 패키지가 설치됩니다. 그렇지 않으면, 프로젝트와 호환되는 최신 버전으로 종속성을 해결하게 됩니다.\nactivate 명령만으로는 누락된 종속성을 설치하지 않습니다. 만약 Project.toml 만 있는 경우, 환경을 해하여 Manifest.toml 을 생성한 후, 누락된 패키지를 설치하고 미리 컴파일해야 합니다. instantiate 명령은 이러한 작업을 모두 자동으로 처리해 줍니다.\n이미 해결된 Manifest.toml 이 있는 경우라도, 패키지가 설치되어 있고 올바른 버전인지를 확인해야 합니다. 이때도 instantiate 명령은 이를 자동으로 처리해 줍니다.\n요컨대, instantiate 는 환경을 사용 준비 상태로 만드는 데 도움을 주는 도구입니다. 만약 수행할 작업이 없다면, instantiate 는 아무 작업도 하지 않습니다.\n\n\n\n\n\n\n노트\n\n\n\nJulia를 실행할 때 activate 명령을 사용하는 대신, --project=&lt;path&gt; 플래그를 통해 시작 시 특정 프로젝트를 지정할 수 있습니다. 예를 들어, 현재 디렉토리의 환경을 사용하여 명령줄에서 스크립트를 실행하려면, 다음과 같은 방법으로 실행할 수 있습니다:\n$ julia --project=. myscript.jl\n\n\n\n\n\n4.3 임시 환경\n임시 환경은 패키지나 여러 패키지를 테스트하기 위해 초기 상태에서 환경을 시작하고, 사용이 끝나면 Pkg가 자동으로 환경을 삭제할 수 있게 해줍니다. 예를 들어, 버그 보고서를 작성할 때, 작성한 대로 실제로 재현 가능한지 확인하기 위해 ‘깨끗한’ 환경에서 최소한의 재현 가능한 예제를 테스트하고 싶을 수 있습니다. 또한, 새로운 패키지를 시도해 볼 작업 공간이 필요하거나, 여러 호환되지 않는 패키지 간의 버전 충돌을 해결하기 위한 샌드박스를 원할 수도 있습니다.\n(@v1.9) pkg&gt; activate --temp # requires Julia 1.5 or later\n  Activating new environment at `/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Project.toml`\n\n(jl_a31egx) pkg&gt; add Example\n    Updating registry at `~/.julia/registries/General`\n   Resolving package versions...\n    Updating `/private/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `/private/var/folders/34/km3mmt5930gc4pzq1d08jvjw0000gn/T/jl_a31egx/Manifest.toml`\n  [7876af07] + Example v0.5.3\n\n\n\n4.4 공유 환경\n공유 환경은 단지 ~/.julia/environments 에 존재하는 환경이다. 기본 v1.9 환경은 따라서 공유환경이다.\n(@v1.9) pkg&gt; st\nStatus `~/.julia/environments/v1.9/Project.toml`\nactivate 명령어에 --shared 플리그를 붙이면 공유 환경이 활성화된다.\n(@v1.9) pkg&gt; activate --shared mysharedenv\n  Activating project at `~/.julia/environments/mysharedenv`\n\n(@mysharedenv) pkg&gt;\n공유 환경은 Pkg REPL 프롬프트에서 이름 앞에 @ 가 붙는다.\n\n\n\n4.5 프로젝트 사전 컴파일\n패키지를 임포트 하기 전에 Julia는 소스 코드를 디스크상에서의 더 효율적인 중간 캐시로 “사전 컴파일(precompile)”합니다. 임포트 되지 않은 패키지가 새 패키지이거나 마지막 캐시 이후 변경된 패키지일 경우 코드 로드를 통해 사전 컴파일이 개시될 수 있습니다.\njulia&gt; using Example\n[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]\n또는 전체 프로젝트나 지정된 의존성을 사전 컴파일할 수 있는 Pkg의 사전 컴파일 옵션을 사용하여 병렬로 수행할 수 있는데, 이 방법이 위의 코드 로드 경로보다 훨씬 빠를 수 있습니다.\n(@v1.9) pkg&gt; precompile\nPrecompiling environment...\n  23 dependencies successfully precompiled in 36 seconds\n그러나 Pkg의 자동 사전 컴파일로 인해 이들 중 어느 것도 일상적으로 필요하지 않습니다.\n\n\n자동 사전 컴파일\n기본적으로 프로젝트에 추가되거나 Pkg 작업에서 업데이트되는 모든 패키지는 해당 의존성과 함께 자동으로 미리 컴파일됩니다.\n(@v1.9) pkg&gt; add Images\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.9/Project.toml`\n  [916415d5] + Images v0.25.2\n    Updating `~/.julia/environments/v1.9/Manifest.toml`\n    ...\nPrecompiling environment...\n  Progress [===================&gt;                     ]  45/97\n  ✓ NaNMath\n  ✓ IntervalSets\n  ◐ CoordinateTransformations\n  ◑ ArnoldiMethod\n  ◑ IntegralArrays\n  ◒ RegionTrees\n  ◐ ChangesOfVariables\n  ◓ PaddedViews\ndevelop 명령은 예외인데 패키지를 빌드하거나 미리 컴파일하지 않습니다. 언제 할지는 사용자가 결정할 수 있습니다.\n자동 사전 컴파일 중에 지정된 패키지 버전 오류가 발생하면 Pkg는 자동으로 시도하는 이후의 시간동안 기억하고 간단한 경고와 함께 해당 패키지를 건너뜁니다. pkg&gt; precompile 은 항상 모든 패키지를 재시도하므로 수동 사전 컴파일을 사용하여 이러한 패키지를 강제로 재시도할 수 있습니다.\n자동 사전 컴파일을 비활성화하려면 ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0을 설정합니다.\n프리컴파일 중에 표시되는 패키지 이름 옆의 지표는 해당 패키지의 사전컴파일 상태를 나타냅니다.\n\n[◐, ◓, ◑, ◒]: 애니메이션 “시계” 문자들은 패키지가 현재 사전컴파일 중임을 나타냅니다.\n✓: 초록색 체크표시는 패키지가 성공적으로 사전컴파일되었음을 나타냅니다. 사전컴파일이 완료되면 해당 패키지는 리스트에서 사라집니다. 체크표시가 노란색인 경우, 그 패키지가 현재 로드되어 있어, 방금 사전컴파일된 버전을 사용하려면 세션을 재시작해야 함을 의미합니다.\n?: 물음표 문자는 PrecompilableError 가 발생했음을 나타내며, 이는 사전컴파일이 허용되지 않음을 의미합니다. 즉, 해당 패키지에서 __precompile__(false) 가 설정된 경우입니다.\n✗: 십자가 표시(엑스)는 패키지의 사전컴파일이 실패했음을 나타냅니다. 이 지표들은 사전컴파일 진행 상황을 이해하고 문제를 해결하는 데 도움을 줍니다.\n\n\n\n\n로드된 패키지의 새 버젼을 사전 컴파일하기\n업데이트된 패키지가 이미 세션에 로드된 경우 사전 컴파일 프로세스가 계속 진행되어 새 버전과 이에 의존하는 모든 패키지를 사전 컴파일하지만 세션을 다시 시작할 때까지 패키지를 사용할 수 없다는 점에 유의하십시오.",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html#패키지-작성",
    "href": "src/application_of_julia/pkg.html#패키지-작성",
    "title": "Pkg.jl",
    "section": "5 패키지 작성",
    "text": "5 패키지 작성\n\n5.1 패키지용 파일 생성\n\n\n\n\n\n\n노트\n\n\n\nPkgTemplates 패키지는 새 패키지용 파일을 생성하는 매우 쉽고 반복 가능하며 사용자 맞춤식의 방법을 제공합니다. 아래에 설명된 최소한의 pkg&gt; generate 기능을 사용하는 대신 PkgTemplates 를 사용하여 새 패키지를 만드는 것이 좋습니다.\n\n\n\n새 패키지에 대한 파일을 생성하려면 pkg&gt; generate 를 실행하십시오.\n(@v1.8) pkg&gt; generate HelloWorld\n이렇게 하면 다음 파일이 포함된 새 프로젝트 HelloWorld가 생성됩니다(외부 tree 명령으로 시각화됩니다).\nshell&gt; tree HelloWorld/\nHelloWorld/\n├── Project.toml\n└── src\n    └── HelloWorld.jl\n\n2 directories, 2 files\n\nProject.toml 파일은 패키지 이름, 고유의 UUID, 버젼, 저자, 그리고 잠재적 의존성을 포함합니다.\nname = \"HelloWorld\"\nuuid = \"b4cd1eb8-1e24-11e8-3319-93036a3eb9f3\"\nversion = \"0.1.0\"\nauthors = [\"Some One &lt;someone@email.com&gt;\"]\n\n[deps]\n\nsrc/HelloWorld.jl 의 내용은 다음과 같습니다\nmodule HelloWorld\n\ngreet() = print(\"Hello World!\")\n\nend # module\n이제 프로젝트를 활성화하고 패키지를 로드할 수 있습니다.\npkg&gt; activate ./HelloWorld\n\njulia&gt; import HelloWorld\n\njulia&gt; HelloWorld.greet()\nHello World!\n\n\n\n5.2 프로젝트에 의존성 추가\n프로젝트에서 표준 라이브러리 패키지인 Random 과 등록된 패키지 JSON 을 사용하고 싶다고 가정해 보겠습니다. 이 패키지를 add 하기만 하면 됩니다(새로 생성된 프로젝트를 actvate 한 이후에는 프롬프트에 이제 프로젝트 이름이 표시됩니다).\n(HelloWorld) pkg&gt; add Random JSON\n Resolving package versions...\n  Updating \"~/Documents/HelloWorld/Project.toml\"\n [682c06a0] + JSON v0.17.1\n [9a3f8284] + Random\n  Updating \"~/Documents/HelloWorld/Manifest.toml\"\n [34da2185] + Compat v0.57.0\n [682c06a0] + JSON v0.17.1\n [4d1e1d77] + Nullables v0.0.4\n ...\nRandom 과 JSON 이 모두 프로젝트의 Project.toml 파일에 추가되었고 결과 의존성이 Manifest.toml 파일에 추가되었습니다. 리졸버(resolver)는 가능한 가장 높은 버전의 각 패키지를 설치했지만 각 패키지가 해당 의존성에 적용하는 호환성을 여전히 존중합니다.\n이제 프로젝트에서 Random 과 JSON 을 모두 사용할 수 있습니다. src/HelloWorld.jl 을 아래와 같이 변경하고\nmodule HelloWorld\n\nimport Random\nimport JSON\n\ngreet() = print(\"Hello World!\")\ngreet_alien() = print(\"Hello \", Random.randstring(8))\n\nend # module\n다시 패키지를 로딩하면 Random 을 사용하는 새로운 greet_alien 함수를 호출 할 수 있습니다.\njulia&gt; HelloWorld.greet_alien()\nHello aT157rHV\n\n\n\n5.3 공개 API 를 정의하기\n다른 패키지에서 유용하게 사용되고, 사람들이 새 버전이 출시될 때 쉽게 업데이트할 수 있기를 원한다면, 업데이트 간에 일관되게 유지될 행동을 문서화하는 것이 중요합니다.\n별도의 언급이 없으면, 패키지의 공개 API는 공개된 기호(심볼)에 대해 설명한 모든 동작으로 정의됩니다. 공개 기호는 export 키워드로 패키지에서 내보내지거나 public 키워드로 공개로 표시된 기호입니다. 이전에 공개됐던 기능의 동작을 변경하여 새 버전이 이전 버전에서 제공한 사양에 더 이상 부합하지 않게 될 경우, Julia에서 변형한 SemVer 에 따라 패키지 버전 번호를 조정해야 합니다. 기호를 공개 API에 포함하고는 싶지만, using YourPackage 를 호출하는 사람들의 전역 네임스페이스에 내보내고 싶지 않다면 public that_symbol 로 그 기호를 공개로 표시해야 합니다. public 키워드로 공개로 표시된 기호는 export 키워드로 공개된 기호만큼이나 공개적이지만, 사람들이 using YourPackage 를 호출할 때는 여전히 ourPackage.that_symbol 과 같이 해당 기호에 접근할 때 수식해야 합니다.\ngreet 함수는 공개 API의 일부로 만들고 싶지만, greet_alien 함수는 포함하지 않으려 한다고 가정해봅시다. 다음과 같이 작성하여 버전 1.0.0으로 릴리스할 수 있습니다:\nmodule HelloWorld\n\nexport greet\n\nimport Random\nimport JSON\n\n\"Writes a friendly message.\"\ngreet() = print(\"Hello World!\")\n\n\"Greet an alien by a randomly generated name.\"\ngreet_alien() = print(\"Hello \", Random.randstring(8))\n\nend # module\n이제 greet 를 다음과같이 바꿉니다.\n\"Writes a friendly message that is exactly three words long.\"\ngreet() = print(\"Hello Lovely World!\")\n새 버전은 1.1.0으로 릴리스할 수 있습니다. 만약 새로운 구현이 기존 문서에 정의된 동작을 준수하면서 메시지가 세 단어 길이여야 한다는 기능을 추가한 것이라면, 이는 호환성을 깨지 않는 변경으로 간주됩니다.\n이후 당신이 greet_alien 을 다음과 같이 바꾼다고 해 봅시다.\n\"Greet an alien by the name of \\\"Zork\\\".\"\ngreet_alien() = print(\"Hello Zork\")\n그리고\nexport greet\n를\nexport greet, greet_alien\n으로 바꿨다고 해 봅시다. 새로운 기능인 greet_alien 을 공개 API에 추가했으므로, 새 버전을 1.2.0 으로 릴리스하는 것이 적절합니다. 비록 greet_alien 이 이전에 문서화되어 있었고 그 새 버전이 이전 문서와 일치하지 않더라도, greet_alien 이 그 당시 exported 된 심볼과 연결되지 않았기 때문에 이는 호환성을 깨는 변경으로 간주되지 않습니다. 따라서, greet_alien 이 새로운 공개 API의 일환으로 추가되었음을 표시하기 위해 마이너 버전을 증가시켜 1.2.0으로 릴리스할 수 있습니다.\n그러나 당신이 greet 를 다음과 같이 변경한다고 해 봅시다.\n\"Writes a friendly message that is exactly four words long.\"\ngreet() = print(\"Hello very lovely world\")\n새로운 버전을 2.0.0 으로 릴리스해야 하는 이유는 다음과 같습니다. 버전 1.1.0 에서는 인사말이 세 단어로 구성된다는 사양을 명시했으며, greet 함수가 export 된 상태였기 때문에 그 설명은 다음 호환성 깨는 릴리스 전까지 모든 미래의 버전에 적용됩니다. 새로운 버전이 이전 사양과 일치하지 않는다면, 이는 호환성을 깨는 변경으로 간주되어야 하기 때문에 메이저 버전을 증가시켜 2.0.0으로 태그 지정해야 합니다.\n버전 번호는 자유롭고 무제한입니다. 즉, 많은 버전 번호를 사용하는 것이 괜찮습니다(예: 버전 6.62.8). 이는 개발 및 릴리스 관리에 있어 유연성을 제공하며, 변경 사항의 범위와 성격에 따라 적절히 버전 번호를 관리하는 것이 중요합니다.\n\n\n\n5.4 패키지에 빌드 단계를 추가하기\n빌드 단계는 패키지가 처음 설치되거나 build 를 통해 명시적으로 호출될 때 실행됩니다. 패키지는 deps/build.jl 파일을 실행하여 빌드됩니다.\njulia&gt; mkpath(\"deps\");\n\njulia&gt; write(\"deps/build.jl\",\n             \"\"\"\n             println(\"I am being built...\")\n             \"\"\");\n\n(HelloWorld) pkg&gt; build\n  Building HelloWorld → `deps/build.log`\n Resolving package versions...\n\njulia&gt; print(readchomp(\"deps/build.log\"))\nI am being built...\n빌드 단계가 실패하면 빌드 단계의 출력이 콘솔에 인쇄됩니다.\njulia&gt; write(\"deps/build.jl\",\n             \"\"\"\n             error(\"Ooops\")\n             \"\"\");\n\n(HelloWorld) pkg&gt; build\n    Building HelloWorld → `~/HelloWorld/deps/build.log`\nERROR: Error building `HelloWorld`:\nERROR: LoadError: Ooops\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] top-level scope\n   @ ~/HelloWorld/deps/build.jl:1\n [3] include(fname::String)\n   @ Base.MainInclude ./client.jl:476\n [4] top-level scope\n   @ none:5\nin expression starting at /home/kc/HelloWorld/deps/build.jl:1\n\n\n\n\n\n\n경고\n\n\n\n빌드 단계에서는 일반적으로 패키지 디렉토리 내의 어떤 파일도 만들거나 수정하지 않습니다. 빌드 단계로부터 어떤 파일을 저장하기 원한다면 Scratch.jl 패키지를 사용하세요.\n\n\n\n\n\n5.5 패키지에 테스트 추가하기\n패키지가 테스트되면 test/runtests.jl 파일이 실행됩니다.\njulia&gt; mkpath(\"test\");\n\njulia&gt; write(\"test/runtests.jl\",\n             \"\"\"\n             println(\"Testing...\")\n             \"\"\");\n\n(HelloWorld) pkg&gt; test\n   Testing HelloWorld\n Resolving package versions...\nTesting...\n   Testing HelloWorld tests passed\n테스트는 패키지 자체와 테스트 관련 의존성을 사용할 수 있는 새로운 Julia 프로세스에서 실행됩니다(아래 참조).\n\n\n테스트용 의존성\n테스트 전용 의존성은 패키지를 설치하거나 로드할 때는 필요 없지만 패키지를 테스트 할 때 필요한 의존성을 말합니다. 테스트 전용 의존성을 추가하는 두가지 방법이 있습니다.\ntarget 기반 테스트 전용 의존성\n테스트용 의존성을 추가 할 때 Project.toml 파일에 아래와 같이 [extra] 섹션과 [target] 섹션에 추가하는 것입니다. 아래는 Markdown 과 Test 를 테스트용 의존성으로 추가합니다.\n[extras]\nMarkdown = \"d6f4376e-aef5-505a-96c1-9c027394607a\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Markdown\", \"Test\"]\n유일하게 지원되는 targes 는 test 와 build 이며 build 는(추천하지 않습니다) 어떤 deps/build.jl 스크립트를 위해 사용됩니다.\n\ntest/Project.toml 파일을 사용하기\n\n\n\n\n\n\n노트\n\n\n\nProject.toml, test/Project.toml 및 이들과 연결된 Manifest.toml 파일 간의 정확한 상호작용은 아직 완전히 정립되지 않았으며, 향후 버전에서 변경될 수 있습니다. 따라서, 이전 섹션에서 설명한 대로 테스트 전용 의존성을 추가하는 기존 방법은 모든 Julia 1.X 릴리스에서 계속 지원될 것입니다. 이는 Julia가 앞으로도 계속 발전하고 있다는 것을 반영합니다. 현재의 방식으로도 테스트 전용 의존성을 관리할 수 있지만, 향후 릴리스에서는 더 나은 관리 방법이나 변경점이 도입될 수 있으니 주의를 기울여야 합니다.\n\n\n\nJulia 1.2 부터 그 이후에는 테스트 의존성이 test/Project.toml 에 선언 될 수 있습니다. 테스트를 실행시키면 Pkg 는 자동적으로 이것과 패키지 프로젝트를 통합하여 테스트 환경을 만듭니다.\n\n\n\n\n\n\n노트\n\n\n\ntest/Project.toml 파일이 존재하지 않는다면 Pkg 는 target 기반 테스트 의존성을 사용합니다.\n\n\n\n테스트 전용 의존성, 즉 테스트할 때만 사용되는 의존성을 추가하려면, 해당 의존성을 test/Project.toml 프로젝트에 추가하면 됩니다. 이는 Pkg REPL에서 이 환경을 활성화한 후, 일반적으로 사용하는 것처럼 add 명령을 사용하여 가능합니다. Test 표준 라이브러리를 테스트 의존성으로 추가하는 방법은 다음과 같습니다:\n(HelloWorld) pkg&gt; activate ./test\n[ Info: activating environment at `~/HelloWorld/test/Project.toml`.\n\n(test) pkg&gt; add Test\n Resolving package versions...\n  Updating `~/HelloWorld/test/Project.toml`\n  [8dfed614] + Test\n  Updating `~/HelloWorld/test/Manifest.toml`\n  [...]\n이제 테스트 스크립트에서 Test 를 사용할 수 있으며 테스트할 때 설치되는 것을 볼 수 있습니다.\njulia&gt; write(\"test/runtests.jl\",\n             \"\"\"\n             using Test\n             @test 1 == 1\n             \"\"\");\n\n(test) pkg&gt; activate .\n\n(HelloWorld) pkg&gt; test\n   Testing HelloWorld\n Resolving package versions...\n  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`\n  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]\n  [8dfed614] + Test\n  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`\n  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]\n   Testing HelloWorld tests passed```\n\n\n\n\n5.6 의존성의 호환성\n모든 의존성은 일반적으로 호환성 제한이 있습니다. 이것은 중요한 주제이므로 호환성 (Compatiblity) 에서 별도로 다룹니다.\n\n\n\n5.7 약한 의존성\n\n\n\n\n\n\n노트\n\n\n\n\n이것은 Pkg 의 고급 사용법이며 Julia 와 Julia 패키지의 초심자들은 넘어가도 된다.\n기술된 특징은 Julia 1.9 이상에서 사용 할 수 있다.\n\n\n\n약한 의존성(weak dependency)은 패키지가 설치될 때 자동으로 설치되지는 않지만, 해당 패키지의 허용 가능한 버전을 설정하여 제어할 수 있는 의존성입니다. 이러한 의존성은 프로젝트 파일의 [weakdeps] 섹션에 나열됩니다.\n[weakdeps]\nSomePackage = \"b3785f31-9d33-4cdf-bc73-f646780f1739\"\n\n[compat]\nSomePackage = \"1.2\"\n양한 의존성은 현재 유일하게 “extensions” 에만 제한적으로 사용되고 있습니다. “extensions” 는 다음 섹션에 설명합니다.\n\n\n\n5.8 패키지 코드의 조건부 로딩 (Extensions)\n\n\n\n\n\n\n노트\n\n\n\n\n이것은 Pkg 의 고급 사용법이며 Julia 와 Julia 패키지의 초심자들은 넘어가도 된다.\n기술된 특징은 Julia 1.9 이상에서 사용 할 수 있다.\n\n\n\n때로는 두 개 이상의 패키지를 잘 작동하도록 만들고 싶지만, 그 중 하나를 다른 패키지의 무조건적인 의존성으로 만들고 싶지 않을 수 있습니다(예를 들어, 로드 시간이 증가할 수 있기 때문에). 패키지 확장(extensions) 은 다른 특정 패키지 집합이 Julia 세션에 로드될 때 자동으로 로드되는 모듈입니다. 이는 외부 패키지인 Requires.jl 이 제공하는 기능과 매우 유사하지만, 이제 Julia가 직접 이러한 기능을 제공하며, 확장을 미리 컴파일할 수 있는 추가적인 이점도 제공합니다.\n\n\n코드 구조\n패키지 확장은 다양한 Julia 패키지의 객체를 플롯할 수 있는 플롯팅 패키지에서 유용하게 사용할 수 있습니다. 이러한 경우 모든 관련 Julia 패키지를 플롯팅 패키지의 의존성으로 추가하면, 실제로 사용되지 않더라도 모든 패키지가 로드되어 비용이 증가할 수 있습니다. 대신, 특정 패키지의 객체를 플롯하는 데 필요한 코드를 별도의 파일(확장)로 분리하여, 우리가 플롯하려는 유형을 정의한 패키지가 로드될 때만 해당 확장이 로드되도록 할 수 있습니다. 아래는 플롯팅 패키지가 외부 패키지 Contour에서 정의한 객체를 표시할 수 있도록 하고자 할 때 코드 구조를 설계하는 예입니다. 다음은 플롯팅 패키지 내의 파일 및 폴더 구조에 대한 예시입니다:\nProject.toml :\nname = \"Plotting\"\nversion = \"0.1.0\"\nuuid = \"...\"\n\n[weakdeps]\nContour = \"d38c429a-6771-53c6-b99e-75d170b6e991\"\n\n[extensions]\n# name of extension to the left\n# extension dependencies required to load the extension to the right\n# use a list for multiple extension dependencies\nContourExt = \"Contour\"\n\n[compat]\nContour = \"0.6.2\"\nsrc/Protting.jl :\nmodule Plotting\n\nfunction plot(x::Vector)\n    # Some functionality for plotting a vector here\nend\n\nend # module\next/ContourExt.jl (혹은 ext/ContourExt/ContourExt.jl 에)\nmodule ContourExt # Should be same name as the file (just like a normal package)\n\nusing Plotting, Contour\n\nfunction Plotting.plot(c::Contour.ContourCollection)\n    # Some functionality for plotting a contour here\nend\n\nend # module\n\n확장(extension)은 임의의 이름을 가질 수 있으며(여기서는 ContourExt), 의존성이 하나인 확장에서는 이 예제의 형식을 따르는 것이 좋은 아이디어일 수 있습니다. Pkg의 출력에서는 확장 이름이 항상 상위 패키지 이름과 함께 표시됩니다.\n\n\n\n\n\n\n노트\n\n\n\n\n확장 의존성을 테스트 대상으로 설정하면 Pkg.test() 등을 실행할 때 해당 의존성이 로드됩니다. 이전 Julia 버전에서는 이 작업을 수행하기 위해 패키지를 [extras] 섹션에도 추가해야 합니다. 이는 다소 번거로울 수 있지만, 이전 Julia 버전의 프로젝트 검증기가 이 절차를 생략할 경우 경고를 발생시킵니다.\n만약 확장(extensions)을 인식하지 못하는 Julia 버전에서 생성된 매니페스트를 확장을 인식하는 Julia 버전에서 사용한다면, 확장이 로드되지 않을 것입니다. 이는 매니페스트에 Julia가 언제 이러한 패키지를 로드해야 하는지를 알리는 정보가 부족하기 때문입니다. 따라서, 사용하려는 Julia 버전에서 생성된 매니페스트를 사용하는 것이 중요합니다.\n\n\n\n\n\n\n확장의 동작\n확장을 사용하는 주요 장점 중 하나는, Plotting 패키지에만 의존하는 사용자는 ContourExt 모듈 내 확장으로 인한 성능의 비용을 지불하지 않는다는 점입니다. 실제로 Contour 패키지가 로드될 때만 ContourExt 확장이 로드되어 새로운 기능을 제공합니다.\n우리 예제에서, 새로운 기능은 Plotting 이라는 상위 패키지에 있는 기존 함수에 추가하는 추가 메서드입니다. 이러한 메서드를 구현하는 것은 패키지 확장의 가장 일반적인 사용 사례 중 하나입니다. 상위 패키지 내에서 확장할 함수는 다음과 같이 메서드가 없는 상태로 정의될 수 있습니다:\n\nfunction plot end\n\n\n\n\n\n\n노트\n\n\n\n확장(extensions)을 별도의 패키지로 간주할 경우, ContourExt 가 Plotting.plot 함수나 Contour.ContourCollection 타입의 소유권을 갖고 있지 않으므로 Plotting.plot(c::Contour.ContourCollection) 을 정의하는 것이 타입 해적(type piracy)이라고 주장할 수 있습니다. (타입 해적은 다른 패키지가 소유한 함수나 타입에 대해서 외부에서 메서드를 정의하거나 확장하는 것을 의미합니다.) 그러나 확장의 경우 확장은 부모 패키지의 함수를 소유하는것으로 간주해도 됩니다.\n\n\n확장에서 상위 패키지의 기호를 재사용하는 대신 새로운 기호(타입, 구조체, 함수 등)를 정의해야 하는 상황도 있을 수 있습니다. 그러한 경우, 새로운 기호는 직접 Plotting 이 아닌, 확장에 해당하는 별도의 모듈(ContourExt 같은)에서 생성됩니다. 만약 상위 패키지에서 확장 기호가 필요하다면, Base.get_extension 을 사용하여 이를 가져와야 합니다.\n다음은 ContourExt 에서 정의한 사용자 정의 타입을 Plotting 에서 접근하는 예제입니다:\next = Base.get_extension(@__MODULE__, :ContourExt)\nif !isnothing(ext)\n    ContourPlotType = ext.ContourPlotType\nend\n반면 서드 파티 라이브러리(즉, 부모 라이브러리가 아닌) 에서 확장의 기호에 접근하는 것은 현재로서는 추천하지 않습니다.\n\n\n하위 호환성\n여기에서는 확장을 지원하는 Julia 버전에서 확장을 사용하는 다양한 방법을 논의하며, 동시에 이전 Julia 버전에서도 유사한 기능을 제공하는 방법을 다룹니다.\n… skip …\n\n\n\n\n5.9 패키지 작명 가이드\n패키지 이름은 도메인 전문가가 아니더라도 대부분의 Julia 사용자가 이해할 수 있어야 합니다. 다음 지침은 General 레지스트리에 적용되지만 다른 패키지 레지스트리에도 유용할 수 있습니다.\nGeneral 레지스트리는 전체 커뮤니티에 속하므로 패키지 이름을 게시할 때 사람들이 패키지 이름에 대해 의견을 가질 수 있습니다. 특히 패키지 이름이 모호하거나 다른 이름과 혼동될 수 있는 경우 더욱 그렇습니다. 일반적으로 패키지에 더 잘 맞는 새 이름에 대한 제안을 받게 됩니다.\n\n전문 용어를 사용하지 마십시오. 특히 혼동의 가능성이 최소화되지 않는 한 약어를 사용하지 마십시오.\n\n\n미국에 대해 이야기할 때는 USA 라고 말하는 것이 좋습니다.\n긍정적인 정신 자세에 대해 이야기하더라도 PMA(Positive Mental Attitude) 라고 말하는 것은 옳지 않습니다.\n\n\n패키지 이름에 Julia를 사용하거나 접두사로 Ju를 사용하지 마십시오.\n\n\n패키지가 Julia 패키지라는 것은 일반적으로 컨텍스트로부터 사용자에게 명확합니다.\n패키지 이름에는 이미 .jl 확장자가 있어 Package.jl 이 Julia 패키지임을 사용자에게 알립니다.\n이름에 Julia가 있으면 패키지가 Julia 언어 자체에 대한 기여자와 연관되어 있거나 기여자가 승인했음을 의미할 수 있습니다.\n\n\n새로운 타입에 대한 대부분의 기능을 제공하는 패키지에는 복수형 이름이 있어야 합니다.\n\n\nDataFrames 는 DataFrame 유형을 제공합니다.\nBloomFilters 는 BloomFilter 유형을 제공합니다.\n반대로 JuliaParser 는 새로운 유형을 제공하지 않지만 대신 JuliaParser.parse() 함수에서 새로운 기능을 제공합니다.\n\n\n짧지만 모호한 이름보다 길지만 명확한 이름을 사용하세요.\n\n\nRandomMatrices는 RndMat 또는 RMT 가 더 짧지만 덜 모호한 이름입니다.\n\n\n덜 체계적인 이름은 해당 도메인에 대한 여러 가능한 접근 방식 중 하나를 구현하는 패키지에 적합할 수 있습니다.\n\n\nJulia는 포괄적인 단일 플로팅 패키지가 없습니다. 대신 Gadfly, PyPlot, Winston 및 기타 패키지는 각각 특정 디자인 철학을 기반으로 고유한 접근 방식을 구현합니다.\n대조적으로, SortingAlgorithms 는 많은 잘 정립된 정렬 알고리즘을 사용하기 위한 일관된 인터페이스를 제공합니다.\n\n\n외부 라이브러리나 프로그램을 래핑하는 패키지는 해당 라이브러리나 프로그램의 이름을 따서 명명해야 합니다.\n\n\nCPLEX.jl은 웹 검색에서 쉽게 식별할 수 있는 CPLEX 라이브러리를 래핑합니다.\nMATLAB.jl은 Julia 내에서 MATLAB 엔진을 호출하는 인터페이스를 제공합니다.\n\n\n패키지 이름을 기존 패키지에 유사하게 지정하지 마십시오.\n\n\nWebsocket은 WebSockets 과 너무 유사하고 사용자에게 혼란을 줄 수 있습니다. 대신 SimpleWebsockets 과 같은 새 이름을 사용하십시오.\n\n\n관련이 없다면 이미 잘 알려저 사용되고 있는 고유의 이름은 피하세요.\n\n\n유명한 파이썬의 tkinter 패키지와 관련이 없다면, 비록 그것이 Tck/Tk 바인딩을 제공하더라도 Tkinter.jl 이나 TkinterGUI.jl 과 같은 이름을 사용하지 마세요. Tkinter.jl 이란 이름은 패키지가 파이썬의 tkinter 개발자들에 의해 배포되거나 그것일 이용할 때만 사용할 수 있습니다.\n혹시나 rust 언어의 유명한 http crate 와 무관하더라도 HTTP.jl 을 사용 할 수 있습니다. 왜냐면 HTTP 는 rust 의 http 보다 hypertext transfer protocol 을 보통 의미하기 때문입니다.\n만약 OpenSSL 라이브러리에 대한 인터페이스를 제공한다면 OpenSSL.jl 이라는 이름을 사용해도 됩니다.\n\n\n\n\n5.10 패키지 등록\n패키지가 준비되면 일반 레지스트리(General Registray)에 등록할 수 있습니다(FAQ 참조). 현재 패키지는 Registrator를 통해 제출됩니다. 등록자 외에도 TagBot은 릴리스 태그 지정 프로세스를 관리하는 데 도움이 됩니다.\n\n\n\n5.11 모범 사례\n패키지는 자체 상태 변경(패키지 디렉토리 내의 파일에 쓰기)을 피해야 합니다. 일반적으로 패키지는 쓰기 가능한 위치(예: 시스템 전체 저장소의 일부로 설치된 경우) 또는 안정적인 위치(예: PackageCompiler.jl에 의해 시스템 이미지에 번들된 경우)에 있다고 가정하지 않아야 합니다. Julia 패키지 생태계의 다양한 사용 사례를 지원하기 위해 Pkg 개발자는 패키지 작성자가 독립적이고 변경 불가능하며 재배치 가능한 패키지를 만드는 데 도움이 되는 여러 보조 패키지 및 기술을 만들었습니다.\n\n아티팩트(Artifacts) 를 사용하여 패키지와 함께 데이터 덩어리를 합쳐서 요청에 의해 다운로드할 수 있습니다. 재배치가 불가능하므로 joinpath(@__DIR__, \"data\", \"my_dataset.csv\") 와 같은 경로를 통해 파일을 열려고 시도하는 것보다 아티팩트를 선호하십시오. 패키지가 사전 컴파일되면 @__DIR__ 의 결과가 미리 컴파일된 패키지 데이터에 고정되며 이 패키지를 배포하려고 하면 잘못된 위치에서 파일을 로드하려고 시도합니다. 아티팩트를 뭉치고 artifact\"name\" 문자열 매크로를 사용하여 쉽게 액세스할 수 있습니다.\nScratch.jl 은 패키지에 대한 변경 가능한 데이터 컨테이너인 “스크래치 공간”이라는 개념을 제공합니다. 스크래치 공간은 패키지에 의해 완전히 관리되는 데이터 캐시를 위해 설계되었으며 패키지 자체가 제거될 때 제거되어야 합니다. 중요한 사용자 생성 데이터의 경우 패키지는 Julia 또는 Pkg에서 관리하지 않는 사용자 지정 경로에 계속 작성해야 합니다.\nPreferences.jl을 사용하면 패키지가 최상위 Project.toml에 대한 기본 설정을 읽고 쓸 수 있습니다. 이러한 기본 설정은 패키지 동작의 다양한 측면을 활성화 또는 비활성화하기 위해 런타임 또는 컴파일 타임에 읽을 수 있습니다. 이전에는 패키지가 사용자 또는 환경에서 설정한 옵션을 기록하기 위해 자체 패키지 디렉토리에 파일을 작성했지만 이제는 Preferences 를 사용할 수 있으므로 권장하지 않습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html#sec-compatibility",
    "href": "src/application_of_julia/pkg.html#sec-compatibility",
    "title": "Pkg.jl",
    "section": "6 호환성 (Compatiblity)",
    "text": "6 호환성 (Compatiblity)\n호환성은 프로젝트가 호환되는 의존성의 버전을 제한하는 기능을 말합니다. 의존성에 대한 호환성이 지정되지 않은 경우 프로젝트는 해당 의존성의 모든 버전과 호환되는 것으로 간주됩니다.\n의존성에 대한 호환성은 Project.toml 파일에 다음과 같이 입력됩니다.\n[compat]\njulia = \"1.0\"\nExample = \"0.4.3\"\n프로젝트 파일에 호환성 항목을 입력한 후 up 을 사용하여 적용할 수 있습니다.\n버전 지정자의 형식은 아래에 자세히 설명되어 있습니다.\n\n\n\n\n\n\n노트\n\n\n\n\ncompat` 명령을 사용하여 Pkg REPL의 compat 항목을 편집하거나 프로젝트 파일을 수동으로 편집합니다.\n아래의 규칙은 Project.toml 파일에 적용됩니다. 레지스트리에 대해서는 레지스트리 호횐성.toml 을 확인하세요.\n\nJulia의 General Registry에 등록하려면 각 종속성이 상한(upper bound)을 포함한 [compat] 항목을 가져야 한다는 점에 유의하세요.\n\n\n\n\n6.1 버젼 지정 형식\n다른 패키지 관리자와 마찬가지로 Julia 패키지 관리자는 semantic versioning(semver)을 따릅니다. 예를 들어 1.2.3 과 같이 주어진 버젼 지정자는 버전 [1.2.3 - 2.0.0) 과 호환되는 것으로 가정합니다. 여기서 ) 는 비포함 상한입니다. 보다 구체적으로 지정하기 위해 버전 지정자는 ^1.2.3 와 같은 캐럿 지정자 나, ~1.2.3 와 같은 물결표 지정자 가 될 수 있습니다. 캐럿 지정자가 기본값이므로 1.2.3 == ^1.2.3입니다. 캐럿과 물결표의 차이점은 다음 섹션에서 설명합니다. 여러 버전 지정자의 합집합은 개별 버전 지정자를 쉼표로 구분하여 형성할 수 있습니다. 예를 들어,\n[compat]\nExample = \"1.2, 2\"\n의 결과는 [1.2.0, 3.0.0) 입니다. 가장 앞에 0 이 나오면 다르게 취급됩니다. Example = \"0.2, 1\"은 [0.2.0 - 0.3.0) \\(\\cup\\) [1.0.0 - 2.0.0)만 됩니다. 가장 앞에 0 이 있는 버전에 대한 자세한 내용은 다음 섹션을 참조하세요.\n\n\n0 으로 시작하는 버젼의 행동 (0.0.x 와 0.x.y)\nsemver 사양에는 주 버전이 0인 모든 버전(1.0.0 이전 버전)이 서로 호환되지 않는다고 나와 있지만 주 버전과 부 버전이 모두 0인 경우에만 적용하기로 했습니다. 즉, 0.0.1과 0.0.2는 호환되지 않는 것으로 간주됩니다. 0이 아닌 부 버전(0.a.b 에서 a != 0인 경우 )이 있는 1.0 이전 버전은 동일한 부 버전 및 더 작거나 동일한 패치 버전(0.a.c 에서 c &lt;= b 인 경우)이 있는 버전과 호환되는 것으로 간주됩니다. 즉, 버전 0.2.2 및 0.2.3은 0.2.1 및 0.2.0과 호환됩니다. 주 버전이 0이고 다른 부 버전이 있는 버전은 호환되는 것으로 간주되지 않으므로 버전 0.3.0은 0.2.0에서 주요 변경 사항이 있을 수 있습니다. 이를 위한 [compat]항목은 다음과 같습니다.\n[compat]\nExample = \"0.0.1\"\n여기서는 [0.0.1, 0.0.2)(버전 0.0.1에만 해당)로 Example 에 대한 버전 바인딩이 발생하는 반면 [compat] 이\n[compat]\nExample = \"0.2.1\"\n라면,[0.2.1, 0.3.0) 으로 버전 바인딩이 발생합니다.\n특히 패키지는 0.2.0과 역호환성을 유지하는 한 0.2.3과 비교하여 기능 추가가 있을 때 버전 = “0.2.4”를 설정할 수 있습니다. version 필드 도 참조하십시오.\n\n\n\n캐럿 지정자\n캐럿(^) 지정자는 semver에 따라 호환되는 업그레이드를 허용합니다. 지정자가 사용되지 않는 경우 이것이 기본 동작입니다. 업데이트된 의존성은 새 버전이 버전 지정자에서 가장 왼쪽의 0이 아닌 숫자를 수정하지 않는 경우 호환되는 것으로 간주됩니다.\n몇 가지 예가 아래에 나와 있습니다.\n[compat]\nPkgA = \"^1.2.3\" # [1.2.3, 2.0.0)\nPkgB = \"^1.2\"   # [1.2.0, 2.0.0)\nPkgC = \"^1\"     # [1.0.0, 2.0.0)\nPkgD = \"^0.2.3\" # [0.2.3, 0.3.0)\nPkgE = \"^0.0.3\" # [0.0.3, 0.0.4)\nPkgF = \"^0.0\"   # [0.0.0, 0.1.0)\nPkgG = \"^0\"     # [0.0.0, 1.0.0)\n\n\n\n물결표 지정자\n물결표 지정자는 보다 제한된 업그레이드 가능성을 제공합니다. 주 버전, 부 버전, 패치 버전을 지정하거나 주 버전과 부 버전을 지정할 때 패치 버전만 변경할 수 있습니다. 주 버전만 지정하면 부 버전과 패치 버전을 모두 업그레이드할 수 있습니다(따라서 ~1은 ^1과 같습니다). 예를 들어:\n[compat]\nPkgA = \"~1.2.3\" # [1.2.3, 1.3.0)\nPkgB = \"~1.2\"   # [1.2.0, 1.3.0)\nPkgC = \"~1\"     # [1.0.0, 2.0.0)\nPkgD = \"~0.2.3\" # [0.2.3, 0.3.0)\nPkgE = \"~0.0.3\" # [0.0.3, 0.0.4)\nPkgF = \"~0.0\"   # [0.0.0, 0.1.0)\nPkgG = \"~0\"     # [0.0.0, 1.0.0)\n주 버전이 0인 모든 버전에서 물결표 및 캐럿 지정자는 동일합니다.\n\n\n\n등호 지정자\n등호 지정자는 특정한 정확한 버전을 위해 사용됩니다.\n[compat]\nPkgA = \"=1.2.3\"           # [1.2.3, 1.2.3]\nPkgA = \"=0.10.1, =0.10.3\" # 0.10.1 or 0.10.3\n\n\n\n부등호 지정자\n부등식을 사용하여 버전 범위를 지정할 수도 있습니다.\n[compat]\nPkgB = \"&gt;= 1.2.3\" # [1.2.3,  ∞)\nPkgC = \"≥ 1.2.3\"  # [1.2.3,  ∞)\nPkgD = \"&lt; 1.2.3\"  # [0.0.0, 1.2.3) = [0.0.0, 1.2.2]\n\n\n\n하이픈 지정자\n하이픈 구문을 사용하여 버전 범위를 지정할 수도 있습니다. 하이픈 양쪽에 공백이 있는지 확인하십시오.\n[compat]\nPkgA = \"1.2.3 - 4.5.6\" # [1.2.3, 4.5.6]\nPkgA = \"0.2.3 - 4.5.6\" # [0.2.3, 4.5.6]\n두 번째 끝점의 지정되지 않은 후행 숫자는 와일드카드로 간주됩니다.\n[compat]\nPkgA = \"1.2.3 - 4.5\"   # 1.2.3 - 4.5.* = [1.2.3, 4.6.0)\nPkgA = \"1.2.3 - 4\"     # 1.2.3 - 4.*.* = [1.2.3, 5.0.0)\nPkgA = \"1.2 - 4.5\"     # 1.2.0 - 4.5.* = [1.2.0, 4.6.0)\nPkgA = \"1.2 - 4\"       # 1.2.0 - 4.*.* = [1.2.0, 5.0.0)\nPkgA = \"1 - 4.5\"       # 1.0.0 - 4.5.* = [1.0.0, 4.6.0)\nPkgA = \"1 - 4\"         # 1.0.0 - 4.*.* = [1.0.0, 5.0.0)\nPkgA = \"0.2.3 - 4.5\"   # 0.2.3 - 4.5.* = [0.2.3, 4.6.0)\nPkgA = \"0.2.3 - 4\"     # 0.2.3 - 4.*.* = [0.2.3, 5.0.0)\nPkgA = \"0.2 - 4.5\"     # 0.2.0 - 4.5.* = [0.2.0, 4.6.0)\nPkgA = \"0.2 - 4\"       # 0.2.0 - 4.*.* = [0.2.0, 5.0.0)\nPkgA = \"0.2 - 0.5\"     # 0.2.0 - 0.5.* = [0.2.0, 0.6.0)\nPkgA = \"0.2 - 0\"       # 0.2.0 - 0.*.* = [0.2.0, 1.0.0)\n\nJulia 1.4\n하이픈 지정자는 최소한 Julia 1.4가 필요하므로 사용할 때 프로젝트 파일에 add 하는 것이 좋습니다\n[compat]\njulia = \"1.4\"\n\n\n\n\n\n6.2 충돌 수정\n버전 충돌은 다른 두 패키지인 B 와 C 에서 사용하는 패키지 D 에서 발생하는 충돌의 예 와 함께 이전에 소개되었습니다. 오류 메시지를 분석한 결과 B가 오래된 버전의 D를 사용하고 있음이 밝혀졌습니다. 이를 해결하기 위해 가장 먼저 시도하는 것은 B 와 해당 호환성 요구 사항을 수정할 수 있도록 pkg&gt; dev B 를 수행하는 것입니다. 편집기에서 Project.toml파일을 열면 다음과 같은 내용을 알 수 있습니다.\n[compat]\nD = \"0.1\"\n일반적으로 첫 번째 단계는 이것을 다음과 같이 수정하는 것입니다.ztty\n[compat]\nD = \"0.1, 0.2\"\n이는 B가 버전 0.1 및 버전 0.2 모두와 호환됨을 나타냅니다. pkg&gt; up 하면 패키지 오류가 수정됩니다. 그러나 먼저 해결해야 할 한 가지 중요한 문제가 있습니다. 아마도 D 의 v0.2 에 B 를 손상시키는 호환되지 않는 변경이 있었을 수 있습니다. 더 진행하기 전에 모든 패키지를 업데이트한 다음 B 의 테스트를 실행하여 pkg&gt; test B 의 출력을 스캔해서 D 의 v0.2가 실제로 사용되고 있는지 확인해야 합니다. (D 의 추가 의존성으로 인해 v0.1 에 고정될 수 있으며 최신 버전에서 B 를 테스트했다고 잘못 생각하고 싶지 않을 것입니다.) 새 버전이 사용되었고 테스트가 여전히 통과된 경우, D 의 v0.2 를 수용하기 위해 B 가 추가 업데이트가 필요하지 않다고 가정할 수 있습니다. 새 릴리스가 만들어지도록 이 변경 사항을 풀 요청으로 B 에 안전하게 제출할 수 있습니다. 대신 오류가 발생하면 B 가 D 의 최신 버전과 호환되기 위해 더 광범위한 업데이트가 필요함을 나타냅니다. 이러한 업데이트는 A 와 B 를 동시에 사용할 수 있게 되기 전에 완료되어야 합니다. 그러나 서로 독립적으로 계속 사용할 수 있습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html#sec-registry",
    "href": "src/application_of_julia/pkg.html#sec-registry",
    "title": "Pkg.jl",
    "section": "7 레지스트리",
    "text": "7 레지스트리\n레지스트리에는 사용 가능한 릴리스, 의존성, 다운로드할 수 있는 위치와 같은 패키지에 대한 정보가 포함되어 있습니다. General 레지스트리 는 기본 레지스트리이며 다른 레지스트리가 설치되어 있지 않으면 자동으로 설치됩니다.\n\n\n7.1 레지스트리 관리\n\n레지스트리는 Pkg REPL에서, 또는 함수적 API(functional API)를 사용하여 추가하거나 제거할수 있고, 업데이트할 수 있습니다. 이 섹션에서는 REPL 인터페이스에 대해 설명합니다. 레지스트리 API는 Registry API Reference에 설명되어 있습니다.\n\n\n레지스트리 추가\nPkg REPL에서 registry add 명령을 사용하여 사용자 지정 레지스트리를 추가할 수 있습니다. 일반적으로 이것은 레지스트리에 대한 URL로 수행됩니다.\n사용자 지정 레지스트리를 추가하면 General 레지스트리가 자동으로 설치되지 않을 수 있습니다. 이 경우 General 레지스트리를 수동으로 추가하기만 하면 됩니다.\npkg&gt; registry add General\n이제 General 레지스트리에 사용된 모든 패키지를 사용할 수 있습니다. registry status(혹은 registry st) 명령어를 통해 현재 설치된 레지스트리를 볼 수있습니다.\npkg&gt; registry st\nRegistry Status\n [23338594] General (https://github.com/JuliaRegistries/General.git)\n레지스트리는 항상 DEPOT_PATH의 첫 번째 항목인 사용자 저장소에 추가됩니다(용어 (Glossary) 섹션 참조).\n\n\n\n\n\n\n\n노트\n\n\n\n패키지 서버가 추가로 사용 가능한 패키지 레지스트리를 광고할 수 있습니다. Pkg가 깨끗한 Julia 저장소(예: 새로 설치한 후)와 함께, JULIA_PKG_SERVER 로 사용자 지정 패키지 서버가 설정된 상태로 실행되면, 해당 서버에서 제공하는 모든 사용 가능한 레지스트리를 자동으로 추가합니다. 저장소에 이미 일부 레지스트리(예: General)가 설치되어 있는 경우, 추가 레지스트리는 인자가 없는 registry add 명령으로 쉽게 설치할 수 있습니다.\n\n\n\n\n레지스트리 제거\n레지스트리는 registry remove(또는 registry rm) 명령으로 제거할 수 있습니다. 여기에서 General 레지스트리를 제거합니다.\npkg&gt; registry rm General\n  Removing registry `General` from ~/.julia/registries/General\n\npkg&gt; registry st\nRegistry Status\n  (no registries found)\nGeneral 이라는 이름의 레지스트리가 여러 개 설치되어 있는 경우 패키지를 조작할 때와 마찬가지로 uuid 로 구분해야 합니다.\npkg&gt; registry rm General=23338594-aafe-5451-b93e-139f81909106\n  Removing registry `General` from ~/.julia/registries/General\n\n\n\n레지스트리 업데이트\nregistry update(또는 registry up) 명령을 사용하여 레지스트리를 업데이트할 수 있습니다. 여기에서 General 레지스트리를 업데이트합니다.\npkg&gt; registry up General\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General`\n설치된 모든 레지스트리를 업데이트하려면 다음을 수행하십시오.\npkg&gt; registry up\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General`\n패키지 작업이 수행될 때 각 세션마다 한번의 레지스트리 업데이트가 자동으로 수행됩니다. 따라서 수동으로 업데이트 해야할 필요는 거의 없습니다.\n\n\n\n\n7.2 레지스트리 포맷\n레지스트리에서 각 패키지는 자체 디렉토리를 갖습니다. 해당 디렉토리에는 Compat.toml, Deps.toml, Package.toml, Versions.toml 과 같은 파일들이 포함되어 있습니다. 이러한 파일들의 형식은 아래에 설명되어 있습니다.\n\n\n레지스트리의 Compat.toml\nCompat.toml 파일은 버젼 넘버를 특정하는 일련의 블록을 포함하며, 의존성의 집합이 아래에 위치합니다. 이런 파일들의 예는 아래와 같습니다.\n[\"0.8-0.8.3\"]\nDependencyA = \"0.4-0.5\"\nDependencyB = \"0.3-0.5\"\n\n[\"0.8.2-0.8.5\"]\nDependencyC = \"0.7-0\"\n버전 범위에서 변경되지 않은 종속성은 이러한 블록으로 그룹화됩니다. 이러한 범위의 해석은 각 줄 아래에 있는 주석을 통해 설명됩니다.\n\"0.7-0.8\"  # [0.7.0, 0.9.0)\n\"0.7-0\"    # [0.7.0, 1.0.0)\n\"0.8.6-0\"  # [0.8.6, 1.0.0)\n\"0.7-*\"    # [0.7.0, ∞)\n패키지 버젼 [0.8.0, 0.8.3] 은 DependencyA 의 [0.4.0, 0.6.0) 에 의존하며 DependencyB 의 [0.3.0, 0.6.0) 에 의존합니다. 그러는 동안 [0.8.2, 0.8.5] 는 DependencyC 의 특정 버젼을 요구합니다.\n\n\n\n레지스트리 성향 (flavors)\n\n\n\n\n\n\n노트\n\n\n\n레지스트리 성향은 Julia 1.8 부터 사용할 수 있습니다.\n\n\n기본 패키지 서버(pkg.julialang.org) 는 레지스트리의 두가지 성향을 제공합니다.\n\nconservative : 대부분의 사용자에게 적합합니다. 이 성향의 모든 패키지와 아티팩트들은 패키지 서버에서 사용가능하며 다른 소스에서 다운받을 필요가 없습니다.\neager : 레지스트리는 패키지나 저장 서버가 과정을 마무리 하지 않았더라도 가장 최신 버젼의 패키지를 제공합니다. 따라서 일부 패키지나 아티팩트는 패키지 서버에 없을 수 있으며 다른 소스(예를 들자면 GitHub) 로부터 다운 받을 수 있습니다.\n\n기본 성향은 conservative 입니다. eager 성향을 선택할 별다른 사정이 없다면 대부분의 사용자들에게는 계속 conservative 성향을 유지하는 것을 추천합니다.\neager 성향을 선택하기 위해서는 다음과 같이 합니다.\nENV[\"JULIA_PKG_SERVER_REGISTRY_PREFERENCE\"] = \"eager\"\n\nimport Pkg\n\nPkg.Registry.update()\nconservative 성향을 선택하기 위해서는 다음과 같이 합니다.\nENV[\"JULIA_PKG_SERVER_REGISTRY_PREFERENCE\"] = \"conservative\"\n\nimport Pkg\n\nPkg.Registry.update()\n\n\n\n레지스트리 개설과 유지\nPkg는 레지스트리를 생성하거나 유지 관리하는 기능이 아니라 레지스트리에 대한 클라이언트 기능만 제공합니다. 그러나 Registrator.jl 및 LocalRegistry.jl 은 레지스트리를 만들고 업데이트하는 방법을 제공하고 RegistryCI.jl 은 레지스트리 유지 관리를 위한 자동화된 테스트 및 병합 기능을 제공합니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html#sec-artifacts",
    "href": "src/application_of_julia/pkg.html#sec-artifacts",
    "title": "Pkg.jl",
    "section": "8 아티팩트(Artifacts)",
    "text": "8 아티팩트(Artifacts)\nPkg는 Julia 패키지가 아닌 데이터의 컨테이너를 설치하고 관리할 수 있습니다. 이러한 컨테이너는 플랫폼 마다의 바이너리 파일, 데이터 세트, 텍스트 또는 다른 종류의 데이터(변경 불가능하고 수명 주기를 가진 데이터 저장소(immutable, life-cycled datastore) 내에 배치하기에 편리한)를 포함할 수 있습니다. 이러한 컨테이너 아티팩트(artifacts) 라고 불리며, 로컬에서 생성되고 어디에서나 호스팅되며 Julia 패키지 설치 시 자동으로 다운로드 및 압축 해제될 수 있습니다. 이 메커니즘은 BinaryBuilder.jl로 빌드된 패키지에 대한 바이너리 의존성을 제공하는 데에도 사용됩니다.\n\n\n8.1 기본적인 사용법\nPkg 아티팩트는 Artifacts.toml 파일에서 선언되며 현재 디렉터리나 패키지의 루트에 배치할 수 있습니다. 현재, Pkg는 URL로부터 압축 가능한 tar 파일 다운로드를 지원합니다. 다음은 github.com 에서 socrates.tar.gz 파일을 다운로드할 수 있는 최소한의 Artifacts.toml 파일입니다. 이 예에서는 socrates 라는 이름이 지정된 단일 아티팩트가 정의됩니다.\n# a simple Artifacts.toml file\n[socrates]\ngit-tree-sha1 = \"43563e7631a7eafae1f9f8d9d332e3de44ad7239\"\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz\"\n    sha256 = \"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58\"\n이 Artifacts.toml 파일이 현재 디렉토리에 있는 경우 socrates.tar.gz 를 다운로드하고 압축을 풀고 artifact\"socrates\"와 함께 사용할 수 있습니다. 이 tarball에는 bin 폴더와 해당 폴더 내에 socrates 라는 텍스트 파일이 포함되어 있으므로 다음과 같이 해당 파일의 내용에 액세스할 수 있습니다.\nusing Pkg.Artifacts\n\nrootpath = artifact\"socrates\"\nopen(joinpath(rootpath, \"bin\", \"socrates\")) do file\n    println(read(file, String))\nend\nURL을 통해 액세스할 수 있는 기존 tarball이 있는 경우 이 방식으로도 액세스할 수 있습니다. Artifacts.toml 을 만들려면 다운로드 파일의 sha256 해시와 압축을 푼 콘텐츠의 git-tree-sha1 이라는 두 가지 해시를 계산해야 합니다. 다음과 같이 계산할 수 있습니다.\nusing Tar, Inflate, SHA\n\nfilename = \"socrates.tar.gz\"\nprintln(\"sha256: \", bytes2hex(open(sha256, filename)))\nprintln(\"git-tree-sha1: \", Tar.tree_hash(IOBuffer(inflate_gzip(filename))))\n패키지 내에서 이 아티팩트에 접근하려면, Artifacts.toml 파일을 패키지의 루트에 배치하여 Project.toml 과 나란히 두세요. 그런 다음, Pkg 를 의존성에 추가하고, compat 섹션에서 julia = \"1.3\" 이상으로 설정해야 합니다.\n\n\n\n8.2 Artifacts.toml 파일\nPkg 는 패키지에서 아티팩트 사용을 기록하고 패키지 설치 시 아티팩트 다운로드를 자동화하기 위해 TOML 파일 형식뿐만 아니라 아티팩트 작업을 위한 API를 제공합니다. 아티팩트는 항상 콘텐츠 해시에 의해 참조될 수 있지만 일반적으로 프로젝트의 소스 트리에 있는 Artifacts.toml 파일의 콘텐츠 해시에 바인딩된 이름으로 액세스됩니다.\n\n\n\n\n\n\n노트\n\n\n\nProject.toml 와 Manifest.toml 대신 JuliaProject.toml 와 JuliaManifest.toml을 사용할 수 있는 것과 비슷하게 JuliaArtifacts.toml 을 사용할 수 있습니다.\n\n\n\nArtifacts.toml 파일의 예는 다음과 같습니다.\n# Example Artifacts.toml file\n[socrates]\ngit-tree-sha1 = \"43563e7631a7eafae1f9f8d9d332e3de44ad7239\"\nlazy = true\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz\"\n    sha256 = \"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58\"\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.bz2\"\n    sha256 = \"13fc17b97be41763b02cbb80e9d048302cec3bd3d446c2ed6e8210bddcd3ac76\"\n\n[[c_simple]]\narch = \"x86_64\"\ngit-tree-sha1 = \"4bdf4556050cb55b67b211d4e78009aaec378cbc\"\nlibc = \"musl\"\nos = \"linux\"\n\n    [[c_simple.download]]\n    sha256 = \"411d6befd49942826ea1e59041bddf7dbb72fb871bb03165bf4e164b13ab5130\"\n    url = \"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-linux-musl.tar.gz\"\n\n[[c_simple]]\narch = \"x86_64\"\ngit-tree-sha1 = \"51264dbc770cd38aeb15f93536c29dc38c727e4c\"\nos = \"macos\"\n\n    [[c_simple.download]]\n    sha256 = \"6c17d9e1dc95ba86ec7462637824afe7a25b8509cc51453f0eb86eda03ed4dc3\"\n    url = \"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-apple-darwin14.tar.gz\"\n\n[processed_output]\ngit-tree-sha1 = \"1c223e66f1a8e0fae1f9fcb9d3f2e3ce48a82200\"\n이 Artifacts.toml은 세 가지 아티팩트를 바인딩합니다. 하나는 socrates, 하나는 c_simple, 다른 하나는 processed_output 입니다. 아티팩트에 필요한 단일 정보는 git-tree-sha1 입니다. 아티팩트는 콘텐츠 해시로만 처리되기 때문에 Artifacts.toml 파일의 목적은 사람이 읽을 수 있는 이름을 콘텐츠 해시에 바인딩하고, 아티팩트를 다운로드할 수 있는 위치에 대한 정보를 제공하는 것과 같은 아티팩트에 대한 메타데이터를 제공하는 것입니다. 또는 단일 이름을 운영 체제 또는 libgfortran 버전과 같은 플랫폼별 제약 조건에 의해 키가 지정되는 여러 해시에 바인딩할 수도 있습니다.\n\n\n\n8.3 아티팩트 타입과 프로퍼티\n위의 예에서 socrates 아티팩트는 여러 다운로드 위치가 있는 플랫폼 독립적 아티팩트를 보여줍니다. socrates 아티팩트를 다운로드하고 설치할 때 URL은 성공할 때까지 순서대로 시도됩니다. socrates 아티팩트는 lazy 로 표시됩니다. 즉, 포함 패키지가 설치될 때 자동으로 다운로드되지 않고 패키지가 처음 사용하려고 할 때 주문형으로 다운로드됩니다.\nc_simple 아티팩트는 플랫폼 의존적인 아티팩트를 보여줍니다. 여기서 c_simple 배열의 각 항목에는 호출 패키지가 호스트 시스템의 특정 사항을 기반으로 적절한 다운로드를 선택하는 데 도움이 되는 키가 포함되어 있습니다. 각 아티팩트에는 각 다운로드 항목에 대한 git-tree-sha1 및 sha256 이 모두 포함되어 있습니다. 이것은 압축을 풀기 전에 다운로드한 타르볼이 안전한지 확인하고 모든 타르볼이 동일한 전체 트리 해시로 확장되도록 하기 위한 것입니다.\nprocessed_output 아티팩트에는 download 구문이 포함되어 있지 않으므로 설치할 수 없습니다. 이런 아티팩트는 이전에 실행되어 새 아티팩트를 생성하고 결과 해시를 이 프로젝트 내의 이름에 바인딩하는 코드의 결과물이 될 것입니다.\n\n\n\n8.4 아티팩트 사용\nPkg.Artifacts 네임스페이스에서 노출되는 편리한 API를 사용하여 아티팩트를 조작할 수 있습니다. 동기를 부여하는 예로 Iris 기계 학습 데이터 세트를 로드해야 하는 패키지를 작성한다고 가정해 보겠습니다. 빌드 단계에서 패키지 디렉토리로 데이터 세트를 다운로드할 수 있고 현재 많은 패키지가 이를 정확하게 수행하지만 몇 가지 중요한 단점이 있습니다.\n\n첫째, 이는 패키지 디렉토리를 수정하여, 패키지 설치를 stateful 로 만드는데 이는 우리가 피하고 싶은 것입니다. 앞으로는 패키지가 설치 후 자체적으로 수정되는 대신 완전히 읽기 전용으로 설치될 수 있는 지점에 도달하고자 합니다.\n둘째, 다운로드된 데이터는 패키지의 다른 버전 간에 공유되지 않습니다. 다양한 프로젝트에서 사용하기 위해 설치된 세 가지 다른 버전의 패키지가 있는 경우 해당 버전 간에 변경되지 않았더라도 데이터의 세 가지 다른 복사본이 필요합니다. 또한 패키지를 업그레이드하거나 다운그레이드할 때마다 영리한(아마도 안전하지 않은) 작업을 수행하지 않는 한 데이터를 다시 다운로드해야 합니다.\n\n아티팩트를 사용하면 iris 아티팩트가 디스크에 이미 존재하는지 확인하고 그렇지 않은 경우에만 다운로드하여 설치한 다음 결과를 Artifacts.toml 파일에 바인딩할 수 있습니다.\nusing Pkg.Artifacts\n\n# This is the path to the Artifacts.toml we will manipulate\nartifact_toml = joinpath(@__DIR__, \"Artifacts.toml\")\n\n# Query the `Artifacts.toml` file for the hash bound to the name \"iris\"\n# (returns `nothing` if no such binding exists)\niris_hash = artifact_hash(\"iris\", artifact_toml)\n\n# If the name was not bound, or the hash it was bound to does not exist, create it!\nif iris_hash == nothing || !artifact_exists(iris_hash)\n    # create_artifact() returns the content-hash of the artifact directory once we're finished creating it\n    iris_hash = create_artifact() do artifact_dir\n        # We create the artifact by simply downloading a few files into the new artifact directory\n        iris_url_base = \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris\"\n        download(\"$(iris_url_base)/iris.data\", joinpath(artifact_dir, \"iris.csv\"))\n        download(\"$(iris_url_base)/bezdekIris.data\", joinpath(artifact_dir, \"bezdekIris.csv\"))\n        download(\"$(iris_url_base)/iris.names\", joinpath(artifact_dir, \"iris.names\"))\n    end\n\n    # Now bind that hash within our `Artifacts.toml`.  `force = true` means that if it already exists,\n    # just overwrite with the new content-hash.  Unless the source files change, we do not expect\n    # the content hash to change, so this should not cause unnecessary version control churn.\n    bind_artifact!(artifact_toml, \"iris\", iris_hash)\nend\n\n# Get the path of the iris dataset, either newly created or previously generated.\n# this should be something like `~/.julia/artifacts/dbd04e28be047a54fbe9bf67e934be5b5e0d357a`\niris_dataset_path = artifact_path(iris_hash)\n이전에 바인딩된 아티팩트를 사용하는 특별한 사례의 경우 현재 패키지에 포함된 Artifacts.toml 파일을 자동으로 검색하고 지정된 아티팩트를 이름으로 조회하고 설치하는 약식 표기인 artifact\"name\" 이 있습니다. 아직 설치되지 않은 경우 해당 아티팩트의 경로를 반환합니다. 이 약식 표기법의 예는 다음과 같습니다.\nusing Pkg.Artifacts\n\n# For this to work, an `Artifacts.toml` file must be in the current working directory\n# (or in the root of the current package) and must define a mapping for the \"iris\"\n# artifact.  If it does not exist on-disk, it will be downloaded.\niris_dataset_path = artifact\"iris\"\n\n\n\n8.5 Pkg.Artifacts API\nArtifacts API는 해시 인식 기능, 이름 인식 기능 및 유틸리티 기능의 세 가지 수준으로 나뉩니다.\n\n해시 인식 기능은 콘텐츠 해시를 처리하며 본질적으로 다른 것은 처리하지 않습니다. 이러한 메서드를 사용하면 아티팩트가 있는지 여부, 경로가 무엇인지 쿼리하고 아티팩트가 디스크의 콘텐츠 해시를 충족하는지 확인하는 등의 작업을 수행할 수 있습니다. 해시 인식 기능에는 다음이 포함됩니다 : artifact_exists(), artifact_path(), remove_artifact(), verify_artifact() 및 archive_artifact(). 일반적으로 remove_artifact() 를 사용하지 말고 대신 Pkg.gc() 를 사용하여 아티팩트 설치를 정리해야 합니다.\n이름 인식 기능은 Artifacts.toml 파일 내에서 바인딩된 이름을 처리하므로 일반적으로 Artifacts.toml 파일에 대한 경로와 아티팩트 이름이 모두 필요합니다. 이름 인식 기능에는 다음이 포함됩니다 : artifact_meta(), artifact_hash(), bind_artifact!(), unbind_artifact!(), download_artifact() and ensure_artifact_installed().\n유틸리티 함수는 create_artifact(), ensure_all_artifacts_installed(), 심지어 @artifact_str 문자열 매크로와 같은 아티팩트 수명의 여러가지 측면을 처리합니다.\n\ndocstring 및 메서드의 전체 목록은 Artifacts API 레퍼런스 섹션을 참조하세요.\n\n\n\n8.6 아티팩트 위치 오버라이딩\n경우에 따라 아티팩트의 위치와 콘텐츠를 재정의할 수 있어야 합니다. 일반적인 사용 사례는 패키지가 게시된 이 의존성의 버전에 관계없이 특정 버전의 이진 의존성을 사용해야 하는 컴퓨팅 환경입니다. 일반적인 Julia 구성이 일반 라이브러리를 다운로드하고 압축을 풀고 연결하는 동안 시스템 관리자는 이를 비활성화하고 대신 로컬 시스템에 이미 설치된 라이브러리를 사용할 수 있습니다. 이를 활성화하기 위해 Pkg 는 아티팩트 저장소 디렉터리(예: 기본 사용자 저장소의 경우 ~/.julia/artifacts/Overrides.toml)에 있는 저장소별 Overrides.toml 파일을 지원합니다. 해시 또는 패키지 UUID 및 바인딩된 아티팩트 이름으로. 또한 대상 위치는 절대 경로이거나 대체 아티팩트 콘텐츠 해시일 수 있습니다. 이를 통해 시스템 관리자는 새 아티팩트를 사용하도록 다른 패키지를 재정의하여 사용할 수 있는 자체 아티팩트를 생성할 수 있습니다.\n# Override single hash to absolute path\n78f35e74ff113f02274ce60dab6e92b4546ef806 = \"/path/to/replacement\"\n\n# Override single hash to new artifact content-hash\n683942669b4639019be7631caa28c38f3e1924fe = \"d826e316b6c0d29d9ad0875af6ca63bf67ed38c3\"\n\n# Override package bindings by specifying the package UUID and bound artifact name\n# For demonstration purposes we assume this package is called `Foo`\n[d57dbccd-ca19-4d82-b9b8-9d660942965b]\nlibfoo = \"/path/to/libfoo\"\nlibbar = \"683942669b4639019be7631caa28c38f3e1924fe\"\nPkg 저장소의 계층적 특성으로 인해 여러 Overrides.toml 파일이 한 번에 적용될 수 있습니다. 이렇게 하면 “내부” Overrides.toml 파일이 “외부” Overrides.toml 파일 내에 배치된 재정의를 재정의할 수 있습니다. 재정의를 제거하고 아티팩트에 대한 기본 위치 논리를 다시 활성화하려면 빈 문자열에 대한 항목 매핑을 삽입합니다.\n78f35e74ff113f02274ce60dab6e92b4546ef806 = \"/path/to/new/replacement\"\n683942669b4639019be7631caa28c38f3e1924fe = \"\"\n\n[d57dbccd-ca19-4d82-b9b8-9d660942965b]\nlibfoo = \"\"\n위에 주어진 두 개의 Overrides.toml 스니펫이 서로 위에 겹쳐 있는 경우 최종 결과는 콘텐츠 해시 78f35e74ff113f02274ce60dab6e92b4546ef806 을 \"/path/to/new/replacement\" 에 매핑하고 Foo.libbar 를 콘텐츠 해시 683942669b4639019be7631caa28c38f3e1924fe 에 의해 식별된 아티팩트에 매핑합니다. 해당 해시는 이전에 재정의되었지만 더 이상 재정의되지 않으므로 Foo.libbar 는 ~/.julia/artifacts/683942669b4639019be7631caa28c38f3e1924fe 와 같은 위치를 직접 확인합니다.\n재정의의 영향을 받는 대부분의 메서드는 honor_overrides=false 를 키워드 인수로 설정하여 재정의를 무시할 수 있습니다. UUID/이름 기반의 오버라이드가 작동하려면 Artifacts.toml 파일을 로드하는 패키지의 UUID 를 알고 로드해야 합니다. 이것은 artifacts\"\" 문자열 매크로에 의해 자동으로 추론되지만 어떤 이유로 패키지 내에서 Pkg.Artifacts API를 수동으로 사용하고 재정의를 적용하려는 경우에는 artifact_meta() 및 pkg_uuid 키워드 인자를 통한 ensure_artifact_installed() 와 같은 API 호출에 패키지 UUID 가 필요합니다.\n\n\n\n8.7 플랫폼 선택 확장\n\n\n\n\n\n\n노트\n\n\n\nPkg의 확장된 플랫폼 선택에는 최소한 Julia 1.7이 필요하며 실험적인 것으로 간주됩니다.\n\n\n\nJulia 1.6의 새로운 기능인 Platform 개체는 확장된 특성을 적용할 수 있으므로 아티팩트에 CUDA 드라이버 버전 호환성, 마이크로아키텍처 호환성, Julia 버전 호환성 등과 같은 태그를 지정할 수 있습니다! 이 기능은 실험적인 것으로 간주되며 향후 변경될 수 있습니다. 패키지 개발자로서 이 기능이 필요한 경우 전체 생태계의 이익을 위해 발전할 수 있도록 우리에게 문의하십시오. Pkg.add() 시간에 아티팩트 선택을 지원하기 위해 Pkg 는 특별하게 이름지어진 파일 &lt;project_root&gt;/.pkg/select_artifacts.jl 을 실행하여 현재 플랫폼 트리플릿을 첫 번째 인수로 전달합니다. 이 아티팩트 선택 스크립트는 지정된 플랫폼에 따라 이 패키지에 필요한 아티팩트를 나타내는 TOML 직렬화된 사전을 출력하고 지정된 플랫폼에서 플랫폼 트리플릿을 명시적으로 제공하지 않는 경우 플랫폼 기능을 자동 감지하는 데 필요한 시스템 검사를 수행해야 합니다. 사전의 형식은 Artifacts.select_downloadable_artifacts() 에서 반환된 형식과 일치해야 하며 실제로 대부분의 패키지는 확장된 Platform 객체로 해당 함수를 호출해야 합니다. 아티팩트 선택 후크 정의의 예는 다음과 같을 수 있으며 두 파일로 분할됩니다.\n# .pkg/platform_augmentation.jl\nusing Libdl, Base.BinaryPlatforms\nfunction augment_platform!(p::Platform)\n    # If this platform object already has a `cuda` tag set, don't augment\n    if haskey(p, \"cuda\")\n        return p\n    end\n\n    # Open libcuda explicitly, so it gets `dlclose()`'ed after we're done\n    dlopen(\"libcuda\") do lib\n        # find symbol to ask for driver version; if we can't find it, just silently continue\n        cuDriverGetVersion = dlsym(lib, \"cuDriverGetVersion\"; throw_error=false)\n        if cuDriverGetVersion !== nothing\n            # Interrogate CUDA driver for driver version:\n            driverVersion = Ref{Cint}()\n            ccall(cuDriverGetVersion, UInt32, (Ptr{Cint},), driverVersion)\n\n            # Store only the major version\n            p[\"cuda\"] = div(driverVersion, 1000)\n        end\n    end\n\n    # Return possibly-altered `Platform` object\n    return p\nend\nusing TOML, Artifacts, Base.BinaryPlatforms\ninclude(\"./platform_augmentation.jl\")\nartifacts_toml = joinpath(dirname(@__DIR__), \"Artifacts.toml\")\n\n# Get \"target triplet\" from ARGS, if given (defaulting to the host triplet otherwise)\ntarget_triplet = get(ARGS, 1, Base.BinaryPlatforms.host_triplet())\n\n# Augment this platform object with any special tags we require\nplatform = augment_platform!(HostPlatform(parse(Platform, target_triplet)))\n\n# Select all downloadable artifacts that match that platform\nartifacts = select_downloadable_artifacts(artifacts_toml; platform)\n\n# Output the result to `stdout` as a TOML dictionary\nTOML.print(stdout, artifacts)\n이 후크 정의에서 우리의 플랫폼 보강 루틴은 시스템 라이브러리(libcuda)를 열고 CUDA 드라이버 버전을 제공하는 기호를 검색한 다음 해당 버전 번호의 주 버전을 우리가 보강하는 Platform 개체의 cuda 속성에 포함합니다. 이 코드가 실제로 로드된 라이브러리를 닫으려고 시도하는 것은 중요하지 않지만(패키지 작업이 완료된 직후 CUDA 패키지에 의해 다시 열릴 가능성이 높으므로) 후크를 가능한 한 가볍고 투명하게 만드는 것이 가장 좋은데 이는 향후 다른 Pkg 유틸리티에서 사용할 수 있기 때문입니다. 자체 패키지에서 다음과 같이 @artifact_str 매크로를 사용할 때 확장된 플랫폼 개체도 사용해야 합니다.\ninclude(\"../.pkg/platform_augmentation.jl\")\n\nfunction __init__()\n    p = augment_platform!(HostPlatform())\n    global my_artifact_dir = @artifact_str(\"MyArtifact\", p)\nend\n이렇게 하면 Pkg가 설치를 시도할 때 동일한 아티팩트가 코드에서 사용됩니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html#sec-glossary",
    "href": "src/application_of_julia/pkg.html#sec-glossary",
    "title": "Pkg.jl",
    "section": "9 용어 (Glossary)",
    "text": "9 용어 (Glossary)\n프로젝트(Project) : 표준 레이아웃이 있는 소스 트리로 다음을 포함합니다 : 1) Julia 코드의 본문을 위한 src 디렉토리, 2) 프로젝트 테스트를 위한 test 디렉토리, 3) 문서 파일을 위한 docs 디렉토리, 4) 빌드 스크립트 및 해당 출력을 위한 deps 디렉토리(선택적). 프로젝트에는 일반적으로 project 파일도 있으며 선택적으로 manifest 파일이 있을 수 있습니다.\n\nProject 파일 : 프로젝트 루트 디렉터리에 있는 Project.toml(또는 JuliaProject.toml)이라는 이름의 파일로 프로젝트 이름, UUID(패키지용), 작성자, 라이선스, 의존하는 패키지와 라이브러리의 이름 및 UUID를 포함하여 프로젝트에 대한 메타데이터를 설명합니다.\nManifest 파일 : 프로젝트의 루트 디렉터리에 있는 Manifest.toml(또는 JuliaManifest.toml)이라는 이름의 파일로, 전체 의존성 그래프와 프로젝트에서 사용하는 각 패키지 및 라이브러리의 정확한 버전을 설명합니다.\n\n패키지(Package): import X 또는 using X를 사용하여 다른 Julia 프로젝트에서 사용할 수 있는 재사용 가능한 기능을 제공하는 프로젝트입니다. 패키지에는 패키지 UUID를 제공하는 uuid 항목이 있는 프로젝트 파일이 있어야 합니다. 이 UUID는 의존하는 프로젝트에서 패키지를 식별하는 데 사용됩니다.\n\n\n\n\n\n\n\n노트\n\n\n\n하위호환성을 위해 REPL 또는 스크립트의 최상위 수준에서 프로젝트 파일이나 UUID 없이 패키지를 로드할 수 있습니다. 그러나 프로젝트 파일이나 UUID가 없는 패키지는 프로젝트에서 로드할 수 없습니다. 프로젝트 파일에서 로드하면 프로젝트 파일과 UUID가 모두 필요합니다.\n\n\n\n응용프로그램(Application) : 다른 Julia 프로젝트에서 재사용할 의도가 없는 독립 실행 기능을 제공하는 프로젝트입니다. 예를 들어 웹 애플리케이션이나 커맨드라인 유틸리티 또는 과학 논문과 함께 제공되는 시뮬레이션/분석 코드가 있습니다. 응용프로그램에 UUID가 있을 수 있지만 필요하지는 않습니다. 응용 프로그램은 의존하는 패키지에 대한 전역 구성 옵션을 제공할 수도 있습니다. 반면에 패키지는 기본 응용 프로그램의 구성과 충돌할 수 있으므로 전역 구성을 제공하지 않을 수 있습니다.\n\n\n\n\n\n\n\n노트\n\n\n\n프로젝트 vs. 패키지 vs. 응용프로그램\n\n프로젝트는 포괄적인 용어입니다 : 패키지와 응용프로그램은 일종의 프로젝트입니다.\n패키지에는 UUID가 있어야 하며 응용프로그램에는 UUID가 있을 수 있지만 필요하지는 않습니다.\n응용프로그램은 글로벌 설정을 제공할 수 있지만 패키지는 제공할 수 없습니다.\n\n\n\n\n환경(Environment) : 다음 세가지의 조합입니다 - 1) 프로젝트 파일에서 제공하는 최상위 이름 맵 2) 의존성 그래프 3) 매니페스트 파일에서 제공하는 패키지에서 진입점까지의 맵. 자세한 내용은 매뉴얼의 코드 로딩 에 대한 섹션을 참조하십시오.\n\n명시적 환경 (Explicit environment) : 명시적인 프로젝트 파일 형식으로 된 환경(environment)과 선택사항인 해당 매니페스트 파일이 디렉터리에 함께 있습니다. 매니페스트 파일이 없으면 암시적 의존성 그래프와 위치 맵이 비어 있습니다.\n암시적 환경 (Implicit environment) : X.jl, X.jl/src/X.jl 또는 X/src/X.jl 형식의 진입지점이 있는 패키지를 포함하는 디렉토리(프로젝트 파일 또는 매니페스트 파일 없음)로 제공되는 환경입니다. 최상위 이름 맵은 이러한 진입점에 의해 암시됩니다. 의존성 그래프는 패키지 디렉토리 내부에 X.jl/Project.toml 또는 X/Project.toml 와 같은 프로젝트 파일의 존재로부터 암시됩니다. . X 패키지의 의존성은 해당 프로젝트 파일(있는 경우)의 의존성입니다. 위치 맵은 진입점 자체에 의해 암시됩니다.\n\n\n레지스트리(Registry) : 표준 레이아웃이 존재하는 메타데이터를 기록하는 소스트리 입니다. 이 메타데이터의 내용은 1) 등록된 패키지 집합, 2) 패키지들이 사용 가능한지, 어떤 버젼에서 서로 호환되거나 되지 않는지에 대한 태그된 버젼 입니다. 레지스트리는 패키지 이름과 UUID로 인덱싱되며 아래의 메타데이터를 제공하는 등록된 각 패키지에 대한 디렉토리가 있습니다.\n\nname - 예를 들면 DataFrames\nUUID - 예를 들면 a93c6f00-e57d-5684-b7b6-d8193f3e46c0\nrepository - 예를 들면 https://github.com/JuliaData/DataFrames.jl.git\nversions - 모든 등록된 버젼 태그들의 목록\n\n각각의 등록된 패키지 버젼들에 대해 아래의 정보가 제공됩니다\n\nsemantic version name - 예를 들면 v1.2.3\ngit tree SHA-1 hash - 예를 들면 7ffb18ea3245ef98e368b02b81e8a86543a11103\n이름부터 의존성의 UUID 에 대한 맵\n호환가능하거나 호환 불가능한 다른 패키지의 버젼들\n\n의존성과 호환성은 압축되었지만 사람이 읽을 수 있는 패키지 버젼의 범위를 사용하는 형식으로 저장됩니다.\n\n저장소 (Depot) : 다양한 패키지 관련 리소스들이 위치하는 시스템상의 디렉토리로 다음을 포함합니다.\n\nenvironment : 공유되는 이름이 붙여진 환경 (예를 들면 v1.0 devtools)\nclones : 패키지 저장소에 있는 그대로의 복제본\ncompiled : 컴파일되어 캐쉬된 패키지 이미지 (.jl 파일들)\nconfig : 전역적인 설정 파일들 (예를 들면 startup.jl)\ndev : 패키지 개발의 기본 디렉토리\nlogs : 로그 파일들 (예를 들면 manifest_usage.toml, repl_history.jl)\npackages : 설치된 패키지 버젼\nregistries : 레지스트리의 복제본 (예를 들면 General)\n\n로드 경로 (Load path) : 패키지 ID 와 의존성 및 진입점이 검색되는 환경의 스택입니다. 로드 경로는 JULIA_LOAD_PATH 환경 변수의 값을 기반으로 시작할 때 채워지는 LOAD_PATH 전역 변수에 의해 Julia에서 제어됩니다. 첫 번째 항목은 주로 현재 프로젝트인 기본 환경이며, 이후 항목은 REPL 또는 최상위 스크립트에서 사용할 수 있는 추가 패키지를 제공합니다.\n저장소 경로 (Depot path) : 패키지 관리자와 Julia 의 코드 로딩 메커니즘이 레지스트리, 설치된 패키지, 명명된 환경, repo 클론, 캐시된 컴파일된 패키지 이미지 및 구성 파일을 찾는 저장소 위치의 스택입니다. 저장소 경로는 JULIA_DEPOT_PATH 환경 변수의 값을 기반으로 시작 시 채워지는 Julia DEPOT_PATH 전역 변수에 의해 제어됩니다. 첫 번째 항목은 “사용자 저장소”이며 현재 사용자가 쓰기 가능하고 소유해야 합니다. 사용자 저장소는 레지스트리 복제, 새 패키지 버전 설치, 명명된 환경 생성 및 업데이트, 패키지 저장소 복제, 새로 컴파일된 패키지 이미지 파일 저장, 로그 파일 작성, 기본적으로 개발 패키지 체크아웃 및 전역 구성 데이터가 저장됩니다. 저장소 경로의 이후 항목은 읽기 전용으로 처리되며 시스템 관리자가 설치하고 관리하는 레지스트리, 패키지 등에 적합합니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html#sec-project_toml_manifest_toml",
    "href": "src/application_of_julia/pkg.html#sec-project_toml_manifest_toml",
    "title": "Pkg.jl",
    "section": "10 Project.toml 과 Manifest.toml",
    "text": "10 Project.toml 과 Manifest.toml\nPkg의 핵심인 두 파일은 Project.toml 과 Manifest.toml 입니다. Project.toml 및 Manifest.toml 은 TOML(따라서 .toml 확장자)로 작성되며 의존성, 버전, 패키지 이름, UUID 등에 대한 정보를 포함합니다.\n\n\n\n\n\n\n노트\n\n\n\nProject.toml 및 Manifest.toml 파일은 패키지 관리자만 사용하는 것이 아닙니다. 그들은 또한 Julia의 코드 로딩에 의해 사용되며 예를 들자면 using Example 이 무슨 일을 해야하는지를 결정합니다. 자세한 내용은 Julia 설명서의 Code Loading 섹션을 참조하십시오.\n\n\n\n\n10.1 Project.toml\n프로젝트 파일은 상위 수준에서 프로젝트를 설명합니다. 예를 들어 패키지/프로젝트 의존성 및 호환성 제약 조건이 프로젝트 파일에 나열됩니다. 파일 항목은 아래에 설명되어 있습니다.\n\n\nauthors 필드\n패키지의 경우 선택적인 authors 필드는 NAME &lt;EMAIL&gt; 형식으로 패키지 작성자를 설명하는 문자열 목록입니다. 예를 들어:\nauthors = [\"Some One &lt;someone@email.com&gt;\",\n           \"Foo Bar &lt;foo@bar.com&gt;\"]\n\n\n\nname 필드\n패키지/프로젝트의 이름은 name 필드에 의해 결정됩니다:\nname = \"Example\"\n이름은 유효한 식별자(identifier) (숫자로 시작하지 않고 true도 false 도 아닌 일련의 유니코드 문자)여야 합니다. 패키지의 경우 패키지 작명 가이드를 따르는 것이 좋습니다. name 필드는 패키지의 필수 항목입니다.\n\n\n\nuuid 필드\nuuid 는 패키지/프로젝트에 대한 범용 고유 식별자 입니다. 예를 들어,\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nuuid 필드는 패키지의 대해 필수 항목입니다.\n\n\n\n\n\n\n노트\n\n\n\n임의의 UUIDs 를 생성하는데 UUIDs.uuid4() 를 사용하는 것을 추천합니다.\n\n\n\n\n\nversion 필드\nversion 은 패키지/프로젝트의 버전 번호가 포함된 문자열입니다. 주 버전, 부 버전 및 패치 번호의 3개 숫자로 구성되어야 하며 . 로 구분됩니다. 예를 들면 다음과 같습니다.\nversion = \"1.2.5\"\nJulia는 Semantic Versioning(SemVer)를 사용하며 version 필드는 SemVer를 따라야 합니다. 기본 규칙은 다음과 같습니다.\n\n1.0.0 이전에는 모든 것이 가능하지만 주요 변경 사항을 만들면 부 버전이 증가해야 합니다.\n1.0.0 이후에는 주 버전을 올릴 때만 주요 변경 사항을 만듭니다.\n1.0.0 이후에는 마이너 버전을 올리지 않고 새로운 공개 API를 추가할 수 없습니다. 여기에는 특히 Base 또는 기타 패키지의 새로운 유형, 함수, 메서드 및 메서드 오버로드가 포함됩니다.\n\n호환성 세션을 참고하세요.\nPkg.jl은 1.0.0 이전 버전의 경우 SemVer 사양과 다릅니다. 자세한 내용은 1.0 이전 동작 섹션을 참조하십시오.\n\n\n\n[deps] 섹션\n패키지/프로젝트의 모든 의존성은 [deps] 섹션에 열거됩니다. 각각의 의존성들은 name-uuid 쌍으로 열거됩니다. 예를 듦면 :\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n보통은 [deps] 섹션에 수동으로 추가할 필요가 없습니다; 대신에 add 같은 Pkg 연산으로 다루어집니다.\n\n\n\n[sources] 섹션\n종속성에 대한 경로 또는 저장소(+ 브랜치)를 지정하는 것은 [sources] 섹션에서 이루어집니다. 이는 해당하는 매니페스트 파일을 번들로 포함하지 않고도 등록되지 않은 종속성을 제어하는 데 특히 유용합니다.\n[sources]\nExample = {url = \"https://github.com/JuliaLang/Example.jl\", rev = \"custom_branch\"}\nSomeDependency = {path = \"deps/SomeDependency.jl\"}\n이 정보는 이 환경이 활성화되어 있을 때만 사용된다는 점에 유의하세요. 즉, 이 프로젝트가 종속성으로 사용되는 패키지인 경우에는 사용되지 않습니다.\n\n\n\n[compat] 섹션\n[deps] 에 열거된 의존성에 대한 호환성의 제약들은 [compat] 섹션에 열거됩니다. 예를 들면\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\n[compat]\nExample = \"1.2\"\n호환성 섹션에 서로 다른 다양한 호환성 제약들이 자세히 설명하였습니다. 비록 julia 는 [deps] 섹션에 의존성이 열거되지 않더라도, julia 자체에 대한 제약들을 열거할수도 있습니다. :\n[compat]\njulia = \"1.1\"\n\n\n\n\n10.2 Manifest.toml\nManifest 파일은 환경 내의 패키지 상태에 대한 절대적인 기록입니다. 여기에는 프로젝트의 (직접 및 간접) 의존성에 대한 정확한 정보가 포함됩니다. Project.toml + Manifest.toml 쌍이 주어지면 정확히 동일한 패키지 환경을 인스턴스화할 수 있으며 이는 재현성에 매우 유용합니다. 자세한 내용은 Pkg.instantiate를 참조하세요.\n\n\n\n\n\n\n노트\n\n\n\nManifest.toml 파일은 Pkg에서 생성되고 및 유지되며, 일반적으로 이 파일은 수동으로 수정하면 안 됩니다.\n\n\n\n\n서로 다른 Julia 버젼에서의 다른 Manifetsts 들\nJulia v1.11부터는 매니페스트 파일을 Manifest-v{major}.{minor}.toml 형식으로 이름을 지정할 수 있는 옵션이 제공됩니다. Julia는 해당 파일이 있을 경우 버전별 매니페스트 파일을 우선적으로 사용합니다. 예를 들어, Manifest-v1.11.toml과 Manifest.toml 이 모두 존재할 경우, Julia 1.11 은 Manifest-v1.11.toml 을 우선적으로 사용합니다. 그러나 Julia 1.10, 1.12 및 다른 모든 버전은 기본적으로 Manifest.toml 을 사용합니다. 이 기능은 다양한 Julia 버전용으로 종속성의 서로 다른 인스턴스화된 버전들을 더 쉽게 관리할 수 있도록 해줍니다. 단, Project.toml 파일은 하나만 있을 수 있습니다. Manifest-v{major}.{minor}.toml 파일은 Pkg에 의해 자동으로 생성되지 않지만, 사용자가 매니페스트 파일의 이름을 수동으로 버전화된 형식에 맞게 변경하면, 이후 Pkg가 이를 관리하며 작업을 진행합니다.\n\n\n\nManifest.toml 항목들\n메니페스트의 최상위 레벨의 세 항복은 다음과 같이 보입니다.\njulia_version = \"1.8.2\"\nmanifest_format = \"2.0\"\nproject_hash = \"4d9d5b552a1236d3c1171abf88d59da3aaac328a\"\n메니페스트가 만들어졌을 때의 Julia 버젼과 메니페스트의 포맷, 그리고 프로젝트 파일의 해쉬 입니다. 이를 통해 매니페스트가 프로젝트 파일에 비해 오래된 상태인지 확인할 수 있습니다.\n각각의 의존성은 manifest 파일에 자체 섹션이 있으며 해당 내용은 의존성이 환경에 추가된 방식에 따라 다릅니다. 모든 의존성 섹션에는 다음 항목의 조합이 포함됩니다.\n\nuuid : 의존성의 UUID. 예를 들면 uuid = \"7876af07-990d-54b4-ab0e-23690620f79a\".\ndeps: 의존성의 의존성에 관한 일련으 목록. 예를 들면 deps = [\"Example\", \"JSON\"].\nversion: 버젼 넘버. 예를 들면 version = \"1.2.6\".\npath: 소스 코드 파일 경로. 예를 들면 path = /home/user/Example.\nrepo-url: 소스코드가 발견된 저장소 URL. 예를 들면 repo-url = \"https://github.com/JuliaLang/Example.jl.git\".\nrepo-rev: a git revision. 예를 드면 repo-rev = \"master\" or a commit repo-rev = \"66607a62a83cb07ab18c0b35c038fcd62987c9b1\".\ngit-tree-sha1 : a content hash of the source tree. 예를 들면 git-tree-sha1 = \"ca3820cc4e66f473467d912c4b2b3ae5dc968444\" .\n\n\n\n\n추가된 패키지\n예를 들어 pkg&gt; add Example 와 같이 페키지 레지스트리로부터 패키지가 추가되거나 plg&gt; add Example@1.2 와 같이 특정 버젼이 추가될 때, Manifest.toml 은 다음과 비슷합니다 :\n[[Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.3\"\n특히 이 패키지가 발견된 레지스트리에 해당 정보가 포함되어 있으므로 repo-url 이 존재하지 않는다는 점에 유의하십시오.\n\n\n\n브랜치로 추가된 패키지\n예를 들어 pkg&gt; Example#master 나 pkg&gt; add https://github.com/JuliaLang/Example.jl.git 와 같이 패키지의 특정 브랜치를 지정하여 를 추가할 때 의존성 섹션은 다음과 같습니다.\n[[Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\nrepo-rev = \"master\"\nrepo-url = \"https://github.com/JuliaLang/Example.jl.git\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"\n우리가 추적하는 브랜치 (master) 와 원격 저장소 ulr (\"https://github.com/JuliaLang/Example.jl.git\") 모두 manifest 에 저장되는것을 알 수 있습니다.\n\n\n\n커밋(commit) 을 통해 추가된 패키지\npkg&gt; add Example#cf6ba6cc0be0bb5f56840188563579d67048be34 와 같이 커밋에 의해 지정되어 패키지를 추적할 때의 의존성 섹션은 다음과 같습니다.\n[[Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\nrepo-rev = \"cf6ba6cc0be0bb5f56840188563579d67048be34\"\nrepo-url = \"https://github.com/JuliaLang/Example.jl.git\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"\n브랜치를 추적할 때와의 유일한한 차이점은 repo-rev 내용입니다.\n\n\n\n개발된 패키지\npkg&gt; develop Example 이나 pkg&gt; develop /path/to/local/folder/Example 처럼 develop 를 통해 패키지를 추가하면 의존성 섹션은 다음과 같습니다.\n[[Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\npath = \"/home/user/.julia/dev/Example/\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"\n소스코드 경로가 포함되며 소스 트리에의 변화가 직접적으로 반영되는것에 주의하십시요.\n\n\n\n고정된 패키지\n고정된 패키지(pinned packages) 역시 manifest 파일에 기록됩니다; pkg&gt; add Example; pin Example 에 의한 의존성 섹션은 다음과 같습니다.\n[[Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\npinned = true\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"\n유일한 차이는 pinned = true 항목이 추가된 것입니다.\n\n\n\n같은 이름을 가진 복수의 패키지\nJulia는 UUID를 기반으로 패키지를 구분하므로 이름만으로는 패키지를 식별하기에 충분하지 않습니다. 동일한 환경에 이름은 같지만 UUID가 다른 여러 패키지가 있을 수 있습니다. 이러한 상황에서 Manifest.toml 파일은 약간 다르게 보입니다. 예를 들어 환경에 A와 B를 추가하고 Project.toml 파일이 다음과 같이 표시되는 상황을 고려하십시오.\n[deps]\nA = \"ead4f63c-334e-11e9-00e6-e7f0a5f21b60\"\nB = \"edca9bc6-334e-11e9-3554-9595dbb4349c\"\nA가 이제 B = \"f41f7b98-334e-11e9-1257-49272045fb24\"에 의존하는 경우, 즉 B 라는 이름을 가진 또 다른 패키지가 있을 경우, Manifest.toml 파일에 두 개의 다른 B 패키지가 있습니다. 이 경우 명확성을 위해 git-tree-sha1 및 version 필드가 제거된 전체 Manifest.toml 파일은 다음과 같습니다.\n[[A]]\nuuid = \"ead4f63c-334e-11e9-00e6-e7f0a5f21b60\"\n\n    [A.deps]\n    B = \"f41f7b98-334e-11e9-1257-49272045fb24\"\n\n[[B]]\nuuid = \"f41f7b98-334e-11e9-1257-49272045fb24\"\n[[B]]\nuuid = \"edca9bc6-334e-11e9-3554-9595dbb4349c\"\n이제 두 개의 B 패키지 배열이 있으며 A의 [deps] 섹션은 A가 의존하는 B 패키지에 대해 명시적으로 확장되었습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html#sec-repl_mode_reference",
    "href": "src/application_of_julia/pkg.html#sec-repl_mode_reference",
    "title": "Pkg.jl",
    "section": "11 REPL 모드 레퍼런스",
    "text": "11 REPL 모드 레퍼런스\n영문 원문 참고",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/application_of_julia/pkg.html#sec-api_reference",
    "href": "src/application_of_julia/pkg.html#sec-api_reference",
    "title": "Pkg.jl",
    "section": "12 API 레퍼런스",
    "text": "12 API 레퍼런스\n영문 원문 참고",
    "crumbs": [
      "Julia 언어의 활용",
      "Pkg.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/dataframes.html",
    "href": "src/ecosystem_of_julia/dataframes.html",
    "title": "DataFrames.jl",
    "section": "",
    "text": "DataFrames.jl 은 2차원 데이터 테이블을 다루는 DataFrame 타입을 지원한다. DataFrame 타입은 파이썬의 pandas 의 DataFrame 이나 R 의 DataFrame 과 같이 테이블 형태의 데이터를 표현하는 데이터 구조이다. 엑셀 sheet 의 각 열과 행을 프로그래밍으로 다루기 위한 데이터 구조라고 생각할 수 있다.",
    "crumbs": [
      "Julia 언어 생태계",
      "DataFrames.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/dataframes.html#설치",
    "href": "src/ecosystem_of_julia/dataframes.html#설치",
    "title": "DataFrames.jl",
    "section": "1 설치",
    "text": "1 설치\n다른 julia 패키지와 마찬가지로 REPL 이나 jupyter 에서\nusing Pkg\nPkg.add(\"DataFrames\")\n를 통해 설치 할 수 있다. 물론 REPL 에서 ] 를 통해 패키지 모드로 진입한 후\n(@v1.10) pkg&gt; add DataFrames\n로 설치할 수도 있다.",
    "crumbs": [
      "Julia 언어 생태계",
      "DataFrames.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/dataframes.html#dataframe",
    "href": "src/ecosystem_of_julia/dataframes.html#dataframe",
    "title": "DataFrames.jl",
    "section": "2 DataFrame",
    "text": "2 DataFrame\n\n시작하기\nDataFrame 타입 인스턴스는 다음과 같이 만들 수 있다.\nIn [1]: using DataFrames\n\nIn [2]: df=DataFrame(a=1:3, b=[\"A\", \"B\", \"C\"])\nOut[2]: 3×2 DataFrame\n Row │ a      b\n     │ Int64  String\n─────┼───────────────\n   1 │     1  A\n   2 │     2  B\n   3 │     3  C\n출력은 REPL 의 모습이며 jupyter 에서는 약간 다르다. DataFrames 는 모듈 이름이며 타입 이름은 마지막 s 가 빠진 DataFrame 이다. df 은 \"a\" 와 \"b\" 의 두 칼럼으로 구성되었으며 각 칼럼은 같은 수의 성분을 갖는 1차원 배열이다. names() 함수를 통해 칼렴 이름(여기서는 “a”, “b”) 를 얻을 수 있다. 칼럼에 대해 접근할 때는 df.a, df.\"a\", df[!, :a], df[!, \"a\"] 와 같이 접근 할 수 있다. 칼럼의 이름은 names(df) 와 propertynames(df) 함수로 얻을 수 있다. names()는 칼럼의 이름을 문자열로 반환하며, propertynames() 는 Symbol 로 반환한다.\nIn [3]: df.a[1]\nOut[3]: 1\n\nIn [4]: df.\"a\"[2]\nOut[4]: 2\n\nIn [5]: df[!, :b][1]\nOut[5]: \"A\"\n\nIn [6]: df[:, \"b\"][2]\nOut[6]: \"B\"\n\nIn [7]: names(df)\nOut[7]: 2-element Vector{String}:\n \"a\"\n \"b\"\n\nIn [8]: propertynames(df)\nOut[8]: 2-element Vector{Symbol}:\n :a\n :b\n\nIn [9]: size(df)\nOut[9]: (3, 2)\n\nIn [10]: size(df, 1)\nOut[10]: 3\nIn [9] 와 In [10] 은 df 의 크기를 알아내는 함수 size() 를 사용하였다. DataFrame 객체만을 전달할 경우 열수와 칼럼수를 반환하며, 두번째 인자로 칼럼 인덱스를 전달할 경우 그 칼럼의 데이터 갯수를 반환한다.\n\n\n\n비어있는 DataFrame 으로부터 시작하기\n비어있는 데이터 프레임으로부터 아래와 같이 시작 할 수 있다.\ndf = DataFrame()\ndf.t = 0:0.1:10\ndf.N = exp.(-df.t./0.3) .+ 0.3\ndf.err = sqrt.(df.N)\nnames(df) 로 확인해보면 t, N, err 라는 세개의 칼럼을 확인 할 수 있다. DataFrame 은 mutable 이므로 각각의 칼럼을 수정 할 수 있다.\ndf.N = exp.(-df.t./0.56) .+ 0.13\n\n\n\n칼럼 별로 다루기",
    "crumbs": [
      "Julia 언어 생태계",
      "DataFrames.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/leastsquarefit.html",
    "href": "src/ecosystem_of_julia/leastsquarefit.html",
    "title": "비선형 최소제곱 피팅",
    "section": "",
    "text": "어떤 실험 결과가 \\(m\\) 개의 독립 변수에 대해 \\(n\\) 차원 벡터로 발생한다고 하자. 이에 대해 모델 함수 \\(\\boldsymbol{F}:\\mathbb{R}^m \\to \\mathbb{R}^n\\)"
  },
  {
    "objectID": "src/ecosystem_of_julia/pkg_dev.html",
    "href": "src/ecosystem_of_julia/pkg_dev.html",
    "title": "패키지 개발",
    "section": "",
    "text": "우리는 이미 Pkg.jl 을 통해 패키지를 설치, 제거하거나 업데이트 하는 것을 알고 있습니다. Pkg.jl 은 이것 뿐만 아니라 패키지 개발에 필요한 환경(environment) 를 설정하고 제어 할 수 있도록 해 줍니다. 여기서는 당신이 어떤 julia 패키지를 개발하며 그것을 github 에 올려놓고 관리한다는 것을 가정합니다. github 사용법을 자세히 다루지 않으며, 당신이 이미 github 계정을 가지고 있다는 것을 가정합니다.\n환경이란 julia 에서 제공하는 별도의 실행 공간이라고 생각할 수 있습니다. 각 환경은 julia 인터프리터와 기본 설치되는 패키지만을 공유합니다. 각 환경마다 별도의 패키지를 설치 할 수 있으며 각 환경마다의 출입이 자유롭습니다. 두개의 환경을 동시에 사용하지는 못합니다. 보통은 당신이 패키지를 개발 할 때 패키지마다 하나의 환경을 만들어서 개발합니다. 새로운 디렉토리와 환경을 만들고 관리하는데 필요한 작은 파일들로 인해 당신의 하드디스크를 약간 소비하지만 충분한 이점이 있습니다. 환경과 더불어 중요한 용어가 의존성(dependency) 입니다. 당신이 패키지를 개발하는데 필요한 julia 자체와 julia 의 다른 패키지, 그리고 각각의 버젼을 합쳐서 의존성이라고 합니다.\n새로운 패키지를 개발한다면 github 에 리포지터리를 생성합니다. 리포지터리 이름은 당신이 만들고자 하는 패키지 이름 + “.jl” 로 합니다. 예를 들어 MyAwesomePackage.jl 같은 이름을 사용 할 수 있습니다. 여기서는 NAJ.jl 로 합니다. 간단하게 readme.md 파일을 작성할 수도 있습니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "패키지 개발"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/pkg_dev.html#시작하기",
    "href": "src/ecosystem_of_julia/pkg_dev.html#시작하기",
    "title": "패키지 개발",
    "section": "1 시작하기",
    "text": "1 시작하기\n이제 터미널에서 NAJ.jl 를 시작할 디렉토리에 들어갑니다. 예를 들어 /Users/myacc/Project 디렉토리에 NAJ.jl 디렉토리를 만들고 이 디렉토리에서 패키지를 만들고 싶다면 /Users/myacc/Project 로 이동합니다. 그리고 julia REPL 을 실행시키고 ] 키를 통해 pkg 모드에 진입합니다.\n(@v1.10) pkg&gt;\n이제 패키지를 초기화 합니다.\n(@v1.10) pkg&gt; generate NAJ.jl\n  Generating  project NAJ:\n    NAJ.jl/Project.toml\n    NAJ.jl/src/NAJ.jl\nNAJ.jl 디렉토리가 생겼고 그 디렉토리 밑에 Project.toml 파일과 src 디렉토리가 생겼으며, src 디렉토리 밑에 NAJ.jl 파일이 생겼습니다. Project.toml 파일은 프로젝트의 정보와 설정을 담는 파일이고, 패키지 이름과 같은 NAJ.jl 파일은 패키지의 julia 코드를 저장합니다.\njulia 에는 현재 작업 디렉토리라는 개념이 있습니다. julia 인터프리터의 경우 인터프리터를 시작할 때 별도로 지정하지 않았아면 julia 인터프리터를 실행한 디렉토리입니다. julia 인터프리터에서 pwd() 함수로 확인 할 수 있으며, cd() 함수를 통해 현재 작업 디렉토리를 이동 할 수 있습니다. NAJ.jl 로 이동합니다.\nIn [1]: cd(\"NAJ.jl\")\n\nIn [2]: pwd()\nOut[2]: \"/Users/myacc/Project/NAJ.jl\"\n이제 터미널로 나갑니다. 이제 NAJ.jl 디렉토리와 git 저장소를 동기화합니다. 아래에서 [git repository address] 에는 실제 github 저장소 주소를 넣습니다. 예를 들면 https://github.com/Julia-KAERI/NAJ.jl.git 같은 것입니다.\ngit init\ngit remote add origin [git repository address]\n현재 저장소는 비어 있으므로 이미 존재하는 파일과 디렉토리를 업로드합니다. 브랜치 이름은 main 이나 master 일 것입니다. 터미널에서 git status 명령어로 확인합니다.\ngit add .\ngit commit -m \"first_upload\"\ngit push origin main # main 혹은 master \n여기까지 별 문제가 없었다면 준비가 다 된 것입니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "패키지 개발"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/pkg_dev.html#활성화",
    "href": "src/ecosystem_of_julia/pkg_dev.html#활성화",
    "title": "패키지 개발",
    "section": "2 활성화",
    "text": "2 활성화\nJulia 인터프리터의 pkg 모드에서 activate . 명령은 현재 디렉토리의 환경을 활성화 하라는 명령입니다.\n(@v1.10) pkg&gt; activate .\n  Activating new project at `~/development/Projects/NAJ.jl`\n\n(NAJ.jl) pkg&gt;\n프롬프트가 (NAJ.jl) 로 바뀌었습니다. 즉 여러분의 환경이 변했습니다. activate 만 치면 기본 환경, 즉 julia 가 처음 설치되었을때의 환경으로 돌아갑니다. 실행 후 입력 프롬프트에서 환경을 확인 할 수 잇습니다.\n(NAJ.jl) pkg&gt; activate\n  Activating project at `~/.julia/environments/v1.10`\n(@v1.10) pkg&gt;\n현재까지 당신의 NAJ.jl 디렉토리는 패키지 생성에서 만든 파일, 디렉토리와 github 에서 사용하는 .git 디렉토리를 제외하면 비어있습니다.\nIn [2]: readdir()\nOut[2]: 3-element Vector{String}:\n \".git\"\n \"Project.toml\"\n \"src\"\n환경을 활성화 하는 방법은 REPL 에서 using Pkg 로 Pkg 를 임포트 한후 activate 함수를 사용하는 방법도 있습니다. activate 함수의 인자로는 환경이 설치된 경로가 필요합니다.\nusing Pkg\nPkg.activate(\"~/development/Projects/NAJ.jl\")\nPkg.status() 함수나 pkg 모드의 status 명령어로 현재의 환경을 확인 할 수 있습니다.\nIn [4]: Pkg.status()\nProject NAJ v0.1.0\nStatus `~/development/Projects/NAJ.jl/Project.toml` (empty project)",
    "crumbs": [
      "Julia 언어 생태계",
      "패키지 개발"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/pkg_dev.html#패키지-추가",
    "href": "src/ecosystem_of_julia/pkg_dev.html#패키지-추가",
    "title": "패키지 개발",
    "section": "3 패키지 추가",
    "text": "3 패키지 추가\n당신이 패키지를 개발하는 데 필요한 외부 패키지를 하나 추가해 봅시다. 쉽게 삭제 할 수 있으니 걱정하지 않아도 됩니다. 아직 생각나지 않는다면 Example 패키지를 추가해 봅시다.\n(NAJ) pkg&gt; add Example\n   Resolving package versions...\n    Updating `~/development/Projects/NAJ.jl/Project.toml`\n  [7876af07] + Example v0.5.3\n    Updating `~/development/Projects/NAJ.jl/Manifest.toml`\n  [7876af07] + Example v0.5.3\nPrecompiling project...\n  1 dependency successfully precompiled in 2 seconds. 1 already precompiled.\n이제 패키지 폴더에 Manifest.toml 파일이 추가되었으며 Pkg.status() 함수를 통해 패키지가 추가되었다는 것을 확인 할 수 있습니다.\nIn [8]: readdir()\nOut[8]: 3-element Vector{String}:\n \".git\"\n \"Manifest.toml\"\n \"Project.toml\"\n\nIn [9]: Pkg.status()\nStatus `~/development/Projects/NAJ.jl/Project.toml`\n  [7876af07] Example v0.5.3",
    "crumbs": [
      "Julia 언어 생태계",
      "패키지 개발"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/pkg_dev.html#project.toml-과-manifest.toml",
    "href": "src/ecosystem_of_julia/pkg_dev.html#project.toml-과-manifest.toml",
    "title": "패키지 개발",
    "section": "4 Project.toml 과 Manifest.toml",
    "text": "4 Project.toml 과 Manifest.toml\ntoml 은 설정을 간편하게 읽고 쓰게 해주는 파일 포멧이며 보통 .toml 확장자를 갖습니다. 텍스트 형식으로 저장하기 때문에 문서편집기에서 직접 편집 할 수 있습니다. 두 파일에 대해 간략히 요약하면 다음과 같습니다.\n\nProject.toml : 프로젝트 파일은 상위 수준에서 프로젝트를 설명합니다. 패키지 작성자 및 이름, 패키지 자체의 버전 정보 및 UUID, 의존성 및 호환성이 이 파일에 나열됩니다.\nManifest.toml : 환경 내의 패키지 상태에 대한 절대적인 기록입니다. 여기에는 프로젝트의 (직접 및 간접) 의존성에 대한 정확한 정보가 포함됩니다. 보통은 환경의 변경 및 패키지 설치/제거 에 따라 자동적으로 생성되며 사용자가 건드리지 않습니다.\n\nProject.toml 과 Manifest.toml 쌍이 주어지면 정확히 동일한 패키지 환경을 복원하거나 생성 할 수 있으며 이는 재현성에 매우 유용합니다. 자세한 내용은 Pkg.instantiate를 참조하기 바랍니다.\n이제 Project.toml 파일에 패키지 정보를 추가합시다. 우선 현재의 파일은 다음과 같을 것입니다.\nname = \"NAJ\"\nuuid = \"3a8672d3-a8d7-4fb7-80dc-526698d5a642\"\nauthors = [\"julia-KAERI &lt;julia.kaeri@gmail.com&gt;\"]\nversion = \"0.1.0\"\n\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nname 은 패키지 이름, authors 는 저자들 정보, versions 는 버젼 정보입니다. 버젼 정보는 .으로 이어진 세개의 수로 구성되며 보통 주버젼, 부버젼, 패치버젼을 말합니다. 보통 정식으로 배포되기전에는 주버젼을 0 으로 합니다. 현재는 초기 상태이므로 버젼이 “0.1.0” 입니다. uuid 는 범용 고유 식별자(universally unique identifier) 의 영어 약자로 여기서는 패키지마다 부여되는 고유한 번호라고 생각할 수 있습니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "패키지 개발"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/pkg_dev.html#패키지-메인-파일",
    "href": "src/ecosystem_of_julia/pkg_dev.html#패키지-메인-파일",
    "title": "패키지 개발",
    "section": "5 패키지 메인 파일",
    "text": "5 패키지 메인 파일\n여기서는 패키지 이름과 같은 NAJ.jl\" 이며src` 디렉토리에 있습니다. 템플릿으로 주어지는 내용은 다음과 같습니다.\nmodule NAJ\n\ngreet() = print(\"Hello World!\")\n\nend # module NAJ\n\n이제 여러분이 여기를 채워가면 됩니다.",
    "crumbs": [
      "Julia 언어 생태계",
      "패키지 개발"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/staticarray.html#설치와-소개",
    "href": "src/ecosystem_of_julia/staticarray.html#설치와-소개",
    "title": "StaticArrays.jl",
    "section": "1 설치와 소개",
    "text": "1 설치와 소개\n] add StaticArrays 로 설치한다. 사용하기 위해서는 아래와 같이 패키지를 사용할 것을 선언 할 수 있다.\nusing StaticArrays\n\nStaticArray 는 그 크기가 정해진 배열이다. Julia 언어의 기초의 배열 에서 다뤘던, 우리가 일반적으로 사용하는 배열은 성분의 타입 T 와 차원 N 이 매개변수로 지정된 타입이다. 다음을 보라.\nIn [1]: typeof([1 2;3 4])\nOut[1]: Matrix{Int64} (alias for Array{Int64, 2})\n그러나 StaticArray 는 그 크기가 타입 매개변수로 전달되는 Array 의 하위타입이다. 즉 StaticArray{Size, T, N} &lt;: AbstractArray{T, N} 이다. 따라서 크기가 다른 StaticArray 는 다른 타입이다.\n\n1차원 배열은 Vector, 2차원 배열이 Matrix 라는 별칭(alias) 을 갖고 있듯이 1차원 StaticArray 는 SVector, 2차원 StaticArray 는 SMatrix 라는 별칭을 가지고 있다. 기본적으로 SArray, SVector, SMatrix 는 immutable 이다. 즉 성분 원소를 변경시킬 수 없다. Mutable 한 StaticArray 는 MArray 이며 마찬가지로 MVector, MMatrix 라는 별칭을 가지고 있다.\n\n그렇다면 StaticArrays 는 언제 사용할까? Julia 성능 팁 에 보면 크기가 100 보다 작은 배열에 StaticArrays 를 사용하면 성능이 대폭 향상되므로 이 경우에 사용을 추천한다. 즉 작은 배열에 대한 계산이 많을 때 StaticArrays 는 매우 유용하다.",
    "crumbs": [
      "Julia 언어 생태계",
      "StaticArrays.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/staticarray.html#사용법",
    "href": "src/ecosystem_of_julia/staticarray.html#사용법",
    "title": "StaticArrays.jl",
    "section": "2 사용법",
    "text": "2 사용법\n\n2.1 생성\n\nSVector\nSVector([1,2,3]) 은 오류를 발생시키며 SVector(1,2,3) 과 같이 사용할 수 있지만 가장 간단한 방법은 배열 앞에 @SVector 매크로를 사용하는 것이다. 크기와 타입를 을 정하여 SVector{3, UInt8}(1,2,3) 과 같이 사용할 수도 있다.\nIn [1]: using StaticArrays\n\nIn [2]: @SVector [1,3,2,5]\nOut[2]: 4-element SVector{4, Int64} with indices SOneTo(4):\n 1\n 3\n 2\n 5\n\nIn [3]: @SVector [cos(t) for t in 0:0.01:π]\nOut[3]: 315-element SVector{315, Float64} with indices SOneTo(315):\n  1.0\n  0.9999500004166653\n  0.9998000066665778\n  0.9995500337489875\n...  \n\nIn [4]: SVector{3,Int8}(1,2,3)\nOut[4]: 3-element SVector{3, Int8} with indices SOneTo(3):\n 1\n 2\n 3\n\n그러나 @SVector 다음에 벡터가 아닌 벡터에 대한 변수가 온다면 에러를 일으킨다.\nIn [28]: v1=[1,2,3]; v2=@SVector v1\nERROR: LoadError: Bad input for @SVector\nStacktrace:\n이 경우 매크로를 사용하지 않고 벡터의 크기를 매개변수로 넣어 다음과 같이 한다.\nIn [30]: v1=[1,2,3]; v2=SVector{3}(v1)\n\n\n\nSMatrix\n기본적으로는 크기와 타입을 정하여 SMatrix{2,2,Float32}(1,2,3,4) 와 같이 생성할 수 있지만 일반적으로는 역시 @SMatrix 매크로를 사용한다.\nIn [4]: @SMatrix rand(3,4)\nOut[4]: 3×4 SMatrix{3, 4, Float64, 12} with indices SOneTo(3)×SOneTo(4):\n 0.616709  0.433282  0.390636   0.0126605\n 0.182085  0.906459  0.0758969  0.96827\n 0.933711  0.909862  0.239658   0.42389\n\nSVector 와 마찬가지로 어떤 Matrix 가 A 라는 변수에 할당되었다면 다음과 같이 SMatrix 로 변경시킨다.\nIn [31]: A=[1 2;3 4]; B=SMatrix{2, 2}(A)\nOut[31]: 2×2 SMatrix{2, 2, Int64, 4} with indices SOneTo(2)×SOneTo(2):\n 1  2\n 3  4\n\n\n\nSArray\n배열의 크기를 Tuple{2,3,4} 나 Tuple{3,5,2,4} 와 같이 지정한다. 다음과 같이 쓸 수 있다.\nIn [22]: SArray{Tuple{2,3,4}, Int16}(collect(1:24))\nOut[22]: 2×3×4 SArray{Tuple{2, 3, 4}, Int16, 3, 24} with indices SOneTo(2)×SOneTo(3)×SOneTo(4):\n[:, :, 1] =\n 1  3  5\n 2  4  6",
    "crumbs": [
      "Julia 언어 생태계",
      "StaticArrays.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/staticarray.html#지원",
    "href": "src/ecosystem_of_julia/staticarray.html#지원",
    "title": "StaticArrays.jl",
    "section": "3 지원",
    "text": "3 지원\n일반적인 Array 와 같이 계산 할 수 있으며, LinearAlgebtra.jl 등의 많은 함수들이 StaticArrays.jl 를 지원한다.\nIn [46]: v2= @SVector [1,2,3]\nOut[46]: 3-element SVector{3, Int64} with indices SOneTo(3):\n 1\n 2\n 3\n\nIn [47]: v2 .+ 1\nOut[47]: 3-element SVector{3, Int64} with indices SOneTo(3):\n 2\n 3\n 4\n\nIn [48]: v1= @SVector [1,2,3]; v2=@SVector [-1, 0, 1];dot(v1, v2)\nOut[48]: 2\n\nIn [49]: using LinearAlgebra\n\nIn [50]: A = @SMatrix rand(3, 3); inv(A)\nOut[50]: 3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  7.03765   -6.72293  -0.990976\n -7.80764   13.4257   -0.435663\n  5.59968  -11.3503    2.22444",
    "crumbs": [
      "Julia 언어 생태계",
      "StaticArrays.jl"
    ]
  },
  {
    "objectID": "src/ecosystem_of_julia/staticarray.html#속도-향상",
    "href": "src/ecosystem_of_julia/staticarray.html#속도-향상",
    "title": "StaticArrays.jl",
    "section": "4 속도 향상",
    "text": "4 속도 향상\n앞서 언급했듯이 StaticArray 는 배열의 크기가 100 보다 작을 때 뚜렷하며, 어느 이상 크다면 오히려 일반 배열보다 속도가 느릴 수 있다. BenchmarkTools.jl 을 통해 확인해보라. 다음은 7 x 7 행렬의 역행렬을 구하는 것에 대해 그 속도를 구하는 것이다.\nusing BenchmarkTools, StaticArrays, LinearAlgebra\n\nA = rand(7, 7)\nB = SMatrix{7, 7}(A);\n\n@btime inv(A)\n@btime inv(B)\n내 맥북프로에서의 결과로는 StaticArray 의 결과가 그렇지 않은 것보다 약 2.5 배 정도 빨랐다.",
    "crumbs": [
      "Julia 언어 생태계",
      "StaticArrays.jl"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html",
    "href": "src/introduction_to_julia/01_julia_language.html",
    "title": "설치와 환경 구성",
    "section": "",
    "text": "다운로드 페이지 에서 다운받을 수도 있고, 맥 OSX 의 경우에는 homebrew, Ubuntu Linux 의 경우에는 apt 같은 운영체제별 패키지 관리자를 이용하여 설치할 수도 있습니다만 Julia 는 공식적으로는 다운로드 페이지에서 다운로드 받아서 설치하거나 juliaup 이라는 패키지를 이용할 것을 권합니다. 설치가 완료된 후 터미널에서 julia 명령을 수행하면 다음과 같은 화면을 볼 수 있을 것입니다.\n\n\n\n\n\n\n그림 1: Julia REPL screenshot\n\n\n\n위의 화면이 보인다면 julia 가 정상적으로 설치 된 것입니다. Julia 언어를 사용하는 방법은 크게 두가지가 있습니다. 하나는 REPL 이라고 불리는 상호작용을 통해 코드의 전체 혹은 일부를 수행하고 결과를 보는 방법이고 다른 하나는 전체 julia 코드를 한번에 수행하는 방법입니다.\n\n\n위의 스크린샷과 같이 julia&gt; 옆에 무언가를 치면 그대로 입력됩니다. 예를 들어 3+3 을 계산하고 싶으면 3+3 을 치고 엔터키를 누르면 그 결과가 출력됩니다.\njulia&gt; 3+3\n6\n이렇게 입력을 기다리다가 입력이 되면 읽어서(Read), 그 값을 평가하고(Evaluation), 그 결과를 출력하는(Printing) 것을 계속 반복하게(Loop) 하게 됩니다. 이것을 영어 단어의 첫글자만 따서 REPL 이라고 합니다. Julia 언어의 기본적인 상호작용은 터미널에서 REPL 을 수행하는 것입니다. 별도의 다른 프로그램이 필요하지 않고, 간단한 계산을 할 때 가장 빠르다는 장점이 있지만 긴 코드를 짤 때 불편하며, 그래프를 출력하는데 많은 제한이 있습니다. 그래서 보통은 다른 환경에서 julia 를 수행합니다. 대표적으로 Jupyter notebook/lab이나 Visual Studio Code 가 있습니다.\n\n\n\n\n기본적으로 julia REPL 의 프롬프트는 julia&gt; 이지만 개인적으로\nIn [1]: 5 + 3\nOut[1]: 8\n와 같은 방식을 선호하기 때문에 위와 같은 방식을 사용합니다. Julia 공식 메뉴얼의 Numbered Prompt 대로 고치면 이렇게 사용 할 수 있습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "설치와 환경 구성"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#julia-설치",
    "href": "src/introduction_to_julia/01_julia_language.html#julia-설치",
    "title": "설치와 환경 구성",
    "section": "",
    "text": "다운로드 페이지 에서 다운받을 수도 있고, 맥 OSX 의 경우에는 homebrew, Ubuntu Linux 의 경우에는 apt 같은 운영체제별 패키지 관리자를 이용하여 설치할 수도 있습니다만 Julia 는 공식적으로는 다운로드 페이지에서 다운로드 받아서 설치하거나 juliaup 이라는 패키지를 이용할 것을 권합니다. 설치가 완료된 후 터미널에서 julia 명령을 수행하면 다음과 같은 화면을 볼 수 있을 것입니다.\n\n\n\n\n\n\n그림 1: Julia REPL screenshot\n\n\n\n위의 화면이 보인다면 julia 가 정상적으로 설치 된 것입니다. Julia 언어를 사용하는 방법은 크게 두가지가 있습니다. 하나는 REPL 이라고 불리는 상호작용을 통해 코드의 전체 혹은 일부를 수행하고 결과를 보는 방법이고 다른 하나는 전체 julia 코드를 한번에 수행하는 방법입니다.\n\n\n위의 스크린샷과 같이 julia&gt; 옆에 무언가를 치면 그대로 입력됩니다. 예를 들어 3+3 을 계산하고 싶으면 3+3 을 치고 엔터키를 누르면 그 결과가 출력됩니다.\njulia&gt; 3+3\n6\n이렇게 입력을 기다리다가 입력이 되면 읽어서(Read), 그 값을 평가하고(Evaluation), 그 결과를 출력하는(Printing) 것을 계속 반복하게(Loop) 하게 됩니다. 이것을 영어 단어의 첫글자만 따서 REPL 이라고 합니다. Julia 언어의 기본적인 상호작용은 터미널에서 REPL 을 수행하는 것입니다. 별도의 다른 프로그램이 필요하지 않고, 간단한 계산을 할 때 가장 빠르다는 장점이 있지만 긴 코드를 짤 때 불편하며, 그래프를 출력하는데 많은 제한이 있습니다. 그래서 보통은 다른 환경에서 julia 를 수행합니다. 대표적으로 Jupyter notebook/lab이나 Visual Studio Code 가 있습니다.\n\n\n\n\n기본적으로 julia REPL 의 프롬프트는 julia&gt; 이지만 개인적으로\nIn [1]: 5 + 3\nOut[1]: 8\n와 같은 방식을 선호하기 때문에 위와 같은 방식을 사용합니다. Julia 공식 메뉴얼의 Numbered Prompt 대로 고치면 이렇게 사용 할 수 있습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "설치와 환경 구성"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#개발환경-설정에-관해",
    "href": "src/introduction_to_julia/01_julia_language.html#개발환경-설정에-관해",
    "title": "설치와 환경 구성",
    "section": "2 개발환경 설정에 관해",
    "text": "2 개발환경 설정에 관해\nJulia 의 개발 환경은 많은 선택지가 있습니다. Python 에서 많이 사용하는 jupyter notebook 을 사용할 수도 있으며, emacs, vim, atom, vscode 와 같은 다양한 편집기를 사용할 수도 있습니다. 개인적으로 Microsoft 사에서 제공하는 텍스트 편집기 겸 통합개발환경인 Visual Studio code (vscode) 를 사용하는 개발환경을 추천합니다. vscode 에서의 julia 지원 페이지 대로 따라 하면 julia 개발 환경을 구성 할 수 있습니다.\n저는 짧은 코드를 계속 입력하면서 결과를 확인하는 작업을 많이 할때는 vscode 의 jupyter 환경을 주로 사용하며, 긴 코드를 사용할 때는 vscode 와 Julia 언어 지원을 사용합니다. Jupyter 에 익숙하지 않다면 단순히 julia 지원만을 사용하는 것도 좋은 방법입니다. 여기에서도 줄단위, 블럭단위, 파일단위로 실행시켜 볼 수 있습니다. 그 이외에도 저는 사용해 본 적이 없지만 Pluto.jl 도 있습니다. 검색창에서 julia 개발 환경 을 검색하면 많은 내용이 나옵니다. 그 중에 여러분의 입맞에 맡는 것을 선택하면 됩니다. 여기에서는 짧은 코드는 Julia REPL 을 바탕으로 설명하겠지만 다른 개발 환경에서도 거의 그대로 결과가 나올 것입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "설치와 환경 구성"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#기본-제공-문서",
    "href": "src/introduction_to_julia/01_julia_language.html#기본-제공-문서",
    "title": "설치와 환경 구성",
    "section": "3 기본 제공 문서",
    "text": "3 기본 제공 문서\n영어로 되어 있는 Julia 에 포함된 기본 도움말은 매우 훌륭합니다\\(^\\ast\\). Julia REPL 에서는 julia&gt; 프롬프트에 ? 를 치면 help&gt;로 변경되는 것을 볼 수 있을 것입니다. 여기에 함수 이름이라든가, 타입 이름 같은 것을 치면 그에 대한 도움말을 제공합니다. Jupyter 에서는 입력 셀에 ?sin 과 같이 ? 를 맨 앞에 두고 입력한후 실행하면 문서를 찾아 제공합니다. vscode 에서는 자동적으로 팝업 윈도우로 제공합니다만 2023년 12월 현재로서는 완전하지 않습니다. 이렇게 제공되는 문서는 당신이 사용하는 Julia 와 페키지에 대한 공식 문서이므로, 가장 믿을만하고 우선적으로 참고해야하는 문서가 되겠습니다.\\(^\\ast\\) 이 도움말은 별도로 제공되는 것이 아니라 소스코드에 주석으로 포함되어 있습니다.\nJulia 언어에 기본적으로 포함되어있는 함수, 모듈들 이외에 많은 모듈을 설치하게 될텐데 그 모듈들도 대부분 똑같은 형식의 도움말을 제공합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "설치와 환경 구성"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#sec-unicode_support",
    "href": "src/introduction_to_julia/01_julia_language.html#sec-unicode_support",
    "title": "설치와 환경 구성",
    "section": "4 유니코드 및 수학 기호 지원",
    "text": "4 유니코드 및 수학 기호 지원\nJulia 에서는 REPL 에서도 수학 기호를 포함한 다양한 문자를 입력하고 사용 할 수 있습니다. \\ 로 시작되는 구문을 입력한 후에 공백 없이 탭 키를 누르면 자동적으로 기호로 변환된됩니다. 예를 들어 Julia REPL(Julia 에서 지원하는 interactive command line 환경), jupyter notebook, vscode 에서 \\alpha 를 치고 곧바로 탭(tab) 키를 누르면 α 로 변환됩니다. 정확히 말하면 \\alp 정도 까지만 입력한 후 탭키를 눌러도 자동완성 기능으로 인해 \\alpha 가 다 입력된 후 α 로 변환된 것입니다. 이렇게 입력된 α 는 일반 알파벳과 같이 변수명으로도 사용 될 수 있습니다. 이 때 입력되는 구문은 LaTeX 와 같거나 유사한 경우가 많습니다. 주의할 것은 π(\\pi+[tab]) 와 ℯ(\\euler + [tab]) 는 특정 값이 지정되어 있는 대표적인 수학 기호입니다. pi 역시 원주율 입니다.\njulia&gt; π\nπ = 3.1415926535897...\n\njulia&gt; ℯ\nℯ = 2.7182818284590...\n\njulia&gt; pi\nπ = 3.1415926535897...\nJulia 에서 사용할 수 있는 유니코드 기호와 \\로 시작하여 탭 키를 눌러 완성되는 문자들은 julia 공식 문서의 Unicode Input 을 참고하시기 바랍니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "설치와 환경 구성"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/01_julia_language.html#완벽한-초보를-위한-설치-가이드",
    "href": "src/introduction_to_julia/01_julia_language.html#완벽한-초보를-위한-설치-가이드",
    "title": "설치와 환경 구성",
    "section": "5 완벽한 초보를 위한 설치 가이드",
    "text": "5 완벽한 초보를 위한 설치 가이드\n만약 당신이 완벽한 초보자라면 아래의 방법을 따라 해 보시기 바랍니다.\n\nJulia 설치\nJulia 다운로드 페이지 에서 다운로드 받고 설치합니다. 윂페이지를 아래로 내리다 보면 크게 Official Binaries for Manual Download 라고 써 있고 거기에 최신 버젼(Current stable release) 을 다운로드 받을 수 있도록 해 놨습니다. 윈도우즈 계열의 OS 라면 시작 버튼을 눌렀을 때 나오는 프로그램 목록에서 Julia 를 실행 시킬 수 있으며 이 때 Julia REPL 그림 1 과 같이 실행됩니다.\n\n\n\nVisual Studio Code 설치\nVisual Studio Code (이하 vscode) 는 현재 전 세계에서 가장 많이 사용하는 텍스트 편집기로 Microsoft 사에서 제작하여 무료로 배포합니다.\nVS code 홈페이지 로 가면 운영체제에 따른 다운로드 버튼이 있습니다. 다운로드 후 실행하면 VS 코드가 설치됩니다. 이후 vscode 를 실행시키면 다음과 같은 화면이 뜨게 됩니다.\n\n\n\n\n\n\n\n그림 2: VS code 처음 시작 화면\n\n\n\n\n\nVS code 한글 설정\n시작화면의 맨 오른쪽의 바로가기 아이콘들중에 윗부분은 아래와 같은 기능을 합니다.\n\n\n\n\n\n\n그림 3: VS code 바로가기\n\n\n\n여기서 확장은 vs code 위에서 vs code 의 기능을 추가해주는 작은 프로그램과 자료들이라고 보면 됩니다. 우선 vscode 의 메뉴와 명령을 한글화해주는 한글팩을 설치합시다. 영어가 익숙하거나 편한 분들은 그대로 사용해도 됩니다. 확장 아이콘을 누르면 많이 사용하는 확장 프로그램의 긴 목록 위에 텍스트를 입력 할 수 있는 칸이 나옵니다. 여기에 korea 혹은 한국 을 입력하면 지구본 모양의 아이콘과 함께 Korean Language pack 이 리스트의 맨 위로 올 것이고 그 옆에 파란 바탕의 하얀 글씨로 Install 이라고 보일 것입니다. 여기서 Install 버튼을 누르면 설치가 시작됩니다. 설치가 종료되면 vscode 오른쪽 아래에 Change Language and Restart 버튼이 보일 것입니다. 이것을 누르면 VS code 가 종료 후 다시 실행되면서 메뉴와 설명의 많은 부분이 한글로 바뀝니다.\n\n\n\nJulia 확장 설치\n한글 설정 때와 같이 vscode 바로가기 에서 확장 아이콘을 누르고 julia 를 검색합니다. 맨 위에 Julia 라는 이름과 로고를 가진 확장 프로그램이 보일 것입니다. 한글 팩을 설치했다면 Install 이 아닌 설치 버튼이 보일 것입니다. 이것을 설치해 줍니다. 이것을 설치하면 바로가기 아이콘에 Julia 아이콘이 추가됩니다.\n\n\n\n\n최초의 Julia 파일 작성\n바로가기의 탐색기 버튼을 누릅니다. 그러면 바로가개 버튼의 바로 오른쪽에 새로운 칸이 열리면서 폴더 열기 버튼이 보일 것입니다. 폴더 열기 버튼을 누르면 운영 체제에 따라 새로운 폴더를 만드는 창이 생깁니다. 여기에 코드를 작성할 폴더를 만들어 줍니다. 저의 경우는 홈 디렉토리 밑에 developement 폴더를 만들고 그 폴더 아래에 test001 폴더를 만들 것입니다. 이미 존재하는 폴더를 선택하면 그 폴더의 파일들이 보일 것입니다. 왠만하면 폴더와 파일 이름은 한글이나 다른 언어를 사용하지 않고 영어 알파벳, 숫자, _ 문자만 사용하시길 추천합니다.\n폴더를 선택하면 운영체제나 계정에 따라 이 폴더의 작성자를 신뢰하느냐는 메시지가 뜰 것입니다. 자신의 계정의 폴더라면 신뢰한다는 버튼을 누르십시요. 타인의 폴더라면 계정의 주인과 상의하시기 바랍니다.\n탐색기 창에 지정한 폴더의 이름과 이 폴더에 포함된 파일들의 이름이 보일 것입니다. 그리고 폴더 이름 옆에 네개의 아이콘이 보입니다. 각각의 아이콘 위에 커서를 가져다만 대고 누르지 않으면 새 파일…, 새 폴더…, 탐색기 새로고침, 탐색기에서 폴더 축소 라는 설명을 볼 수 있습니다. 설명대로 각각 새로운 파일을 만들거나, 지정한 폴더 아래에 새로운 폴더를 만들거나, 탐색기의 파일 목록을 다시 읽습니다. 탐색기에서 폴더 축소는 현재 폴더 아래에 파일과 폴더가 많은 경우 특히 하위폴더의 파일 이름이 보일 경우 이것을 접어서 더 간략하게 보도록 해 줍니다.\n이제 새 파일 버튼을 누르면 폴더창 아래에 입력칸이 생길 것입니다. 여기에 파일 이름을 입력합니다. 앞서 말했듯이 영어 알파벳과 숫자만을 사용하여 test01.jl 이라고 입력합니다. jl 은 julia 파일에 대한 표준적인 확장자입니다.\n여기에 다음과 같이 입력합니다.\n2+3\n\nexp(1)\n\ncos(0)\n첫번째 줄의 2+3 줄에 커서를 옮기고 Control+Enter (혹은 Ctrl+Enter) 를 누릅니다. 그렇게 되면 커서가 위치한 줄, 혹은 블럭을 실행하여 그 결과를 julia REPL 로 출력합니다. 아마 vscode 의 하단에 터미널이 열리면서\nOut[1]: 5\n과 같이 보일 것입니다. vscode 는 자체에 터미널이 내장되어 있어 다른 터미널을 사용하지 않고 여기서 많은 일을 할 수 있습니다.\nWindows/Linux 에서 Alt+Enter, Mac 에서 Option+Enter 키를 누르면 파일의 코드 전체를 REPL 에서 실행합니다.\n\n\n\nNotebook\n같은 폴더에 test01.ipynb 라는 이름을 가진 파일을 새로 만들어 줍니다. 그렇다면 아래와 같은 모양이 될 것입니다. ipynb 는 Jupyter notebook 혹은 jupyter lab 에서 사용하는 노트북 파일의 기본 확장자입니다.\n\n\n\n\n\n\n그림 4: vscode notebook 시작화면\n\n\n\n\n오른쪽 상단에 커널 선택이 아니라 Julia 1.10.3 과 같은 방금전 설치한 julia 버젼이 나타난다면 그냥 두고 아니라면 커널 선택을 눌러 선택해 줍니다. 그리고 1이라고 써 있는 칸(이것을 입력셀 이라고 합니다)의 오른쪽 하단이 보기처럼 Python 이나 julia 가 아닌 다른 것이라면 그 부분을 눌러 julia 를 선택해 줍니다. 아래와 같이 julia 버젼과 입력셀에 julia 가 보이면 성공입니다.\n\n\n\n\n\n\n그림 5: vscode notebook julia\n\n\n\n\n입력셀에 아래의 코드를 복사&붙여넣기를 해 봅니다.\ntsum = 0\nfor i in 1:10\n    tsum+=i\nend\nprintln(tsum)\n그리고 Shift+Enter 를 누릅니다. 다음과 같이 입력창 아래에 55 라는 결과가 나오면 성공입니다.\n\n\n\n\n\n\n그림 6: vscode notebook 입력창 실행\n\n\n\nShift+Enter 는 입력창을 실행시키고, 가장 마지막 명령어의 실행 결과를 출력하며, 다음 입력창으로 갑니다. 다음 입력창이 존재하지 않으면 새로운 입력창을 만듭니다.\n\nVisual Studio Code 의 노트북은 Jupyter notebook 혹은 그 개선 버젼인 Jupyter-lab 과 유사한 실행 환경입니다. jupyter notebook 이나 lab 은 웹브라우저에서 실행되는데 이것을 vscode 에서 실행되도록 한 것입니다. 개인적으로는 jupyter notebook 보다 이쪽을 더 선호합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "설치와 환경 구성"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/03_functions_and_operators.html",
    "href": "src/introduction_to_julia/03_functions_and_operators.html",
    "title": "연산자와 함수",
    "section": "",
    "text": "연산자는 add(a, b) 와 같은 함수 이름, 괄호, 인자 의 형식을 따르지 않는 함수를 말합니다.\n\n\n많은 다른 프로그래밍 언어에서와 같이 x = y 는 y 의 값을 x 에 할당한다는 표현식이며 == 와 === 는 이 기호의 왼편과 오른편의 변수나 값이 같은지 아닌지를 판단하여 같으면 true 다르면 false 를 반환하는 연산자입니다. === 는 == 보다 더 엄격하게 판단합니다. 예를 들어,\nIn [1]: 2==2.0\nOut[1]: true\n\nIn [2]: 2===2.0\nOut[2]: false\n를 보면 2==2.0 은 true 이지만 2===2.0 은 false 입니다. === 는 타입의 종류까지 같아야 true 를 반환합니다. 그런데 == 는 좀 혼란스럽습니다. 다음 경우를 봅시다.\nIn [3]: 1.0 == 1.0f0\nOut[3]: true\n\nIn [4]: 2.0 == 2.0f0\nOut[4]: true\n\nIn [5]: 1.2 == 1.2f0\nOut[5]: false\n\nIn [6]: Float32(1.2) == 1.2f0\nOut[6]: true\n1.0 등 왼쪽의 값들은 모두 Float64 타입이며 오른쪽의 값들은 Float32 의 값입니다. 1.0 == 1.0f0 는 true 인데 1.2 == 1.2f0 는 false 입니다. 이런 행동을 내부적인 코드 수준에서 이해하는 것은 힘든 일입니다. 다만 다른 타입의 값을 비교할 때, 특히 같은지 여부를 판단할 때는 매우 조심해야 한다는 것을 알아야 합니다.\n\n\n\n\n기본적인 값에 대한 연산에는 다음과 같은 것들이 있습니다.\n\n\n\n표현\n정의\n\n\n\n\n+x\n항등 연산\n\n\n-x\n덧셈에 대한 역원. 혹은 x 에 -1 을 곱한 수\n\n\nx + y\n덧셈\n\n\nx - y\n뺄셈\n\n\nx * y\n곱셈\n\n\nx / y\n나눗셈\n\n\nx ÷ y\n나눗셈의 정수 몫, div(x, y) 와 같다.\n\n\nx \\ y\n역 나눗셈. y / x 와 같다.\n\n\nx ^ y\n거듭제곱. x 의 y 승\n\n\nx % y\n나머지. rem(x, y) 와 같다.\n\n\nx//y\nx, y 가 정수일 때 유리수 타입의 \\(x/y\\)\n\n\n\n\n÷ 는 \\div+ [tab] 키 로 입력 할 수 있습니다.\nx / y 에서 x 와 y 가 모두 정수일 때는 실수로 타입이 변환됩니다. 즉 5/2 는 2.5 이며 6/3 은 2.0 입니다.\nx//y 는 x, y 가 정수일 때 Julia 의 Rational 타입의 값을 반환합니다. 앞서 말했듯이 Julia 에서 유리수는 Int64 나 Float64 와 같은 고유한 타입입니다.\nx ÷ y 는 x 와 y 가 모두 정수 타입이라면 정수몫을 리턴하지만 x 나 y 가 정수가 아닌 부동수일 경우에는 정수몫을 부동소수로 반환합니다. 아래의 예를 참고하세요.\n\nIn [7]: 173 ÷ 2\nOut[7]: 86\n\nIn [8]: 173 ÷ 2.0\nOut[8]: 86.0\n\nIn [9]: 173.0 ÷ 2\nOut[9]: 86.0\n\nIn [10]: -173 ÷ 2\nOut[10]: -86\n\n\n\n실수 \\(a\\) 를 실수 \\(d\\) 로 나눌 때 \\(a=k\\cdot d + r\\) 을 만족하는 정수 \\(k\\)를 몫이라고 하고 \\(r\\) 을 나머지라고 합니다. \\(a,\\,d\\) 가 양수라면 \\(0\\le r &lt; d\\) 를 만족하는 \\(r\\) 을 찾으면 됩니다. 그런데 \\(a,\\,d\\) 둘 가운데 하나라도 음수 일 경우를 생각해 봅시다. 예를 들어 \\(13.0\\) 을 \\(-3.0\\) 으로 나누는 경우,\n\\[\n\\begin{aligned}\n13.0 &= (-4.0) \\times (-3.0) -1.0, \\\\\n13.0 &= (-5.0) \\times (-3.0) + 2.0,\n\\end{aligned}\n\\]\n과 같이 몫 나머지를 각각 (-4.0, -1.0) 이나 (-5.0, 2.0) 으로 생각 할 수 있습니다. \\(a=kd + r\\) 로 표현할 때 나머지 \\(r\\) 의 부호를 \\(a\\) 를 따르도록 하는 경우와 \\(d\\) 의 부호를 따르도록 하는 경우가 있는데 julia 의 나머지 a % r 은 a 의 부호를 따릅니다. 모든 경우에 대해 \\(0 \\le |r| &lt; |d|\\) 입니다.\nIn [11]: -13.0 % 3.0\nOut[11]: -1.0\n\nIn [12]: 13.0 % -3.0\nOut[12]: 1.0\n\nIn [13]: -13.0 % -3.0\nOut[13]: -1.0\n\n\n\n\n\n\n부동소수 나머지 연산에서의 Round-off 에러\n\n\n\n원칙적으로는 a == (a ÷ d) * d + (a % d) 이어야 하지만, a 나 d 가 부동소수일 경우 round-off 에러로 인해 차이가 있을 수 있습니다.\nIn [14]: (-13.3 ÷ 3.0) * 3.0 + (-13.3 % 3.0)\nOut[14]: -13.3\n\nIn [15]: (17.24 ÷ 3.42) * 3.42 + (17.24 % 3.42)\nOut[15]: 17.240000000000002\n\n\n\n\n\n\n\n불(Bool) 타입에 대한 연산은 다음과 같은 것이 있습니다.\n\n\n\n표현\n설명\n\n\n\n\n!x\n부정(negation)\n\n\nx && y\nshort-circuiting and\n\n\nx || y\nshort-circuiting or\n\n\n\n\n!(true) 는 false 이고 !(false) 는 true 입니다.\n아래에 나오는 비트별 연산자 & 와 | 도 불 연산에 and 연산과 or 연산으로 사용될 수 있습니다.\n\n\n\n\n\n논리연산자 x && y 는 x 를 먼저 평가하여 true 이면 y 를 평가하며 y 도 true 이면 연산의 결과는 true 가 됩니다. x 가 false 이면 y 는 평가할 필요가 없이 결과는 false 가 됩니다. 그런데 y 가 불 값이 아닌 어떤 기능을 하는 함수라면 어떻게 될까요? x && y 는 x 가 true 일 경우에만 y 를 실행시키는 조건부 실행문이 됩니다. x || y 일 때는 반대로 x 가 true 이면 true 를 리턴하고 x 가 거짓이면 y 를 실행시킵니다. 불 연산을 사용하여 조건에 따라 실행시키는 것을 short-circuiting 연산이라고 하며, julia 에서 상당히 많이 사용되는 테크닉 입니다.\nIn [19]: x=3\nOut[19]: 3\n\nIn [20]: x&gt;0 && println(\"true and short-circuiting and\")\ntrue and short-circuiting and\n\nIn [21]: x&lt;0 && println(\"false and short-circuiting and\")\nOut[21]: false\n\nIn [22]: x&gt;0 || println(\"true and short-circuiting or\")\nOut[22]: true\n\nIn [23]: x&lt;0 || println(\"false and short-circuiting or\")\nfalse and short-circuiting or\n\n\n\n\n비트는 true 혹은 false 값을 갖는 정보 단위입니다. 아래의 표는 비트에 대한 연산자를 설명합니다.\n\n\n\n표현\nName\n\n\n\n\n~x\nbitwise not\n\n\nx & y\nbitwise and\n\n\nx | y\nbitwise or\n\n\nx ⊻ y\nbitwise xor (exclusive or)\n\n\nx ⊼ y\nbitwise nand (not and)\n\n\nx ⊽ y\nbitwise nor (not or)\n\n\nx &gt;&gt;&gt; y\nlogical shift right\n\n\nx &gt;&gt; y\narithmetic shift right\n\n\nx &lt;&lt; y\nlogical/arithmetic shift left\n\n\n\n\n⊻ 는 \\xor + 탭키, ⊼ 는 \\nand + 탭키, ⊽ 는 \\nor + 탭키 로 입력합니다. &gt;&gt;&gt; 나 &lt;&lt; 는 단순한 키보드 입력입니다.\n한국어 위키백과-비트연산 과 영어 위키백과-비트연산 을 참고하시기 바랍니다\nx&gt;&gt;y 의 경우는 정수 x 를 \\(2^y\\) 로 나눈 몫을 계산하는데 자주 사용됩니다. 예를 들어\n\nIn [24]: 15&gt;&gt;1 # 15 나누기 2^1=2 의 몫\nOut[24]: 7\n\nIn [25]: 427&gt;&gt;2 #427 나누기 2^2=4 의 몫\nOut[25]: 106\n입니다. 비트연산에 대해 편리한 함수로 입력값을 비트 문자열로 바꾸어주는 bitstring() 함수가 있습니다.\nIn [26]: bitstring(1)\nOut[26]: \"0000000000000000000000000000000000000000000000000000000000000001\"\n\nIn [27]: bitstring(3.23)\nOut[27]: \"0100000000001001110101110000101000111101011100001010001111010111\"\n\n\n\n\n비교 연산은 표현을 평가하여 true 혹은 false 를 반환합니다.\n\n\n\n표현\ntrue 인 경우\n\n\n\n\nx == y\nx 와 y 가 같을 때\n\n\nx != y, x ≠ y\nx 와 y 가 다를 때\n\n\nx &lt; y\nx 가 y 보다 작을 때\n\n\nx &lt;= y, x ≤ y\nx 가 y 보다 작거나 같을 때\n\n\nx &gt; y\nx 가 y 보다 클 때\n\n\nx &gt;= y , x ≥ y\nx 가 y 보다 크거나 같을 때\n\n\n\n\n≠ 는 \\ne+탭 키, ≤ 는 \\le+ 탭 키, ≥ 는 \\ge + 탭 키 를 통해 입력합니다.\n비교 연산을 1 &lt; 2 &lt;= 3 &lt; 5 != 10 &lt; 12 같이 이어서 쓸 수 있습니다. 모든 비교 항목이 true 일 때만 true 를 리턴합니다.\n\n특히 부동소수가 포함된 계산의 결과를 비교할때는 조심해야 합니다. Round-off 에러로 인해 오류가 발생 할 수 있습니다.\nIn [28]: 0 == 0.0\nOut[28]: true\n\nIn [29]: 4 == 4.0\nOut[29]: true\n\nIn [30]: 8.3-1.0 == 7.3\nOut[30]: false",
    "crumbs": [
      "Julia 언어의 기초",
      "연산자와 함수"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/03_functions_and_operators.html#기본-연산자",
    "href": "src/introduction_to_julia/03_functions_and_operators.html#기본-연산자",
    "title": "연산자와 함수",
    "section": "",
    "text": "연산자는 add(a, b) 와 같은 함수 이름, 괄호, 인자 의 형식을 따르지 않는 함수를 말합니다.\n\n\n많은 다른 프로그래밍 언어에서와 같이 x = y 는 y 의 값을 x 에 할당한다는 표현식이며 == 와 === 는 이 기호의 왼편과 오른편의 변수나 값이 같은지 아닌지를 판단하여 같으면 true 다르면 false 를 반환하는 연산자입니다. === 는 == 보다 더 엄격하게 판단합니다. 예를 들어,\nIn [1]: 2==2.0\nOut[1]: true\n\nIn [2]: 2===2.0\nOut[2]: false\n를 보면 2==2.0 은 true 이지만 2===2.0 은 false 입니다. === 는 타입의 종류까지 같아야 true 를 반환합니다. 그런데 == 는 좀 혼란스럽습니다. 다음 경우를 봅시다.\nIn [3]: 1.0 == 1.0f0\nOut[3]: true\n\nIn [4]: 2.0 == 2.0f0\nOut[4]: true\n\nIn [5]: 1.2 == 1.2f0\nOut[5]: false\n\nIn [6]: Float32(1.2) == 1.2f0\nOut[6]: true\n1.0 등 왼쪽의 값들은 모두 Float64 타입이며 오른쪽의 값들은 Float32 의 값입니다. 1.0 == 1.0f0 는 true 인데 1.2 == 1.2f0 는 false 입니다. 이런 행동을 내부적인 코드 수준에서 이해하는 것은 힘든 일입니다. 다만 다른 타입의 값을 비교할 때, 특히 같은지 여부를 판단할 때는 매우 조심해야 한다는 것을 알아야 합니다.\n\n\n\n\n기본적인 값에 대한 연산에는 다음과 같은 것들이 있습니다.\n\n\n\n표현\n정의\n\n\n\n\n+x\n항등 연산\n\n\n-x\n덧셈에 대한 역원. 혹은 x 에 -1 을 곱한 수\n\n\nx + y\n덧셈\n\n\nx - y\n뺄셈\n\n\nx * y\n곱셈\n\n\nx / y\n나눗셈\n\n\nx ÷ y\n나눗셈의 정수 몫, div(x, y) 와 같다.\n\n\nx \\ y\n역 나눗셈. y / x 와 같다.\n\n\nx ^ y\n거듭제곱. x 의 y 승\n\n\nx % y\n나머지. rem(x, y) 와 같다.\n\n\nx//y\nx, y 가 정수일 때 유리수 타입의 \\(x/y\\)\n\n\n\n\n÷ 는 \\div+ [tab] 키 로 입력 할 수 있습니다.\nx / y 에서 x 와 y 가 모두 정수일 때는 실수로 타입이 변환됩니다. 즉 5/2 는 2.5 이며 6/3 은 2.0 입니다.\nx//y 는 x, y 가 정수일 때 Julia 의 Rational 타입의 값을 반환합니다. 앞서 말했듯이 Julia 에서 유리수는 Int64 나 Float64 와 같은 고유한 타입입니다.\nx ÷ y 는 x 와 y 가 모두 정수 타입이라면 정수몫을 리턴하지만 x 나 y 가 정수가 아닌 부동수일 경우에는 정수몫을 부동소수로 반환합니다. 아래의 예를 참고하세요.\n\nIn [7]: 173 ÷ 2\nOut[7]: 86\n\nIn [8]: 173 ÷ 2.0\nOut[8]: 86.0\n\nIn [9]: 173.0 ÷ 2\nOut[9]: 86.0\n\nIn [10]: -173 ÷ 2\nOut[10]: -86\n\n\n\n실수 \\(a\\) 를 실수 \\(d\\) 로 나눌 때 \\(a=k\\cdot d + r\\) 을 만족하는 정수 \\(k\\)를 몫이라고 하고 \\(r\\) 을 나머지라고 합니다. \\(a,\\,d\\) 가 양수라면 \\(0\\le r &lt; d\\) 를 만족하는 \\(r\\) 을 찾으면 됩니다. 그런데 \\(a,\\,d\\) 둘 가운데 하나라도 음수 일 경우를 생각해 봅시다. 예를 들어 \\(13.0\\) 을 \\(-3.0\\) 으로 나누는 경우,\n\\[\n\\begin{aligned}\n13.0 &= (-4.0) \\times (-3.0) -1.0, \\\\\n13.0 &= (-5.0) \\times (-3.0) + 2.0,\n\\end{aligned}\n\\]\n과 같이 몫 나머지를 각각 (-4.0, -1.0) 이나 (-5.0, 2.0) 으로 생각 할 수 있습니다. \\(a=kd + r\\) 로 표현할 때 나머지 \\(r\\) 의 부호를 \\(a\\) 를 따르도록 하는 경우와 \\(d\\) 의 부호를 따르도록 하는 경우가 있는데 julia 의 나머지 a % r 은 a 의 부호를 따릅니다. 모든 경우에 대해 \\(0 \\le |r| &lt; |d|\\) 입니다.\nIn [11]: -13.0 % 3.0\nOut[11]: -1.0\n\nIn [12]: 13.0 % -3.0\nOut[12]: 1.0\n\nIn [13]: -13.0 % -3.0\nOut[13]: -1.0\n\n\n\n\n\n\n부동소수 나머지 연산에서의 Round-off 에러\n\n\n\n원칙적으로는 a == (a ÷ d) * d + (a % d) 이어야 하지만, a 나 d 가 부동소수일 경우 round-off 에러로 인해 차이가 있을 수 있습니다.\nIn [14]: (-13.3 ÷ 3.0) * 3.0 + (-13.3 % 3.0)\nOut[14]: -13.3\n\nIn [15]: (17.24 ÷ 3.42) * 3.42 + (17.24 % 3.42)\nOut[15]: 17.240000000000002\n\n\n\n\n\n\n\n불(Bool) 타입에 대한 연산은 다음과 같은 것이 있습니다.\n\n\n\n표현\n설명\n\n\n\n\n!x\n부정(negation)\n\n\nx && y\nshort-circuiting and\n\n\nx || y\nshort-circuiting or\n\n\n\n\n!(true) 는 false 이고 !(false) 는 true 입니다.\n아래에 나오는 비트별 연산자 & 와 | 도 불 연산에 and 연산과 or 연산으로 사용될 수 있습니다.\n\n\n\n\n\n논리연산자 x && y 는 x 를 먼저 평가하여 true 이면 y 를 평가하며 y 도 true 이면 연산의 결과는 true 가 됩니다. x 가 false 이면 y 는 평가할 필요가 없이 결과는 false 가 됩니다. 그런데 y 가 불 값이 아닌 어떤 기능을 하는 함수라면 어떻게 될까요? x && y 는 x 가 true 일 경우에만 y 를 실행시키는 조건부 실행문이 됩니다. x || y 일 때는 반대로 x 가 true 이면 true 를 리턴하고 x 가 거짓이면 y 를 실행시킵니다. 불 연산을 사용하여 조건에 따라 실행시키는 것을 short-circuiting 연산이라고 하며, julia 에서 상당히 많이 사용되는 테크닉 입니다.\nIn [19]: x=3\nOut[19]: 3\n\nIn [20]: x&gt;0 && println(\"true and short-circuiting and\")\ntrue and short-circuiting and\n\nIn [21]: x&lt;0 && println(\"false and short-circuiting and\")\nOut[21]: false\n\nIn [22]: x&gt;0 || println(\"true and short-circuiting or\")\nOut[22]: true\n\nIn [23]: x&lt;0 || println(\"false and short-circuiting or\")\nfalse and short-circuiting or\n\n\n\n\n비트는 true 혹은 false 값을 갖는 정보 단위입니다. 아래의 표는 비트에 대한 연산자를 설명합니다.\n\n\n\n표현\nName\n\n\n\n\n~x\nbitwise not\n\n\nx & y\nbitwise and\n\n\nx | y\nbitwise or\n\n\nx ⊻ y\nbitwise xor (exclusive or)\n\n\nx ⊼ y\nbitwise nand (not and)\n\n\nx ⊽ y\nbitwise nor (not or)\n\n\nx &gt;&gt;&gt; y\nlogical shift right\n\n\nx &gt;&gt; y\narithmetic shift right\n\n\nx &lt;&lt; y\nlogical/arithmetic shift left\n\n\n\n\n⊻ 는 \\xor + 탭키, ⊼ 는 \\nand + 탭키, ⊽ 는 \\nor + 탭키 로 입력합니다. &gt;&gt;&gt; 나 &lt;&lt; 는 단순한 키보드 입력입니다.\n한국어 위키백과-비트연산 과 영어 위키백과-비트연산 을 참고하시기 바랍니다\nx&gt;&gt;y 의 경우는 정수 x 를 \\(2^y\\) 로 나눈 몫을 계산하는데 자주 사용됩니다. 예를 들어\n\nIn [24]: 15&gt;&gt;1 # 15 나누기 2^1=2 의 몫\nOut[24]: 7\n\nIn [25]: 427&gt;&gt;2 #427 나누기 2^2=4 의 몫\nOut[25]: 106\n입니다. 비트연산에 대해 편리한 함수로 입력값을 비트 문자열로 바꾸어주는 bitstring() 함수가 있습니다.\nIn [26]: bitstring(1)\nOut[26]: \"0000000000000000000000000000000000000000000000000000000000000001\"\n\nIn [27]: bitstring(3.23)\nOut[27]: \"0100000000001001110101110000101000111101011100001010001111010111\"\n\n\n\n\n비교 연산은 표현을 평가하여 true 혹은 false 를 반환합니다.\n\n\n\n표현\ntrue 인 경우\n\n\n\n\nx == y\nx 와 y 가 같을 때\n\n\nx != y, x ≠ y\nx 와 y 가 다를 때\n\n\nx &lt; y\nx 가 y 보다 작을 때\n\n\nx &lt;= y, x ≤ y\nx 가 y 보다 작거나 같을 때\n\n\nx &gt; y\nx 가 y 보다 클 때\n\n\nx &gt;= y , x ≥ y\nx 가 y 보다 크거나 같을 때\n\n\n\n\n≠ 는 \\ne+탭 키, ≤ 는 \\le+ 탭 키, ≥ 는 \\ge + 탭 키 를 통해 입력합니다.\n비교 연산을 1 &lt; 2 &lt;= 3 &lt; 5 != 10 &lt; 12 같이 이어서 쓸 수 있습니다. 모든 비교 항목이 true 일 때만 true 를 리턴합니다.\n\n특히 부동소수가 포함된 계산의 결과를 비교할때는 조심해야 합니다. Round-off 에러로 인해 오류가 발생 할 수 있습니다.\nIn [28]: 0 == 0.0\nOut[28]: true\n\nIn [29]: 4 == 4.0\nOut[29]: true\n\nIn [30]: 8.3-1.0 == 7.3\nOut[30]: false",
    "crumbs": [
      "Julia 언어의 기초",
      "연산자와 함수"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/03_functions_and_operators.html#함수",
    "href": "src/introduction_to_julia/03_functions_and_operators.html#함수",
    "title": "연산자와 함수",
    "section": "2 함수",
    "text": "2 함수\nJulia 에서의 함수는 많은 다른 언어들과 마찬가지로 함수명 뒤의 괄호 ( ) 안에 필요한 값들을 입력하여 함수를 실행시킵니다. 변수 a 에 대한 sin 함수값을 알고싶다면 sin(a) 로 입력합니다. 이 때 sin 이 함수 이름이며 함수에 입력되는 값 a 를 인자(argument) 라고 합니다. 인자는 값일수도 있고 문자열 혹은 다른 것일 수 있으며, 하나일 수도 있고 여러개일 수도 있습니다.\n\n수학 함수\nJulia 에서 제공 하는 함수 가운데 기본적인 함수를 소개합니다. 이 함수들의 정의와 사용법에 대해서는 관련 문서 를 참고하기 바랍니다.\n\n\n\n\n\n\n\n설명\n함수\n\n\n\n\n최대공약수, 최소공배수\ngcd, lcm\n\n\n절대값과 부호\nabs, abs2, sign, signbit, copysign, flipsign\n\n\n제곱근, 지수, 로그 관련\nsqrt, cbrt , hypot, exp, expm1, ldexp, log, log2, ,log10, exponent\n\n\n반올림, 올림, 내림 관련\nround, floor, ceil, trunc\n\n\n삼각함수\nsin, cos, tan, cot, sec, csc\n\n\n역 삼각함수\nasin, acos, atan, acot, asec, acsc\n\n\n쌍곡선 함수\nsinh, cosh, tanh, coth, sech, csch\n\n\n역 쌍곡선 함수\nasinh, acosh, atanh, acoth, asech, acsch\n\n\n기타\nsinc, cosc\n\n\n\n\n\n\n사용자 정의 함수\n예를 들어 두 값 x 와 y 를 입력 받아 두 값의 합을 반환하는 함수는 다음과 같이 정의합니다.\nfunction myadd(x, y)\n    return x+y\nend\n혹은 간단하게\nmyadd2(x, y) = x+y\n와 같이 정의할 수도 있습니다. 위의 myadd 와 myadd2 는 기능상 동일합니다.\n함수 정의는 function 으로 시작하여 함수 이름이 나오고 ( ) 안에 인자를 받는 변수와 그 정보를 나열합니다. 결과를 반환해야 할 경우 return 후에 반환해야 할 값이나 변수를 써 주고, end 로 끝납니다. return 이 나오면, 그 이후는 평가하지 않고 종료합니다.\nfunction myadd3(x)\n    return x+1\n    println(x+2)\nend\n에 대해 myadd3(3) 을 실행시키면 3+1=4 를 반환하고 종료하며 return 의 다음 명령인 println(x+2) 명령은 수행하지 않습니다.\n만약 함수 정의 안에 return 이 없다면 end 바로 앞의 표현식의 결과를 리턴합니다.\nfunction aa(a)\n    a+1\nend\n에 대해 b=aa(3) 을 수행하면 end 바로 앞의 a+1 을 리턴하므로 b==4 입니다. 만약 아무 것도 리턴하고 싶지 않다면 명시적으로 return nothing 이라고 해 주는 것이 좋습니다.\n\n\n\n익명함수 (람다함수)\n인자 -&gt; 반환하는 함수의 표현식 꼴로 선언되는 이름 없는 함수를 익명함수(anonymous function) 혹은람다 함수(lambda function) 이라고 합니다. 우선은 함수를 간단하게 정의하는 데도 사용합니다.\nIn [1]: sq = (x-&gt;x^2)\nOut[1]: #11 (generic function with 1 method)\n\nIn [2]: sq(3)\nOut[2]: 9\n\nIn [3]: sq(\"ab\")\nOut[3]: \"abab\"\nsq = (x-&gt;x^2) 를 봅시다. 오른쪽의 (x-&gt;x^2) 는 입력 x 에 대해 x^2 를 반환하는 익명 함수를 의미하며 sq = (x-&gt;x^2) 는 이 함수 객체를 sq 변수에 할당했습니다. 따라서 sq 는 함수이며 sq(3) 는 3^2 인 9 를 반환하고 sq(\"ab\") 는 \"ab\"^2==\"abab\" 를 반환합니다.\n익명 함수는 여려개의 인자를 가질 수도 있습니다.\nIn [4]: madd = (x, y) -&gt; x+y\nOut[4]: #13 (generic function with 1 method)\n\nIn [5]: madd(3, -2)\nOut[5]: 1\n익명함수를 위와 같이 사용하는 것은 다음과 같은 경우에 비해 이점이 없습니다.\nIn [10]: madd2(x,y) = x+y\nOut[10]: madd2 (generic function with 1 method)\n\nIn [11]: madd2(3, -2)\nOut[11]: 1\n익명함수는 map 함수에서의 익명함수의 사용 에서 볼 수 있듯이 map, reduce, 등에서 유용하게 사용됩니다. 또한 배열 comprehension 에서도 유용하게 사용 할 수 있습니다.\n\n\n\n익명 함수 : do ... end, begin ... end\n람다 함수 이외에 익명함수를 정의하는 방법은 do ... end 블럭과 begin ... end 블럭이 있습니다. 이것은 do ... end, begin ... end 의 사용 에서 좀 더 다루도록 하겠습니다.\n\n\n\n선택적 인자\n인자의 값을 입력하지 않아도 되는 인자를 선택적 인자(optional arguments) 라고 합니다.\n\n기본값이 있는 선택적 인자\n함수의 특정 인자에 대한 기본값을 정할 수 있으며 함수를 실행 할 때 이 인자에 값을 입력하지 않으면 기본값이 사용됩니다. 영어로는 Optional argument 라고 합니다. 예를 들어,\nmyadd3(x, y=1) = x+y\n와 같이 정의하면 y 를 입력하지 않았을 경우 즉 myadd(3) 으로 함수를 실행시켰을 경우 y=1 로 수행 됩니다. 즉 myadd(3)==4 입니다.\n\n\n\n기본값이 없는 선택적 인자\n실제로 코드상에서 기본값이 없는 선택적 인자는 없습니다. 일반적으로 기본값이 없는 선택적 인자는 인자의 값이 주어졌느냐 안주어졌느냐가 중요 할 때 사용합니다. 예를 들어 위의 myadd3 에서 myadd(2, 1) 과 myadd(2) 는 구별 할 수 없습니다. 인자가 선택되지 않았을 때 어떤 기능을 하고싶다면 어떻게 할까요? 특별히 인자가 특정 타입을 받는 경우라면? 이때는 보통 nothing 을 기본 인자로 놓습니다. 이 선택적 인자에 값을 입력한다면 정수여야 한다면 타입 유니온을 사용할 수 있습니다.\nfunction optional_arg(x, y::Union{Nothing, Integer} = nothing)\n    if y === nothing\n        return x^2\n    else\n        return x+y\n    end\nend\n이 경우 optional_arg(3) 은 y=nothing 으로 입력이 되기 때문에 \\(9\\) 를 반환하지만 optional_arg(3, 4) 는 y=4 로 입력이 되므로 3+4 인 7 이 반환됩니다.\nIn [10]: function optional_arg(x, y::Union{Nothing, Integer} = nothing)\n             if y === nothing\n                 return x^2\n             else\n                 return x+y\n             end\n         end\nOut[10]: optional_arg (generic function with 2 methods)\n\nIn [11]: optional_arg(3)\nOut[11]: 9\n\nIn [12]: optional_arg(3, 4)\nOut[12]: 7\n\n\n\n\n키워드 인자\n인자에 특정한 키워드를 반드시 사용하도록 정할 수도 있습니다. 함수의 정의에서 ; 으로 구분하여 ; 앞에는 순서대로 정해진 인자가, ; 에는 키워드로 정해진 인자가 오도록 합니다.\nIn [1]: function myfunc(x, y; color=\"red\")\n            println(\"color = $color, x=$x, y=$y\")\n        end\nOut[1]: myfunc (generic function with 1 method)\n\nIn [2]: myfunc(1, color=2, 3)  # 키워드로 정해진 인자는 인자 입력의 순서를 무시한다.\ncolor = 2, x=1, y=3\n\nIn [3]: myfunc(1, 2)\ncolor = red, x=1, y=2\n함수 호출에서 키워드로 정해진 인자는 인자의 입력 순서를 무시하며, 키워드가 없는 인자끼리의 순서대로 인자가 입력된다는 것을 알 수 있습니다.\n\n\n\n인자와 반환값의 타입 지정\n함수를 정의 할 때 인자나 반환값의 타입을 :: 연산자를 통해 지정 할 수 있습니다. 예를 들어,\nfunction mfunc(x::Int64)::Int64\n    return x+1\nend\n는 인자 x 의 타입을 Int64 로 지정하였으며, x 에 Int64 타입이 아닌 인자가 할당될 경우 에러가 발생합니다. 리턴값의 타입을 지정하는 경우는 약간 다른데 julia 는 리턴 값을 지정된 타입으로 변환시키려고 하며, 변환될 경우는 변환된 값을, 변환되지 않을 경우는 에러를 출력합니다. 예를 들어,\nfunction mfunc2(x)::Int64\n    return x/2\nend\n에서 mfunc2(1) 은 1/2 가 정수로 변환되지 않으므로 에러를 출력하지만 myfunc(2.0) 은 2.0/2 가 정수로 변환되므로 변환된 Int64 타입의 값 1 을 리턴합니다.\nIn [1]: function myfunc2(x)::Int64\n        return x/2\n        end\nOut[1]: myfunc2 (generic function with 1 method)\n\nIn [2]: myfunc2(1)\nERROR: InexactError: Int64(0.5)\n...\n\nIn [3]: myfunc2(2.0)\nOut[3]: 1\n\n여러분들은 타입에 너무 엄격한 것이 아니냐고 생각 할 수 있습니다. 만약 어떠 함수의 인자로 UInt8 이든 Int64 든 상관 없이 정수만을 받고 싶을 수도 있습니다. 이에 대한 방법은 타입의 계층 구조 에서 다루도록 하겠습니다.\n\n\n\n함수의 시그너쳐와 메서드\n함수 이름과 인자의 갯수, 각 인자의 타입의 정보를 함수의 시그너쳐(signature)라고 합니다. Julia 에서는 하나의 함수 이름으로 인자의 타입과 갯수에 따라 각각 다른 기능을 하게 할 수 있는데 이를 메서드(method)라고 합니다. 자세한 것은 메서드 다중 디스패치 에서 다루도록 하겠습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "연산자와 함수"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html",
    "href": "src/introduction_to_julia/05_control_flows.html",
    "title": "흐름 제어",
    "section": "",
    "text": "컨테이너를 순회하며 컨테이너에 포함된 아이템 만큼의 어떤 일을 수행하기 위한 구문입니다. 또한 컨테이너의 각 아이템을 이용한 계산과 명령을 수행 할 수 있습니다. 예를 들어 아래는 1 부터 100 까지의 합을 구하는 코드인데 for i ∈ 1:100 은 StepRange 타입인 1:100 의 각 성분들을 순서대로 i 라는 변수로 받아 end 까지의 명령을 수행한다는 의미입니다. 여기서 ∈ 는 in 으로 대체할 수 있습니다.\nnsum = 0\nfor i ∈ 1:100\n    nsum+= i\nend\n같은 크기의 컨테이너를 zip 명령어로 묶어서 동시에 순회할 수도 있습니다.\naa=(\"a\", \"b\", \"c\", \"d\")\nfor (a, v) in zip(aa, 1:4)\n    println(\"$a, $v\")\nend\n그 결과는 아래와 같습니다.\na, 1\nb, 2\nc, 3\nd, 4\n\nenumerate() 함수를 통해 인덱스 와 포함된 아이템을 같이 순회할 수도 있습니다다.\nfor (i, v) in enumerate(aa)\n    println(\"Index = $i, value = $v\")\nend\nIndex = 1, value = a\nIndex = 2, value = b\nIndex = 3, value = c\nIndex = 4, value = d\n\n사전 타입의 경우 key 와 value 를 다음과 같이 순회할 수 있습니다. 사전은 순서가 없으므로, 아래와 같은 경우에는 key 와 value 가 나오는 순서는 임의적이라고 생각해야 합니다.\ndict1 = Dict(\"a\"=&gt;1, \"b\"=&gt;2, \"c\"=&gt;3.3)\nfor (k, v) in dict1\n    println(\"Key = $k, value = $v\")\nend\nKey = c, value = 3.3\nKey = b, value = 2\nKey = a, value = 1\n\n컨테이너에 포함된 아이템의 수만큼 1부터 순회하고 싶다면 eachindex() 를 사용할 수 있습니다.\nfor i in eachindex((\"a\", \"b\", \"c\", \"d\"))\n    println(i)\nend\n\n\n\n구구단을 for 문을 써서 출력한다면 우선 다음과 같이 코드를 짤 수 있습니다.\nfor i in 2:9 \n    for j in 1:9\n        println(\"$i x $j = $(i*j)\")\n    end\nend\n하나의 for 문마다 하나의 end 가 필요합니다. Julia 는 다중 루프를 한 줄에 처리할 수 있게 해 줍니다. 아래의 코드는 위의 코드와 같은 일을 합니다.\nfor i in 2:9, j in 1:9\n    println(\"$i x $j = $(i*j)\")\nend",
    "crumbs": [
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#for-...-end",
    "href": "src/introduction_to_julia/05_control_flows.html#for-...-end",
    "title": "흐름 제어",
    "section": "",
    "text": "컨테이너를 순회하며 컨테이너에 포함된 아이템 만큼의 어떤 일을 수행하기 위한 구문입니다. 또한 컨테이너의 각 아이템을 이용한 계산과 명령을 수행 할 수 있습니다. 예를 들어 아래는 1 부터 100 까지의 합을 구하는 코드인데 for i ∈ 1:100 은 StepRange 타입인 1:100 의 각 성분들을 순서대로 i 라는 변수로 받아 end 까지의 명령을 수행한다는 의미입니다. 여기서 ∈ 는 in 으로 대체할 수 있습니다.\nnsum = 0\nfor i ∈ 1:100\n    nsum+= i\nend\n같은 크기의 컨테이너를 zip 명령어로 묶어서 동시에 순회할 수도 있습니다.\naa=(\"a\", \"b\", \"c\", \"d\")\nfor (a, v) in zip(aa, 1:4)\n    println(\"$a, $v\")\nend\n그 결과는 아래와 같습니다.\na, 1\nb, 2\nc, 3\nd, 4\n\nenumerate() 함수를 통해 인덱스 와 포함된 아이템을 같이 순회할 수도 있습니다다.\nfor (i, v) in enumerate(aa)\n    println(\"Index = $i, value = $v\")\nend\nIndex = 1, value = a\nIndex = 2, value = b\nIndex = 3, value = c\nIndex = 4, value = d\n\n사전 타입의 경우 key 와 value 를 다음과 같이 순회할 수 있습니다. 사전은 순서가 없으므로, 아래와 같은 경우에는 key 와 value 가 나오는 순서는 임의적이라고 생각해야 합니다.\ndict1 = Dict(\"a\"=&gt;1, \"b\"=&gt;2, \"c\"=&gt;3.3)\nfor (k, v) in dict1\n    println(\"Key = $k, value = $v\")\nend\nKey = c, value = 3.3\nKey = b, value = 2\nKey = a, value = 1\n\n컨테이너에 포함된 아이템의 수만큼 1부터 순회하고 싶다면 eachindex() 를 사용할 수 있습니다.\nfor i in eachindex((\"a\", \"b\", \"c\", \"d\"))\n    println(i)\nend\n\n\n\n구구단을 for 문을 써서 출력한다면 우선 다음과 같이 코드를 짤 수 있습니다.\nfor i in 2:9 \n    for j in 1:9\n        println(\"$i x $j = $(i*j)\")\n    end\nend\n하나의 for 문마다 하나의 end 가 필요합니다. Julia 는 다중 루프를 한 줄에 처리할 수 있게 해 줍니다. 아래의 코드는 위의 코드와 같은 일을 합니다.\nfor i in 2:9, j in 1:9\n    println(\"$i x $j = $(i*j)\")\nend",
    "crumbs": [
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#while-...-end",
    "href": "src/introduction_to_julia/05_control_flows.html#while-...-end",
    "title": "흐름 제어",
    "section": "2 while ... end",
    "text": "2 while ... end\nwhile 이후에 조건이 오고 그 조건이 참이면 end 까지 실행합니다. 1 부터 100 까지의 합을 구하는 코드를 while ... end 를 이용하여 구현해 봅시다.\nnsum = 0\nnn = 1\nwhile nn&lt;=100\n    nsum += nn\n    nn += 1\nend\nwhile ... end 를 쓸 때 조심할 것은 종료조건이 충족되지 않는 것입니다. for ... end 의 경우는 정해진 수의 컨테이너의 아이템만을 순회하므로 어쨌든 무조건 종료되지만 while ... end 의 경우는 종료되지 않는 무한루프에 빠질 수 있습니다.\n\n\n루프에서 벗어나기\n루프 수행 도중 벗어나고자 할 때는 break 를 씁니다. 예를 들어 1, 1/2, 1/3 과 같이 자연수의 역수를 계속 곱하다가 1/10000 보다 작아지는 첫번째 자연수를 구한다면, 1 부터 충분히 큰 수 (그 역수가 1/10000 보다 작은 수를 선택 할 수도 있다) 까지 루프를 수행하고 그 누적곱이 1/10000 보다 작을 때 break 로 루플에서 빠져나오면 됩니다.\nresult = 1.0\nfor n in 1:10000\n    result *=(1/n)\n    if result &lt; 1.0/10000\n        print(\"$n is the value\")\n        break\n    end\nend\nbreak 는 전체 루프에서 벗어나는 것이 아니라 break 를 포함하는 가장 인접한 루프로부터만 벗어납니다. 예를 들어,\nfor i in 1:10\n    for j in 1:10\n        println(\"i=$i, j=$j\")\n        if j &gt; 5\n            break\n        end\n    end\nend\n코드의 break 는 j&gt;5 일 때 break 되며, i 루프는 벗어나지 못하고 1 부터 10 까지 진행됩니다. 그러나,\nfor i in 1:10, j in 1:10\n    println(\"i=$i, j=$j\")\n    if j &gt; 5\n        break\n    end\nend\n는 i=1, j=6 에서 break 되어 멈춥니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#if-분기문",
    "href": "src/introduction_to_julia/05_control_flows.html#if-분기문",
    "title": "흐름 제어",
    "section": "3 if 분기문",
    "text": "3 if 분기문\n어떤 조건이 충족되는 지 여부를 따질 때 if ... elseif ... end 구문을 사용합니다. 어떤 수 x 에 대해 x&gt;0 이면 1 을 x&lt;0 이면 -1 을, x=0 이면 0 을 리턴하는 함수 msign(x) 를 만들어 봅시다.\nfunction msign(x)\n    if x&gt;zero(x)\n        return one(x)\n    elseif x&lt;zero(x) \n        return -one(x)\n    else\n        return zero(x)\n    end\nend\nzero(x) 는 x 의 타입에서의 0 값을 리턴하는 함수이며, one(x) 는 x 타입의 1 값을 리턴하는 함수입니다. x 는 어떤 값일 수도 있고 타입일 수도 있습니다. zero(1) 은 Int64 타입의 1 이며, one(Float32) 는 Float32 타입의 0.0 입니다. for, while 과 같이 if 블럭도 end 로 끝내야 합니다.\nif 블록에서 elseif 나 else 는 필요 없다면 생략해도 됩니다. 예를 들어 1 부터 100 까지의 정수 가운데 3의 배수만을 더한 합을 구한다고 하면,\nresult = 0\nfor i in 1:100\n    if i % 3 == 0\n        result += i\n    end\nend\n와 같이 사용 할 수 있습니다. i % 3 == 0 일 때만 result += i 를 수행하고 다른 경우는 아무 일도 수행하지 않습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#삼항-연산자-a-b-c",
    "href": "src/introduction_to_julia/05_control_flows.html#삼항-연산자-a-b-c",
    "title": "흐름 제어",
    "section": "4 삼항 연산자 a ? b : c",
    "text": "4 삼항 연산자 a ? b : c\na 는 true/false 를 따질 수 있는 조건이며, true 이면 b 를 실행시키고 false 이면 c 를 실행 시킵니다. 예를 들어, 절대값을 리턴하는 함수 mabs() 를 다음과 같이 짧게 구현 할 수 있습니다.\nmabs(x) = (x&gt;0) ? x : -x\n여기서 주의해야 할 것은 ? 와 : 각각의 앞, 뒤에 공백이 존재해야 한다는 것입니다. (x&gt;0)? x : -x 나 (x&gt;0)? x: -x 같은 것들은 에러를 발생시킵니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/05_control_flows.html#begin-...-end-블럭",
    "href": "src/introduction_to_julia/05_control_flows.html#begin-...-end-블럭",
    "title": "흐름 제어",
    "section": "5 begin ... end 블럭",
    "text": "5 begin ... end 블럭\nJulia 에서 한줄에 여러 명령을 처리하기 위해 ; 을 사용 할 수 있습니다. 예를 들어\nx=3;y=5;z=x+y\n는 세가지 명렁을 차례로 입력한 것과 같습니다. 이것을 begin ... end 블럭으로 묶을 수 있습니다.\nz = begin\n    x=3\n    y=5\n    x+y\nend",
    "crumbs": [
      "Julia 언어의 기초",
      "흐름 제어"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html",
    "href": "src/introduction_to_julia/07_module_package.html",
    "title": "이름공간, 모듈, 패키지",
    "section": "",
    "text": "프로그래밍할 때에는 많은 변수, 함수, 자료형의 이름이 필요합니다. 보통은 이름이 중복된다면 에러가 발생하거나 나중에 나오는 것이 앞에 나온 것을 삭제시키고 그 자리를 대신하게 되는데 이것은 큰 문제를 발생시킬 수 있습니다. 이런 것을 막기 위해 중복되지 않은 이름을 사용해야 하지만 코드가 길어지면 이것도 아주 골치아픈 일이 될 수 있습니다. 그래서 많은 프로그래밍 언어들이 이름공간(namespace)과 변수가 유효한 범위를 구현합니다. Julia 에서 이름공간은 뒤에 설명할 모듈(module) 마다 생성됩니다. Julia 가 실행될 때 Main 모듈로 실행되며, julia REPL 이나 Jupyter 에서도 Main 이 최상위 모듈입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#이름-공간과-변수의-범위",
    "href": "src/introduction_to_julia/07_module_package.html#이름-공간과-변수의-범위",
    "title": "이름공간, 모듈, 패키지",
    "section": "",
    "text": "프로그래밍할 때에는 많은 변수, 함수, 자료형의 이름이 필요합니다. 보통은 이름이 중복된다면 에러가 발생하거나 나중에 나오는 것이 앞에 나온 것을 삭제시키고 그 자리를 대신하게 되는데 이것은 큰 문제를 발생시킬 수 있습니다. 이런 것을 막기 위해 중복되지 않은 이름을 사용해야 하지만 코드가 길어지면 이것도 아주 골치아픈 일이 될 수 있습니다. 그래서 많은 프로그래밍 언어들이 이름공간(namespace)과 변수가 유효한 범위를 구현합니다. Julia 에서 이름공간은 뒤에 설명할 모듈(module) 마다 생성됩니다. Julia 가 실행될 때 Main 모듈로 실행되며, julia REPL 이나 Jupyter 에서도 Main 이 최상위 모듈입니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#모듈",
    "href": "src/introduction_to_julia/07_module_package.html#모듈",
    "title": "이름공간, 모듈, 패키지",
    "section": "2 모듈",
    "text": "2 모듈\n모듈은 어떤 기능과 관련된 값, 함수, 자료형 등의 모음입니다. 추상적인 개념이 아닌 julia 에 그 문법이 정의된 기능으로 아래의 예제 코드와 같이 module 로 시작해서 end 로 끝납니다. 모듈 안에는 다른 모듈이 포함 될 수 있습니다. 하나의 파일에 여러개의 모듈이 같이 있을 수도 있습니다.\nmodule mymodule1\n\nexport a, mf\na=2\nb=3\nfunction mf(x)\n    return x*2\nend\n\nend\n앞서 설명했듯이 모듈은 새로운 전역적인 이름공간을 만들 수 있습니다. 그 안에서 정의된 이름들은 다른 이름공간의 이름과 충돌할 염려 없이 사용 할 수 있습니다. 다른 이름공간에서 모듈의 이름을 사용하기 위해서는 우선 모듈 내에서 export 명령어를 통해 밖에서 사용 할 수 있는 이름을 지정해 줘야 합니다. 예를 들어\nIn [1]: module mymodule1\n        export a, mf\n        a=2\n        b=3\n        function mf(x)\n            return x*2\n        end\n        end\nOut[1]: Main.mymodule1\n이 모듈은 REPL 이 실행될 때 만들어지는 Main 이라는 전역적인 이름공간 내에 mymodule1 이라는 이름이 붙은 부분적인 이름공간을 만듭니다. 부분적 이름공간의 이름에 접근할 때는 . 으로 구분하여 Main.mymodule1.a 와 같이 접근하거나 전역적 이름공간을 제외한 mymodule1.a 와 같이 접근합니다. 예를 들어\nIn [2]: mymodule1.mf(3)\nOut[2]: 6\n는 mymodule1 모둘의 함수 mf 를 의미합니다.\n\n\nusing\nusing 명령어는 module 에서 export 명령어를 통해 지정한 이름들을 전역적 이름공간에서 사용 할 수 있게 해 줍니다.\nIn [6]: using .mymodule1\n\nIn [7]: a\nOut[7]: 2\n\nIn [8]: mf(3)\nOut[8]: 6\n\nIn [9]: mymodule1.b\nOut[9]: 3\n\nIn [10]: b\nERROR: UndefVarError: `b` not defined\nexport 를 통해 지정되지 않은 b 는 전역 이름공간에서 사용 할 수 없으며 굳이 접근하고자 하면 mymodule1.b 와 같이 접근해야 합니다.\n\n\n\nimport\nusing 명령어는 모듈 내의 이름을 전역적인 이름공간으로 가져오는데 비해 import 명령어는 모듈 이름만을 전역적인 이름공간으로 가져옵니다. 즉 import mymodule1 을 하면 mymodule1.a 나 mymodule1.mf 를 통해 접근해야 합니다. 그렇다면 단순히 REPL 에서 사용할 때는 차이가 없게 됩니다. 이 차이를 알기 위해 다음과 같은 내용을 mymodule.jl 파일로 저장합니다.\nmodule mymodule1\nexport a, mf\na=2\nb=3\nfunction mf(x)\n    return x*2\nend\nend\n\nmodule mymodule2\nexport b, mf\na=4\nb=5\nfunction mf(x)\n    return x*a*b\nend\n두 모듈 모두 mf 란 함수가 존재하며 export 되므로 충돌의 가능성이 있습니다.. 이제 julia REPL 에서 모듈이 있는 파일을 읽고 mf 함수를 실행시켜 봅니다.\nIn [1]: include(\"mymodule.jl\")\nOut[1]: Main.mymodule2\n\nIn [2]: using .mymodule1\n\nIn [3]: mf(1)\nOut[3]: 2\nIn [2] 에서는 mymodule1 모듈만을 반입했으므로 mf 함수는 mymodule1 모듈의 그것입니다.\nIn [4]: using .mymodule2\nWARNING: using mymodule2.mf in module Main conflicts with an existing identifier.\n\nIn [5]: b\nOut[5]: 5\n\nIn [6]: mf(3)\nOut[6]: 6\nusing .mymodule2 를 하면 충돌이 발생하기 때문에 julia 인터프리터는 경고합니다. b 는 mymodule2 에서 반입된 5 가 사용되며 mf 함수는 먼저 반입된 mymodule1 의 그것입니다. 이렇게 이름이 충돌하는 것은 중요한 오류를 발생시킬 수 있으므로 절대로 피해야 합니다. 이런 경우에는 import 를 사용하는 것이 하나의 방법입니다. 아래와 같이 import 다음에 . 을 앞에 붙이고 모듈 이름을 써서 반입하면 모듈 이름과 모듈 내의 이름을 . 으로 구분하여 사용 할 수 있습니다.\nIn [1]: include(\"mymodule.jl\")\nOut[1]: Main.mymodule2\n\nIn [2]: import .mymodule1\n\nIn [3]: import .mymodule2\n\nIn [4]: mymodule1.mf(1)\nOut[4]: 2\n\nIn [5]: mymodule2.mf(2)\nOut[5]: 40\n\n\n\nusing ... as, import ... as\n또 하나의 방법은 이름을 바꾸는 것입니다. usimg .mymodule1: a as a1, mf as mf1 이라고 하면 mymodule1 모듈의 a 를 전역적인 이름영역으로 반입하면서 그 이름을 a1 으로 바꾸며, mf 를 mf1 으로 이름을 바꿉니다. 이름울 바꾸지 않고 반입할 경우는 as ... 없이 이름만 쓰면 됩니다. 아래 코드의 In [2] 처럼 하면 됩니다.\nIn [1]: include(\"mymodule.jl\")\nOut[1]: Main.mymodule2\n\nIn [2]: using .mymodule1: a, mf as mf1\n\nIn [3]: a\nOut[3]: 2\n\nIn [4]: mf\nERROR: UndefVarError: `mf` not defined\n...\n\nIn [5]: mf1\nOut[5]: mf (generic function with 1 method)\n\nIn [6]: using .mymodule2:b, mf as mf2\n\nIn [7]: b\nOut[7]: 5\n\nIn [8]: mf2(a)\nOut[8]: 40\n\nIn [9]: mf1(1)\nOut[9]: 2\n이름을 바꾸는 것은 이름의 중복을 방지하는데도 사용되지만, 긴 이름을 짧게 해서 편리하게 쓰고자 할 경우나, 짧은 이름을 명확하게 하기위해 긴 이름으로 바꿀 때도 사용할 수 있습니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#변수의-범위",
    "href": "src/introduction_to_julia/07_module_package.html#변수의-범위",
    "title": "이름공간, 모듈, 패키지",
    "section": "3 변수의 범위",
    "text": "3 변수의 범위\n모듈을 통해 이름공간과 다른 이름공간을 현재의 이름공간으로 반입하는 법을 알아보았습니다. 이름공간 내에서 사용 할 수 있는 변수를 전역적(global) 이라고 합니다. 반대로 이름공간 내의 특정 부분에서만 사용할 수 있는 변수를 지역적(local) 이라고 합니다. 변수가 유효한 지역적인 범위를 만들어 낼 수 있는 코드 영역을 블럭 (block)이라고 합시다. 대표적으로 함수를 정의하는 function ... end 구문이나 흐름 제어문인 for ... end 구문입니다. 이들은 그 내에서만 유효한 변수를 선언 할 수 있습니다.\n이제 이름 공간 내에서 변수의 범위를 알아봅시다. 아래 코드를 수행하기 전에 i 와 j 라는 변수를 할당하지 않았다고 합시다.\nfor i in 1:10\n    j=i+1\nend\n이 때 i 나 j 는 for ... end 블럭 밖에서는 접근 할 수 없으며, 접근하려고 하면 ERROR: UndefVarError 에러가 발생합니다.\n그러나 아래 코드와 같이 미리 j 변수를 정해둔 경우에는 j 변수는 for ... end 블럭 안에서 그대로 적용됩니다.\nj=0\nfor i in 1:10\n    j=i+1\nend\nprintln(\"j=$j\")\n\n이젠 함수의 경우를 봅시다.\nIn [1]: j=4\nOut[1]: 4\n\nIn [2]: function mf1(x)\n        k = x+j\n        return k\n        end\nOut[2]: mf1 (generic function with 1 method)\n\nIn [3]: mf1(5)\nOut[3]: 9\n\nIn [4]: k\nERROR: UndefVarError: `k` not defined\n위의 코드에서 j 는 전역적 범위에서 4 를 할당받았습니다\\(^\\ast\\). mf1 이라는 함수 안의 k 라는 변수는 함수 내부에만 영항을 끼칠 수 있습니다. 그러나 j 는 전역변수이므로 함수 내의 j 는 함수 밖의 j 와 동일합니다. \\(^\\ast\\) 함수 내에서 인자로 주어지지 않은 함수 밖의 변수를 사용하는 것은 대부분의 경우 피해야 할 습관입니다. 이 경우는 무조건 인자로 전달해서 함수에서 처리해야 하지만, 변수 범위를 설명하기 위해 억지로 예를 든 것입니다.\n\nIn [4]: function mf2(x)\n        k = x+1\n            function mf3(y)\n                return (k+1)\n            end\n            return mf3(x+1)\n        end\n\nOut[4]: mf2 (generic function with 1 method)\n\nIn [5]: mf2(3)\nOut[5]: 5\nmf2 함수 정의 안에서는 새로운 지역적 변수들을 정의 할 수 있으며 mf3 는 mf2 안에서 더 지역적인 변수들을 만들 수 있습니다. k 는 mf2 함수 내에서 정의되었기 때문에 mf3 함수 정의 내에서 사용 할 수 있습니다. 이렇게 변수의 범위는 계층적입니다. 최상위에 전역적인 이름들이 있으며, 그 하위 범위마다 지역적인 변수를 사용 할 수 있습니다. 하위의 블럭에서는 상위의 변수를 사용 할 수 있습니다. 필요하다면 지역적 블럭에서 전역적인 혹은 상위의 블럭의 변수와 같은 이름을 갖지만 별도로 동작하는 이름을 만들 수 있습니다\\(^\\ast\\).  하지만 혼동을 일으키며, 이러한 혼동은 에러의 큰 원인이 되기 때문에 되도록이면 피해야 할 것입니다.\\(^\\ast\\) 이렇게 상위 이름공간에서 정의된 이름을 하위 이름공간에서 별도로 사용할 때, 해당하는 상위 이름공간의 이름의 효과를 일시적으로 멈추는 것을 shadowing 이라고 합니다.\n\n\n영역 타입\n전역적 혹은 지역적 범위의 변수를 생성 할 수 있는 블럭은 다음과 같습니다.\n\n\n\n\n\n\n\n\nConstruct\n영역 타입\n혀용되는 이름공간\n\n\n\n\nmodule, baremodule\n전역\n전역\n\n\nstruct\n지역 (soft)\n전역\n\n\nfor, while, try\n전역, 지역 (soft)\n전역\n\n\nmacro\n지역 (hard)\n전역\n\n\nfunctions, do 블럭, let 블럭, comprehensions, generators\n지역 (hard)\n전역, 지역\n\n\n\n여기에 빠진 begin 블럭과, if 블럭은 영역 변수를 만들 수 없습니다. 즉 이 두 블럭 내에서 변수를 선언하더라도 상위 영역의 변수에 포함됩니다.\n상위 범위의 이름은 하위 범위에서 사용 할 수 있습니다. 문제는 상위 범위에 있는 이름과 같은 이름을 하위 범위에서 사용할 때 이며 크게 두가지로 나눌 수 있겠습니다.\n\n상위 범위 변수를 그대로 사용하고 싶을 때.\n상위 변수와 같은 이름을 가진 변수를 별도로 하위 범위에서 사용하고 싶을 때.\n\n2번의 경우는 굳이 상위 변수와 같은 이름을 사용한다기 보다는, 상위 범위에 많은 변수명과 연산이 얽혀 있는데 그것을 일일이 확인하고 싶지 않을 때에 발생한다고 볼 수 있겠습니다. 이때는 local 을 사용하면 되는데 이후 설명하겠습니다.\n상위 범위에서 v=1 이라고 이름을 할당 했다고 합시다. 하위 범위에서 v=2 라고 변수를 명시적으로 할당 했다면 하위 이름공간의 영역에서는 v==2 이며 상위 이름공간의 v 는 가려집니다. 그런데 변수에 값을 할당 하지 않고 w=v+2 와 같이 v 의 값을 사용 할 때의 성질에 따라 hard scope 와 soft scope 로 나뉩니다.\n\nHard scope 의 경우 : 해당 하위 이름공간에 지역적 범위의 변수 v 가 생성됩니다.\n\nIn [1]: v=1\nOut[1]: 1\n\nIn [2]: function myfunc1(x)\n            println(\"in myfunc1, v+x=\", v+x)\n        end\nOut[2]: myfunc1 (generic function with 1 method)\n\nIn [3]: function myfunc2(x)\n            v=3 # local variable 이 생성됩니다. shadowing !!\n            println(\"in myfunc1, v=3, v+x=\", v+x)\n        end\nOut[3]: myfunc2 (generic function with 1 method)\n\nIn [4]: myfunc1(3)\nin myfunc1, v+x=4\n\nIn [5]: myfunc2(3)\nin myfunc1, v=3, v+x=6\n\nIn [6]: v\nOut[6]: 1\n\nSoft scope 의 경우\n\nJulia REPL 이나 jupyter 와 같이 interactive mode 일 경우에는 상위 범위의 변수 v 가 할당됩니다.\nInteractive mode 가 아닐경우에는 경고가 출력되며 하위 범위의 변수 v 가 생성됩니다.\n\n\n\n\n연습문제 1 for ... end 는 soft scope 입니다. 아래의 코드를 파일로 저장하고 julia 로 실행시켜보고 어떤 경고(Warning) 가 출력되는지 확인해 봅시다. Julia REPL 이나 jupyter 로 실행시켜 봅시다.\nv=10\nfor i in 1:10\n    v=i\nend\n\n\n\n\nlocal\n다음 코드를 봅시다.\nv1 = 0\nv2 = 3\nif v2 &lt; 5 \n    v1 = v2+1\n    x = sin(v1)\nend\n이미 v1=0 라고 선언되었으며 if 문의 분기조건을 충족하기 때문에 위 코드의 실행이 끝나면 v1=4 가 됩니다. 그런데 당신이 실제로 원하는 것은 v1 값을 바꾸는 것이 아니라 단지 sin(v2+1) 을 계산하는 것이었다고 합시다. 코드가 길거나 많은 변수가 복잡하게 계산되고 있다면 이런 일이 벌어질 수 있습니다. 이 때 변수 할당 앞에 local 키워드를 놓으면 이 변수는 더 상위 범위의 같은 이름의 변수와 내부적으로 다르게 처리하며, 상위 범위의 미리 선언된 변수의 값에 영향을 주지 않습니다. 즉\nv1 = 0\nv2 = 3\nif v2 &lt; 5 \n    local v1 = v2+1\n    x = sin(v1)\nend\n를 실행시키고 난 뒤에도 v1 == 0 입니다. local 키워드는 전역적으로 어떤 변수가 선언되었더라도 지역적인 변수를 만들어서 그 변수를 사용하며, 전역적인 변수는 건드리지 않도록 합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/07_module_package.html#패키지",
    "href": "src/introduction_to_julia/07_module_package.html#패키지",
    "title": "이름공간, 모듈, 패키지",
    "section": "4 패키지",
    "text": "4 패키지\n패키지는 모듈들과 모듈들을 관리하고 테스트하기위한 여러 파일들의 모음입니다. 공식적으로 지원되는 패키지들은 https://juliapackages.com 에서 확인 할 수 있습니다.\nJulia 를 설치하면 기본적으로 많은 자료형과 함수들도 같이 설치되지만 이것만으로는 충분하지 않습니다. 어떤 패키지는 Julia 언어와 함께 제공되며, 어떠 패키지는 패키지 관리자 Pkg.jl 을 이용하여 설치할 수 있습니다. Julia 의 패키지들은 Github 저장소에서 관리됩니다.\n\n패키지 추가\n패키지를 추가하는 방법은 두가지가 있습니다. 우선은\nusing Pkg\n를 실햄합니다. Pkg 는 패키지를 관리해주는 패키지로 기본적으로 julia 에 포함된 패키지 입니다. using Pkg 는 이제 Pkg 패키지에 포함된 여러 값, 함수, 자료형 등을 사용수 있도록 julia 에게 준비하라는 뜻입니다. 패키지 설치는 Pkg.add 함수를 사용합니다. 예를 들어 코드의 수행을 분석해주는 BenchmarkTools 를 설치한다면\nPkg.add(\"BenchmarkTools\")\n를 실행시키면 됩니다. 보통 하나의 패키지는 다른 패키지를 필요로 하는데 이 필요성 관계를 의존성(dependency) 이라고 합니다. Julia 는 자동적으로 이 패키지를 설치하는데 필요한 다른 패키지도 설치합니다. 패키지 설치가 성공하면\nusing BenchmarkTools\n명령문을 통해 BenchmarkTools 패키지의 여러 기능을 사용 할 수 있습니다.\n\n\n\n패키지 update\n보통 널리 사용되는 패키지는 끊임없이 개선됩니다. 이것을 update 라고 하며\nPkg.update()\n명령어는 이미 설치된 패키지 전체를 자동적으로 업데이트 합니다. 설치된 패키지가 많으면 몇분 정도의 시간이 걸릴 수도 있습니다.\n\n\n\n패키지 제거\nBenchmarkTools 패키지를 제거할때는 Pkg.rm(\"BenchmarkTools\") 명렬어를 수행하면 됩니다. 만약 제거하고자 하는 패키지에 의존하는 다른 패키지가 존재한다면 제거 할 수 없습니다. 억지로 제거할 수는 있지만 추천하지 않습니다. 다른 패키지를 먼저 제거하고 제거하십시요.\n\n\n\n패키지의 사용\n앞의 모듈의 사용과 마찬가지로 using 혹은 import 명령문을 사용합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "이름공간, 모듈, 패키지"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10_metaprogramming_and_macro.html",
    "href": "src/introduction_to_julia/10_metaprogramming_and_macro.html",
    "title": "메타프로그래밍과 매크로",
    "section": "",
    "text": "메타프로그래밍은 프로그램 실행중에 자기 자신 혹은 다른 프로그램을 읽고 수정하고 실행할 수 있는 기술을 말합니다. Julia 처럼 어떤 언어가 자기 자신을 메타프로그래밍 하는것을 reflection 이라고 합니다. Julia 에서는 메타프로그래밍이 macro 를 통해 구현됩니다. Julia 에서의 메타프로그래밍과 매크로를 이해하기 위해서는 소스코드가 어떻게 실행되는지 그 과정을 이해해야 합니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "메타프로그래밍과 매크로"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10_metaprogramming_and_macro.html#표현식",
    "href": "src/introduction_to_julia/10_metaprogramming_and_macro.html#표현식",
    "title": "메타프로그래밍과 매크로",
    "section": "1 표현식",
    "text": "1 표현식\n\n표현식의 생성\n\nMeta.parse\nJulia 에서 소스코드의 실행은 소스코드의 문자열을 파싱(parsing) 하여 Expr 객체인 표현식(expression) 을 만드는데서 시작합니다. 문자열을 표현식으로 바꾸는 함수는 Meta.parse 입니다. `\nIn [1]: ex1 = Meta.parse(\"1+2\")\nOut[1]: :(1 + 2)\n\nIn [2]: typeof(ex1)\nOut[2]: Expr\n\nIn [3]: ex1.head\nOut[3]: :call\n\nIn [4]: ex1.args\nOut[4]: 3-element Vector{Any}:\n  :+\n 1\n 2\nExpr 객체는 head 와 args 라는 두 부분으로 나뉩니다. head 는 Symbol 타입으로 표현식의 종류를, args 는 표현식에 사용되는 Symbol, 값, 구문 등을 의미합니다. 앞서 ex1.head 가 :call 인데 이것은 함수, 혹은 연산자 호출이라는 것을 의미합니다. 아래의 코드에서 보듯이 함수 호출이 아닌 할당에서는 head 가 :(=) 로 바뀝니다.\nIn [5]: ex2=Meta.parse(\"a=2\")\nOut[5]: :(a = 2)\n\nIn [6]: ex2.head, ex2.args\nOut[6]: (:(=), Any[:a, 2])\n\n표현식은 eval 함수를 통해 실행 할 수 있습니다.\nIn [8]: eval(ex1)\nOut[8]: 3\n\n\n\nQuoting\n우리는 앞서 심볼 타입 에서 a=:b 와 같이 : 를 사용하여 심볼 타입을 정의하는 것을 보았습니다. : 로 시작하는 구문은 심볼 타입 뿐만 아니라 표현식도 생성합니다. Out[1] 에서 보듯이 : 로 시작하여 ( ) 안에 표현된 구문은 표현식을 정의합니다. 이렇게 :( ) 를 이용하여 표현식을 정의하는 것을 quoting 이라고 합니다.\nIn [1]: ex1 = :(a=1+2)\nOut[1]: :(a = 1 + 2)\n\nIn [2]: ex2 = Meta.parse(\"a=1+2\")\nOut[2]: :(a = 1 + 2)\n\nIn [3]: ex1==ex2\nOut[3]: true\n\nIn [4]: eval(ex1)\nOut[4]: 3\n\nIn [5]: a\nOut[5]: 3\n\n\n표현식의 내부\n이제 표현식이 내부적으로 어떻게 구성되는지를 봅시다. 보통 두가지 방법이 있습니다. 하나는 dump 함수를 통해 들여쓰기와 참조 표시를 포함하여 출력하는 것입니다.\nIn [7]: dump(ex1)\nExpr\n  head: Symbol =\n  args: Array{Any}((2,))\n    1: Symbol a\n    2: Expr\n      head: Symbol call\n      args: Array{Any}((3,))\n        1: Symbol +\n        2: Int64 1\n        3: Int64 2\n다른 하나는 S-표현식 의 형태로 보는 것으로 Meta.show_sexp 함수를 이용합니다.\nIn [8]: Meta.show_sexpr(ex1)\n(:(=), :a, (:call, :+, 1, 2))\n\n\n\n:( ) 안에 값이 있는 경우\n한가지 유의해야 할 것은 표현식에 :(3) 처럼 :( ) 안에 값을 넣는다면 표현식이 아닌 값이 됩니다.\nIn [12]: :(3)\nOut[12]: 3\n\nIn [13]: :(3.34)\nOut[13]: 3.34\n\nIn [14]: :(\"aBγΔ\")\nOut[14]: \"aBγΔ\"\n\n\n\n\n\nquote ... end\n앞서 알아본 것처럼 :( ) 를 이용한 quting 을 통해 표현식을 정의 할 수 있으며 단순한 표현식에 적합합니다. 좀 더 복잡한 표현식을 위해서는 quote ... end 블럭을 다음과 같이 사용 할 수 있습니다.\nex = quote\n    x = 1\n    y = 2\n    x + y\nend\nex 는 :(x=1;y=2;x+y) 와 같습니다.\n\n\n\n표현식의 보간법\n\n$ 를 이용한 보간\n$ 를 이용한 문자열 보간처럼 $ 를 이용하여 표현식을 보간 할 수 있습니다.\nIn [1]: a=1;\n\nIn [2]: ex1 = :(b=$a+3)\nOut[2]: :(b = 1 + 3)\nex1 표현식 내의 $a 는 즉시 a 라는 변수가 가진 값 1 로 치환됩니다. $ 로 보간하지 않았을 경우에는 a 변수의 값이 바뀔 경우 그 결과가 달라집니다.\nIn [3]: ex2 = :(b=a+3)\nOut[3]: :(b = a + 3)\n\nIn [4]: eval(ex1), eval(ex2)\nOut[4]: (4, 4)\n\nIn [5]: a=4; eval(ex1), eval(ex2)\nOut[5]: (4, 7)\n앞서 말했듯이 $ 로 보간했을 때는 즉시 변수가 현재의 값으로 치환됩니다. 따라서 ex1 에는 변수 a 의 흔적이 남아 있지 않습니다. 그러나 $ 로 보간되지 않은 ex2 는 eval 함수가 실행 될 때의 a 값이 입력되므로 그 값이 바뀌게 됩니다.\nIn [6]: Meta.show_sexpr(ex1)\n(:(=), :b, (:call, :+, 1, 3))\n\nIn [7]: Meta.show_sexpr(ex2)\n(:(=), :b, (:call, :+, :a, 3))\n\n\n\n스플래팅 보간\n$ 를 이용한 보간은 한번에 하나의 표현식만 보간합니다. 앞서 알아본 … 연산자 처럼 표현식의 배열을 이용하여 한꺼번에 보간 할 수 있습니다.\nIn [1]: exprs = [:a, :b, :c]\nOut[1]: 3-element Vector{Symbol}:\n :a\n :b\n :c\n\nIn [2]: :(f(1, $(exprs...)))\nOut[2]: :(f(1, a, b, c))\n\n\n\n중첩된 quote\n앞서 우리는 표현식의 보간을 알아보았습니다. 표현식 또한 표현식에 보간 될 수 있습니다. 다음을 봅시다.\nIn [1]: ex = :(1+2);\n\nIn [2]: ex1 = quote $ex end\nOut[2]: quote\n    #= REPL[2]:1 =#\n    1 + 2\nend\n\nIn [3]: eval(ex1)\nOut[3]: 3\n\nIn [4]: ex2 = quote ex end\nOut[4]: quote\n    #= REPL[4]:1 =#\n    ex\nend\n\nIn [5]: eval(ex2)\nOut[5]: :(1 + 2)\n\nIn [6]: eval(eval(ex2))\nOut[6]: 3\nex 는 표현식이며 ex1 은 quoto ... end 안에 $ex 즉 1+2 라는 식을 삽입합니다. 따라서 ex1 은 quote 1+2 end 와 같습니다. ex2 는 quote ... end 안에 :(1+2) 를 삽입합니다. 따라서 ex2 는 quote :(1+2) end 와 같으며, eval(ex2) 는 (1 + 2) 를 반환합니다. 아래의 ex3 는 당연히 quote ex end 와 같습니다.\nIn [8]: ex3 = quote quote $ex end end\nOut[8]: quote\n    #= REPL[8]:1 =#\n    $(Expr(:quote, quote\n    #= REPL[8]:1 =#\n    $(Expr(:$, :ex))\nend))\nend\n\n\n\n\nQuoteNode\n\n\n\n함수를 호출하는 표현식\n두 수의 최대공약수를 구하는 함수는 gcd 입니다. 즉 gcd(4, 6) 은 2 입니다. 이 표현식에 대한 S-표현식은 다음과 같습니다.\nIn [1]: ex1 = :(gcd(4, 6))\nOut[1]: :(gcd(4, 6))\n\nIn [2]: Meta.show_sexpr(ex1)\n(:call, :gcd, 4, 6)\nS- 표현식을 이용하여 ex1 과 같은 표현식을 Expr(:call, :gcd, 4, 6) 을 통해 만들 수 있습니다.\nIn [3]: ex3 = Expr(:call, :gcd, 4, 6)\nOut[3]: :(gcd(4, 6))\n\nIn [4]: eval(ex3)\nOut[4]: 2\n즉 인자 op1, op1 를 받는 함수 func1 을 호출하는 표현식은 Expr(:call, :func1, op1, op2) 입니다. 만약 인자가 많아지면 계속 , 로 이어 쓰면 됩니다.",
    "crumbs": [
      "Julia 언어의 기초",
      "메타프로그래밍과 매크로"
    ]
  },
  {
    "objectID": "src/introduction_to_julia/10_metaprogramming_and_macro.html#매크로",
    "href": "src/introduction_to_julia/10_metaprogramming_and_macro.html#매크로",
    "title": "메타프로그래밍과 매크로",
    "section": "2 매크로",
    "text": "2 매크로\n매크로는 인자를 받아 표현식을 반환하는 특별한 타입의 함수라고 볼 수 있습니다. mymacro 라는 함수에 인자로 ag1, ag2 를 입력 할 때 @mymacro(ag1, ag2) 혹은 @mymacro ag1 ag2 와 같이 실핼 시킬 수 있습니다. 좀 더 자세히 알아봅시다.\n\n매크로와 함수의 차이\n매크로에 인자를 입력 할 수 있으며, 역시 함수와 유사합니다. 그러나 매크로는 함수와 다른 몇가지 차이점이 존재합니다.\n\n매크로는 전역 범위 내에서만 정의 될 수 있습니다.\n매크로의 인자는 매크로 내부에서 인자에 대한 표현식으로 바뀝니다.\n매크로의 반환값은 표현식이며 반환값을 값으로 반환하지 않고 실행합니다.\n매크로는 함수처럼 괄호 안에 인자를 나열할 수도 있으며, 괄호 없이 공백으로 구분하여 나열할 수도 있습니다.\n\n\n1은 매크로가 함수 정의 안이나 for ... end 같은 블럭 내부에서 정의될 수 없다는 것을 말합니다. 함수는 이와 반대로 함수 내부나 블럭 내부에서 정의 될 수 있습니다.\n\n\n매크로의 정의와 반환값\n매크로는 인자들을 받아 표현식을 반환하는 함수를 의미합니다. 매크로는 함수와 비슷하게 macro ... end 구문으로 정의하며, 매크로 이름 앞에 @ 를 붙여 실행 할 수 있습니다.\nIn [1]: macro hello_world()\n            return :(println(\"Hello, world!\"))\n        end\nOut[1]: @hello_world (macro with 1 method)\n\nIn [2]: @hello_world()\nHello, world!\n\n\n\n매크로의 인자\n우선 매크로에 전달되는 인자가 매크로 내부에서 어떻게 되는지 알아봅시다.\nIn [1]: macro hello_world(your_name)\n            println(\"In macro, arg is = \", your_name, \", and the type is \", typeof(your_name))\n            return :(println(:\"Hello, world! I'm \", $your_name))\n        end\nOut[1]: @hello_world (macro with 1 method)\n\nIn [2]: @hello_world(\"Julia\")\nIn macro, arg is = Julia, and the type is String\nHello, world! I'm Julia\n\nIn [3]: @hello_world(1+1)\nIn macro, arg is = 1 + 1, and the type is Expr\nHello, world! I'm 2\nIn [3] 를 봅시다. 인자로 1+1 을 넣었을 때 macro 내부에서는 Expr 객체인 :(1+1) 로 인식이 된다는 것을 알 수 있습니다. In [2] 의 경우처럼 식이 아닌 값을 넣는 경우는 앞에서 언급했듯이 표현식이 값으로 바뀝니다.\n\n\n\n매크로의 반환값과 macroexpand 매크로\n매크로는 정의상 표현식을 반환하지만 실제로는 반환되는 표현식을 실행합니다. 표현식을 반환받기 위해서는 macroexpand 라는 매크로를 사용합니다.\nIn [10]: @macroexpand(hello_world(\"Julia\"))\nOut[10]: :(hello_world(\"Julia\"))\n@macroexpand 는 매크로 분석에 아주 유용한 메크로입니다. 앞으로 @macroexpand 와 같이 @ 로 시작하는 이름은 별다른 설명이 없다면 매크로를 의미합니다.\n\n\n\n매크로 실행시 인자의 입력\n매크로는 인자를 함수처럼 ( ) 안에 넣어서 전달 할 수도 있지만 매크로 이름 뒤와 인자들 사이에 공백을 두고 나열 할 수 있습니다.\nIn [1]: macro club_members(mem1, mem2, mem3)\n            return :(println(\"Members are : \", $mem1, \", \", $mem2, \", \", $mem3))\n            end\nOut[1]: @club_members (macro with 1 method)\n\nIn [2]: @club_members(\"John\", \"Jenny\", \"Jucy\")\nMembers are : John, Jenny, Jucy\n\nIn [3]: @club_members \"Henny\" \"Mark\" \"Tony\"\nMembers are : Henny, Mark, Tony\n\n\n\n\n@assert 매크로\n개인적으로 많이 사용하는 매크로입니다. @assert 매크로는 인자로 true 나 false 를 판별하는 표현식과 문자열을 받으며 표현식이 true 일 경우는 아무것도 하지 않고 false 일 경우는 에러를 내며 프로그램을 정지합니다. @assert 매크로는 built-in 이므로 julia 에서 추가 패키지 설치 없이 실행 할 수 있습니다.\nIn [1]: @assert 2==3 \"에러 메시지\"\nERROR: AssertionError: 에러 메시지\n...\n2==3 은 거짓이므로 에러를 발생시킵니다. 에러에는 여러 종류가 있으며 여기서는 AssertionError 를 발생시켰습니다. 에러를 발생시킬 때는 추가 메시지를 출력 할 수 있는데 @assert 의 두번째 인자가 바로 추가메시지 입니다. @macroexpand 를 통해 @assert 가 반환하는 표현식을 봅시다.\nIn [22]: @macroexpand @assert a==b\nOut[22]: :(if a == b\n      nothing\n  else\n      Base.throw(Base.AssertionError(\"a == b\"))\n  end)\n자 이제 이것과 같은 일을 하는 매크로를 작성 해 봅시다. 실제 @assert 매크로와는 다를 수 있지만 거의 똑같이 작동합니다.\nIn [1]: macro myassert(ex, msgs...)\n            msg = ((isempty(msgs) ? ex : msgs[1]) |&gt; string)\n            return :($ex ? nothing : AssertionError($msg))\n        end\nOut[1]: @myassert (macro with 1 method)\n\nIn [2]: @myassert 3&gt;4 \"맞을 경우는 메시지가 출력되지 않음\"\nOut[2]: AssertionError(\"맞을 경우는 메시지가 출력되지 않음\")\n\nIn [3]: @myassert 3&lt;4 \"맞을 경우는 메시지가 출력되지 않음\"\n\n\n\n청결한 매크로\n매크로에 전달되는 표현식이 매크로를 오염시킬 수 있습니다. 다음의 코드를 봅시다.\nmacro mm(ex)\n    return quote\n        t = 1\n        println(\"표현식 평가 이전 t = \", t)\n        val = $ex\n        println(\"표현식 평가 이후 t = \", t, \", val = \", val)\n        return val\n    end\nend\n@mm t=100 으로 실행시키면 다음과 같은 출력을 얻습니다.\n표현식 평가 이전 t = 1\n표현식 평가 이후 t = 100, val = 100\n100\n코드의 5 번째 줄 val = $ex 에서 실제로 수행하는 것은 val = t = 100 이며, t 와 val 모두 100 이 됩니다. 이 때 사용될 수 있는 것이 esc 함수입니다. esc 함수는 매크로 내에서만 사용 할 수 있는 함수로, 표현식을 평가할 때 내부 변수의 오염을 막아줍니다. 이제 다음 코드를 봅시다.\nmacro nn(ex)\n    return quote\n        t = 1\n        println(\"표현식 평가 이전 t = \", t)\n        val = $(esc(ex))\n        println(\"표현식 평가 이후 t = \", t, \", val = \", val)\n        val\n    end\nend\n@mm 과 @nn 의 차이는 5번째 줄에 esc 함수를 사용했다는 것 뿐입니다. @nn t=100 을 실행하면 우리가 원했던 오염되지 않은 결과를 얻습니다.\n표현식 평가 이전 t = 1\n표현식 평가 이후 t = 1, val = 100\n100\n\n\n\n코드 생성\n예를 들어 당신이 Float64 형태의 값에 대한 특별한 타입을 필요로 한다고 합시다. 이 값은 일반적인 실수에 대해 sin 과 cos 값이 바뀌고, 따라서 tan 와 cot 함수값이 바뀌어야 한다고 합시다. 실제로 이런 타입이 필요한지는 모르겠지만 일단은 연습입니다. 새로운 타입을 XNum 이라고 합시다. 물론 sin(v::XNum) = cos(v.val) 과 같이 네 함수에 대해 정의 할 수 있지만 표현식을 이용하여 다음과 같이 일괄적으로 바꿔 줄 수 있습니다.\nstruct XNum\n    val::Real\n\n    function XNum(v::Real)\n        return new(Float64(v))\n    end\nend\n\nfor (op1, op2) ∈ zip((:sin, :cos, :tan, :cot), (:cos, :sin, :cot, :tan))\n    eval(quote\n        Base.$op1(a::XNum) = XNum($op2(a.val))\n    end)\nend\nfor ... 문 안의 eval(ex::Expr) 함수는 표현식 ex 를 실행시키며 이것은 @eval 매크로를 사용하여 다음과 같이 쓸 수 있습니다.\nfor (op1, op2) ∈ zip((:sin, :cos, :tan, :cot), (:cos, :sin, :cot, :tan))\n    @eval Base.$op1(a::XNum) = XNum($op2(a.val))\nend",
    "crumbs": [
      "Julia 언어의 기초",
      "메타프로그래밍과 매크로"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html",
    "href": "src/application_of_julia/performance_tips.html",
    "title": "Julia 성능 팁",
    "section": "",
    "text": "노트\n\n\n\n\nJulia Performace Tips 2024.11.15 버젼의 번역 & 요약 등등등.\n개인용으로 작성한 문서임. 보는것은 자유지만 오탈자 등의 오류는 장담 못함.\n다음에 나오는 섹션들에서는 Julia 코드를 가능한한 빠르게 실행시키는데 도움이 되는 몇 가지 기술에 대해 간략하게 검토한다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-important_code_should_be_in_function",
    "href": "src/application_of_julia/performance_tips.html#sec-important_code_should_be_in_function",
    "title": "Julia 성능 팁",
    "section": "1 성능에 중요한 코드는 함수 내에 위치해야 한다",
    "text": "1 성능에 중요한 코드는 함수 내에 위치해야 한다\n성능에 중요한 코드는 함수 안에 위치해야 한다. Julia 컴파일러의 작동 방식때문에 함수 내부의 코드는 최상위 레벨 코드보다 훨씬 빠르다.\n함수를 사용하는 것은 성능에만 중요한 것은 아니다 : 함수는 더 재사용 가능하고 테스트 가능하며, 수행 단계와 입출력을 명확하게 한다. 단순한 스크립트가 아닌 함수를 작성하라 는 Julia’s Styleguide의 권장 사항이다.\n함수는 전역 변수를 직접적으로 연산하는 대신에 인자를 받아야 한다. 아래를 보라.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-avoid_untyped_global_variable",
    "href": "src/application_of_julia/performance_tips.html#sec-avoid_untyped_global_variable",
    "title": "Julia 성능 팁",
    "section": "2 타입이 지정되지 않은 전역변수를 피하라.",
    "text": "2 타입이 지정되지 않은 전역변수를 피하라.\n전역 변수에 타입이 지정되지 않은 경우 해당 변수의 값이 언제든지 변경될 수 있으며, 이것은 타입이 변경 될 수 있다는 의미이다. 이는 컴파일러가 전역 변수를 사용하는 코드를 최적화하는 것을 어렵게 만든다. 이러한 문제는 전역 수준에서 사용되는 타입 별칭, 즉 타입을 값으로 가지는 변수에도 해당됩니다. 변수는 가능한 한 로컬로 선언하거나 함수의 인자로 전달해야 한다.\n전역적인 이름은 대부분 상수로 선언되며, 그렇게 선언하는 것이 성능을 향상시킨다.\nconst DEFAULT_VAL = 0\n전역변수가 항상 같은 타입이라면, 그 타입이 지정(annotaed) 되어야 한다\n타입이 명시되지 않은 전역변수는, 그것의 사용 시점에 지정한다면 최적화 될 수 있다:\nglobal x = rand(1000)\n\nfunction loop_over_global()\n    s = 0.0\n    for i in x::Vector{Float64}\n        s += i\n    end\n    return s\nend\n인자를 함수에 전달하는 것은 더 좋은 스타일이다. 이것은 코드의 재사용성을 증가시키고 입력과 출력이 무엇인지 명확하게 한다.\n\n\n\n\n\n\n\n노트\n\n\n\nREPL 에서의 모든 코드는 전역적으로 평가되므로 최상위 레벨이서 정의되고 할당된 변수는 전역변수가 된다. 모듈 내부의 최상위 레벨에서 정의된 변수도 전역변수이다.\n\n\nREPL 세션에서:\njulia&gt; x = 1.0\n는 아래와 같다.\njulia&gt; global x = 1.0\n따라서 앞서 논의된 성능에 관련된 사항은 여기에 적용된다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-time_macro_and_memory_allocation",
    "href": "src/application_of_julia/performance_tips.html#sec-time_macro_and_memory_allocation",
    "title": "Julia 성능 팁",
    "section": "3 @time 을 이용하여 성능을 측정하고 메모리 할당에 유의할 것",
    "text": "3 @time 을 이용하여 성능을 측정하고 메모리 할당에 유의할 것\n@time 매크로는 성능을 측정하는 유용한 도구이다. 앞서 논의했던 전역변수에 대한 보기를 타입 지정(type annotation)을 제거하고 여기서 반복 해 보자.\njulia&gt; x = rand(1000);\n\njulia&gt; function sum_global()\n           s = 0.0\n           for i in x\n               s += i\n           end\n           return s\n       end;\n\njulia&gt; @time sum_global()\n  0.011539 seconds (9.08 k allocations: 373.386 KiB, 98.69% compilation time)\n523.0007221951678\n\njulia&gt; @time sum_global()\n  0.000091 seconds (3.49 k allocations: 70.156 KiB)\n523.0007221951678\n첫번째 호출(@time sum_global()) 에서 함수가 컴파일된다. (만약 이 세션에서 @time 을 아직 사용하지 않았다면 시간 측정에 필요한 함수도 같이 컴파일한다.) 첫번째 실행에서의 결과를 진지하게 받아들이지 말기를 바란다. 두번째 실행에서 시간을 보고할 뿐만 아니라 상당한 크기의 메모리가 할당되었음을 확인할 수 있다. 우리는 여기서 단지 64 비트 부동소수 벡터의 모든 성분을 더하는 계산을 하는 것이며, 따라서 메모리를 할당할 필요가 없다.(최소한 @time 이 리포트하는 heap 영역에서는 그렇다.)\n@time 이 보고하는 메모리 할당은 특히 heap 할당을 의미하는데, 이는 주로 가변(mutable) 객체나 가변 크기 컨테이너(예: Array, Dict, 문자열, 또는 실행 시간에 타입이 결정되는 “타입 불안정” 객체)를 생성하거나 확장할 때 필요하다. 이러한 메모리 블록의 할당(또는 해제)은 종종 libc 로의 호출(예: C 언어의 malloc 호출)을 필요로 하며, 가비지 컬렉션을 위해 추적해야 합니다. 반면에, 숫자(대형 숫자를 제외), 튜플, 불변(immutable) 구조체와 같은 불변 값은 스택이나 CPU 레지스터 메모리 등 더 저렴한 위치에 저장될 수 있어, 이들에 대한 “할당”의 성능 비용은 보통 문제가 되지 않는다다.\n예상치 못한 메모리 할당은 대부분의 경우 코드에 문제가 있다는 표시이며, 일반적으로 타입-안정성이나 다수의 작은 임시 배열을 생성하는 것에 관련된 문제이다. 결론적으로 할당 자체 뿐만아니라 함수를 위해 작성된 코드도 최적화와는 거리가 멀 가능성이 높다. 이러한 지표를 진지하게 여기고 아래의 조언을 따르라.\n위의 경우, 메모리 할당은 타입이 불안정한 전역 변수 x 의 사용으로 인해 발생하였다. 따라서 x 를 함수의 인수로 전달하면 더 이상 메모리가 할당되지 않는다(아래에 표시된 남은 메모리 할당은 전역 범위에서 @time 매크로를 실행한 결과로 인한 것입니다). 이렇게 하면 첫 번째 호출 이후 성능이 크게 향상된다.\njulia&gt; x = rand(1000);\n\njulia&gt; function sum_arg(x)\n           s = 0.0\n           for i in x\n               s += i\n           end\n           return s\n       end;\n\njulia&gt; @time sum_arg(x)\n  0.007551 seconds (3.98 k allocations: 200.548 KiB, 99.77% compilation time)\n523.0007221951678\n\njulia&gt; @time sum_arg(x)\n  0.000006 seconds (1 allocation: 16 bytes)\n523.0007221951678\n\n위에 보이는 1 allocations 는 @time 매크로를 전역 범위에서 실행시키며 발생한 것이다. 만약 이 매크로를 함수 내부에서 실행시킨다면 우리는 어떤 할당도 발생하지 않는다는 것을 확인 할 수 있다.\n\njulia&gt; time_sum(x) = @time sum_arg(x);\n\njulia&gt; time_sum(x)\n  0.000002 seconds\n523.0007221951678\n몇몇 경우에서는 당신의 함수가 그 연산의 일부로서 메모리를 할당할 필요가 있을수 있으며, 이는 앞서의 간단한 상황을 복잡하게 한다. 이 경우에는 문제를 진단하기 위해 아래의 tools 가운데 하나를 사용하거나, 알고리즘적인 부분과 할당 부분을 분리하는 함수를 작성하는 것을 고려하라( Pre-allocationg outputs 을 참고하라)\n\n\n\n\n\n\n\n노트\n\n\n\n고급 벤치마킹을 위해 BenchmarkTools.jl 사용을 고려해보라. 무엇보다도 이것은 잡음을 줄이기 위해 여러번 함수를 평가한다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-tools",
    "href": "src/application_of_julia/performance_tips.html#sec-tools",
    "title": "Julia 성능 팁",
    "section": "4 Tools",
    "text": "4 Tools\nJulia 와 Julia 패키지 생태계는 당신이 문제를 진단하고 코드의 성능을 향상시킬 여러 도구들을 포함한다.\n\nProfiling 은 당신의 코드를 실행시키는 성능을 측정하며 병목 지점을 찾아준다. 복잡한 프로젝트용으로는 ProfileView 패키지가 당신의 프로파일링 결과를 시각화하는데 도움이 될 것이다.\nJET 패키지는 당신의 코드에 나타나는 공통적인 성능 문제를 찾는데 도움을 줄 수 있다.\n@time, @allocated , 또는 프로파일러(가비지 컬렉션 루틴 호출을 통해)가 보고하는 예상보다 큰 메모리 할당은 코드에 문제가 있음을 시사한다. 할당에 대한 다른 명확한 이유가 보이지 않는다면 타입 문제를 의심하라. 또한, --track-allocation=user 옵션으로 Julia를 시작하고 생성된 *.mem 파일을 확인하여 이러한 할당이 발생하는 위치에 대한 정보를 얻을 수 있다. 자세한 내용은 메모리 할당 분석을 참조하세요.\n@code warntype 은 타입 불확실성을 발생시키는 표현을 찾는데 도움이 되는 정보를 제공한다. 아래의 (code_warntype?) 을 읽어보라.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-avoid_container_with_abstract_type_parameters",
    "href": "src/application_of_julia/performance_tips.html#sec-avoid_container_with_abstract_type_parameters",
    "title": "Julia 성능 팁",
    "section": "5 추상 타입 매개변수를 포함하는 콘테이너를 피하라.",
    "text": "5 추상 타입 매개변수를 포함하는 콘테이너를 피하라.\n배열(Array)을 포함하여 매개화된 타입을 가지고 일할 때, 가능한 한 추상 타입으로 매개화하는것을 피하는 것이 최선이다.\n다음을 보라.\njulia&gt; a = Real[]\nReal[]\n\njulia&gt; push!(a, 1); push!(a, 2.0); push!(a, π)\n3-element Vector{Real}:\n 1\n 2.0\n π = 3.1415926535897...\n\na 는 추상 타입 Real 의 배열이므로, 어떤 Real 값도 포함 할 수 있다. Real 객체는 임의의 크기와 구조를 갖기 때문에 a 는 각각의 할당된 Real 객체를 가리키는 포인터의 배열로 표현되어야 한다. 그러나 만약 당신이 같은 타입의 값들, 예를 들면 Float64 와 같은 값들만 a 에 저장하는것을 허용한다면 이들은 좀 더 효율적으로 저장될 수 있다.\n\njulia&gt; a = Float64[]\nFloat64[]\n\njulia&gt; push!(a, 1); push!(a, 2.0); push!(a,  π)\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.141592653589793\na 에 수들을 할당하면 이 수들은 Float64 로 변환되며 효율적으로 다뤄질 수 있는 연속적인 64 비트 부동소수값의 블록으로 저장된다.\n만약 추상 타입 컨테이너를 사용할 수 밖에 없다면 런타임에서의 타입 확인을 피하기 위해 Any 로 매개화하는게 좋을 때도 있다. 예를 들자면 IdDict{Any, Any} 는 idDict{Type, Vector} 보다 성능이 좋다.\nParametric Types 의 논의를 참고하라.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-type_declarations",
    "href": "src/application_of_julia/performance_tips.html#sec-type_declarations",
    "title": "Julia 성능 팁",
    "section": "6 타입 선언",
    "text": "6 타입 선언\n타입 선언이 선택 사항인 많은 언어에서는, 선언을 하는 것이 빠르게 동작하는 코드를 만드는 지름길이다. Julia 에서는 그렇지 않다. Julia에서는 컴파일러가 보통 모든 함수 인자, 지역변수와 표현(expression)의 타입을 알고 있다. 그러나 그러나 몇몇 특정 상황에서는 선언이 도움이 된다.\n\n\n6.1 추상 타입을 가진 필드를 피하라\n타입은 그 필드의 타입을 특정하지 않고 선언 될 수 있다.\njulia&gt; struct MyAmbiguousType\n           a\n       end\n\n위 코드에서 a 는 어떤 타입도 될 수 있다. 이것은 때대로 유용하지만 단점도 존재한다: 컴파일러는 MyAmbiguousType 객체에 대해 고성능 코드를 생성할 수 없다. 컴파일러는 어떻게 코드를 빌드할 지 결정하기위해 값이 아닌 객체의 타입을 사용하기 때문이다. 안타깝지만 MyAmbiguousType 객체에 대해 추정할 수 있는 것이 거의 없다.\n\njulia&gt; b = MyAmbiguousType(\"Hello\")\nMyAmbiguousType(\"Hello\")\n\njulia&gt; c = MyAmbiguousType(17)\nMyAmbiguousType(17)\n\njulia&gt; typeof(b)\nMyAmbiguousType\n\njulia&gt; typeof(c)\nMyAmbiguousType\n비록 b 와 c 에 대한 메모리 내부에서의 내재적인 데이터 표현이 아주 다를지라도, 그 둘의 값은 같은 타입이다. a 필드에 수를 저장하더라도, UInt8 의 메모리 표현과 Float64의 메모리 표현이 다르다는 사실은 CPU가 두개의 서로 다른 종류의 명령어(instructions)를 사용하여 다룰 필요가 있다는 것을 의미한다. 타입으로부터 필요한 정보를 얻을 수 없으므로 이 결정은 런타임에 이루어진다. 이것이 성능을 떨어트린다.\na의 타입을 선언하면 이를 개선시킬 수 있다. 여기서, 우리는 a 가 여러 타입들 중 아무거나 하나의 타입이 될 수 있는 경우에 초점을 두자. 이 경우 매개변수를 쓰는 것이 자연스러운 해법이다. 예를 들어 다음과 같다.\njulia&gt; mutable struct MyType{T&lt;:AbstractFloat}\n           a::T\n       end\n이것은 아래보다 좋은 선택이다.\njulia&gt; mutable struct MyStillAmbiguousType\n           a::AbstractFloat\n       end\n왜냐면 첫번째 버젼은 wrapper 객체의 타입에서 a 의 타입을 지정했기 때문이다. 예를 들어보자:\njulia&gt; m = MyType(3.2)\nMyType{Float64}(3.2)\n\njulia&gt; t = MyStillAmbiguousType(3.2)\nMyStillAmbiguousType(3.2)\n\njulia&gt; typeof(m)\nMyType{Float64}\n\njulia&gt; typeof(t)\nMyStillAmbiguousType\n필드 a 의 타입은 m의 타입으로 부터 쉽게 결정되지만 t 의 타입으로부터는 그렇지 않다. 물론 t 내부에서 필드 a의 타입을 바꾸는 것이 가능하다.\njulia&gt; typeof(t.a)\nFloat64\n\njulia&gt; t.a = 4.5f0\n4.5f0\n\njulia&gt; typeof(t.a)\nFloat32\n반대로, m 이 만들어진 다음에는 m.a 의 type 은 변할 수 없다.\njulia&gt; m.a = 4.5f0\n4.5f0\n\njulia&gt; typeof(m.a)\nFloat64\nm 의 타입으로부터 m.a 의 타입을 알 수 있다는 사실과, 이 타입이 mid-function 을 변경시킬수 없다는 사실은 컴파일러가 t 와 같은 객체가 아닌 m 과 같은 객체에 대해 고도로 최적화된 코드를 생성하도록 해 준다.\n물론, 이 모든것은 우리가 m 을 구체적 타입(concrete type)을 이용하여 m 을 구성했을 경우에만 사실이다. 이것은 abstract 타입을 이용하여 명시적으로 구성했을 경우에는 사실이 아니다.\njulia&gt; m = MyType{AbstractFloat}(3.2)\nMyType{AbstractFloat}(3.2)\n\njulia&gt; typeof(m.a)\nFloat64\n\njulia&gt; m.a = 4.5f0\n4.5f0\n\njulia&gt; typeof(m.a)\nFloat32\n실제적인 경우에는 이러한 객체는 MyStillAmbiguousType 과 동일하게 행동한다.\n아래의 간단한 함수\nfunc(m::MyType) = m.a+1\n에 대해\ncode_llvm(func, Tuple{MyType{Float64}})\ncode_llvm(func, Tuple{MyType{AbstractFloat}})\n를 사용하여 간단한 함수를 위해 생성된 대량의 코드를 비교하는 것은 매우 교육적으로 유익하다.1\n결과가 너무 길어서 여기에 제시하지 않지만 여러분이 직접 해보길 바란다. 첫번째 경우는 타입이 완전히 지정되었으므로 컴파일러가 실행시간에 타입을 결정하는 코드를 만들 필요가 전혀 없다. 결과적으로 짧고 빠른 코드가 된다.\n전적으로 매개화되지 않은 타입(not-fully-parameterized type)은 추상 타입처럼 행동한다. 예를 들어, 전적으로 특정된 Array{T, n} 은 concrete 하지만 파라미터가 없는 Array 자체는 concrete 하지 않다.\njulia&gt; !isconcretetype(Array), !isabstracttype(Array), isstructtype(Array), !isconcretetype(Array{Int}), isconcretetype(Array{Int,1})\n(true, true, true, true, true)\n이 경우 MyType 의 필드를 a::Array 로 선언하지 않고, 대신에 a::Array{T, N} 으로 선언하거나 이나 a::A 으로 선언하며 {T, N} 이나 A 를 MyType 의 파라미터로 선언하는 것이 낫다.\n\n\n\n6.2 추상 컨테이너를 필드로 갖는 것을 피하라.\n동일한 최선의 방법은 컨테이너 타입에도 적용된다:\njulia&gt; struct MySimpleContainer{A&lt;:AbstractVector}\n           a::A\n       end\n\njulia&gt; struct MyAmbiguousContainer{T}\n           a::AbstractVector{T}\n       end\n\njulia&gt; struct MyAlsoAmbiguousContainer\n           a::Array\n       end\n예를 들어 :\njulia&gt; c = MySimpleContainer(1:3);\n\njulia&gt; typeof(c)\nMySimpleContainer{UnitRange{Int64}}\n\njulia&gt; c = MySimpleContainer([1:3;]);\n\njulia&gt; typeof(c)\nMySimpleContainer{Vector{Int64}}\n\njulia&gt; b = MyAmbiguousContainer(1:3);\n\njulia&gt; typeof(b)\nMyAmbiguousContainer{Int64}\n\njulia&gt; b = MyAmbiguousContainer([1:3;]);\n\njulia&gt; typeof(b)\nMyAmbiguousContainer{Int64}\n\njulia&gt; d = MyAlsoAmbiguousContainer(1:3);\n\njulia&gt; typeof(d), typeof(d.a)\n(MyAlsoAmbiguousContainer, Vector{Int64})\n\njulia&gt; d = MyAlsoAmbiguousContainer(1:1.0:3);\n\njulia&gt; typeof(d), typeof(d.a)\n(MyAlsoAmbiguousContainer, Vector{Float64})\nMySimpleContainer 객체는 그 타입과 매개변수가 전부 지정되었으므로 컴파일러가 최적화된 함수를 생성할수 있다. 대부분의 경우는 이것으로 충분하다.\n이제 컴파일러가 완벽히 일을 해치울 수 있는 반면, 당신이 a의 원소의 타입에 따라 다른 일을 하는 코드를 작성해야 하는 경우도 있다. 이에 대한 가장 좋은 방법은 별도의 함수(여기서는 foo) 를 이용하여 당신이 원하는 기능을 감싸는 것이다.\njulia&gt; function sumfoo(c::MySimpleContainer)\n           s = 0\n           for x in c.a\n               s += foo(x)\n           end\n           s\n       end\nsumfoo (generic function with 1 method)\n\njulia&gt; foo(x::Integer) = x\nfoo (generic function with 1 method)\n\njulia&gt; foo(x::AbstractFloat) = round(x)\nfoo (generic function with 2 methods)\n이렇게 컴파일러가 모든 경우에서 최적화된 코드를 생성하도록 하면서, 모든 것을 단순하게 유지할 수 있다.\n그러나, MySimpleContianer 의 a 필드의 AbstractVector의 타입이나 상이한 원소 타입 대해 각각 다른 버젼의 외부 함수를 선언해야 할 필요가 있을 수도 있다. 당신은 이렇게 할 수 있다:\njulia&gt; function myfunc(c::MySimpleContainer{&lt;:AbstractArray{&lt;:Integer}})\n           return c.a[1]+1\n       end\nmyfunc (generic function with 1 method)\n\njulia&gt; function myfunc(c::MySimpleContainer{&lt;:AbstractArray{&lt;:AbstractFloat}})\n           return c.a[1]+2\n       end\nmyfunc (generic function with 2 methods)\n\njulia&gt; function myfunc(c::MySimpleContainer{Vector{T}}) where T &lt;: Integer\n           return c.a[1]+3\n       end\nmyfunc (generic function with 3 methods)\njulia&gt; myfunc(MySimpleContainer(1:3))\n2\n\njulia&gt; myfunc(MySimpleContainer(1.0:3))\n3.0\n\njulia&gt; myfunc(MySimpleContainer([1:3;]))\n4\n\n\n\n6.3 타입이 지정되지 않은 위치로부터 값을 지정하기\n많은 경우 임의의 타입을 저장 할 수 있는 자료구조(Array{Any} 타입의 배열) 를 이용하는것이 편하다. 그러나 이런 구조들 가운데 하나를 이용하면서 동시에 원소의 타입을 안다면, 컴파일러와 이 지식을 공유하는 것이 도움이 된다:\nfunction foo(a::Array{Any,1})\n    x = a[1]::Int32\n    b = x+1\n    ...\nend\n여기서 우리는 a 의 첫번째 원소가 Int32 타입이라는 것을 안다. 이렇게 지정하게 되면, 그 값이 기대했던 타입이 아닐 때 런타임 에러를 발생시키며, 잠재적으로 어떤 버그를 미리 발견할수도 있다.\na[1] 의 타입을 정확히 알지 못하는 경우 x 는 x = convert(Int32, a[1]) 로 선언 될 수 있다. convert 함수를 사용하게 되면 a[1] 은 Int32 로 변환될 수 있는 어떤 객체(예를 들면 UInt8)도 될 수 있으며, 타입 요구 조건을 완하함으로서 코드의 일반성을 향상시킨다. convert 함수 자체가 타입 안정성을 확보하기 위해 문맥상에서(in the context) 타입 지정을 필요로 한다는 것에 유의하라. 이는 컴파일러가 함수의 모든 인자들의 타입을 알지 못하면, convert 함수에 있어서 조차 함수의 리턴 값의 타입을 추론하지 못하기 때문이다.\n만약 타입이 추상적 타입이거나 런타임에 구성된다면 타입 지정은 성능을 향상시킬수 없다.(실제로 저하시킬수도 있다.) 이는 컴파일러가 뒤따르는 코드를 특정하는데 타입 지정을 사용할 수 없으며, 따라서 타입을 확인하는데 시간이 걸리기 때문이다. 예를 들어 다음 코드 를 보자.\nfunction nr(a, prec)\n    ctype = prec == 32 ? Float32 : Float64\n    b = Complex{ctype}(a)\n    c = (b + 1.0f0)::Complex{ctype}\n    abs(c)\nend\nc 에 대한 지정은 성능을 해친다. 런타임에 구성되는 타입에 관련된 성능 좋은 코드를 작성하기 위해서는 아래에 논의될 function-barrier technique 를 사용하고, 구성되는 타입이 커널 함수의 인자에 나타나서, 커널 작동이 컴파일러에 의해 제대로 특정되도록 해야 한다. 예를 들어, 위의 코드에서 b 가 구성되자 마자 다른 함수 k (the kernel) 에 전달 될 수 있다. 예를 들어 함수 k 가 b 를 타입 파라미터 T 에 대해 Complex{T} 로 선언하였다면, k 에서의 할당문(assignment statement) 에서 나타나는 아래와 같은 타입 지정\nc = (b + 1.0f0)::Complex{T}\n은 성능을 해치지 않는데(도움도 되지 않지만) 이는 컴파일러가 c 의 타입을 k가 컴파일 될 때 결정하기 때문이다.\n\n\n\n6.4 언제 Julia가 specializing(타입 특정) 을 피하는지 숙지하라.\n경험적으로 Julia는 Type, Function 및 Vararg의 세 가지 특정한 경우에서 인자 타입 매개변수를 자동으로 특정하는것을 피한다. Julia는 인자가 메서드 내부에서 사용될 때 항상 특정하지만, 이 인자가 다른 함수에 전달될 때는 특정하지 않는다. 이렇게 하면 보통 실행시간에는 성능에 영항을 주지 않으며 컴파일러의 성능을 향상시킨다. 만약 당신이 런타임에 성능에 영향이 있다는것을 발견한다면, 메서드 선언에서 타입 변수를 추가하여 타입 특정을 유도할 수 있다. 여기에 몇몇 예를 제시하겠다.\n이것은 타입특정을 하지 않는다. (함수 인지 t 는 Type 이다.)\nfunction f_type(t)  # or t::Type\n    x = ones(t, 10)\n    return sum(map(sin, x))\nend\n그러나 아래는 특정한다.\nfunction g_type(t::Type{T}) where T\n    x = ones(T, 10)\n    return sum(map(sin, x))\nend\n아래는 특정하지 않는다. (g_func 의 인자 g 는 Function 타입이다. )\nf_func(f, num) = ntuple(f, div(num, 2))\ng_func(g::Function, num) = ntuple(g, div(num, 2))\n그러나 아래는 특정한다.\nh_func(h::H, num) where {H} = ntuple(h, div(num, 2))\n다음은 특정하지 않는다. (Vararg 의 경우)\nf_vararg(x::Int...) = tuple(x...)\n그러나 아래는 특정한다.\ng_vararg(x::Vararg{Int, N}) where {N} = tuple(x...)\n여러 타입 파라미터중 오직 하나만 강제로 특정하고, 나머지는 제한을 두지 않고 싶을수도 있다. 예를 들어 다음의 코드는 특정하며, 모든 인자들이 같은 타입이 아닐 때 유용하다.\nh_vararg(x::Vararg{Any, N}) where {N} = tuple(x...)\n@code_typed 와 그 친구들은 비록 Julia 가 보통은 메쏘드 호츨에서 특정하지 않더라도 항상 타입을 특정한 코드를 보여준다. 함수 인자 타입이 변했을 때 타입 특정을 생성하는지 확인하고 싶다면, 즉 (@which f(...)).specializations 가 궁금한 인자에 대해 타입 특정을 포함하고 있는지 알고 싶다면, method internals 를 확인할 필요가 있다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-break_functions_into_multiplie_definition",
    "href": "src/application_of_julia/performance_tips.html#sec-break_functions_into_multiplie_definition",
    "title": "Julia 성능 팁",
    "section": "7 함수를 다중 정의로 분리하라",
    "text": "7 함수를 다중 정의로 분리하라\n함수를 많은 작은 정의들로 작성하는 것은 컴파일러가 가장 적절한 코드를 호출하거나, inline 처리까지도 하도록 해 준다.\n아래는 다중 정의로 작성되어야만 하는 복합 함수(compound function)의 예이다.\nusing LinearAlgebra\n\nfunction mynorm(A)\n    if isa(A, Vector)\n        return sqrt(real(dot(A,A)))\n    elseif isa(A, Matrix)\n        return maximum(svdvals(A))\n    else\n        error(\"mynorm: invalid argument\")\n    end\nend\n이 코드는 더 간결하교 효율적으로 고쳐질 수 있다:\nnorm(x::Vector) = sqrt(real(dot(x, x)))\nnorm(A::Matrix) = maximum(svdvals(A))\n그러나 mynorm 예제처럼 작성된 코드에서 컴파일러는 불필요한 코드를 상당히 효과적으로 최적화하여 제거할 수 있다는 것에 유의해야 한다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-write_type_stable_functions",
    "href": "src/application_of_julia/performance_tips.html#sec-write_type_stable_functions",
    "title": "Julia 성능 팁",
    "section": "8 “Type-Stable” 함수를 작성하라",
    "text": "8 “Type-Stable” 함수를 작성하라\n가능하다면 함수가 항상 같은 타입을 반환하도록 보장하는 것이 유용하다. 다음 코드를 살펴보자.\npos(x) = x &lt; 0 ? 0 : x\n비록 이것이 무해해 보이겠지만, 문제는 0 은 정수이며(Int 타입) x 는 어떤 타입도 가능하다는 것이다. 따라서 x 의 값에 따라 두가지 타입중 하나를 반환할 수 있다. 이런 동작은 허용되며, 어떤 경우엔 바람직 할 수도 있다. 그러나 이것은 아래와 같이 쉽게 수정된다.\npos(x) = x &lt; 0 ? zero(x) : x\noneunit 함수나, 더 일반적인 oftype(x, y) 가 있다. 후자는 y 를 x의 타입으로 변화시켜 리턴한다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-avoid_changing_the_type_of_variables",
    "href": "src/application_of_julia/performance_tips.html#sec-avoid_changing_the_type_of_variables",
    "title": "Julia 성능 팁",
    "section": "9 변수의 타입을 변화시키는 것을 피하라",
    "text": "9 변수의 타입을 변화시키는 것을 피하라\n유사한 타입 안정성(type stability) 문제는 함수 내에서 반복적으로 사용되는 변수에서도 존재한다.\nfunction foo()\n    x = 1\n    for i = 1:10\n        x /= rand()\n    end\n    return x\nend\n지역변수 x 는 정수로 시작해서 한 루프 다음에 / 연산으로 인해 부동소수가 된다. 이것은 컴파일러가 루프의 몸체를 최적화하는것을 어렵게 한다. 몇가지 가능한 수정사항이 있다.\n\nx 를 x=1.0 으로 초기화한다\nx 를 명시적으로 x::Float64=1 로 선언한다\n명시적 형변환을 사용한다 : x=oneunit(Float64)\n첫번재 루프로 즉 x=1/rand() 로 초기화 하고 i=2:10 에 대해 반복한다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-kernel_barrier",
    "href": "src/application_of_julia/performance_tips.html#sec-kernel_barrier",
    "title": "Julia 성능 팁",
    "section": "10 커널 함수를 분리한다 (aka function barriers)",
    "text": "10 커널 함수를 분리한다 (aka function barriers)\n많은 함수는 몇몇 설정 작업을 한 후 핵심 계산 수행을 위한 많은 반복작업을 하는 패턴을 따른다. 가능한 경우 핵심 계산 부분을 별도의 함수로 분리하는것은 좋은 생각이다. 예를 들어 아래의 다소 부자연스러운 함수는 임의로 선택된 타입의 배열을 반환한다.\njulia&gt; function strange_twos(n)\n           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\n           for i = 1:n\n               a[i] = 2\n           end\n           return a\n       end;\n\njulia&gt; strange_twos(3)\n3-element Vector{Int64}:\n 2\n 2\n 2\n이것은 다음과 같이 쓰여져야 한다.\njulia&gt; function fill_twos!(a)\n           for i = eachindex(a)\n               a[i] = 2\n           end\n       end;\n\njulia&gt; function strange_twos(n)\n           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\n           fill_twos!(a)\n           return a\n       end;\n\njulia&gt; strange_twos(3)\n3-element Vector{Int64}:\n 2\n 2\n 2\nJulia 컴파일러는 함수 경계에서 인자 타입에 대한 코드를 특정하며, 따라서 원래의 구현에서는 루프를 도는 동안에는 a의 타입을 알지 못한다(왜나면 임의로 선택되었기 때문에). 따라서 내부의 루프가 fill_two! 의 부분으로 a 의 두 타입에 대해 리컴파일 되었으므로, 두번째 버젼이 일반적으로 빠르다.\n두번째 폼이 대부분 더 좋은 스타일이며 코드를 재사용하는데도 좋다.\n이 패턴은 Julia Base 에서 상당수 사용된다. 예를 들어 abstractarray.jl 의 vcat 과 hcat 을 보거나, fill! 함수를 찾아보면 우리의 fill_twos! 함수를 대신해서 쓸 수 있을 것이다.\nstrange_twos 와 같은 함수는 불확실한 타입의 데이터, 예를 들면 입력 파일로부터 정수, 소수(floats), 문자열 및 기타등을 포함한 데이터를 읽거나 할 경우와 같은 상황에서 발생한다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-types_with_values_as_parameters",
    "href": "src/application_of_julia/performance_tips.html#sec-types_with_values_as_parameters",
    "title": "Julia 성능 팁",
    "section": "11 매개변수로 사용되는 값을 가진 타입",
    "text": "11 매개변수로 사용되는 값을 가진 타입\n축당 3개씩의 값을 갖는 N-차원 배열을 만든다고 하자. 이런 배열은 아래와 같이 만들 수 있다.\njulia&gt; A = fill(5.0, (3, 3))\n3×3 Matrix{Float64}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n이런 방법은 잘 작동한다: 컴파일러는 (fill 함수가 채우는 함수라는 의미에서) 채워지는 값의 타입(5.0::Float64) 와 차원 ((3, 3)::NTuple{2, Int})을 알기때문에 A 가 Array{Float64, 2} 라고 이해할 수 있다. 이것은 컴파일러가 향후 같은 함수내에서 A 를 사용하는데 더 효율적인 코드를 생성할 수 있다는 것을 의미한다.\n이제 임의의 차원 3x3x… 을 갖는 배열을 생성한다고 하자; 다음과 같은 함수로 시도해 볼 수 있을것이다.\njulia&gt; function array3(fillval, N)\n           fill(fillval, ntuple(d-&gt;3, N))\n       end\narray3 (generic function with 1 method)\n\njulia&gt; A = array3(5.0, 2)\n3×3 Matrix{Float64}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n위의 코드는 작동하지만, (@code_warntype array3(5.0, 2) 를 통해 당신이 스스로 확인 할 수 있듯이) 문제는 출력 타입이 추정될수 없다는 것이다: 인자 N 은 정수 타입의 값이며, 타입 추론은 앞으로 이 값이 어떻게 될지 추정하지 않으며 할수도 없다\\(^\\dagger\\). 이것은 이 함수의 출력값을 사용하는 코드가 보수적이어야 하며, A 에 접근 할 때마다 타입을 확인해야 한다는 것을 의미한다; 이러한 코드는 매우 느릴것이다.\\(^\\dagger\\) 배열의 타입은 그 차원를 포함한다는 것을 알아야 한다. 위의 코드에서 A 의 타입은 Array{Float64, 3} 이다.\n이러한 문제를 해결하는 가장 좋은 방법은 function-barrier technique 을 사용하는 것이다. 그러나 몇몇 경우에서는 당신이 타입 불안정성도 같이 제거하기를 원할 수도 있다. 이런 경우는 차원을 매개변수로 전달하는것도 (예를 들자면 Val{T}() 를 이용하여) 한 방법이다: (“Value types”를 보라)\njulia&gt; function array3(fillval, ::Val{N}) where N\n           fill(fillval, ntuple(d-&gt;3, Val(N)))\n       end\narray3 (generic function with 1 method)\n\njulia&gt; array3(5.0, Val(2))\n3×3 Matrix{Float64}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0\nJulia 에는 Val{N::Int} 객체를 두번째 매개변수로 받는 특별한 ntuple 버젼이 존재한다. 여기서 N 은 타입 매개변수로 그 값을 컴파일러에게 알려준다. 결론적으로 이 버젼의 array3 는 컴파일러가 리턴 타입을 알게 해 준다.\n그러나 이런 기술을 사용하는 것은 아주 민감할 수 있다. 예를 들어 array3 를 아래와 같이 함수에서 호출한다면 이 방법은 소용 없을 것이다.\nfunction call_array3(fillval, n)\n    A = array3(fillval, Val(n))\nend\n여기서 똑같은 문제가 발생했다: 컴파일러는 n 이 무엇인지 예상할 수 없으며, 따라서 Val(n) 의 타입도 알수가 없다. Val 을 사용하려고 하면서, 부정확하게 사용한다면 많은 경우 성능이 악화된다. (당신이 Val 과 function-barrier 트릭을 효율적으로 결합하여 커널 함수를 더 효율적으로 작성했을 때에만 위의 코드가 사용되어야 한다.)\nVal 의 올바른 사용 예는 다음과 같다.\nfunction filter3(A::AbstractArray{T,N}) where {T,N}\n    kernel = array3(1, Val(N))\n    filter(A, kernel)\nend\n이 예에서 N 은 매개변수로 전달되었고 그 “값”이 컴파일러에게 알려졌다. T 가 hard-coded/literal (Val(3)) 이거나 타입영역에서 이미 특정되었을 때에만 Val(T) 이 제대로 동작한다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#multiple-dispatch-의-위험한-오용-혹은-types-with-values-as-parameters-에-대한-추가사항",
    "href": "src/application_of_julia/performance_tips.html#multiple-dispatch-의-위험한-오용-혹은-types-with-values-as-parameters-에-대한-추가사항",
    "title": "Julia 성능 팁",
    "section": "12 Multiple dispatch 의 위험한 오용 (혹은 types with values-as-parameters 에 대한 추가사항)",
    "text": "12 Multiple dispatch 의 위험한 오용 (혹은 types with values-as-parameters 에 대한 추가사항)\n일단 다중 디스패치(multiple dispatch) 를 이해하게 되었다면, 다소 극단적으로 모든 곳에 사용하고자 하는 자연스러운 경항이 있다. 예를 들어 다중 디스패치를 이용하여 정보를 저장하고자 한다면,\nstruct Car{Maker, Model}\n    year::Int\n    ...more fields...\nend\n라고 작성하고 객체애 대해 Car{:Honda,:Accord}(year, args...) 라고 디스패치 한다고 하자.\n이것은 아래의 조건이 충족될 때 사용할 만 하다.\n\n각각의 Car 에 대해 CPU intensive 한 프로세스를 수행해야 하며, 컴파일 타임에 Maker 와 Model 을 알 경우에 훨씬 효율적이 되고, 서로 다른 Make 와 Model 이 그다지 많지 않을 때.\n같은 Car 의 타입으로 이루어진 동종의(homogeneous) 목록으로 작업을 수행하여, (예를 들자면) Array{Car{:Honda, :Accord}, N} 의 배열에 그 목록을 모두 저장 할 수 있을 때.\n\n후자의 조건이 충종된다면, 이런 동종의 배열을 처리하는 함수는 생산적으로 특정될 수 있다: 이후 Julia 는 각 원소들의 타입을 알기 때문에(콘테이너 안의 모든 객체는 동일한 구체적인 타입이다) 그 함수가 컴파일 될 때 (런타임에서의 타입 확인을 불필요게 하며) 올바른 메쏘드를 찾아 낼 수 있다. 따라서 전체 리스트를 처리하는 효율적인 코드를 만들어낸다.\n이 조건들이 충족되지 못하면 이득을 볼 것이 없을 것이며, 혹은 결과적으로 발생하는 “combinational explosion of types” 는 역효과를 낳을 수도 있다. 만약 items[i+1] 이 item[i] 와 다른 타입이라면 Julia는 런타임에 타입을 조회할 것이고 메쏘드 테이블에서 적절한 메쏘드를 조회할 것이며, 타입 교차(type intersection) 을 통해 일치하는 메쏘드를 찾고, 그것이 이미 JIT 컴파일 되었는지 확인하여 아직 컴파일 되지 않았다면 컴파일하고, 그것을 호출한다. 본질적으로 (Julia 의) 전체 타입 시스템 및 JIT 컴파일 장치가 당신의 코드에서 switch 문 또는 사전 조회(dictionary lookup)와 동등한 것을 기본적으로 실행하도록 요청하는 것이다.\n(\\(1\\)) 타입 디스패치, (\\(2\\)) dictionary lookup, (\\(3\\)) a “switch” statement 를 비교하는 몇몇 런타임 벤치마크가 메일링 리스트 에 기록되어 있다.\n런타임보다 컴파일 타임에서의 효과가 더 안좋을 수도 있다: Julia 는 각각의 Car{Maker, Model} 에 대해 특정 함수를 컴파일할 것이다; 만약 이런 타입이 수백 수천개라면 이런 객체를 매개변수로 받아들이는 모든 함수 (당신 스스로 작성한 get_year 류의 함수부터 Julia Base 의 generic push! 함수까지) 에 대해 컴파일한 수백 수천개의 변형을 갖게 될 것이다. 각각의 변형은 컴파일된 코드의 케쉬 사이즈와 메쏘드들에 대한 내부적인 리스트의 길이 등을 증가시킬 것이다. Values-as-Parameters 에 대한 과도한 열광은 대량의 컴퓨팅 자원을 쉽게 낭비할 수 있다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-columnwise_access_to_array",
    "href": "src/application_of_julia/performance_tips.html#sec-columnwise_access_to_array",
    "title": "Julia 성능 팁",
    "section": "13 배열을 메모리 순, 즉 열을 따라 접근할 것",
    "text": "13 배열을 메모리 순, 즉 열을 따라 접근할 것\nJulia의 다차원 배열은 열-우선 순서(column-major order)로 저장된다. 즉 (메모리에서) 한번에 한 열(column) 씩 차례로 저장된다는 의미이다. 이것은 vec 함수나 [:] 구문을 이용하여 아래와 같이 확인 할 수 있다. (배열이 [1 2 3 4] 순이 아닌 [1 3 2 4] 순으로 저장되는 것에 주목하라.)\njulia&gt; x = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia&gt; x[:]\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4\n\n이런 열-우선 관행은 포트란, 매트랩, R 을 포함하는 몇몇 언어에 공통적이다. 열보다 행을 우선하는 행-우선 순서(row-major order) 는 C 나 Python (numpy) 을 포함하는 다른 언어에 사용된다. 배열 순서(ordering of arrays)는 array 를 순회할 때 성능에 지대한 영향을 미칠 수 있음을 기억하라. 열-우선 배열에서 기역해야할 경험칙은 첫번째 인덱스가 가장 빨리 변한다는 것이다. 이것은 기본적으로 슬라이스 표현에서 가장 먼저 나오는 인덱스가 가장 안쪽에 위치한 루프의 인덱스 일 때 더 빠름을 의미한다. 배열을 : 로 인덱싱한다는 것은 내재적으로 특정 차원의 모든 원소를 반복적으로 순회한다는 것을 기억하라; 예를 들자면, 행보다 열을 추출하는 것이 더 빠르다.\n다음의 인위적인 보기를 살펴보자. 벡터(Vector) 를 받아서 정사각행렬 을 리턴하는데, 리턴하는 행렬의 행이나 열이 입력 벡터의 복사본으로 채워지도록 하여 리턴하는 함수를 작성한다고 하자. 입력벡터의 복사본으로 채워지는 것이 행인지 열인지는 중요하지 않다고 가정하자.(코드의 나머지는 이것에 따라 쉽게 변경 될 수 있다.) 기본으로 제공되는(built-in) repeat 함수 이외에, 아마도 최소한 네가지 방법이 가능할 것이다.\nfunction copy_cols(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for i = inds\n        out[:, i] = x\n    end\n    return out\nend\n\nfunction copy_rows(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for i = inds\n        out[i, :] = x\n    end\n    return out\nend\n\nfunction copy_col_row(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for col = inds, row = inds\n        out[row, col] = x[row]\n    end\n    return out\nend\n\nfunction copy_row_col(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for row = inds, col = inds\n        out[row, col] = x[col]\n    end\n    return out\nend\n이제 입력 벡터로 동일한 난수 10000 개를 위의 함수에 대한 입력 벡터로 사용하여 각각의 수행시간을 측정해 보자.\njulia&gt; x = randn(10000);\n\njulia&gt; fmt(f) = println(rpad(string(f)*\": \", 14, ' '), @elapsed f(x))\n\njulia&gt; map(fmt, [copy_cols, copy_rows, copy_col_row, copy_row_col]);\ncopy_cols:    0.331706323\ncopy_rows:    1.799009911\ncopy_col_row: 0.415630047\ncopy_row_col: 1.721531501\ncopy_cols 가 copy_rows 보다 훨씬 빠른것애 주목하라. copy_cols 는 Matrix 의 열 기반 메모리 배치를 고려하여 한번에 한 열씩 채우기 때문에 예상 할 수 있는 결과이다. 추가로 copy_col_row 는 copy_row_col 보다 훨씬 빠른데, 이는 앞서 언급한 슬라이스 표현의 첫번째 원소가 가장 내부 깊숙히 위치한 루프에 결합되어야 한다는 경험칙을 따르기 때문이다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-pre_allocating_outputs",
    "href": "src/application_of_julia/performance_tips.html#sec-pre_allocating_outputs",
    "title": "Julia 성능 팁",
    "section": "14 출력의 사전 할당",
    "text": "14 출력의 사전 할당\n만약 함수의 리턴값이 배열이나 다른 복합 타입이라면 메모리를 할당해야 할 수도 있다. 불행하게도 할당과 그 역인 가비지 콜렉션은 빈번히 중요한 병목지점이 된다.\n때때로 출력(outputs)을 미리 할당하여(사전 할당), 함수를 호출할때마다 메모리를 할당할 필요성을 제거할수도 있다. 간단한 보기로 다음 둘을 비교해보자.\nfunction xinc(x)\n    return [x, x+1, x+2]\nend;\n\nfunction loopinc()\n    y = 0\n    for i = 1:10^7\n        ret = xinc(i)\n        y += ret[2]\n    end\n    return y\nend;\nfunction xinc!(ret::AbstractVector{T}, x::T) where T\n    ret[1] = x\n    ret[2] = x+1\n    ret[3] = x+2\n    nothing\nend;\n\nfunction loopinc_prealloc()\n    ret = Vector{Int}(undef, 3)\n    y = 0\n    for i = 1:10^7\n        xinc!(ret, i)\n        y += ret[2]\n    end\n    return y\nend;\n수행시간 측정 결과는 다음과 같다.\njulia&gt; @time loopinc()\n  0.529894 seconds (40.00 M allocations: 1.490 GiB, 12.14% gc time)\n50000015000000\n\njulia&gt; @time loopinc_prealloc()\n  0.030850 seconds (6 allocations: 288 bytes)\n50000015000000\n사전할당의 다른 장점들이 있는데, 예를 들면 함수 호출자가 알고리즘을 이용하여 출력 타입을 조절할 수 있다는 것이다. 위의 보기에서 우리는 우리가 원했다면 Array 가 아닌 SubArray 를 전달 할 수 있었다.\n극단적인 경우, 사전할당은 당신의 코드를 추하게 만들 수도 있으므로, 성능 측정 뿐만 아니라 다른 판단도 필요하다. 그러나 (원소별로 처리하는)벡터화된 함수의 경우는 x .= f.(y) 같은 편의적 구문을 혼합된 루프(fused loops) 와 함께 임시적 배열 없이 사용 할 수 있다.(dot syntax for vectorizing functions 를 보라).",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#use-mutablearithmetics-for-more-control-over-allocation-for-mutable-arithmetic-types",
    "href": "src/application_of_julia/performance_tips.html#use-mutablearithmetics-for-more-control-over-allocation-for-mutable-arithmetic-types",
    "title": "Julia 성능 팁",
    "section": "15 Use MutableArithmetics for more control over allocation for mutable arithmetic types",
    "text": "15 Use MutableArithmetics for more control over allocation for mutable arithmetic types\nNumber 의 일부 서브타입, 예를 들어 BigInt 나 BigFloat 는 가변(mutable) 구조체 타입으로 구현될 수 있으며, 또는 가변적인 성분을 가질 수 있다. Julia Base 의 산술 인터페이스는 이러한 경우 편리함을 효율성보다 우선시하는 경향이 있어, 이를 단순하게 사용하면 최적의 성능을 발휘하지 못할 수 있습니다. 반면에 MutableArithmetics 패키지의 추상화는 이러한 타입의 가변성을 활용하여 필요한 만큼만 할당하는 빠른 코드를 작성할 수 있게 한다. 또한, MutableArithmetics 는 필요할 때 가변 산술 타입의 값을 명시적으로 복사할 수 있도록 해준다. MutableArithmetics 는 사용자 패키지이며, Julia 프로젝트와는 관련이 없다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-more_dots_operations",
    "href": "src/application_of_julia/performance_tips.html#sec-more_dots_operations",
    "title": "Julia 성능 팁",
    "section": "16 더 많은 도트 : 벡터화된 연산을 결합",
    "text": "16 더 많은 도트 : 벡터화된 연산을 결합\nJulia 는 도트 구문(dot syntax)을 사용하여 어떠한 스칼라 함수도 벡터화 함수(vectorized function) 호출로 변환시키고 연산자를 벡터화된 연산자로 변환시킬 수 있다. 중첩된 “도트 호출” 은 융합(fusing) 되는 특별한 성질을 지닌다 : 중첩된 호출은 구문 레벨에서 임시 배열이 할당되지 않고 단일 루프로 병합된다.2 .= 및 유사한 할당 연산자를 사용한다면, 그 결과를 사전 할당된 배열의 그 자리에(in place) 저장될 수 있다. (이전을 보라)\n선형대수학적 맥락에서 이것은 vector + vector 와 vector * scalar 연산자가 정의되었더라도, vector .+ vector 와 vector .* scalar 를 사용하는 것이 유리할 수 있는데, 이것은 결과 루프가 주변 계산들과 병합될 수 있기 때문이다. 예를 들어 다음 두 함수를 보자.\njulia&gt; f(x) = 3x.^2 + 4x + 7x.^3;\n\njulia&gt; fdot(x) = @. 3x^2 + 4x + 7x^3; # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3\nf 와 fdot 은 같은 일을 한다. 그러나 (@. 매크로3의 도움으로 정의된) fdot 이 배열에 적용되었을 때 훨씬 빠르다.\njulia&gt; x = rand(10^6);\n\njulia&gt; @time f(x);\n  0.019049 seconds (16 allocations: 45.777 MiB, 18.59% gc time)\n\njulia&gt; @time fdot(x);\n  0.002790 seconds (6 allocations: 7.630 MiB)\n\njulia&gt; @time f.(x);\n  0.002626 seconds (8 allocations: 7.630 MiB)\nfdot(x) 가 f(x) 보다 10배 빠르고 메모리도 1/6 만 할당하는데 이것은 f(x) 의 * 와 + 연산이 새로운 임시 배열을 할당하고 별도의 루프에서 실행되기 때문이다. (이 보기에서는 그냥 f.(x) 만 하면 fdot(x) 만큼 빠르지만 많은 상황에서 별도의 벡터화된 연산에 대한 별도의 함수를 정의하는 것 보다는 그냥 당신의 표현식에 도트를 뿌리는게 더 편하다.)",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#더-적은-도트",
    "href": "src/application_of_julia/performance_tips.html#더-적은-도트",
    "title": "Julia 성능 팁",
    "section": "17 더 적은 도트 :",
    "text": "17 더 적은 도트 :\n위에서 언급한 도트와 루프의 결합은 간결하고 관용적인 코드로 매우 효율적인 작업을 표현할 수 있게 한다. 그러나 결합된 연산은 브로드캐스트의 매 반복마다 계산된다는 점을 기억하는 것이 중요하다. 따라서, 특히 composed 또는 다차원 브로드캐스트가 있는 상황에서는 도트 호출을 가진 표현식이 의도한 것보다 더 많은 횟수의 함수를 계산할 수 있다. 예를 들어, 행들이 유클리드 노름 1을 가지는 랜덤 행렬을 생성하고 싶다고 가정하자. 이 경우 다음과 같은 코드를 작성할 수도 있습니다.\njulia&gt; x = rand(1000, 1000);\n\njulia&gt; d = sum(abs2, x; dims=2);\n\njulia&gt; @time x ./= sqrt.(d);\n  0.002049 seconds (4 allocations: 96 bytes)\n이 코드는 일단 동작하지만, 실제로는 행 x[i, :] 의 각 성분에 대해 sqrt(d[i]) 를 다시 계산하게 됩니다. 이는 필요한 것보다 훨씬 많은 제곱근 계산을 수행하게 만든다. 결합된 표현식이 어떤 인덱스를 따라 반복하는지를 정확히 살펴보기 위해서는, Broadcast.combine_axes 를 결합된 표현식의 인자에 호출할 수 있습니다. 이것은 반복 축에 해당하는 범위를 튜플로 반환하며, 이 범위의 길이를 곱한 값이 결합된 연산에 대한 총 호출 횟수가 된다.\n따라서 브로드캐스트 표현식의 일부 구성 요소가 특정 축을 따라 일정할 경우—예를 들어, 이전 예시에서 두 번째 차원의 sqrt—이 구성 요소의 결합을 강제로 해제하여 성능을 개선할 가능성이 있습니다. 즉, 브로드캐스트된 연산의 결과를 미리 할당하고, 일정한 축을 따라 캐시된 값을 재사용하는 것이다. 이를 위한 몇 가지 가능한 방법으로는, 임시 변수를 사용하거나, 점 표현식의 구성 요소를 identity 로 래핑하거나, 동등한 내재적 벡터화된(그러나 결합되지 않은) 함수를 사용하는 것 등이 있습니다.\n예를 들어, 다음과 같이 코드를 수정할 수 있다:\njulia&gt; @time let s = sqrt.(d); x ./= s end;\n  0.000809 seconds (5 allocations: 8.031 KiB)\n\njulia&gt; @time x ./= identity(sqrt.(d));\n  0.000608 seconds (5 allocations: 8.031 KiB)\n\njulia&gt; @time x ./= map(sqrt, d);\n  0.000611 seconds (4 allocations: 8.016 KiB)\n이러한 방법 중 어느 것을 사용하더라도, 약 세 배의 속도 향상을 가져올 수 있다\\(^\\ast\\). 물론 이를 위해서는 메모리 할당이 필요합니다. 큰 규모의 브로드캐스트 객체에 대해서는 이러한 속도 향상이 점근적으로 매우 커질 수 있습다. 최적화를 통해 계산 속도를 높이고 성능을 개선할 수 있는 좋은 예라 할 수 있다.\\(^\\ast\\) 본인의 PC에서는 약 두배 정도의 성능향상을 보였다",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-using_views_for_slices",
    "href": "src/application_of_julia/performance_tips.html#sec-using_views_for_slices",
    "title": "Julia 성능 팁",
    "section": "18 슬라이스에서 views 를 사용하기",
    "text": "18 슬라이스에서 views 를 사용하기\nJulia 에서 array[1:5, :] 과 같은 “slice” 표현은 데이터의 복사본을 만든다. (array[1:5, :]=... 와 같이 할당의 왼쪽에 위치한 경우에는 array 의 부분에 대한 직접 할당이다.) 이 슬라이스에 많은 연산을 수행하는 것은 성능에 좋은데, 이는 큰 원본 배열의 인덱스로 접근하는 것보다 작은 복사본에 대해 연산하는 것이 효율적이기 때문이다. 반면에 만약 소수의 간단한 연산만을 수항한다면 할당과 복사 연산을 수행하는 비용이 중요해진다.\n이에 대한 대안은 배열의 “view” 를 만드는 것이다. view 는 원본 배열의 데이터를 실제로 참조하는 배열 객체 (SubArray) 로서, 복사본을 만들지 않는다. (만약 view 에 기록한다면 원본 데이터를 수정하는 것이다). 개별 슬라이스에 대해 view 함수룰 호출하거나, 더 간단하게는 전체 표현이나 코드의 블록 앞에 @views 를 삽입하여 view 를 만들 수 있다. 예를 들어 :\njulia&gt; fcopy(x) = sum(x[2:end-1]);\n\njulia&gt; @views fview(x) = sum(x[2:end-1]);\n\njulia&gt; x = rand(10^6);\n\njulia&gt; @time fcopy(x);\n  0.003051 seconds (3 allocations: 7.629 MB)\n\njulia&gt; @time fview(x);\n  0.001020 seconds (1 allocation: 16 bytes)\nfview 버젼에서 두가지 모두 3배의 속도 향상과 메모리 할당 감소가 발생했음에 주목하라.(본인의 PC에서는 4.7배였다.)",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-copying_data_is_not_always_bad",
    "href": "src/application_of_julia/performance_tips.html#sec-copying_data_is_not_always_bad",
    "title": "Julia 성능 팁",
    "section": "19 데이터 카피는 항상 나쁜것은 아니다.",
    "text": "19 데이터 카피는 항상 나쁜것은 아니다.\n배열은 메모리에 연속적으로 저장되며, CPU vectorization에 적합하고 캐싱(caching)으로 인해 메모리 액세스가 감소한다. 이것들은 열-우선 순서로 저장되는것이 권장되는 것과 같은 이유이다. 불규한 접근 패턴과 비 연속적인 views 는 순차적이지 않은 메모리 접근으로 인해 배열에 대한 계산을 급격하게 느리게한다.\n불규칙적으로 접근되는 데이터를 이에 대한 연산 이전에 인접 배열(contiguous array)로 카피하는 것은 아래의 보기와 같은 상당한 속도 향상을 이끌어 낼 수 있다. 여기서는 행렬이 곱해지기 전에 임의로 섞여진 인덱스로 접근된다. 일반적인 배열로 복사하는 것은 복사와 할당에 들어가는 비용을 고려하더라도 곱하기 속도를 끌어올린다.\njjulia&gt; using Random\n\njulia&gt; A = randn(3000, 3000);\n\njulia&gt; x = randn(2000);\n\njulia&gt; inds = shuffle(1:3000)[1:2000];\n\njulia&gt; function iterated_neural_network(A, x, depth)\n           for _ in 1:depth\n               x .= max.(0, A * x)\n           end\n           argmax(x)\n       end\n\njulia&gt; @time iterated_neural_network(view(A, inds, inds), x, 10)\n  0.324903 seconds (12 allocations: 157.562 KiB)\n1569\n\njulia&gt; @time iterated_neural_network(A[inds, inds], x, 10)\n  0.054576 seconds (13 allocations: 30.671 MiB, 13.33% gc time)\n1569\n복사본을 위한 충분한 메모리가 있는 경우 view를 배열에 복사하는 비용은 인접 배열에서 행렬 곱셈을 수행하는 속도 향상에 의해 극복된다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-use_staticarrays_jl_for_small_array",
    "href": "src/application_of_julia/performance_tips.html#sec-use_staticarrays_jl_for_small_array",
    "title": "Julia 성능 팁",
    "section": "20 작은 크기의 벡터/행렬 연산에는 StaticArrays.jl 사용을 고려해보라",
    "text": "20 작은 크기의 벡터/행렬 연산에는 StaticArrays.jl 사용을 고려해보라\n\n\n\n\n\n\n노트\n\n\n\n이 강죄에서 StaticArrays.jl 참고할 수 있다.\n\n\n당신이 매우 작고 (원소의 수가 100개 이하의) 크기가 고정된 (즉, 실행 이전에 크기를 알 수 있는) 배열을 다루려고 한다면 StaticArrays.jl 패키지 를 사용하고 싶어할 수도 있다. 이 패키지는 당신이 이 배열을 표현하는데 불필요한 힙(heap) 할당을 피하며, 컴파일러가 배열의 크기에 특화된 코드를 작성하도록, 즉 벡터 연산을 완전히 풀고(루프를 제거하고) 원소를 CPU 레지스터에 저장하도록 해 준다.\n예를 들어, 만약 당신이 2차원 기하학에서의 계산을 하고 있다면 성분이 2개인 벡터에 대한 많은 계산을 수행할 것이다. StaticArrays.jl 의 SVector 를 사용하면 편리한 벡터 노테이션과 벡터 v 와 u 에 대한 norm(3v-w) 와 같은 연산을 수행하며, 이때 컴파일러는 @inbounds hypot(3v[1]-w[1], 3v[2]-w[2]) 와 동등한 최소한의 계산을 하도록 코드를 전개한다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-avoid_string_interpolation_for_outputs",
    "href": "src/application_of_julia/performance_tips.html#sec-avoid_string_interpolation_for_outputs",
    "title": "Julia 성능 팁",
    "section": "21 입출력에서 문자열 interpolation 을 피하라",
    "text": "21 입출력에서 문자열 interpolation 을 피하라\n파일이나 입출력 장체에 데이터를 쓸 때 추가적인 intermadiate strings 를 만드는것은 오버헤드의 원인이다.\nprintln(file, \"$a $b\")\n위의 코드 대신에 아래의 코드를 사용하라.\nprintln(file, a, \" \", b)\n코드의 첫번째 버젼은 문자열을 만들고 그것을 파일에 쓰지만, 두번째 버젼은 값을 직접적으로 파일에 쓴다. 몇몇 경우에서는 문자열 인터폴레이션이 읽기 힘들다는 것에 역시 주의하라. 예를 들어,\nprintln(file, \"$(f(a))$(f(b))\")\n과\nprintln(file, f(a), f(b))\n를 비교해보라.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-optimize_networ_IO_during_paralle_execution",
    "href": "src/application_of_julia/performance_tips.html#sec-optimize_networ_IO_during_paralle_execution",
    "title": "Julia 성능 팁",
    "section": "22 병렬 처리동안의 네트워크 입출력을 최적화하라",
    "text": "22 병렬 처리동안의 네트워크 입출력을 최적화하라\n\n네트워크 병렬 처리는 잘 몰라서..\n\n병렬로 원격 함수를 처리한다고 하자:\nusing Distributed\n\nresponses = Vector{Any}(undef, nworkers())\n@sync begin\n    for (idx, pid) in enumerate(workers())\n        @async responses[idx] = remotecall_fetch(foo, pid, args...)\n    end\nend\n는 아래 보다 빠르다.\nusing Distributed\n\nrefs = Vector{Any}(undef, nworkers())\nfor (idx, pid) in enumerate(workers())\n    refs[idx] = @spawnat pid foo(args...)\nend\nresponses = [fetch(r) for r in refs]\nThe former results in a single network round-trip to every worker, while the latter results in two network calls - first by the (spawnat?) and the second due to the fetch (or even a wait). The fetch/wait is also being executed serially resulting in an overall poorer performance.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-fix_deprecation_warrnings",
    "href": "src/application_of_julia/performance_tips.html#sec-fix_deprecation_warrnings",
    "title": "Julia 성능 팁",
    "section": "23 사용 중단(deprecation) 경고에 따른 수정",
    "text": "23 사용 중단(deprecation) 경고에 따른 수정\n사용이 중단된(deprecated) 함수는 내부적으로 관련된 경고를 출력하기 위해 한차례 조회한다. 이 여분의 조회는 중대한 지연의 원인이 되므로 사용이 중단된 모든 함수는 경고에 따라 수정되어야 한다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-tweaks",
    "href": "src/application_of_julia/performance_tips.html#sec-tweaks",
    "title": "Julia 성능 팁",
    "section": "24 Tweaks",
    "text": "24 Tweaks\n빡빡한 내부 루프에서 도움이 되는 몇가지 사소한 사항이다.\n\n불필요한 배열을 피하라. 예를 들어 sum([x, y, z]) 를 사용하지 말고 x+y+z 를 사용하라.\nabs(z)^2 대신에 abs2(z) 를 사용하라. 일반적인 경우 복소수 인자에 abs 를 사용하지 말고 abs2를 이용하여 코드를 다시 써라.\n정수의 나누기의 몫을 구할때는 trunc(x/y) 대신에 div(x, y) 를 사용하고, floor(x/y) 대신에 fld(x, y) 를, ceil(x/y) 대신에 cld(x, y) 를 사용하라.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#performance-annotations",
    "href": "src/application_of_julia/performance_tips.html#performance-annotations",
    "title": "Julia 성능 팁",
    "section": "25 Performance Annotations",
    "text": "25 Performance Annotations\n때로는 특정 프로그램 속성을 보장하여 더 나은 최적화를 가능하게 할 수 있다.\n\n@inbounds 를 사용하면 표현식 내에서 배열의 경계를 확인하지 않는다. 이것을 사용하기 전헤 꼭 확인하라. 만약 이후의 구문에서 경계를 벗어나면, 프로그램이 멈추거나, silent corruption 이 발생할 수 있다.\n@fastmath 는 실수에 대해 올바른, 그러나 IEEE 수에 대해서는 다른 부동소수 연산을 허용한다. 이것때문에 수치적 결과가 달라질 수 있으므로 조심해야 한다. 이것은 clang 의 ffast-math 옵션에 상응한다.\niteration 이 독립적이며 재배열될 수 있을 경우에만 @simd 를 for 루프 앞에 놓으라. 많은 경우 Julia는 @simd 매크로 없이도 자동으로 코드를 벡터화할 수 있지만, 이런 변환이 원래는 불법적인 상황에서만 이 매크로가 유용하다. 예를 들어, 부동 소수점 재결합(부동 소숫점 연산이 수학적으로 동등할경우 연산 순서를 임의로 바꾸는것, 즉 코드는 (a+b)+c 를 말하지만 컴파일러가 a+(b+c) 를 계산하는등) 을 허용하거나 종속적인 메모리 접근을 무시하는 경우(@simd ivdep) 등이 이에 해당합니다. 반복이 종속적인 루프를 앞에 @simd 를 놓으면 예상치 못한 결과를 초래할 수 있으므로 매우 신중해야 한다. 특히, 일부 AbstractArray 서브타입의 setindex! 메서드는 반복 순서에 따라 본질적으로 종속적일 수 있다. 이 기능은 실험적이며 향후 Julia 버전에서 변경되거나 사라질 수 있다는것에 유의하라.\n\n1:n 을 사용하여 AbstractArray로 인덱싱하는 일반적인 관습은 Array가 비관습적인 인덱싱을 사용하는 경우 안전하지 않으며 경계 검사가 꺼져 있으면 세그멘테이션 오류가 발생할 수 있다. LinearIndices(x) 또는 eachindex(x)를 대신 사용하라(Arrays with custom indices 를 참고하라.)\n\n\n\n\n\n\n주의\n\n\n\n@simd 가 가장 내부의 for 루프에 직접적으로 위치해야 하는 반면에 @inbounds 와 @fastmath 는 단일 표현이나 중첩된 코드 블락의 모든 표현식에서 사용될 수 있다. 즉 @inbounds begin 이나 @inbounds for 처럼.\n\n\n@inbounds 와 @simd 마크업을 모두 사용하는 예제는 다음과 같다. 여기서는 @noinline 을 사용하여 최적화기가 지나치게 영리하게 작동하여 벤치마크를 무너뜨리는 것을 방지한다:\n@noinline function inner(x, y)\n    s = zero(eltype(x))\n    for i=eachindex(x)\n        @inbounds s += x[i]*y[i]\n    end\n    return s\nend\n\n@noinline function innersimd(x, y)\n    s = zero(eltype(x))\n    @simd for i = eachindex(x)\n        @inbounds s += x[i] * y[i]\n    end\n    return s\nend\n\nfunction timeit(n, reps)\n    x = rand(Float32, n)\n    y = rand(Float32, n)\n    s = zero(Float64)\n    time = @elapsed for j in 1:reps\n        s += inner(x, y)\n    end\n    println(\"GFlop/sec        = \", 2n*reps / time*1E-9)\n    time = @elapsed for j in 1:reps\n        s += innersimd(x, y)\n    end\n    println(\"GFlop/sec (SIMD) = \", 2n*reps / time*1E-9)\nend\n\ntimeit(1000, 1000)\n\n2.4 GHz 인텔 코어 i5 프로세서에서 의 결과는 다음과 같다.\nGFlop/sec        = 1.9467069505224963\nGFlop/sec (SIMD) = 17.578554163920018\n(GFlop/sec 는 성능 측정 단위이며 클수록 좋다)\n\n여기에 세가지 종류의 지정의 보기를 제시한다. 이 프로그램은 일차원 배열의 유한 차분을 계산하고 그 결과의 L2-norm 을 구한다.\nfunction init!(u::Vector)\n    n = length(u)\n    dx = 1.0 / (n-1)\n    @fastmath @inbounds @simd for i in 1:n #by asserting that `u` is a `Vector` we can assume it has 1-based indexing\n        u[i] = sin(2pi*dx*i)\n    end\nend\n\nfunction deriv!(u::Vector, du)\n    n = length(u)\n    dx = 1.0 / (n-1)\n    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx\n    @fastmath @inbounds @simd for i in 2:n-1\n        du[i] = (u[i+1] - u[i-1]) / (2*dx)\n    end\n    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx\nend\n\nfunction mynorm(u::Vector)\n    n = length(u)\n    T = eltype(u)\n    s = zero(T)\n    @fastmath @inbounds @simd for i in 1:n\n        s += u[i]^2\n    end\n    @fastmath @inbounds return sqrt(s)\nend\n\nfunction main()\n    n = 2000\n    u = Vector{Float64}(undef, n)\n    init!(u)\n    du = similar(u)\n\n    deriv!(u, du)\n    nu = mynorm(du)\n\n    @time for i in 1:10^6\n        deriv!(u, du)\n        nu = mynorm(du)\n    end\n\n    println(nu)\nend\n\nmain()\n\n2.7 GHz Intel Core i7 의 결과는\n$ julia wave.jl;\n  1.207814709 seconds\n4.443986180758249\n\n$ julia --math-mode=ieee wave.jl;\n  4.487083643 seconds\n4.443986180758249\n여기서 --math-mode=ieee 옵션은 @fastmath 매크로를 무효화하여 결과를 비교할 수 있게 해 준다.\n@fastmath 옵션에 의해 3.7 배의 속도 향상이 있었다. 이것은 대단히 큰데, 보통의 속도 향상은 이보다 작다 (위의 특별한 보기에서는 벤치마크가 이루어지는 집합을 프로세서의 L1 캐시에 적합할 정도로 작게 잡는데 이것은 메모리에 접근에 의한 지연이 발생하지 않게 해서 계산 시간이 CPU 사용에만 최대한 의존하게 한다. 그러나 실제 프로그램에서는 이련 경우가 거의 없다) 또한 이 경우, 최적화가 그 결과값을 바꾸지 않았다. 많은 경우 그 결과는 약간 차이가 난다. 어떤 경우, 특히 수치적으로 불안한(Round-off 에러에 의해 그 값이 상당히 변할 수 있는) 알고리즘의 경우는, 그 결과값이 매우 차이가 날 수 있다.\n@fastmath 는 부동 소수점 표현식을 재배열한다. 예를 들어, 평가 순서를 변경하거나 특수한 경우(inf, NaN)가 발생하지 않는다고 가정한다. 이 경우(그리고 이 특정 컴퓨터에서) 주요 차이점은 함수 deriv 내에서 1 / (2*dx) 표현식을 루프 밖으로 이동시킨다는 점이다. 즉, idx = 1 / (2*dx) 로 작성한 것처럼 계산이 루프 외부에서 이루어진다. 루프 내에서는 표현식 ... / (2*dx) 가 ... * idx 로 변환되어 훨씬 빠르게 계산된다. 물론, 컴파일러에 의해 적용되는 실제 최적화와 결과적인 속도 증가는 하드웨어에 크게 의존한다. Julia의 code_native 함수를 사용하여 생성된 코드의 변화를 확인할 수 있다.\n또한 @fastmath 는 NaN 이 계산 과정에 발생하지 않는고 가정한다. 그러나 실제 발생할경우 예기치 못한 결과가 발생 할 수 있다.\nIn [11]: f(x) = isnan(x);\n\nIn [12]: f(NaN)\nOut[12]: true\n\nIn [13]: f_fast(x) = @fastmath isnan(x);\n\nIn [14]: f_fast(NaN)\nOut[14]: false",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-subnormal_number_is_zero",
    "href": "src/application_of_julia/performance_tips.html#sec-subnormal_number_is_zero",
    "title": "Julia 성능 팁",
    "section": "26 비정규수를 zero 로 취급한다",
    "text": "26 비정규수를 zero 로 취급한다\n부동소수에서 비정규수(subnormal number) 는 그 절대값이 0 에 매우 가까운 작은 수이다. 이 비정규수는 다수의 하드웨어에서 계산 성능을 떨어트린다. set_zero_subnormals(true) 는 부동 소수 연산에서 비정규수를 영으로 취급하도록 하며 이는 몇몇 하드웨어에서 계산 속도를 높인다. 반대로 set_zero_subnormals(false) 는 IEEE 기준에 따라 엄밀하게 다루도록 한다.\n아래의 예는 비정규수가 당신의 하드웨어에서 어떻게 영향을 끼치는지 확인을 할 수 있게 해준다.\nfunction timestep(b::Vector{T}, a::Vector{T}, Δt::T) where T\n    @assert length(a)==length(b)\n    n = length(b)\n    b[1] = 1                            # Boundary condition\n    for i=2:n-1\n        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * Δt\n    end\n    b[n] = 0                            # Boundary condition\nend\n\nfunction heatflow(a::Vector{T}, nstep::Integer) where T\n    b = similar(a)\n    for t=1:div(nstep,2)                # Assume nstep is even\n        timestep(b,a,T(0.1))\n        timestep(a,b,T(0.1))\n    end\nend\n\nheatflow(zeros(Float32,10),2)           # Force compilation\nfor trial=1:6\n    a = zeros(Float32,1000)\n    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic\n    @time heatflow(a,1000)\nend\n6번 계산을 시도하며 짝수번째일 때 set_zero_subnomals(true) 이다. 위의 코드를 실행했을 때의 결과는 다음과 비슷할 것이다.\n  0.002202 seconds (1 allocation: 4.063 KiB)\n  0.001502 seconds (1 allocation: 4.063 KiB)\n  0.002139 seconds (1 allocation: 4.063 KiB)\n  0.001454 seconds (1 allocation: 4.063 KiB)\n  0.002115 seconds (1 allocation: 4.063 KiB)\n  0.001455 seconds (1 allocation: 4.063 KiB)\n짝수번째 실행에서 속도가 매우 빨라졌음을 알 수 있다. 계산 과정에서 많은 비정규수가 발생하는데 a 의 수가 지수적으로 감소하며, 시간이 지남에 따라 점차 수렴에 가까워 지기 때문이다.\n비정규수를 0 으로 취급하는것은 조심스러워야 한다. x-y==0 인 것은 x=y 를 의미하지만 비정규수를 0 으로 취급할 경우 이것이 성립하지 않을 수도 있다.\nIn [15]: x = 3f-38; y = 2f-38;\n\nIn [16]: set_zero_subnormals(true); (x - y, x == y)\nOut[16]: (0.0f0, false)\n\nIn [17]: set_zero_subnormals(false); (x - y, x == y)\nOut[17]: (1.0000001f-38, false)\n\n비정규수를 0으로 만드는 방법 이외에 사용하는 것은 0 값들로 초기화된 배열에 작은 난수를 넣는 것이다. 예를 들어 다음과 같이.\na = rand(Float32, 1000) * 1.0f-9",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-code_warntype_macro",
    "href": "src/application_of_julia/performance_tips.html#sec-code_warntype_macro",
    "title": "Julia 성능 팁",
    "section": "27 @code_warntype",
    "text": "27 @code_warntype\n@code_warntype (혹은 함수형인 code_warntype) 은 때때로 타입에 관련된 문제를 진단하는데 도움이 된다. 여기에 보기가 있다.:\njulia&gt; @noinline pos(x) = x &lt; 0 ? 0 : x;\n\njulia&gt; function f(x)\n           y = pos(x)\n           return sin(y*x + 1)\n       end;\n\njulia&gt; @code_warntype f(3.2)\nVariables\n  #self#::Core.Const(f)\n  x::Float64\n  y::UNION{FLOAT64, INT64}\n\nBody::Float64\n1 ─      (y = Main.pos(x))\n│   %2 = (y * x)::Float64\n│   %3 = (%2 + 1)::Float64\n│   %4 = Main.sin(%3)::Float64\n└──      return %4\n@code_warntype 혹은 그 사촌뻘인 @code_lowered, @code_typed, @code_llvm 의 출력을 해석하는 것은 약간의 연습이 필요하다. 당신의 코드는 컴파일된 기계 코드를 생성하는 과정에서 많이 요약된 형태로 제시된다. 대부분의 표현은 ::T 로 타입이 제시되어 있다.(여기서 T 는 예를 들자면 Float64 일 수 있다) @code_warntype 의 가장 중요한 특징은 구체적이지 않은 타입은 빨간색으로 표현된다는 것이다.\n최상단에는 함수의 추정된 반환 타입이 Body::Float64로 표시된다. 다음 줄은 Julia 의 SSA IR 형식으로 f 의 본체(Body)를 표현한다. 숫자가 적힌 상자들은 레이블 이며 당신의 코드에서 (goto 를 통해) 점프하는 지점을 의미한다. Body 를 보면 첫번째로 발생하는 것은 pos 가 호출되며 리턴값이 Union 타입 UNION{FLOAT64, INT64}으로 추론되는데 구체적 타입이 아니므로 대문자로 보여진다. 이것은 입력 타입들로부터 pos 의 정확한 리턴 타입을 알 수 없다는 것을 의미한다. 그러나 y 가 Float64 든 Int64 든 상관 없이 y*x 의 결과는 Float64 이다. 몇몇 중간 계산들이 타입-불안정 할 지라도 f(x::Float64) 의 출력은 타입-불안정 하지 않다.\n이 정보를 어떻게 사용할지는 당신에게 달려 있다. 분명하게도 pos 를 타입-안정적이 되도록 고정하는것은 지극히 최선이 될 것이다: 당신이 그렇게 한다면 f 내의 모든 변수는 구체적 타입이 되고, 그 성능은 최적이 된다. 그러나 이런 종류의 일시적인 타입 불안정성이 크게 중요하지 않은 상황이 있다: 여를 들자면 pos 가 결코 고립되어(in isolation) 사용되지 않는다면, f 의 출력이 Float64인 입력 타입에 대해 타입-안정적이므로 이후 코드를 타입 불안정성이 전파(propagating) 되는 것으로부터 보호해준다. 이것은 특히 타입 불안정성을 수정하는 것이 어렵거나 불가능할 경우와 깊이 관계가 있다. 이 경우, 위에 기술한 팁들(예를 들자면, 타입 지정을 추가하거나 함수를 분리하는것 등)은 타입 불안정성으로부터의 피해를 방지하는 가장 좋은 수단이다. 예를 들어, 함수 firstfind 는 어떤 키가 발견되는 인덱스를 리턴하거나, 키가 없다면 nothing을 리턴하므로 명백히 타입-불안정 하다. 중요할 지도 모르는 타입-불안정성을 쉽게 찾기 위해 missing 이나 nothing 을 포함하는 Unions 는 빨간색이 아닌 노란색으로 강조된다.\n아래의 예는 non-leaf types 를 포함한다고 표시된 표현들을 해석하는데 도움이 된다.\n\nBody::UNION{T1, T2} 로 시작하는 함수 Body\n\n해석 : 함수의 반환 타입이 안정적이지 않다.\n제안 : 반환값의 타입을 지정해야 하더라도, 반환값을 타입-안정적으로 만들라.\n\ninvoke Main.g(%%x::Int64)::UNION{FLOAT64, INT64}\n\n해석 : 타입-불안정한 함수 g 를 호출한다.\n제안 : 함수를 수정하거나 필요하다면 반한 값의 타입을 지정하라\n\ninvoke Base.getindex(%%x::Array{Any,1}, 1::Int64)::ANY\n\n해석 : 빈약하게 타입된 배열의 원소에 접근한다.\n제안 : 더 잘 정의된 타입의 배열을 사용하거나, 필요하다면 접근하는 개별적 원소의 타입을 지정하라\n\nBase.getfield(%%x, :(:data))::ARRAY{FLOAT64,N} WHERE N\n\n해석 : non-leaf type 인 필드를 취하라. 이 경우 x 의 타입 ArrayContainer 는 data::Array{T} 필드를 가지고 있다. 그러나 Array 는 차원 N 을 필요로 하는데 N 은 concrete type 이어야 한다. \n제안 : Array{T, 3} 이나 Array{T, N} 과 같은 concrete 타입을 사용하라. 여기서 N 은 이제 ArrayContainer 의 매개변수이다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-performance_of_captured_variables",
    "href": "src/application_of_julia/performance_tips.html#sec-performance_of_captured_variables",
    "title": "Julia 성능 팁",
    "section": "28 포획된 변수의 성능",
    "text": "28 포획된 변수의 성능\nfunction abmult(r::Int)\n    if r &lt; 0\n        r = -r\n    end\n    f = x -&gt; x * r\n    return f\nend\n함수 admult 는 함수 f 를 반환하는데 f 는 인자에 r 의 절대값을 곱한 값을 반환한다. f 변수로 할당된 내부 함수는 closure 라고 불린다. 내부 함수는 do-블록 및 제너레이터 표현식에서도 사용된다.\n이 스타일의 코드는 언어에 성능상의 도전 과제를 제공한다. 파서(parser)는 이 코드를 더 낮은 수준의 명령어로 번역할 때, 내부 함수를 별도의 코드 블록으로 추출하며 상당히 재구성한다. 내부 함수 및 이를 둘러싼 스코프가 공유하는 r 과 같은 “포획된” 변수 들은 힙 할당 “상자”로도 추출되며, 이는 내부 함수와 외부 함수 모두 접근할 수 있다. 이는 언어 사양상, 외부 스코프(또는 다른 내부 함수)가 r 을 수정한 후에도 내부 스코프의 r 이 외부 스코프의 r 과 동일해야 하기 때문이다.\n앞 단락에서 언급한 파서(paerser) 란 abmult 를 포함하는 모듈이 처음 로드될 때의 컴파일 단계로, 함수가 처음 호출되는 이후 단계와는 다르다. 파서는 Int 가 고정된 타입인지 또는 r = -r 이 Int 를 다른 Int 로 변환하는지를 알지 못한다. 타입 추론의 마법은 컴파일의 이후 단계에서 발생한다.\n따라서, 파서는 r 이 고정 타입(Int)을 가진다는 것과, 내부 함수가 생성된 후 r 이 값이 변하지 않는다는 것을 알지 못한다(그래서 상자가 필요하지 않음을 알지 못한다). 그래서, 파서는 Any 와 같은 추상 타입을 갖는 객체를 보유하는 상자에 대한 코드를 생성하며, 이는 r 이 발생할 때마다 런타임 타입 디스패치를 요구한다. 이는 @code_warntype 을 위 함수에 적용하여 검증할 수 있다. 이 상자화 작업과 런타임 타입 디스패치는 성능 저하를 유발할 수 있다.\n성능이 중요한 코드 섹션에서 포획된 변수를 사용하는 경우 다음 팁을 통해 이러한 사용이 성능에 효율적이도록 할 수 있다. 먼저, 포획된 변수의 타입이 변경되지 않는 것이 확실하다면, 변수에 대해 타입을 명시적으로 지정할 수 있다(변수의 오른쪽 측면이 아닌 변수 자체에 대해).\nfunction abmult2(r0::Int)\n    r::Int = r0\n    if r &lt; 0\n        r = -r\n    end\n    f = x -&gt; x * r\n    return f\nend\n타입지정을 사용하면 박스화된 객체에 구체적인 타입을 연결할 수 있어 변수 포획으로 인한 성능 손실을 부분적으로 회복할 수 있다. 더 나아가, 포획된 변수가 클로저가 생성된 이후에 다시 할당될 필요가 없다면, let 블록을 사용하여 박스화가 전혀 필요 없음을 아래와 같이 표시할 수 있다.\nfunction abmult3(r::Int)\n    if r &lt; 0\n        r = -r\n    end\n    f = let r = r\n            x -&gt; x * r\n    end\n    return f\nend\nlet 블록은 새로운 변수 r 을 생성하며, 이 변수의 스코프는 내부 함수로 제한된다. 이 두 번째 방법은 포획된 변수가 있을 때, 전체 언어 성능을 복구하는 방법이다. 컴파일러의 이 부분은 빠르게 발전하고 있는 영역이므로 향후 릴리스에서는 성능을 최적화하기 위해 이 수준의 프로그래머에 의한 지정이 필요하지 않을 가능성이 높다. 현재로서는 FastClosures 같은 사용자 기여 패키지가 abmult3 에서 let 문 삽입을 자동화하는 기능을 제공한다. 이러한 패키지는 클로저 사용 시 성능 저하를 방지하고 최적화를 돕기 위해 let 블록을 적절히 추가해 줍니다. 패키지를 통해 이러한 작업을 자동화하면 코드의 가독성과 유지 보수성을 높일 수 있다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-multithreading_and_linear_algebra",
    "href": "src/application_of_julia/performance_tips.html#sec-multithreading_and_linear_algebra",
    "title": "Julia 성능 팁",
    "section": "29 멀티스레딩과 선형대수",
    "text": "29 멀티스레딩과 선형대수\n이 섹션은 각 스레드에서 선형 대수 연산을 수행하는 멀티스레드 Julia 코드에 적용된다. 실제로 이러한 선형 대수 연산은 BLAS/LAPACK 호출을 포함하며, 이 호출들 역시 멀티스레드로 동작한다. 이 경우, 두 가지 다른 유형의 멀티스레딩으로 인해 코어가 과도하게 사용되지 않도록 해야 합니다.\nJulia는 선형 대수를 위해 OpenBLAS의 사본을 컴파일하여 사용하며, 이의 스레드 수는 환경 변수 OPENBLAS_NUM_THREADS 로 제어된다. Julia를 실행할 때 커맨드 라인 옵션으로 설정하거나, Julia 세션에서 BLAS.set_num_threads(N) 을 통해 변경할 수 있다 (서브모듈 BLAS 는 using LinearAlgebra 를 통해 export 된다). 현재 값은 BLAS.get_num_threads() 로 확인할 수 있다 사용자가 아무것도 지정하지 않으면, Julia는 OpenBLAS 스레드 수에 대해 합리적인 값을 선택하려고 한다(예: 플랫폼, Julia 버전 등 기반으로). 그러나 일반적으로 수동으로 확인하고 설정하는 것이 권장된다. OpenBLAS의 동작은 다음과 같습니다:\n\nOPENBLAS_NUM_THREADS=1 인 경우, OpenBLAS는 호출하는 Julia 스레드를 사용한다. 이는 계산을 실행하는 Julia 스레드 내에서 “작동”합니다.\nOPENBLAS_NUM_THREADS=N&gt;1 인 경우, OpenBLAS는 자체 스레드 풀(N 개 스레드)을 생성하고 관리한다. 모든 Julia 스레드 간에 공유되는 단 하나의 OpenBLAS 스레드 풀이 존재한다.\n\nJULIA_NUM_THREADS=X 로 멀티스레드 모드에서 Julia를 시작할 때, OPENBLAS_NUM_THREADS=1 로 설정하는 것이 일반적으로 추천된다. 위에서 설명한 동작에 따라, BLAS 스레드 수를 N&gt;1 로 늘리면 성능이 쉽게 저하될 수 있으며, 특히 N&lt;&lt;X 일 때 더욱 그렇다. 그러나 이는 일반적인 기준일 뿐이며, 각각의 스레드 수를 설정하는 최선의 방법은 특정 애플리케이션에서 실험해 보는 것이다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/performance_tips.html#sec-alternative_linearalgebra_backends",
    "href": "src/application_of_julia/performance_tips.html#sec-alternative_linearalgebra_backends",
    "title": "Julia 성능 팁",
    "section": "30 대안적인 선형대수 백엔드",
    "text": "30 대안적인 선형대수 백엔드\nOpenBLAS 외에도 선형 대수 성능을 향상시킬 수 있는 여러 다른 백엔드가 존재한다. 대표적인 예로는 MKL.jl 과 AppleAccelerate.jl 이 있다. 이들은 외부 패키지이기 때문에 여기서 자세히 다루지는 않는다. 각 패키지의 문서를 참조할 수 있다. 특히 이들은 멀티스레딩과 관련해서 OpenBLAS와 다른 동작을 가지므로, 문서를 통해 이를 확인하는 것이 중요하다.\n\n\n1 역자의 iMac 에서 실행해보면,\njulia&gt; code_llvm(func, Tuple{MyType{Float64}})\n;  @ REPL[7]:1 within `func`\ndefine double @julia_func_399({}* nonnull align 8 dereferenceable(8) %0) #0 {\ntop:\n; ┌ @ Base.jl:42 within `getproperty`\n   %1 = bitcast {}* %0 to double*\n   %2 = load double, double* %1, align 8\n; └\n; ┌ @ promotion.jl:379 within `+` @ float.jl:399\n   %3 = fadd double %2, 1.000000e+00\n; └\n  ret double %3\n}\n과\njulia&gt; code_llvm(func, Tuple{MyType{AbstractFloat}})\n;  @ REPL[7]:1 within `func`\ndefine nonnull {}* @japi1_func_411({}* %0, {}** %1, i32 %2) #0 {\ntop:\n  %3 = alloca [2 x {}*], align 8\n  %gcframe2 = alloca [3 x {}*], align 16\n  %gcframe2.sub = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe2, i64 0, i64 0\n  %.sub = getelementptr inbounds [2 x {}*], [2 x {}*]* %3, i64 0, i64 0\n  %4 = bitcast [3 x {}*]* %gcframe2 to i8*\n  call void @llvm.memset.p0i8.i32(i8* nonnull align 16 dereferenceable(24) %4, i8 0, i32 24, i1 false)\n  %5 = alloca {}**, align 8\n  store volatile {}** %1, {}*** %5, align 8\n  %6 = call {}*** inttoptr (i64 140703617757141 to {}*** (i64)*)(i64 261) #2\n  %7 = bitcast [3 x {}*]* %gcframe2 to i64*\n  store i64 4, i64* %7, align 16\n  %8 = load {}**, {}*** %6, align 8\n  %9 = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe2, i64 0, i64 1\n  %10 = bitcast {}** %9 to {}***\n  store {}** %8, {}*** %10, align 8\n  %11 = bitcast {}*** %6 to {}***\n  store {}** %gcframe2.sub, {}*** %11, align 8\n  %12 = bitcast {}** %1 to {}***\n  %13 = load {}**, {}*** %12, align 8\n; ┌ @ Base.jl:42 within `getproperty`\n   %14 = load atomic {}*, {}** %13 unordered, align 8\n; └\n  %15 = bitcast {}* %14 to i64*\n  %16 = getelementptr inbounds i64, i64* %15, i64 -1\n  %17 = load atomic i64, i64* %16 unordered, align 8\n  %18 = and i64 %17, -16\n  %19 = inttoptr i64 %18 to {}*\n  %.not = icmp eq {}* %19, inttoptr (i64 4901751808 to {}*)\n  br i1 %.not, label %L5, label %L8\n\nL5:                                               ; preds = %top\n  %20 = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe2, i64 0, i64 2\n  store {}* %14, {}** %20, align 16\n  %21 = call nonnull {}* @\"j_+_412\"({}* nonnull %14, i64 signext 1) #3\n  br label %L10\n\nL8:                                               ; preds = %top\n  %22 = getelementptr inbounds [3 x {}*], [3 x {}*]* %gcframe2, i64 0, i64 2\n  store {}* %14, {}** %22, align 16\n  store {}* %14, {}** %.sub, align 8\n  %23 = getelementptr inbounds [2 x {}*], [2 x {}*]* %3, i64 0, i64 1\n  store {}* inttoptr (i64 4453740640 to {}*), {}** %23, align 8\n  %24 = call nonnull {}* @jl_apply_generic({}* inttoptr (i64 4917381120 to {}*), {}** nonnull %.sub, i32 2)\n  br label %L10\n\nL10:                                              ; preds = %L8, %L5\n  %value_phi = phi {}* [ %21, %L5 ], [ %24, %L8 ]\n  %25 = load {}*, {}** %9, align 8\n  %26 = bitcast {}*** %6 to {}**\n  store {}* %25, {}** %26, align 8\n  ret {}* %value_phi\n}\n이다. Julia REPL 과 markdown 의 신텍스 하이라이팅 컬러가 다르므로 Julia REPL 에서는 다른 색이르 보일 수 있다.\n2 예를 들어 배열 X=[1 2 3 4] 에 대한 sin.(cos.(x)) 는 [sin(cos(x)) for x in X] 와 결과가 같다.\n3 @. expr 은 expr 의 모든 함수 호출을 도트 호출로 (예를 들면 f(x) 를 f.(x) 로), 모든 할당을 도트 할당으로 (예를 들면 += 을 .+= 으로) 바꾸어 주는 매크로이다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 성능 팁"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html",
    "href": "src/application_of_julia/style_guide.html",
    "title": "Julia 스타일 가이드",
    "section": "",
    "text": "이 문서는 관례적인 julia 언어의 코딩 스타일의 몇가지 모습에 대해 다룹니다. 이 규칙들중에 어떤 것도 절대적이지 않으며 단지 당신이 언어에 친숙해지고 다른 여러가지중에 선택하도록 제안하는 것입니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-indentation",
    "href": "src/application_of_julia/style_guide.html#sec-indentation",
    "title": "Julia 스타일 가이드",
    "section": "1 들여쓰기",
    "text": "1 들여쓰기\n각 들여쓰기 레벨마다 4개의 공백을 사용합니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-write_functions",
    "href": "src/application_of_julia/style_guide.html#sec-write_functions",
    "title": "Julia 스타일 가이드",
    "section": "2 단순한 스크립트가 아닌 함수를 사용한다",
    "text": "2 단순한 스크립트가 아닌 함수를 사용한다\nWriting code as a series of steps at the top level is a quick way to get started solving a problem, but you should try to divide a program into functions as soon as possible. Functions are more reusable and testable, and clarify what steps are being done and what their inputs and outputs are. Furthermore, code inside functions tends to run much faster than top level code, due to how Julia’s compiler works.\nIt is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants like pi).\n코드를 최상위 단계에서 일련의 단계로 작성하는 것은 문제를 해결하는 빠른 시작 방법이지만 가능한 한 빨리 프로그램을 함수로 나누는 것이 좋습니다. 함수는 재사용 가능하고 테스트하기 쉬우며, 수행 중인 단계와 입력 및 출력이 무엇인지 명확하게 해줍니다. 더욱이, Julia의 컴파일러 작동 방식 때문에 함수 내부의 코드는 최상위 레벨 코드보다 훨씬 더 빠르게 실행되는 경향이 있습니다.\n또한, 함수는 전역 변수를 직접 사용하는 대신(π와 같은 상수를 제외하고) 인자를 받아야 한다는 점을 강조할 가치가 있습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-avoid_writing_overly-specific_types",
    "href": "src/application_of_julia/style_guide.html#sec-avoid_writing_overly-specific_types",
    "title": "Julia 스타일 가이드",
    "section": "3 과도하게 타입을 특정하는것을 피하세요",
    "text": "3 과도하게 타입을 특정하는것을 피하세요\n코드는 가능한 한 generic 해야 합니다. Generic 이란 코드 작성 시점이 아니라 코드 동작 시점에서 결정되는 것을 말합니다.\nComplex{Float64}(x)\n보다는 generic 함수를 사용하여 다음과 같이 쓰는 것이 좋습니다.\ncomplex(float(x))\n이 버젼은 x 를 항상 같은 타입이 아닌 적당한 타입으로 변경합니다.\n이 스타일 지침은 특히 함수의 인자와 관련이 있습니다. 예를 들어, 실제로 어떤 정수든 가능하다면 특정 인자를 반드시 Int 나 Int32 로 선언하지 말고 추상 타입인 Integer 를 사용하세요. 사실, 다른 메서드 정의와의 모호성을 해결할 필요가 없다면, 많은 경우 인수 타입을 생략할 수도 있습니다. 필요한 작업을 지원하지 않는 타입이 전달되면 어쨌든 MethodError 가 발생하기 때문입니다. (이를 덕 타이핑이라고 합니다.)\n아래의 addone 함수의 정의를 예를 들어 봅시다. 이 함수는 인자에 1 을 더한 값을 반환합니다.\naddone(x::Int) = x + 1                 # works only for Int\naddone(x::Integer) = x + oneunit(x)    # any integer type\naddone(x::Number) = x + oneunit(x)     # any numeric type\naddone(x) = x + oneunit(x)             # any type supporting + and oneunit\naddone 의 마지막 정의는 oneunit 을 지원하는 모든 타입과 해당 타입에서 동작하는 + 연산을 처리할 수 있습니다. (oneunit(x) 는 x 와 동일한 타입에서 1 을 반환하며, 의도치 않은 타입 승격을 방지합니다.) 핵심은, addone(x) = x + oneunit(x) 와 같은 일반적인 정의만 작성해도 성능상의 손실이 전혀 없다는 점입니다. Julia는 필요에 따라 자동으로 특화된 버전을 컴파일하기 때문입니다.\n예를 들어, addone(12) 를 처음 호출하면, Julia는 x::Int 인수를 위한 특화된 addone 함수를 자동으로 컴파일하고, oneunit 호출을 인라인된 값 1로 대체합니다. 따라서 위에서 언급한 addone 함수의 처음 세 가지 정의는 네 번째 정의와 완전히 중복됩니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-handle_excess_argument_diversity_in_the_caller",
    "href": "src/application_of_julia/style_guide.html#sec-handle_excess_argument_diversity_in_the_caller",
    "title": "Julia 스타일 가이드",
    "section": "4 과도한 인자의 다양성을 호출할 때 처리세요",
    "text": "4 과도한 인자의 다양성을 호출할 때 처리세요\nfunction foo(x, y)\n    x = Int(x); y = Int(y)\n    ...\nend\nfoo(x, y)\n를 쓰는 대신에 아래를 사용하세요.\nfunction foo(x::Int, y::Int)\n    ...\nend\nfoo(Int(x), Int(y))\nfoo 실제로는 모든 타입의 수를 받지는 않기 때문에 후자가 더 나은 스타일입니다. 단지 Int 들을 받을 뿐입니다.\n여기서 하나의 문제는 함수가 본질적으로 정수만을 필요로 한다면, 함수를 호출할 때 정수가 아닌 수에 대해 어떻게 변환할지(예: floor 나 ceil)를 명시적으로 결정하도록 강제하는 것이 더 나을 수 있다는 점입니다. 또 다른 문제는 더 구체적인 타입을 선언하면 향후 메서드 정의를 위한 더 많은 “여지”을 남길 수 있다는 점입니다. 즉, 특정 타입에 대해 메서드를 정의하면, 추후 다른 타입이나 추상 타입에 대해 별도의 메서드를 정의하기가 더 용이해질 수 있습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#인자를-변경하는-함수의-이름-끝에-를-붙이세요-sec-append__at_the_end_of_function_name",
    "href": "src/application_of_julia/style_guide.html#인자를-변경하는-함수의-이름-끝에-를-붙이세요-sec-append__at_the_end_of_function_name",
    "title": "Julia 스타일 가이드",
    "section": "5 인자를 변경하는 함수의 이름 끝에 ! 를 붙이세요 {#sec-append_!_at_the_end_of_function_name}",
    "text": "5 인자를 변경하는 함수의 이름 끝에 ! 를 붙이세요 {#sec-append_!_at_the_end_of_function_name}\nfunction double(a::AbstractArray{&lt;:Number})\n    for i in eachindex(a)\n        a[i] *= 2\n    end\n    return a\nend\n대신에\nfunction double!(a::AbstractArray{&lt;:Number})\n    for i in eachindex(a)\n        a[i] *= 2\n    end\n    return a\nend\n를 사용하세요.\nJulia Base는 이러한 관례를 전반적으로 사용하며, 복사 와 수정 형태를 모두 제공하는 함수(예: sort와 sort!)와 단순히 수정만 하는 함수(예: push!, pop!, splice!)의 예제를 포함하고 있습니다. 이러한 함수들은 편의를 위해 수정된 배열을 반환하는 것이 일반적입니다.\n입출력(IO) 또는 난수 생성기(RNG)를 사용하는 함수는 주목할 만한 예외입니다. 이 함수들은 거의 반드시 IO나 RNG를 변형해야 하므로, 함수 이름 끝에 !를 붙이는 것은 IO 변형이나 RNG 상태 진행 이외의 다른 변형이 있음을 나타냅니다. 예를 들어 rand(x)는 RNG를 변형하지만, rand!(x) 는 RNG와 x를 모두 변형합니다. 마찬가지로, read(io) 는 io를 변형하지만, read!(io, x)는 io와 x 를 모두 변형합니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-avoid_strange_type_unios",
    "href": "src/application_of_julia/style_guide.html#sec-avoid_strange_type_unios",
    "title": "Julia 스타일 가이드",
    "section": "6 이상한 타입 Unions 를 피하세요",
    "text": "6 이상한 타입 Unions 를 피하세요\nUnion{Function, AbstractString} 과 같은 타입은 대개 설계가 더 분명해야 한다는 것을 의미합니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-avoid_elaborate_container_types",
    "href": "src/application_of_julia/style_guide.html#sec-avoid_elaborate_container_types",
    "title": "Julia 스타일 가이드",
    "section": "7 복잡한 컨테이너 타입을 피하세요",
    "text": "7 복잡한 컨테이너 타입을 피하세요\n다음과 같은 배열을 만드는 것은 보통 도움이 안됩니다.\na = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)\n이경우 Vector{Any}(undef, n) 이 낫습니다. 하나의 타입에 많은 것들을 때려박는 것보다는 특정 사용에서 a[i]::Int 와 같이 컴파일러에게 알려주는 것이 더 도움이 됩니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#section",
    "href": "src/application_of_julia/style_guide.html#section",
    "title": "Julia 스타일 가이드",
    "section": "8 ",
    "text": "8",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-prefer_exported_methods_over_direct_field_access",
    "href": "src/application_of_julia/style_guide.html#sec-prefer_exported_methods_over_direct_field_access",
    "title": "Julia 스타일 가이드",
    "section": "8 직접적으로 필드에 접근하기보다는 export 된 메서드를 사용하세요",
    "text": "8 직접적으로 필드에 접근하기보다는 export 된 메서드를 사용하세요\n관례적인 Julia 코드는 일반적으로 모듈에서 export된 메서드를 해당 타입에 대한 인터페이스로 간주해야 합니다. 객체의 필드는 대개 구현의 세부사항으로 취급되며, API로 명시되지 않는 한 사용자 코드에서 직접 접근해서는 안 됩니다. 이는 다음과 같은 여러 이점을 제공합니다.\n\n패키지 개발자는 구현을 변경해도 사용자 코드를 깨뜨리지 않을 수 있습니다.\n메서드는 map 과 같은 고차 함수에 전달할 수 있습니다. 예를 들어, map(imag, zs)는 [z.im for z in zs] 보다 간결하고 추상적입니다.\n메서드는 추상 타입에 정의될 수 있습니다.\n메서드는 서로 다른 타입 간에 공유될 수 있는 개념적 연산을 기술할 수 있습니다. 예를 들어, real(z) 는 복소수(Complex)와 사원수(Quaternion) 모두에서 동작합니다.\n\nJulia의 디스패치 시스템은 이러한 스타일을 권장합니다. 예를 들어, play(x::MyType) 는 특정 타입에 대해서만 play 메서드를 정의하며, 다른 타입은 각자의 구현을 가질 수 있습니다.\n마찬가지로, export 되지 않은 함수는 내부적으로 사용되며 변경될 가능성이 높습니다. 문서에서 명시하지 않는 한, 이러한 함수는 공개 API로 간주되지 않습니다.\n이 규칙에 대한 반례는 NamedTupe, RegexMatch, StatStruct 가 있습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-using_naming_convections_with_julia_base",
    "href": "src/application_of_julia/style_guide.html#sec-using_naming_convections_with_julia_base",
    "title": "Julia 스타일 가이드",
    "section": "9 Julia base/ 와 일치하도록 이름을 붙이세요",
    "text": "9 Julia base/ 와 일치하도록 이름을 붙이세요\nJulia 코드에서 이름 지정에 대한 스타일 가이드는 다음과 같습니다:\n\n모듈 및 타입 이름에는 대문자와 카멜 케이스(CamelCase)를 사용합니다. : module SparseArrays, struct UnitRange\n함수 이름에는 소문자를 사용합니다(maximum, convert). 읽기 괜찮다면 여러 단어를 붙여 씁니다(isequal, haskey). 필요할 때는 단어 구분자로 밑줄(_)을 사용합니다. 개념을 조합한 경우에도 혹은 수식어가 있을 때에도 밑줄을 사용합니다(remotecall_fetch 는 fetch(remotecall(...)) 의 더 효율적인 구현을 의미합니다). .\n하나 이상의 인수를 수정하는 함수는 이름 끝에 ! 를 붙입니다(sort!, push!).\n간결함을 중시하되, 약어는 피합니다(indxin 보다는 indexin). 약어는 기억하기 어렵고, 특정 단어를 어떻게 축약했는지 혼동을 일으킬 수 있습니다.\n\n여러 단어가 필요한 함수 이름은 해당 함수가 하나 이상의 개념을 표현하는지 고려하십시오. 필요하다면 함수 이름을 더 작은 조각으로 나누는 것이 좋습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-write_functions_with_argument_ordering_simmilar_to_julia_base",
    "href": "src/application_of_julia/style_guide.html#sec-write_functions_with_argument_ordering_simmilar_to_julia_base",
    "title": "Julia 스타일 가이드",
    "section": "10 함수 인자의 순서를 Julia Base 와 비슷하게 하세요",
    "text": "10 함수 인자의 순서를 Julia Base 와 비슷하게 하세요\nJulia 의 Base 라이브러리는 함수 인수의 순서를 다음과 같은 일반 규칙에 따라 배치합니다. 이는 적용 가능한 경우에 해당하며, 일관된 사용자 경험을 제공합니다:\n\n함수 인자. 첫 번째 인수로 함수가 올 경우, do 블록을 사용해 다중 라인의 익명 함수를 전달할 수 있습니다.\nI/O 스트림. I/O 객체가 첫 번째로 오면 sprint 와 같은 함수에 전달하기 용이합니다/ 예: sprint(show, x).\n수정되는 입력 수정되는 입력은 먼저 나옵니다. 예를 들어 fill!(x, v) 에서 x 는 수정 대상이고, 값 v 는 뒤에 옵니다.\n타입. 보통 타입 인자가 있을 경우 함수의 출력이 이 타입을 갖도록 되는 경우가 많습니다.예를 들어 parse(Int, \"1\").그러나 read(io, String) 의 경우, I/O 객체가 타입보다 앞에 오며, 일반 규칙에 맞는 예외입니다.\n수정되지 않는 입력. 수정되지 않는 입력은 수정되는 입력 뒤에 옵니다. 예를 들어 fill!(x, v) 에서 v 는 수정되지 않는 입력입니다.\n키. 연관 컬렉션에서는 키-값 쌍의 키를 나타냅니다. 인덱스 컬렉션에서는 인덱스를 나타냅니다.\n값. 연관 컬렉션에서는 키-값 쌍의 값입니다. fill!(x, v) 의 경유와 비슷합니다.\n기타 인자. 위에 해당하지 않는 나머지 인수입니다.\n가변 인수(Varargs). 함수 호출 시 끝에 무제한 나열 가능한 인수입니다. 예를 들어 Matrix{T}(undef, dims) 에서 차원(dims) 는 튜플로도(Matrix{T}(undef, (1,2))), 가변 인수(Vararg)로 도 (Matrix{T}(undef, 1, 2)) 전달 가능합니다.\n키워드 인수. 키워드 인수는 항상 함수 정의의 마지막에 위치합니다.\n\n대다수 함수는 위에 나열된 모든 종류의 인자를 받지 않습니다. 숫자는 단지 함수에 적용 가능한 인자들의 우선순위를 나타내기 위한 것입니다.\n물론 예외도 있습니다. convert 에서 첫번째 인자는 항상 타입입니다. setindex! 에서는 값이 인덱스보다 앞에 옵니다. 이는 인덱스를 가변 인자로 제공할 수 있게 하기 위함입니다.\nAPI를 설계할 때 이 순서를 최대한 준수하면 함수 사용자가 일관된 경험을 할 수 있습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-dont_overuse_try_catch",
    "href": "src/application_of_julia/style_guide.html#sec-dont_overuse_try_catch",
    "title": "Julia 스타일 가이드",
    "section": "11 try-catch 를 남용하지 마세요",
    "text": "11 try-catch 를 남용하지 마세요\ntry-catch 로 에러를 탐지하는 것보다 피하는 것이 낫습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-dont_parrenthesize_conditions",
    "href": "src/application_of_julia/style_guide.html#sec-dont_parrenthesize_conditions",
    "title": "Julia 스타일 가이드",
    "section": "12 조건문을 괄호로 싸지 마세요",
    "text": "12 조건문을 괄호로 싸지 마세요\nJulia 는 if 나 while 문에서 괄호를 요구하지 않습니다. if (a == b) 대신에 if a == b 를 사용하세요.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-don_overuse_...",
    "href": "src/application_of_julia/style_guide.html#sec-don_overuse_...",
    "title": "Julia 스타일 가이드",
    "section": "13 ... 를 남용하지 마세요",
    "text": "13 ... 를 남용하지 마세요",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-don_overuse_splicing",
    "href": "src/application_of_julia/style_guide.html#sec-don_overuse_splicing",
    "title": "Julia 스타일 가이드",
    "section": "13 ... 를 남용하지 마세요",
    "text": "13 ... 를 남용하지 마세요\n함수 인자 에서 스플라이싱(splicing) 을 자주 사용하면 중독성이 있을 수 있습니다. 예를 들어, [a..., b...] 대신에 간단히 [a; b] 를 사용하세요. 또한, collect(a) 는 [a...] 보다 더 나은 방법입니다. 하지만 a 가 이미 이터러블(iterable) 한 객체라면, 굳이 배열로 변환하지 않고 그대로 두는 것이 더 효율적일 때가 많습니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-ensure_constructors_return_type",
    "href": "src/application_of_julia/style_guide.html#sec-ensure_constructors_return_type",
    "title": "Julia 스타일 가이드",
    "section": "14 생성자가 바로 그 타입을 반환하는지 확인하세요",
    "text": "14 생성자가 바로 그 타입을 반환하는지 확인하세요\n타입 T 에 대한 T(x) 메서드를 호출할 때 보통 T 타입을 반환할것을 기대합니다. 예상하지 못한 타입을 반환하는 생성자(constructor) 는 혼란과 예측하지 못한 행동을 일으킬 수 있습니다.\njulia&gt; struct Foo{T}\n           x::T\n       end\n\njulia&gt; Base.Float64(foo::Foo) = Foo(Float64(foo.x))  # Do not define methods like this\n\njulia&gt; Float64(Foo(3))  # Should return `Float64`\nFoo{Float64}(3.0)\n\njulia&gt; Foo{Int}(x) = Foo{Float64}(x)  # Do not define methods like this\n\njulia&gt; Foo{Int}(3)  # Should return `Foo{Int}`\nFoo{Float64}(3.0)\n코드의 명확성과 타입 일관성을 유지하기 위해 항상 생성자가 생성하는 타입을 반환하도록 설계하세요",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-dont_use_unnecessary_static_parameters",
    "href": "src/application_of_julia/style_guide.html#sec-dont_use_unnecessary_static_parameters",
    "title": "Julia 스타일 가이드",
    "section": "15 불필요한 정적 매개변수를 사용하지 마세요",
    "text": "15 불필요한 정적 매개변수를 사용하지 마세요\nfoo(x::T) where {T&lt;:Real} = ...\n와 같은 함수 시그너쳐는 T 가 함수 내부에서 사용되지 않는다면 아래와 같이 변경되어야 합니다.\nfoo(x::Real) = ...\n심지어 T 가 사용되더라도 typeof(T) 로 대체될 수 있습니다. 성능 차이는 없습니다. 이것은 일반적인 정적 매개변수 사용에 대한 주의(caution) 은 아니며 단지 필요하지 않을 경우에 대한 주의입니다.\n또한 컨테이너 타입은 함수 내부에 타입 매개변수가 필요할 수 있습니다. 추상 컨테이너를 필드로 갖는 것을 피하라 를 참고하시기 바랍니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-avoid_confusion_whether_between_something_is_an_istance_or_type",
    "href": "src/application_of_julia/style_guide.html#sec-avoid_confusion_whether_between_something_is_an_istance_or_type",
    "title": "Julia 스타일 가이드",
    "section": "16 인스턴스와 타입에 대한 혼동을 피하라",
    "text": "16 인스턴스와 타입에 대한 혼동을 피하라\n다음과 같은 정의는 혼란스럽습니다.\nfoo(::Type{MyType}) = ...\nfoo(::MyType) = foo(MyType)\n해당 개념이 MyType 으로 작성될지 아니면 MyType() 으로 작성될지 결정하고, 그 결정을 일관되게 유지하는 것이 중요합니다.\n선호되는 스타일은 기본적으로 인스턴스를 사용하고 필요하다면 Type{MyType} 에 대한 메서드를 추가하는 것입니다.\n만약 타입이 사실상 열거형(enumeration)이라면, 이를 단일 타입(이상적으로는 immutable struct 혹은 원시 타입(primitive type))으로 정의하고, 열거형 값들을 그 타입의 인스턴스로 만드는 것이 좋습니다. 생성자와 변환 함수는 값이 유효한지 검증할 수 있습니다. 이 방식은 열거형 타입을 추상 타입으로 정의하고, 그 “값들”을 서브타입으로 만드는 방식보다 선호됩니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-dont_overuse_macro",
    "href": "src/application_of_julia/style_guide.html#sec-dont_overuse_macro",
    "title": "Julia 스타일 가이드",
    "section": "17 매크로를 남요하지 마세요",
    "text": "17 매크로를 남요하지 마세요\n매크로가 실제로는 함수로 작성될 수 있을 지 확인하세요.\n특히 매크로 내에서 eval 을 호출하는 것은 매우 위험한 신호입니다. eval 을 사용하면 해당 매크로는 최상위에서만 동작할 수 있게 됩니다. 만약 이런 매크로가 함수로서 쓰여질 수 있다면 런타임 값에 자연스럽게 접근할 수 있게 됩니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#sec-don_expose_unsafe_operations_at_the_interface_level",
    "href": "src/application_of_julia/style_guide.html#sec-don_expose_unsafe_operations_at_the_interface_level",
    "title": "Julia 스타일 가이드",
    "section": "18 인터페이스 레벨에서 안전하지 않은 동작을 노출하지 마세요",
    "text": "18 인터페이스 레벨에서 안전하지 않은 동작을 노출하지 마세요\n내이티브 포인터를 사용하는 타입을 사용한다고 합시다.\nmutable struct NativeType\n    p::Ptr{UInt8}\n    ...\nend\n아래와 같은 정의를 작성하지 마세요.\ngetindex(x::NativeType, i) = unsafe_load(x.p, i)\n문제는 이것이 안전하지 않으며, 메모리 버그에 취약하다는 것을 알지 못한채 사용자가 x[i] 에 무언가를 쓸 수 있다는 것입니다.\n이러한 함수는 안정성을 보장하기 위해 작업을 확인하거나, 그렇지 않으면 unsafe 라는 이름을 포함하여 호출자에게 경고를 해야 합니다.",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  },
  {
    "objectID": "src/application_of_julia/style_guide.html#기본-콘테이너-타입의-메서드를",
    "href": "src/application_of_julia/style_guide.html#기본-콘테이너-타입의-메서드를",
    "title": "Julia 스타일 가이드",
    "section": "19 기본 콘테이너 타입의 메서드를",
    "text": "19 기본 콘테이너 타입의 메서드를",
    "crumbs": [
      "Julia 언어의 활용",
      "Julia 스타일 가이드"
    ]
  }
]